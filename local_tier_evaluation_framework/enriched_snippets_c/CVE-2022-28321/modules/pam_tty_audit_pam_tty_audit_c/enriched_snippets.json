[
  {
    "function_name": "pam_sm_close_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_tty_audit/pam_tty_audit.c",
    "lines": "419-450",
    "snippet": "int\npam_sm_close_session (pam_handle_t *pamh, int flags, int argc,\n\t\t      const char **argv)\n{\n  const void *status_;\n\n  (void)flags;\n  (void)argc;\n  (void)argv;\n  if (pam_get_data (pamh, DATANAME, &status_) == PAM_SUCCESS)\n    {\n      const struct audit_tty_status *status;\n      int fd;\n\n      status = status_;\n\n      fd = nl_open ();\n      if (fd == -1\n\t  || nl_send (fd, AUDIT_TTY_SET, NLM_F_ACK, status,\n\t\t      sizeof (*status)) != 0\n\t  || nl_recv_ack (fd) != 0)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"error restoring audit status: %m\");\n\t  if (fd != -1)\n\t    close (fd);\n\t  return PAM_SESSION_ERR;\n\t}\n      close (fd);\n      pam_syslog (pamh, LOG_DEBUG, \"restored status to %d\", status->enabled);\n    }\n  return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/pam_ext.h>",
      "#include <linux/netlink.h>",
      "#include <libaudit.h>",
      "#include <unistd.h>",
      "#include <sys/socket.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fnmatch.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define DATANAME \"pam_tty_audit_last_state\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"restored status to %d\"",
            "status->enabled"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"error restoring audit status: %m\""
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nl_recv_ack",
          "args": [
            "fd"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "nl_recv_ack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_tty_audit/pam_tty_audit.c",
          "lines": "182-195",
          "snippet": "static int\nnl_recv_ack (int fd)\n{\n  struct nlmsgerr err;\n\n  if (nl_recv (fd, NLMSG_ERROR, &err, sizeof (err)) != 0)\n    return -1;\n  if (err.error != 0)\n    {\n      errno = -err.error;\n      return -1;\n    }\n  return 0;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/pam_ext.h>",
            "#include <linux/netlink.h>",
            "#include <libaudit.h>",
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fnmatch.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <linux/netlink.h>\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fnmatch.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\nnl_recv_ack (int fd)\n{\n  struct nlmsgerr err;\n\n  if (nl_recv (fd, NLMSG_ERROR, &err, sizeof (err)) != 0)\n    return -1;\n  if (err.error != 0)\n    {\n      errno = -err.error;\n      return -1;\n    }\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nl_send",
          "args": [
            "fd",
            "AUDIT_TTY_SET",
            "NLM_F_ACK",
            "status",
            "sizeof (*status)"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "nl_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_tty_audit/pam_tty_audit.c",
          "lines": "67-106",
          "snippet": "static int\nnl_send (int fd, unsigned type, unsigned flags, const void *data, size_t size)\n{\n  struct sockaddr_nl addr;\n  struct msghdr msg;\n  struct nlmsghdr nlm;\n  struct iovec iov[2];\n  ssize_t res;\n\n  nlm.nlmsg_len = NLMSG_LENGTH (size);\n  nlm.nlmsg_type = type;\n  nlm.nlmsg_flags = NLM_F_REQUEST | flags;\n  nlm.nlmsg_seq = 0;\n  nlm.nlmsg_pid = 0;\n  iov[0].iov_base = &nlm;\n  iov[0].iov_len = sizeof (nlm);\n  DIAG_PUSH_IGNORE_CAST_QUAL;\n  iov[1].iov_base = (void *)data;\n  DIAG_POP_IGNORE_CAST_QUAL;\n  iov[1].iov_len = size;\n  addr.nl_family = AF_NETLINK;\n  addr.nl_pid = 0;\n  addr.nl_groups = 0;\n  msg.msg_name = &addr;\n  msg.msg_namelen = sizeof (addr);\n  msg.msg_iov = iov;\n  msg.msg_iovlen = 2;\n  msg.msg_control = NULL;\n  msg.msg_controllen = 0;\n  msg.msg_flags = 0;\n  res = sendmsg (fd, &msg, 0);\n  if (res == -1)\n    return -1;\n  if ((size_t)res != nlm.nlmsg_len)\n    {\n      errno = EIO;\n      return -1;\n    }\n  return 0;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/pam_ext.h>",
            "#include <linux/netlink.h>",
            "#include <libaudit.h>",
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fnmatch.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <linux/netlink.h>\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fnmatch.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\nnl_send (int fd, unsigned type, unsigned flags, const void *data, size_t size)\n{\n  struct sockaddr_nl addr;\n  struct msghdr msg;\n  struct nlmsghdr nlm;\n  struct iovec iov[2];\n  ssize_t res;\n\n  nlm.nlmsg_len = NLMSG_LENGTH (size);\n  nlm.nlmsg_type = type;\n  nlm.nlmsg_flags = NLM_F_REQUEST | flags;\n  nlm.nlmsg_seq = 0;\n  nlm.nlmsg_pid = 0;\n  iov[0].iov_base = &nlm;\n  iov[0].iov_len = sizeof (nlm);\n  DIAG_PUSH_IGNORE_CAST_QUAL;\n  iov[1].iov_base = (void *)data;\n  DIAG_POP_IGNORE_CAST_QUAL;\n  iov[1].iov_len = size;\n  addr.nl_family = AF_NETLINK;\n  addr.nl_pid = 0;\n  addr.nl_groups = 0;\n  msg.msg_name = &addr;\n  msg.msg_namelen = sizeof (addr);\n  msg.msg_iov = iov;\n  msg.msg_iovlen = 2;\n  msg.msg_control = NULL;\n  msg.msg_controllen = 0;\n  msg.msg_flags = 0;\n  res = sendmsg (fd, &msg, 0);\n  if (res == -1)\n    return -1;\n  if ((size_t)res != nlm.nlmsg_len)\n    {\n      errno = EIO;\n      return -1;\n    }\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nl_open",
          "args": [],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "nl_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_tty_audit/pam_tty_audit.c",
          "lines": "61-65",
          "snippet": "static int\nnl_open (void)\n{\n  return socket (AF_NETLINK, SOCK_RAW, NETLINK_AUDIT);\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/pam_ext.h>",
            "#include <linux/netlink.h>",
            "#include <libaudit.h>",
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fnmatch.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <linux/netlink.h>\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fnmatch.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\nnl_open (void)\n{\n  return socket (AF_NETLINK, SOCK_RAW, NETLINK_AUDIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_get_data",
          "args": [
            "pamh",
            "DATANAME",
            "&status_"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <linux/netlink.h>\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fnmatch.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define DATANAME \"pam_tty_audit_last_state\"\n\nint\npam_sm_close_session (pam_handle_t *pamh, int flags, int argc,\n\t\t      const char **argv)\n{\n  const void *status_;\n\n  (void)flags;\n  (void)argc;\n  (void)argv;\n  if (pam_get_data (pamh, DATANAME, &status_) == PAM_SUCCESS)\n    {\n      const struct audit_tty_status *status;\n      int fd;\n\n      status = status_;\n\n      fd = nl_open ();\n      if (fd == -1\n\t  || nl_send (fd, AUDIT_TTY_SET, NLM_F_ACK, status,\n\t\t      sizeof (*status)) != 0\n\t  || nl_recv_ack (fd) != 0)\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"error restoring audit status: %m\");\n\t  if (fd != -1)\n\t    close (fd);\n\t  return PAM_SESSION_ERR;\n\t}\n      close (fd);\n      pam_syslog (pamh, LOG_DEBUG, \"restored status to %d\", status->enabled);\n    }\n  return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_open_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_tty_audit/pam_tty_audit.c",
    "lines": "253-417",
    "snippet": "int\npam_sm_open_session (pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n  enum command { CMD_NONE, CMD_ENABLE, CMD_DISABLE };\n\n  enum command command;\n  struct audit_tty_status *old_status, new_status;\n  const char *user;\n  int i, fd, open_only;\n  struct passwd *pwd;\n#ifdef HAVE_STRUCT_AUDIT_TTY_STATUS_LOG_PASSWD\n  int log_passwd;\n#endif /* HAVE_STRUCT_AUDIT_TTY_STATUS_LOG_PASSWD */\n\n  (void)flags;\n\n  if (pam_get_user (pamh, &user, NULL) != PAM_SUCCESS)\n    {\n      pam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n      return PAM_SESSION_ERR;\n    }\n\n  pwd = pam_modutil_getpwnam(pamh, user);\n  if (pwd == NULL)\n    {\n      pam_syslog(pamh, LOG_NOTICE,\n                 \"open_session unknown user '%s'\", user);\n      return PAM_SESSION_ERR;\n    }\n\n  command = CMD_NONE;\n  open_only = 0;\n#ifdef HAVE_STRUCT_AUDIT_TTY_STATUS_LOG_PASSWD\n  log_passwd = 0;\n#endif /* HAVE_STRUCT_AUDIT_TTY_STATUS_LOG_PASSWD */\n  for (i = 0; i < argc; i++)\n    {\n      const char *str;\n\n      if ((str = pam_str_skip_prefix(argv[i], \"enable=\")) != NULL\n\t  || (str = pam_str_skip_prefix(argv[i], \"disable=\")) != NULL)\n\t{\n\t  enum command this_command;\n\t  char *copy, *tok_data, *tok;\n\n\t  this_command = *argv[i] == 'e' ? CMD_ENABLE : CMD_DISABLE;\n\t  copy = strdup (str);\n\t  if (copy == NULL)\n\t    return PAM_SESSION_ERR;\n\t  for (tok = strtok_r (copy, \",\", &tok_data);\n\t       tok != NULL && command != this_command;\n\t       tok = strtok_r (NULL, \",\", &tok_data))\n\t    {\n\t      uid_t min_uid = 0, max_uid = 0;\n\t      switch (parse_uid_range(pamh, tok, &min_uid, &max_uid))\n\t\t{\n\t\tcase UID_RANGE_NONE:\n\t\t    if (fnmatch (tok, user, 0) == 0)\n\t\t\tcommand = this_command;\n\t\t    break;\n\t\tcase UID_RANGE_MM:\n\t\t    if (pwd->pw_uid >= min_uid && pwd->pw_uid <= max_uid)\n\t\t\tcommand = this_command;\n\t\t    break;\n\t\tcase UID_RANGE_MIN:\n\t\t    if (pwd->pw_uid >= min_uid)\n\t\t\tcommand = this_command;\n\t\t    break;\n\t\tcase UID_RANGE_ONE:\n\t\t    if (pwd->pw_uid == max_uid)\n\t\t\tcommand = this_command;\n\t\t    break;\n\t\tcase UID_RANGE_ERR:\n\t\t    break;\n\t\t}\n\t    }\n\t  free (copy);\n\t}\n      else if (strcmp (argv[i], \"open_only\") == 0)\n\topen_only = 1;\n      else if (strcmp (argv[i], \"log_passwd\") == 0)\n#ifdef HAVE_STRUCT_AUDIT_TTY_STATUS_LOG_PASSWD\n        log_passwd = 1;\n#else /* HAVE_STRUCT_AUDIT_TTY_STATUS_LOG_PASSWD */\n        pam_syslog (pamh, LOG_WARNING,\n                    \"The log_passwd option was not available at compile time.\");\n#warning \"pam_tty_audit: The log_passwd option is not available.  Please upgrade your headers/kernel.\"\n#endif /* HAVE_STRUCT_AUDIT_TTY_STATUS_LOG_PASSWD */\n      else\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"unknown option `%s'\", argv[i]);\n\t}\n    }\n  if (command == CMD_NONE)\n    return PAM_SUCCESS;\n\n  old_status = malloc (sizeof (*old_status));\n  if (old_status == NULL)\n    return PAM_SESSION_ERR;\n\n  fd = nl_open ();\n  if (fd == -1\n      && errno == EPROTONOSUPPORT)\n    {\n      pam_syslog (pamh, LOG_WARNING, \"unable to open audit socket, audit not \"\n                  \"supported; tty_audit skipped\");\n      free (old_status);\n      return PAM_IGNORE;\n    }\n  else if (fd == -1\n      || nl_send (fd, AUDIT_TTY_GET, 0, NULL, 0) != 0\n      || nl_recv (fd, AUDIT_TTY_GET, old_status, sizeof (*old_status)) != 0)\n    {\n      pam_syslog (pamh, LOG_ERR, \"error reading current audit status: %m\");\n      if (fd != -1)\n\tclose (fd);\n      free (old_status);\n      return PAM_SESSION_ERR;\n    }\n\n  memcpy(&new_status, old_status, sizeof(new_status));\n\n  new_status.enabled = (command == CMD_ENABLE ? 1 : 0);\n#ifdef HAVE_STRUCT_AUDIT_TTY_STATUS_LOG_PASSWD\n  new_status.log_passwd = log_passwd;\n#endif /* HAVE_STRUCT_AUDIT_TTY_STATUS_LOG_PASSWD */\n  if (old_status->enabled == new_status.enabled\n#ifdef HAVE_STRUCT_AUDIT_TTY_STATUS_LOG_PASSWD\n      && old_status->log_passwd == new_status.log_passwd\n#endif /* HAVE_STRUCT_AUDIT_TTY_STATUS_LOG_PASSWD */\n     )\n    {\n      open_only = 1; /* to clean up old_status */\n      goto ok_fd;\n    }\n\n  if (open_only == 0\n      && pam_set_data (pamh, DATANAME, old_status, cleanup_old_status)\n      != PAM_SUCCESS)\n    {\n      pam_syslog (pamh, LOG_ERR, \"error saving old audit status\");\n      close (fd);\n      free (old_status);\n      return PAM_SESSION_ERR;\n    }\n\n  if (nl_send (fd, AUDIT_TTY_SET, NLM_F_ACK, &new_status,\n\t       sizeof (new_status)) != 0\n      || nl_recv_ack (fd) != 0)\n    {\n      pam_syslog (pamh, LOG_ERR, \"error setting current audit status: %m\");\n      close (fd);\n      if (open_only != 0)\n\tfree (old_status);\n      return PAM_SESSION_ERR;\n    }\n  /* Fall through */\n ok_fd:\n  close (fd);\n  pam_syslog (pamh, LOG_DEBUG, \"changed status from %d to %d\",\n\t      old_status->enabled, new_status.enabled);\n  if (open_only != 0)\n    free (old_status);\n  return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/pam_ext.h>",
      "#include <linux/netlink.h>",
      "#include <libaudit.h>",
      "#include <unistd.h>",
      "#include <sys/socket.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fnmatch.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define DATANAME \"pam_tty_audit_last_state\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "old_status"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"changed status from %d to %d\"",
            "old_status->enabled",
            "new_status.enabled"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"error setting current audit status: %m\""
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nl_recv_ack",
          "args": [
            "fd"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "nl_recv_ack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_tty_audit/pam_tty_audit.c",
          "lines": "182-195",
          "snippet": "static int\nnl_recv_ack (int fd)\n{\n  struct nlmsgerr err;\n\n  if (nl_recv (fd, NLMSG_ERROR, &err, sizeof (err)) != 0)\n    return -1;\n  if (err.error != 0)\n    {\n      errno = -err.error;\n      return -1;\n    }\n  return 0;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/pam_ext.h>",
            "#include <linux/netlink.h>",
            "#include <libaudit.h>",
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fnmatch.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <linux/netlink.h>\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fnmatch.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\nnl_recv_ack (int fd)\n{\n  struct nlmsgerr err;\n\n  if (nl_recv (fd, NLMSG_ERROR, &err, sizeof (err)) != 0)\n    return -1;\n  if (err.error != 0)\n    {\n      errno = -err.error;\n      return -1;\n    }\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nl_send",
          "args": [
            "fd",
            "AUDIT_TTY_SET",
            "NLM_F_ACK",
            "&new_status",
            "sizeof (new_status)"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "nl_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_tty_audit/pam_tty_audit.c",
          "lines": "67-106",
          "snippet": "static int\nnl_send (int fd, unsigned type, unsigned flags, const void *data, size_t size)\n{\n  struct sockaddr_nl addr;\n  struct msghdr msg;\n  struct nlmsghdr nlm;\n  struct iovec iov[2];\n  ssize_t res;\n\n  nlm.nlmsg_len = NLMSG_LENGTH (size);\n  nlm.nlmsg_type = type;\n  nlm.nlmsg_flags = NLM_F_REQUEST | flags;\n  nlm.nlmsg_seq = 0;\n  nlm.nlmsg_pid = 0;\n  iov[0].iov_base = &nlm;\n  iov[0].iov_len = sizeof (nlm);\n  DIAG_PUSH_IGNORE_CAST_QUAL;\n  iov[1].iov_base = (void *)data;\n  DIAG_POP_IGNORE_CAST_QUAL;\n  iov[1].iov_len = size;\n  addr.nl_family = AF_NETLINK;\n  addr.nl_pid = 0;\n  addr.nl_groups = 0;\n  msg.msg_name = &addr;\n  msg.msg_namelen = sizeof (addr);\n  msg.msg_iov = iov;\n  msg.msg_iovlen = 2;\n  msg.msg_control = NULL;\n  msg.msg_controllen = 0;\n  msg.msg_flags = 0;\n  res = sendmsg (fd, &msg, 0);\n  if (res == -1)\n    return -1;\n  if ((size_t)res != nlm.nlmsg_len)\n    {\n      errno = EIO;\n      return -1;\n    }\n  return 0;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/pam_ext.h>",
            "#include <linux/netlink.h>",
            "#include <libaudit.h>",
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fnmatch.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <linux/netlink.h>\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fnmatch.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\nnl_send (int fd, unsigned type, unsigned flags, const void *data, size_t size)\n{\n  struct sockaddr_nl addr;\n  struct msghdr msg;\n  struct nlmsghdr nlm;\n  struct iovec iov[2];\n  ssize_t res;\n\n  nlm.nlmsg_len = NLMSG_LENGTH (size);\n  nlm.nlmsg_type = type;\n  nlm.nlmsg_flags = NLM_F_REQUEST | flags;\n  nlm.nlmsg_seq = 0;\n  nlm.nlmsg_pid = 0;\n  iov[0].iov_base = &nlm;\n  iov[0].iov_len = sizeof (nlm);\n  DIAG_PUSH_IGNORE_CAST_QUAL;\n  iov[1].iov_base = (void *)data;\n  DIAG_POP_IGNORE_CAST_QUAL;\n  iov[1].iov_len = size;\n  addr.nl_family = AF_NETLINK;\n  addr.nl_pid = 0;\n  addr.nl_groups = 0;\n  msg.msg_name = &addr;\n  msg.msg_namelen = sizeof (addr);\n  msg.msg_iov = iov;\n  msg.msg_iovlen = 2;\n  msg.msg_control = NULL;\n  msg.msg_controllen = 0;\n  msg.msg_flags = 0;\n  res = sendmsg (fd, &msg, 0);\n  if (res == -1)\n    return -1;\n  if ((size_t)res != nlm.nlmsg_len)\n    {\n      errno = EIO;\n      return -1;\n    }\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"error saving old audit status\""
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_data",
          "args": [
            "pamh",
            "DATANAME",
            "old_status",
            "cleanup_old_status"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&new_status",
            "old_status",
            "sizeof(new_status)"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"error reading current audit status: %m\""
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nl_recv",
          "args": [
            "fd",
            "AUDIT_TTY_GET",
            "old_status",
            "sizeof (*old_status)"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "nl_recv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_tty_audit/pam_tty_audit.c",
          "lines": "108-180",
          "snippet": "static int\nnl_recv (int fd, unsigned type, void *buf, size_t size)\n{\n  struct sockaddr_nl addr;\n  struct msghdr msg;\n  struct nlmsghdr nlm;\n  struct iovec iov[2];\n  ssize_t res, resdiff;\n\n again:\n  iov[0].iov_base = &nlm;\n  iov[0].iov_len = sizeof (nlm);\n  msg.msg_name = &addr;\n  msg.msg_namelen = sizeof (addr);\n  msg.msg_iov = iov;\n  msg.msg_iovlen = 1;\n  msg.msg_control = NULL;\n  msg.msg_controllen = 0;\n  msg.msg_flags = 0;\n  if (type != NLMSG_ERROR)\n    {\n      res = recvmsg (fd, &msg, MSG_PEEK);\n      if (res == -1)\n\treturn -1;\n      if (res != NLMSG_LENGTH (0))\n\t{\n\t  errno = EIO;\n\t  return -1;\n\t}\n      if (nlm.nlmsg_type == NLMSG_ERROR)\n\t{\n\t  struct nlmsgerr err;\n\n\t  iov[1].iov_base = &err;\n\t  iov[1].iov_len = sizeof (err);\n\t  msg.msg_iovlen = 2;\n\t  res = recvmsg (fd, &msg, 0);\n\t  if (res == -1)\n\t    return -1;\n\t  if ((size_t)res != NLMSG_LENGTH (sizeof (err))\n\t      || nlm.nlmsg_type != NLMSG_ERROR)\n\t    {\n\t      errno = EIO;\n\t      return -1;\n\t    }\n\t  if (err.error == 0)\n\t    goto again;\n\t  errno = -err.error;\n\t  return -1;\n\t}\n    }\n  if (size != 0)\n    {\n      iov[1].iov_base = buf;\n      iov[1].iov_len = size;\n      msg.msg_iovlen = 2;\n    }\n  res = recvmsg (fd, &msg, 0);\n  if (res == -1)\n    return -1;\n  resdiff = NLMSG_LENGTH(size) - (size_t)res;\n  if (resdiff < 0\n      || nlm.nlmsg_type != type)\n    {\n      errno = EIO;\n      return -1;\n    }\n  else if (resdiff > 0)\n    {\n      memset((char *)buf + size - resdiff, 0, resdiff);\n    }\n  return 0;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/pam_ext.h>",
            "#include <linux/netlink.h>",
            "#include <libaudit.h>",
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fnmatch.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <linux/netlink.h>\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fnmatch.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\nnl_recv (int fd, unsigned type, void *buf, size_t size)\n{\n  struct sockaddr_nl addr;\n  struct msghdr msg;\n  struct nlmsghdr nlm;\n  struct iovec iov[2];\n  ssize_t res, resdiff;\n\n again:\n  iov[0].iov_base = &nlm;\n  iov[0].iov_len = sizeof (nlm);\n  msg.msg_name = &addr;\n  msg.msg_namelen = sizeof (addr);\n  msg.msg_iov = iov;\n  msg.msg_iovlen = 1;\n  msg.msg_control = NULL;\n  msg.msg_controllen = 0;\n  msg.msg_flags = 0;\n  if (type != NLMSG_ERROR)\n    {\n      res = recvmsg (fd, &msg, MSG_PEEK);\n      if (res == -1)\n\treturn -1;\n      if (res != NLMSG_LENGTH (0))\n\t{\n\t  errno = EIO;\n\t  return -1;\n\t}\n      if (nlm.nlmsg_type == NLMSG_ERROR)\n\t{\n\t  struct nlmsgerr err;\n\n\t  iov[1].iov_base = &err;\n\t  iov[1].iov_len = sizeof (err);\n\t  msg.msg_iovlen = 2;\n\t  res = recvmsg (fd, &msg, 0);\n\t  if (res == -1)\n\t    return -1;\n\t  if ((size_t)res != NLMSG_LENGTH (sizeof (err))\n\t      || nlm.nlmsg_type != NLMSG_ERROR)\n\t    {\n\t      errno = EIO;\n\t      return -1;\n\t    }\n\t  if (err.error == 0)\n\t    goto again;\n\t  errno = -err.error;\n\t  return -1;\n\t}\n    }\n  if (size != 0)\n    {\n      iov[1].iov_base = buf;\n      iov[1].iov_len = size;\n      msg.msg_iovlen = 2;\n    }\n  res = recvmsg (fd, &msg, 0);\n  if (res == -1)\n    return -1;\n  resdiff = NLMSG_LENGTH(size) - (size_t)res;\n  if (resdiff < 0\n      || nlm.nlmsg_type != type)\n    {\n      errno = EIO;\n      return -1;\n    }\n  else if (resdiff > 0)\n    {\n      memset((char *)buf + size - resdiff, 0, resdiff);\n    }\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"unable to open audit socket, audit not \"\n                  \"supported; tty_audit skipped\""
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nl_open",
          "args": [],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "nl_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_tty_audit/pam_tty_audit.c",
          "lines": "61-65",
          "snippet": "static int\nnl_open (void)\n{\n  return socket (AF_NETLINK, SOCK_RAW, NETLINK_AUDIT);\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/pam_ext.h>",
            "#include <linux/netlink.h>",
            "#include <libaudit.h>",
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fnmatch.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <linux/netlink.h>\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fnmatch.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\nnl_open (void)\n{\n  return socket (AF_NETLINK, SOCK_RAW, NETLINK_AUDIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (*old_status)"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"unknown option `%s'\"",
            "argv[i]"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_WARNING",
            "\"The log_passwd option was not available at compile time.\""
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"log_passwd\""
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"open_only\""
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fnmatch",
          "args": [
            "tok",
            "user",
            "0"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_uid_range",
          "args": [
            "pamh",
            "tok",
            "&min_uid",
            "&max_uid"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "parse_uid_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_tty_audit/pam_tty_audit.c",
          "lines": "208-251",
          "snippet": "static enum uid_range\nparse_uid_range(pam_handle_t *pamh, const char *s,\n                uid_t *min_uid, uid_t *max_uid)\n{\n    const char *range = s;\n    const char *pmax;\n    char *endptr;\n    enum uid_range rv = UID_RANGE_MM;\n\n    if ((pmax=strchr(range, ':')) == NULL)\n        return UID_RANGE_NONE;\n    ++pmax;\n\n    if (range[0] == ':')\n        rv = UID_RANGE_ONE;\n    else {\n            errno = 0;\n            *min_uid = strtoul (range, &endptr, 10);\n            if (errno != 0 || (range == endptr) || *endptr != ':') {\n                pam_syslog(pamh, LOG_DEBUG,\n                           \"wrong min_uid value in '%s'\", s);\n                return UID_RANGE_ERR;\n            }\n    }\n\n    if (*pmax == '\\0') {\n        if (rv == UID_RANGE_ONE)\n            return UID_RANGE_ERR;\n\n        return UID_RANGE_MIN;\n    }\n\n    errno = 0;\n    *max_uid = strtoul (pmax, &endptr, 10);\n    if (errno != 0 || (pmax == endptr) || *endptr != '\\0') {\n        pam_syslog(pamh, LOG_DEBUG,\n                   \"wrong max_uid value in '%s'\", s);\n        return UID_RANGE_ERR;\n    }\n\n    if (rv == UID_RANGE_ONE)\n        *min_uid = *max_uid;\n    return rv;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/pam_ext.h>",
            "#include <linux/netlink.h>",
            "#include <libaudit.h>",
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fnmatch.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <linux/netlink.h>\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fnmatch.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic enum uid_range\nparse_uid_range(pam_handle_t *pamh, const char *s,\n                uid_t *min_uid, uid_t *max_uid)\n{\n    const char *range = s;\n    const char *pmax;\n    char *endptr;\n    enum uid_range rv = UID_RANGE_MM;\n\n    if ((pmax=strchr(range, ':')) == NULL)\n        return UID_RANGE_NONE;\n    ++pmax;\n\n    if (range[0] == ':')\n        rv = UID_RANGE_ONE;\n    else {\n            errno = 0;\n            *min_uid = strtoul (range, &endptr, 10);\n            if (errno != 0 || (range == endptr) || *endptr != ':') {\n                pam_syslog(pamh, LOG_DEBUG,\n                           \"wrong min_uid value in '%s'\", s);\n                return UID_RANGE_ERR;\n            }\n    }\n\n    if (*pmax == '\\0') {\n        if (rv == UID_RANGE_ONE)\n            return UID_RANGE_ERR;\n\n        return UID_RANGE_MIN;\n    }\n\n    errno = 0;\n    *max_uid = strtoul (pmax, &endptr, 10);\n    if (errno != 0 || (pmax == endptr) || *endptr != '\\0') {\n        pam_syslog(pamh, LOG_DEBUG,\n                   \"wrong max_uid value in '%s'\", s);\n        return UID_RANGE_ERR;\n    }\n\n    if (rv == UID_RANGE_ONE)\n        *min_uid = *max_uid;\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\",\"",
            "&tok_data"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "copy",
            "\",\"",
            "&tok_data"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "argv[i]",
            "\"disable=\""
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "argv[i]",
            "\"enable=\""
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"open_session unknown user '%s'\"",
            "user"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_modutil_getpwnam",
          "args": [
            "pamh",
            "user"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_NOTICE",
            "\"cannot determine user name\""
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_user",
          "args": [
            "pamh",
            "&user",
            "NULL"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <linux/netlink.h>\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fnmatch.h>\n#include <errno.h>\n#include \"config.h\"\n\n#define DATANAME \"pam_tty_audit_last_state\"\n\nint\npam_sm_open_session (pam_handle_t *pamh, int flags, int argc, const char **argv)\n{\n  enum command { CMD_NONE, CMD_ENABLE, CMD_DISABLE };\n\n  enum command command;\n  struct audit_tty_status *old_status, new_status;\n  const char *user;\n  int i, fd, open_only;\n  struct passwd *pwd;\n#ifdef HAVE_STRUCT_AUDIT_TTY_STATUS_LOG_PASSWD\n  int log_passwd;\n#endif /* HAVE_STRUCT_AUDIT_TTY_STATUS_LOG_PASSWD */\n\n  (void)flags;\n\n  if (pam_get_user (pamh, &user, NULL) != PAM_SUCCESS)\n    {\n      pam_syslog(pamh, LOG_NOTICE, \"cannot determine user name\");\n      return PAM_SESSION_ERR;\n    }\n\n  pwd = pam_modutil_getpwnam(pamh, user);\n  if (pwd == NULL)\n    {\n      pam_syslog(pamh, LOG_NOTICE,\n                 \"open_session unknown user '%s'\", user);\n      return PAM_SESSION_ERR;\n    }\n\n  command = CMD_NONE;\n  open_only = 0;\n#ifdef HAVE_STRUCT_AUDIT_TTY_STATUS_LOG_PASSWD\n  log_passwd = 0;\n#endif /* HAVE_STRUCT_AUDIT_TTY_STATUS_LOG_PASSWD */\n  for (i = 0; i < argc; i++)\n    {\n      const char *str;\n\n      if ((str = pam_str_skip_prefix(argv[i], \"enable=\")) != NULL\n\t  || (str = pam_str_skip_prefix(argv[i], \"disable=\")) != NULL)\n\t{\n\t  enum command this_command;\n\t  char *copy, *tok_data, *tok;\n\n\t  this_command = *argv[i] == 'e' ? CMD_ENABLE : CMD_DISABLE;\n\t  copy = strdup (str);\n\t  if (copy == NULL)\n\t    return PAM_SESSION_ERR;\n\t  for (tok = strtok_r (copy, \",\", &tok_data);\n\t       tok != NULL && command != this_command;\n\t       tok = strtok_r (NULL, \",\", &tok_data))\n\t    {\n\t      uid_t min_uid = 0, max_uid = 0;\n\t      switch (parse_uid_range(pamh, tok, &min_uid, &max_uid))\n\t\t{\n\t\tcase UID_RANGE_NONE:\n\t\t    if (fnmatch (tok, user, 0) == 0)\n\t\t\tcommand = this_command;\n\t\t    break;\n\t\tcase UID_RANGE_MM:\n\t\t    if (pwd->pw_uid >= min_uid && pwd->pw_uid <= max_uid)\n\t\t\tcommand = this_command;\n\t\t    break;\n\t\tcase UID_RANGE_MIN:\n\t\t    if (pwd->pw_uid >= min_uid)\n\t\t\tcommand = this_command;\n\t\t    break;\n\t\tcase UID_RANGE_ONE:\n\t\t    if (pwd->pw_uid == max_uid)\n\t\t\tcommand = this_command;\n\t\t    break;\n\t\tcase UID_RANGE_ERR:\n\t\t    break;\n\t\t}\n\t    }\n\t  free (copy);\n\t}\n      else if (strcmp (argv[i], \"open_only\") == 0)\n\topen_only = 1;\n      else if (strcmp (argv[i], \"log_passwd\") == 0)\n#ifdef HAVE_STRUCT_AUDIT_TTY_STATUS_LOG_PASSWD\n        log_passwd = 1;\n#else /* HAVE_STRUCT_AUDIT_TTY_STATUS_LOG_PASSWD */\n        pam_syslog (pamh, LOG_WARNING,\n                    \"The log_passwd option was not available at compile time.\");\n#warning \"pam_tty_audit: The log_passwd option is not available.  Please upgrade your headers/kernel.\"\n#endif /* HAVE_STRUCT_AUDIT_TTY_STATUS_LOG_PASSWD */\n      else\n\t{\n\t  pam_syslog (pamh, LOG_ERR, \"unknown option `%s'\", argv[i]);\n\t}\n    }\n  if (command == CMD_NONE)\n    return PAM_SUCCESS;\n\n  old_status = malloc (sizeof (*old_status));\n  if (old_status == NULL)\n    return PAM_SESSION_ERR;\n\n  fd = nl_open ();\n  if (fd == -1\n      && errno == EPROTONOSUPPORT)\n    {\n      pam_syslog (pamh, LOG_WARNING, \"unable to open audit socket, audit not \"\n                  \"supported; tty_audit skipped\");\n      free (old_status);\n      return PAM_IGNORE;\n    }\n  else if (fd == -1\n      || nl_send (fd, AUDIT_TTY_GET, 0, NULL, 0) != 0\n      || nl_recv (fd, AUDIT_TTY_GET, old_status, sizeof (*old_status)) != 0)\n    {\n      pam_syslog (pamh, LOG_ERR, \"error reading current audit status: %m\");\n      if (fd != -1)\n\tclose (fd);\n      free (old_status);\n      return PAM_SESSION_ERR;\n    }\n\n  memcpy(&new_status, old_status, sizeof(new_status));\n\n  new_status.enabled = (command == CMD_ENABLE ? 1 : 0);\n#ifdef HAVE_STRUCT_AUDIT_TTY_STATUS_LOG_PASSWD\n  new_status.log_passwd = log_passwd;\n#endif /* HAVE_STRUCT_AUDIT_TTY_STATUS_LOG_PASSWD */\n  if (old_status->enabled == new_status.enabled\n#ifdef HAVE_STRUCT_AUDIT_TTY_STATUS_LOG_PASSWD\n      && old_status->log_passwd == new_status.log_passwd\n#endif /* HAVE_STRUCT_AUDIT_TTY_STATUS_LOG_PASSWD */\n     )\n    {\n      open_only = 1; /* to clean up old_status */\n      goto ok_fd;\n    }\n\n  if (open_only == 0\n      && pam_set_data (pamh, DATANAME, old_status, cleanup_old_status)\n      != PAM_SUCCESS)\n    {\n      pam_syslog (pamh, LOG_ERR, \"error saving old audit status\");\n      close (fd);\n      free (old_status);\n      return PAM_SESSION_ERR;\n    }\n\n  if (nl_send (fd, AUDIT_TTY_SET, NLM_F_ACK, &new_status,\n\t       sizeof (new_status)) != 0\n      || nl_recv_ack (fd) != 0)\n    {\n      pam_syslog (pamh, LOG_ERR, \"error setting current audit status: %m\");\n      close (fd);\n      if (open_only != 0)\n\tfree (old_status);\n      return PAM_SESSION_ERR;\n    }\n  /* Fall through */\n ok_fd:\n  close (fd);\n  pam_syslog (pamh, LOG_DEBUG, \"changed status from %d to %d\",\n\t      old_status->enabled, new_status.enabled);\n  if (open_only != 0)\n    free (old_status);\n  return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "parse_uid_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_tty_audit/pam_tty_audit.c",
    "lines": "208-251",
    "snippet": "static enum uid_range\nparse_uid_range(pam_handle_t *pamh, const char *s,\n                uid_t *min_uid, uid_t *max_uid)\n{\n    const char *range = s;\n    const char *pmax;\n    char *endptr;\n    enum uid_range rv = UID_RANGE_MM;\n\n    if ((pmax=strchr(range, ':')) == NULL)\n        return UID_RANGE_NONE;\n    ++pmax;\n\n    if (range[0] == ':')\n        rv = UID_RANGE_ONE;\n    else {\n            errno = 0;\n            *min_uid = strtoul (range, &endptr, 10);\n            if (errno != 0 || (range == endptr) || *endptr != ':') {\n                pam_syslog(pamh, LOG_DEBUG,\n                           \"wrong min_uid value in '%s'\", s);\n                return UID_RANGE_ERR;\n            }\n    }\n\n    if (*pmax == '\\0') {\n        if (rv == UID_RANGE_ONE)\n            return UID_RANGE_ERR;\n\n        return UID_RANGE_MIN;\n    }\n\n    errno = 0;\n    *max_uid = strtoul (pmax, &endptr, 10);\n    if (errno != 0 || (pmax == endptr) || *endptr != '\\0') {\n        pam_syslog(pamh, LOG_DEBUG,\n                   \"wrong max_uid value in '%s'\", s);\n        return UID_RANGE_ERR;\n    }\n\n    if (rv == UID_RANGE_ONE)\n        *min_uid = *max_uid;\n    return rv;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/pam_ext.h>",
      "#include <linux/netlink.h>",
      "#include <libaudit.h>",
      "#include <unistd.h>",
      "#include <sys/socket.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fnmatch.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"wrong max_uid value in '%s'\"",
            "s"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "pmax",
            "&endptr",
            "10"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_DEBUG",
            "\"wrong min_uid value in '%s'\"",
            "s"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "range",
            "&endptr",
            "10"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "range",
            "':'"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <linux/netlink.h>\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fnmatch.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic enum uid_range\nparse_uid_range(pam_handle_t *pamh, const char *s,\n                uid_t *min_uid, uid_t *max_uid)\n{\n    const char *range = s;\n    const char *pmax;\n    char *endptr;\n    enum uid_range rv = UID_RANGE_MM;\n\n    if ((pmax=strchr(range, ':')) == NULL)\n        return UID_RANGE_NONE;\n    ++pmax;\n\n    if (range[0] == ':')\n        rv = UID_RANGE_ONE;\n    else {\n            errno = 0;\n            *min_uid = strtoul (range, &endptr, 10);\n            if (errno != 0 || (range == endptr) || *endptr != ':') {\n                pam_syslog(pamh, LOG_DEBUG,\n                           \"wrong min_uid value in '%s'\", s);\n                return UID_RANGE_ERR;\n            }\n    }\n\n    if (*pmax == '\\0') {\n        if (rv == UID_RANGE_ONE)\n            return UID_RANGE_ERR;\n\n        return UID_RANGE_MIN;\n    }\n\n    errno = 0;\n    *max_uid = strtoul (pmax, &endptr, 10);\n    if (errno != 0 || (pmax == endptr) || *endptr != '\\0') {\n        pam_syslog(pamh, LOG_DEBUG,\n                   \"wrong max_uid value in '%s'\", s);\n        return UID_RANGE_ERR;\n    }\n\n    if (rv == UID_RANGE_ONE)\n        *min_uid = *max_uid;\n    return rv;\n}"
  },
  {
    "function_name": "cleanup_old_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_tty_audit/pam_tty_audit.c",
    "lines": "197-203",
    "snippet": "static void\ncleanup_old_status (pam_handle_t *pamh, void *data, int error_status)\n{\n  (void)pamh;\n  (void)error_status;\n  free (data);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/pam_ext.h>",
      "#include <linux/netlink.h>",
      "#include <libaudit.h>",
      "#include <unistd.h>",
      "#include <sys/socket.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fnmatch.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "data"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <linux/netlink.h>\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fnmatch.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\ncleanup_old_status (pam_handle_t *pamh, void *data, int error_status)\n{\n  (void)pamh;\n  (void)error_status;\n  free (data);\n}"
  },
  {
    "function_name": "nl_recv_ack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_tty_audit/pam_tty_audit.c",
    "lines": "182-195",
    "snippet": "static int\nnl_recv_ack (int fd)\n{\n  struct nlmsgerr err;\n\n  if (nl_recv (fd, NLMSG_ERROR, &err, sizeof (err)) != 0)\n    return -1;\n  if (err.error != 0)\n    {\n      errno = -err.error;\n      return -1;\n    }\n  return 0;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/pam_ext.h>",
      "#include <linux/netlink.h>",
      "#include <libaudit.h>",
      "#include <unistd.h>",
      "#include <sys/socket.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fnmatch.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nl_recv",
          "args": [
            "fd",
            "NLMSG_ERROR",
            "&err",
            "sizeof (err)"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "nl_recv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_tty_audit/pam_tty_audit.c",
          "lines": "108-180",
          "snippet": "static int\nnl_recv (int fd, unsigned type, void *buf, size_t size)\n{\n  struct sockaddr_nl addr;\n  struct msghdr msg;\n  struct nlmsghdr nlm;\n  struct iovec iov[2];\n  ssize_t res, resdiff;\n\n again:\n  iov[0].iov_base = &nlm;\n  iov[0].iov_len = sizeof (nlm);\n  msg.msg_name = &addr;\n  msg.msg_namelen = sizeof (addr);\n  msg.msg_iov = iov;\n  msg.msg_iovlen = 1;\n  msg.msg_control = NULL;\n  msg.msg_controllen = 0;\n  msg.msg_flags = 0;\n  if (type != NLMSG_ERROR)\n    {\n      res = recvmsg (fd, &msg, MSG_PEEK);\n      if (res == -1)\n\treturn -1;\n      if (res != NLMSG_LENGTH (0))\n\t{\n\t  errno = EIO;\n\t  return -1;\n\t}\n      if (nlm.nlmsg_type == NLMSG_ERROR)\n\t{\n\t  struct nlmsgerr err;\n\n\t  iov[1].iov_base = &err;\n\t  iov[1].iov_len = sizeof (err);\n\t  msg.msg_iovlen = 2;\n\t  res = recvmsg (fd, &msg, 0);\n\t  if (res == -1)\n\t    return -1;\n\t  if ((size_t)res != NLMSG_LENGTH (sizeof (err))\n\t      || nlm.nlmsg_type != NLMSG_ERROR)\n\t    {\n\t      errno = EIO;\n\t      return -1;\n\t    }\n\t  if (err.error == 0)\n\t    goto again;\n\t  errno = -err.error;\n\t  return -1;\n\t}\n    }\n  if (size != 0)\n    {\n      iov[1].iov_base = buf;\n      iov[1].iov_len = size;\n      msg.msg_iovlen = 2;\n    }\n  res = recvmsg (fd, &msg, 0);\n  if (res == -1)\n    return -1;\n  resdiff = NLMSG_LENGTH(size) - (size_t)res;\n  if (resdiff < 0\n      || nlm.nlmsg_type != type)\n    {\n      errno = EIO;\n      return -1;\n    }\n  else if (resdiff > 0)\n    {\n      memset((char *)buf + size - resdiff, 0, resdiff);\n    }\n  return 0;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include \"pam_cc_compat.h\"",
            "#include <security/pam_modutil.h>",
            "#include <security/pam_modules.h>",
            "#include <security/pam_ext.h>",
            "#include <linux/netlink.h>",
            "#include <libaudit.h>",
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fnmatch.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <linux/netlink.h>\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fnmatch.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\nnl_recv (int fd, unsigned type, void *buf, size_t size)\n{\n  struct sockaddr_nl addr;\n  struct msghdr msg;\n  struct nlmsghdr nlm;\n  struct iovec iov[2];\n  ssize_t res, resdiff;\n\n again:\n  iov[0].iov_base = &nlm;\n  iov[0].iov_len = sizeof (nlm);\n  msg.msg_name = &addr;\n  msg.msg_namelen = sizeof (addr);\n  msg.msg_iov = iov;\n  msg.msg_iovlen = 1;\n  msg.msg_control = NULL;\n  msg.msg_controllen = 0;\n  msg.msg_flags = 0;\n  if (type != NLMSG_ERROR)\n    {\n      res = recvmsg (fd, &msg, MSG_PEEK);\n      if (res == -1)\n\treturn -1;\n      if (res != NLMSG_LENGTH (0))\n\t{\n\t  errno = EIO;\n\t  return -1;\n\t}\n      if (nlm.nlmsg_type == NLMSG_ERROR)\n\t{\n\t  struct nlmsgerr err;\n\n\t  iov[1].iov_base = &err;\n\t  iov[1].iov_len = sizeof (err);\n\t  msg.msg_iovlen = 2;\n\t  res = recvmsg (fd, &msg, 0);\n\t  if (res == -1)\n\t    return -1;\n\t  if ((size_t)res != NLMSG_LENGTH (sizeof (err))\n\t      || nlm.nlmsg_type != NLMSG_ERROR)\n\t    {\n\t      errno = EIO;\n\t      return -1;\n\t    }\n\t  if (err.error == 0)\n\t    goto again;\n\t  errno = -err.error;\n\t  return -1;\n\t}\n    }\n  if (size != 0)\n    {\n      iov[1].iov_base = buf;\n      iov[1].iov_len = size;\n      msg.msg_iovlen = 2;\n    }\n  res = recvmsg (fd, &msg, 0);\n  if (res == -1)\n    return -1;\n  resdiff = NLMSG_LENGTH(size) - (size_t)res;\n  if (resdiff < 0\n      || nlm.nlmsg_type != type)\n    {\n      errno = EIO;\n      return -1;\n    }\n  else if (resdiff > 0)\n    {\n      memset((char *)buf + size - resdiff, 0, resdiff);\n    }\n  return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <linux/netlink.h>\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fnmatch.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\nnl_recv_ack (int fd)\n{\n  struct nlmsgerr err;\n\n  if (nl_recv (fd, NLMSG_ERROR, &err, sizeof (err)) != 0)\n    return -1;\n  if (err.error != 0)\n    {\n      errno = -err.error;\n      return -1;\n    }\n  return 0;\n}"
  },
  {
    "function_name": "nl_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_tty_audit/pam_tty_audit.c",
    "lines": "108-180",
    "snippet": "static int\nnl_recv (int fd, unsigned type, void *buf, size_t size)\n{\n  struct sockaddr_nl addr;\n  struct msghdr msg;\n  struct nlmsghdr nlm;\n  struct iovec iov[2];\n  ssize_t res, resdiff;\n\n again:\n  iov[0].iov_base = &nlm;\n  iov[0].iov_len = sizeof (nlm);\n  msg.msg_name = &addr;\n  msg.msg_namelen = sizeof (addr);\n  msg.msg_iov = iov;\n  msg.msg_iovlen = 1;\n  msg.msg_control = NULL;\n  msg.msg_controllen = 0;\n  msg.msg_flags = 0;\n  if (type != NLMSG_ERROR)\n    {\n      res = recvmsg (fd, &msg, MSG_PEEK);\n      if (res == -1)\n\treturn -1;\n      if (res != NLMSG_LENGTH (0))\n\t{\n\t  errno = EIO;\n\t  return -1;\n\t}\n      if (nlm.nlmsg_type == NLMSG_ERROR)\n\t{\n\t  struct nlmsgerr err;\n\n\t  iov[1].iov_base = &err;\n\t  iov[1].iov_len = sizeof (err);\n\t  msg.msg_iovlen = 2;\n\t  res = recvmsg (fd, &msg, 0);\n\t  if (res == -1)\n\t    return -1;\n\t  if ((size_t)res != NLMSG_LENGTH (sizeof (err))\n\t      || nlm.nlmsg_type != NLMSG_ERROR)\n\t    {\n\t      errno = EIO;\n\t      return -1;\n\t    }\n\t  if (err.error == 0)\n\t    goto again;\n\t  errno = -err.error;\n\t  return -1;\n\t}\n    }\n  if (size != 0)\n    {\n      iov[1].iov_base = buf;\n      iov[1].iov_len = size;\n      msg.msg_iovlen = 2;\n    }\n  res = recvmsg (fd, &msg, 0);\n  if (res == -1)\n    return -1;\n  resdiff = NLMSG_LENGTH(size) - (size_t)res;\n  if (resdiff < 0\n      || nlm.nlmsg_type != type)\n    {\n      errno = EIO;\n      return -1;\n    }\n  else if (resdiff > 0)\n    {\n      memset((char *)buf + size - resdiff, 0, resdiff);\n    }\n  return 0;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/pam_ext.h>",
      "#include <linux/netlink.h>",
      "#include <libaudit.h>",
      "#include <unistd.h>",
      "#include <sys/socket.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fnmatch.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)buf + size - resdiff",
            "0",
            "resdiff"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "size"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recvmsg",
          "args": [
            "fd",
            "&msg",
            "0"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "sizeof (err)"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recvmsg",
          "args": [
            "fd",
            "&msg",
            "0"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "0"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recvmsg",
          "args": [
            "fd",
            "&msg",
            "MSG_PEEK"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <linux/netlink.h>\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fnmatch.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\nnl_recv (int fd, unsigned type, void *buf, size_t size)\n{\n  struct sockaddr_nl addr;\n  struct msghdr msg;\n  struct nlmsghdr nlm;\n  struct iovec iov[2];\n  ssize_t res, resdiff;\n\n again:\n  iov[0].iov_base = &nlm;\n  iov[0].iov_len = sizeof (nlm);\n  msg.msg_name = &addr;\n  msg.msg_namelen = sizeof (addr);\n  msg.msg_iov = iov;\n  msg.msg_iovlen = 1;\n  msg.msg_control = NULL;\n  msg.msg_controllen = 0;\n  msg.msg_flags = 0;\n  if (type != NLMSG_ERROR)\n    {\n      res = recvmsg (fd, &msg, MSG_PEEK);\n      if (res == -1)\n\treturn -1;\n      if (res != NLMSG_LENGTH (0))\n\t{\n\t  errno = EIO;\n\t  return -1;\n\t}\n      if (nlm.nlmsg_type == NLMSG_ERROR)\n\t{\n\t  struct nlmsgerr err;\n\n\t  iov[1].iov_base = &err;\n\t  iov[1].iov_len = sizeof (err);\n\t  msg.msg_iovlen = 2;\n\t  res = recvmsg (fd, &msg, 0);\n\t  if (res == -1)\n\t    return -1;\n\t  if ((size_t)res != NLMSG_LENGTH (sizeof (err))\n\t      || nlm.nlmsg_type != NLMSG_ERROR)\n\t    {\n\t      errno = EIO;\n\t      return -1;\n\t    }\n\t  if (err.error == 0)\n\t    goto again;\n\t  errno = -err.error;\n\t  return -1;\n\t}\n    }\n  if (size != 0)\n    {\n      iov[1].iov_base = buf;\n      iov[1].iov_len = size;\n      msg.msg_iovlen = 2;\n    }\n  res = recvmsg (fd, &msg, 0);\n  if (res == -1)\n    return -1;\n  resdiff = NLMSG_LENGTH(size) - (size_t)res;\n  if (resdiff < 0\n      || nlm.nlmsg_type != type)\n    {\n      errno = EIO;\n      return -1;\n    }\n  else if (resdiff > 0)\n    {\n      memset((char *)buf + size - resdiff, 0, resdiff);\n    }\n  return 0;\n}"
  },
  {
    "function_name": "nl_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_tty_audit/pam_tty_audit.c",
    "lines": "67-106",
    "snippet": "static int\nnl_send (int fd, unsigned type, unsigned flags, const void *data, size_t size)\n{\n  struct sockaddr_nl addr;\n  struct msghdr msg;\n  struct nlmsghdr nlm;\n  struct iovec iov[2];\n  ssize_t res;\n\n  nlm.nlmsg_len = NLMSG_LENGTH (size);\n  nlm.nlmsg_type = type;\n  nlm.nlmsg_flags = NLM_F_REQUEST | flags;\n  nlm.nlmsg_seq = 0;\n  nlm.nlmsg_pid = 0;\n  iov[0].iov_base = &nlm;\n  iov[0].iov_len = sizeof (nlm);\n  DIAG_PUSH_IGNORE_CAST_QUAL;\n  iov[1].iov_base = (void *)data;\n  DIAG_POP_IGNORE_CAST_QUAL;\n  iov[1].iov_len = size;\n  addr.nl_family = AF_NETLINK;\n  addr.nl_pid = 0;\n  addr.nl_groups = 0;\n  msg.msg_name = &addr;\n  msg.msg_namelen = sizeof (addr);\n  msg.msg_iov = iov;\n  msg.msg_iovlen = 2;\n  msg.msg_control = NULL;\n  msg.msg_controllen = 0;\n  msg.msg_flags = 0;\n  res = sendmsg (fd, &msg, 0);\n  if (res == -1)\n    return -1;\n  if ((size_t)res != nlm.nlmsg_len)\n    {\n      errno = EIO;\n      return -1;\n    }\n  return 0;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/pam_ext.h>",
      "#include <linux/netlink.h>",
      "#include <libaudit.h>",
      "#include <unistd.h>",
      "#include <sys/socket.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fnmatch.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sendmsg",
          "args": [
            "fd",
            "&msg",
            "0"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "size"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <linux/netlink.h>\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fnmatch.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\nnl_send (int fd, unsigned type, unsigned flags, const void *data, size_t size)\n{\n  struct sockaddr_nl addr;\n  struct msghdr msg;\n  struct nlmsghdr nlm;\n  struct iovec iov[2];\n  ssize_t res;\n\n  nlm.nlmsg_len = NLMSG_LENGTH (size);\n  nlm.nlmsg_type = type;\n  nlm.nlmsg_flags = NLM_F_REQUEST | flags;\n  nlm.nlmsg_seq = 0;\n  nlm.nlmsg_pid = 0;\n  iov[0].iov_base = &nlm;\n  iov[0].iov_len = sizeof (nlm);\n  DIAG_PUSH_IGNORE_CAST_QUAL;\n  iov[1].iov_base = (void *)data;\n  DIAG_POP_IGNORE_CAST_QUAL;\n  iov[1].iov_len = size;\n  addr.nl_family = AF_NETLINK;\n  addr.nl_pid = 0;\n  addr.nl_groups = 0;\n  msg.msg_name = &addr;\n  msg.msg_namelen = sizeof (addr);\n  msg.msg_iov = iov;\n  msg.msg_iovlen = 2;\n  msg.msg_control = NULL;\n  msg.msg_controllen = 0;\n  msg.msg_flags = 0;\n  res = sendmsg (fd, &msg, 0);\n  if (res == -1)\n    return -1;\n  if ((size_t)res != nlm.nlmsg_len)\n    {\n      errno = EIO;\n      return -1;\n    }\n  return 0;\n}"
  },
  {
    "function_name": "nl_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_tty_audit/pam_tty_audit.c",
    "lines": "61-65",
    "snippet": "static int\nnl_open (void)\n{\n  return socket (AF_NETLINK, SOCK_RAW, NETLINK_AUDIT);\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include \"pam_cc_compat.h\"",
      "#include <security/pam_modutil.h>",
      "#include <security/pam_modules.h>",
      "#include <security/pam_ext.h>",
      "#include <linux/netlink.h>",
      "#include <libaudit.h>",
      "#include <unistd.h>",
      "#include <sys/socket.h>",
      "#include <syslog.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fnmatch.h>",
      "#include <errno.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_NETLINK",
            "SOCK_RAW",
            "NETLINK_AUDIT"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/pam_ext.h>\n#include <linux/netlink.h>\n#include <libaudit.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fnmatch.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic int\nnl_open (void)\n{\n  return socket (AF_NETLINK, SOCK_RAW, NETLINK_AUDIT);\n}"
  }
]