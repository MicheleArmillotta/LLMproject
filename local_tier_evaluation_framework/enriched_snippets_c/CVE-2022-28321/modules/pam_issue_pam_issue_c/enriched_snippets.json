[
  {
    "function_name": "read_issue_quoted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_issue/pam_issue.c",
    "lines": "160-304",
    "snippet": "static int\nread_issue_quoted(pam_handle_t *pamh, FILE *fp, char **prompt)\n{\n    int c;\n    size_t size = 1024;\n    size_t issue_len = 0;\n    char *issue;\n    struct utsname uts;\n\n    *prompt = NULL;\n\n    if ((issue = malloc(size)) == NULL) {\n\tpam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\treturn PAM_BUF_ERR;\n    }\n\n    (void) uname(&uts);\n\n    while ((c = getc(fp)) != EOF) {\n\tconst char *src = NULL;\n\tsize_t len = 0;\n\tchar buf[1024] = \"\";\n\n\tif (c == '\\\\') {\n\t    if ((c = getc(fp)) == EOF)\n\t\tbreak;\n\t    switch (c) {\n\t      case 's':\n\t\tsrc = uts.sysname;\n\t\tlen = strnlen(uts.sysname, sizeof(uts.sysname));\n\t\tbreak;\n\t      case 'n':\n\t\tsrc = uts.nodename;\n\t\tlen = strnlen(uts.nodename, sizeof(uts.nodename));\n\t\tbreak;\n\t      case 'r':\n\t\tsrc = uts.release;\n\t\tlen = strnlen(uts.release, sizeof(uts.release));\n\t\tbreak;\n\t      case 'v':\n\t\tsrc = uts.version;\n\t\tlen = strnlen(uts.version, sizeof(uts.version));\n\t\tbreak;\n\t      case 'm':\n\t\tsrc = uts.machine;\n\t\tlen = strnlen(uts.machine, sizeof(uts.machine));\n\t\tbreak;\n\t      case 'o':\n#ifdef HAVE_GETDOMAINNAME\n\t\tif (getdomainname(buf, sizeof(buf)) >= 0)\n\t\t    buf[sizeof(buf) - 1] = '\\0';\n#endif\n\t\tbreak;\n\t      case 'd':\n\t      case 't':\n\t\t{\n\t\t    const char *weekday[] = {\n\t\t\t\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\",\n\t\t\t\"Fri\", \"Sat\" };\n\t\t    const char *month[] = {\n\t\t\t\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\",\n\t\t\t\"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\",\n\t\t\t\"Nov\", \"Dec\" };\n\t\t    time_t now;\n\t\t    struct tm *tm;\n\n\t\t    (void) time (&now);\n\t\t    tm = localtime(&now);\n\n\t\t    if (c == 'd')\n\t\t\tsnprintf (buf, sizeof buf, \"%s %s %d  %d\",\n\t\t\t\tweekday[tm->tm_wday], month[tm->tm_mon],\n\t\t\t\ttm->tm_mday, tm->tm_year + 1900);\n\t\t    else\n\t\t\tsnprintf (buf, sizeof buf, \"%02d:%02d:%02d\",\n\t\t\t\ttm->tm_hour, tm->tm_min, tm->tm_sec);\n\t\t}\n\t\tbreak;\n\t      case 'l':\n\t\t{\n\t\t    const char *ttyn = ttyname(1);\n\t\t    if (ttyn) {\n\t\t\tconst char *str = pam_str_skip_prefix(ttyn, \"/dev/\");\n\t\t\tif (str != NULL)\n\t\t\t    ttyn = str;\n\t\t\tsrc = ttyn;\n\t\t\tlen = strlen(ttyn);\n\t\t    }\n\t\t}\n\t\tbreak;\n\t      case 'u':\n\t      case 'U':\n\t\t{\n\t\t    unsigned int users = 0;\n\t\t    struct utmp *ut;\n\t\t    setutent();\n\t\t    while ((ut = getutent())) {\n\t\t\tif (ut->ut_type == USER_PROCESS)\n\t\t\t    ++users;\n\t\t    }\n\t\t    endutent();\n\t\t    if (c == 'U')\n\t\t\tsnprintf (buf, sizeof buf, \"%u %s\", users,\n\t\t\t          (users == 1) ? \"user\" : \"users\");\n\t\t    else\n\t\t\tsnprintf (buf, sizeof buf, \"%u\", users);\n\t\t    break;\n\t\t}\n\t      default:\n\t\tbuf[0] = c; buf[1] = '\\0';\n\t    }\n\t} else {\n\t    buf[0] = c; buf[1] = '\\0';\n\t}\n\n\tif (src == NULL) {\n\t    src = buf;\n\t    len = strlen(buf);\n\t}\n\tif (issue_len + len + 1 > size) {\n\t    char *new_issue;\n\n\t    size += len + 1;\n\t    new_issue = realloc (issue, size);\n\t    if (new_issue == NULL) {\n\t\t_pam_drop(issue);\n\t\treturn PAM_BUF_ERR;\n\t    }\n\t    issue = new_issue;\n\t}\n\tmemcpy(issue + issue_len, src, len);\n\tissue_len += len;\n    }\n\n    issue[issue_len] = '\\0';\n\n    if (ferror(fp)) {\n\tpam_syslog(pamh, LOG_ERR, \"read error: %m\");\n\t_pam_drop(issue);\n\treturn PAM_SERVICE_ERR;\n    }\n\n    *prompt = issue;\n    return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <utmp.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int read_issue_raw(pam_handle_t *pamh, FILE *fp, char **prompt);",
      "static int read_issue_quoted(pam_handle_t *pamh, FILE *fp, char **prompt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "issue"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"read error: %m\""
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ferror",
          "args": [
            "fp"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "issue + issue_len",
            "src",
            "len"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "issue"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "issue",
            "size"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof buf",
            "\"%u\"",
            "users"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof buf",
            "\"%u %s\"",
            "users",
            "(users == 1) ? \"user\" : \"users\""
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "endutent",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getutent",
          "args": [],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setutent",
          "args": [],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ttyn"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "ttyn",
            "\"/dev/\""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttyname",
          "args": [
            "1"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof buf",
            "\"%02d:%02d:%02d\"",
            "tm->tm_hour",
            "tm->tm_min",
            "tm->tm_sec"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof buf",
            "\"%s %s %d  %d\"",
            "weekday[tm->tm_wday]",
            "month[tm->tm_mon]",
            "tm->tm_mday",
            "tm->tm_year + 1900"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "localtime",
          "args": [
            "&now"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "&now"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getdomainname",
          "args": [
            "buf",
            "sizeof(buf)"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "uts.machine",
            "sizeof(uts.machine)"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "uts.version",
            "sizeof(uts.version)"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "uts.release",
            "sizeof(uts.release)"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "uts.nodename",
            "sizeof(uts.nodename)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "uts.sysname",
            "sizeof(uts.sysname)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getc",
          "args": [
            "fp"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getc",
          "args": [
            "fp"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uname",
          "args": [
            "&uts"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"out of memory\""
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "size"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <syslog.h>\n#include <time.h>\n#include <utmp.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"config.h\"\n\nstatic int read_issue_raw(pam_handle_t *pamh, FILE *fp, char **prompt);\nstatic int read_issue_quoted(pam_handle_t *pamh, FILE *fp, char **prompt);\n\nstatic int\nread_issue_quoted(pam_handle_t *pamh, FILE *fp, char **prompt)\n{\n    int c;\n    size_t size = 1024;\n    size_t issue_len = 0;\n    char *issue;\n    struct utsname uts;\n\n    *prompt = NULL;\n\n    if ((issue = malloc(size)) == NULL) {\n\tpam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\treturn PAM_BUF_ERR;\n    }\n\n    (void) uname(&uts);\n\n    while ((c = getc(fp)) != EOF) {\n\tconst char *src = NULL;\n\tsize_t len = 0;\n\tchar buf[1024] = \"\";\n\n\tif (c == '\\\\') {\n\t    if ((c = getc(fp)) == EOF)\n\t\tbreak;\n\t    switch (c) {\n\t      case 's':\n\t\tsrc = uts.sysname;\n\t\tlen = strnlen(uts.sysname, sizeof(uts.sysname));\n\t\tbreak;\n\t      case 'n':\n\t\tsrc = uts.nodename;\n\t\tlen = strnlen(uts.nodename, sizeof(uts.nodename));\n\t\tbreak;\n\t      case 'r':\n\t\tsrc = uts.release;\n\t\tlen = strnlen(uts.release, sizeof(uts.release));\n\t\tbreak;\n\t      case 'v':\n\t\tsrc = uts.version;\n\t\tlen = strnlen(uts.version, sizeof(uts.version));\n\t\tbreak;\n\t      case 'm':\n\t\tsrc = uts.machine;\n\t\tlen = strnlen(uts.machine, sizeof(uts.machine));\n\t\tbreak;\n\t      case 'o':\n#ifdef HAVE_GETDOMAINNAME\n\t\tif (getdomainname(buf, sizeof(buf)) >= 0)\n\t\t    buf[sizeof(buf) - 1] = '\\0';\n#endif\n\t\tbreak;\n\t      case 'd':\n\t      case 't':\n\t\t{\n\t\t    const char *weekday[] = {\n\t\t\t\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\",\n\t\t\t\"Fri\", \"Sat\" };\n\t\t    const char *month[] = {\n\t\t\t\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\",\n\t\t\t\"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\",\n\t\t\t\"Nov\", \"Dec\" };\n\t\t    time_t now;\n\t\t    struct tm *tm;\n\n\t\t    (void) time (&now);\n\t\t    tm = localtime(&now);\n\n\t\t    if (c == 'd')\n\t\t\tsnprintf (buf, sizeof buf, \"%s %s %d  %d\",\n\t\t\t\tweekday[tm->tm_wday], month[tm->tm_mon],\n\t\t\t\ttm->tm_mday, tm->tm_year + 1900);\n\t\t    else\n\t\t\tsnprintf (buf, sizeof buf, \"%02d:%02d:%02d\",\n\t\t\t\ttm->tm_hour, tm->tm_min, tm->tm_sec);\n\t\t}\n\t\tbreak;\n\t      case 'l':\n\t\t{\n\t\t    const char *ttyn = ttyname(1);\n\t\t    if (ttyn) {\n\t\t\tconst char *str = pam_str_skip_prefix(ttyn, \"/dev/\");\n\t\t\tif (str != NULL)\n\t\t\t    ttyn = str;\n\t\t\tsrc = ttyn;\n\t\t\tlen = strlen(ttyn);\n\t\t    }\n\t\t}\n\t\tbreak;\n\t      case 'u':\n\t      case 'U':\n\t\t{\n\t\t    unsigned int users = 0;\n\t\t    struct utmp *ut;\n\t\t    setutent();\n\t\t    while ((ut = getutent())) {\n\t\t\tif (ut->ut_type == USER_PROCESS)\n\t\t\t    ++users;\n\t\t    }\n\t\t    endutent();\n\t\t    if (c == 'U')\n\t\t\tsnprintf (buf, sizeof buf, \"%u %s\", users,\n\t\t\t          (users == 1) ? \"user\" : \"users\");\n\t\t    else\n\t\t\tsnprintf (buf, sizeof buf, \"%u\", users);\n\t\t    break;\n\t\t}\n\t      default:\n\t\tbuf[0] = c; buf[1] = '\\0';\n\t    }\n\t} else {\n\t    buf[0] = c; buf[1] = '\\0';\n\t}\n\n\tif (src == NULL) {\n\t    src = buf;\n\t    len = strlen(buf);\n\t}\n\tif (issue_len + len + 1 > size) {\n\t    char *new_issue;\n\n\t    size += len + 1;\n\t    new_issue = realloc (issue, size);\n\t    if (new_issue == NULL) {\n\t\t_pam_drop(issue);\n\t\treturn PAM_BUF_ERR;\n\t    }\n\t    issue = new_issue;\n\t}\n\tmemcpy(issue + issue_len, src, len);\n\tissue_len += len;\n    }\n\n    issue[issue_len] = '\\0';\n\n    if (ferror(fp)) {\n\tpam_syslog(pamh, LOG_ERR, \"read error: %m\");\n\t_pam_drop(issue);\n\treturn PAM_SERVICE_ERR;\n    }\n\n    *prompt = issue;\n    return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "read_issue_raw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_issue/pam_issue.c",
    "lines": "131-158",
    "snippet": "static int\nread_issue_raw(pam_handle_t *pamh, FILE *fp, char **prompt)\n{\n    char *issue;\n    struct stat st;\n\n    *prompt = NULL;\n\n    if (fstat(fileno(fp), &st) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"stat error: %m\");\n\treturn PAM_SERVICE_ERR;\n    }\n\n    if ((issue = malloc(st.st_size + 1)) == NULL) {\n\tpam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\treturn PAM_BUF_ERR;\n    }\n\n    if ((off_t)fread(issue, 1, st.st_size, fp) != st.st_size) {\n\tpam_syslog(pamh, LOG_ERR, \"read error: %m\");\n\t_pam_drop(issue);\n\treturn PAM_SERVICE_ERR;\n    }\n\n    issue[st.st_size] = '\\0';\n    *prompt = issue;\n    return PAM_SUCCESS;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <utmp.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int read_issue_raw(pam_handle_t *pamh, FILE *fp, char **prompt);",
      "static int read_issue_quoted(pam_handle_t *pamh, FILE *fp, char **prompt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "issue"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"read error: %m\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "issue",
            "1",
            "st.st_size",
            "fp"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"out of memory\""
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "st.st_size + 1"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"stat error: %m\""
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fileno(fp)",
            "&st"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "fp"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <syslog.h>\n#include <time.h>\n#include <utmp.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"config.h\"\n\nstatic int read_issue_raw(pam_handle_t *pamh, FILE *fp, char **prompt);\nstatic int read_issue_quoted(pam_handle_t *pamh, FILE *fp, char **prompt);\n\nstatic int\nread_issue_raw(pam_handle_t *pamh, FILE *fp, char **prompt)\n{\n    char *issue;\n    struct stat st;\n\n    *prompt = NULL;\n\n    if (fstat(fileno(fp), &st) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"stat error: %m\");\n\treturn PAM_SERVICE_ERR;\n    }\n\n    if ((issue = malloc(st.st_size + 1)) == NULL) {\n\tpam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\treturn PAM_BUF_ERR;\n    }\n\n    if ((off_t)fread(issue, 1, st.st_size, fp) != st.st_size) {\n\tpam_syslog(pamh, LOG_ERR, \"read error: %m\");\n\t_pam_drop(issue);\n\treturn PAM_SERVICE_ERR;\n    }\n\n    issue[st.st_size] = '\\0';\n    *prompt = issue;\n    return PAM_SUCCESS;\n}"
  },
  {
    "function_name": "pam_sm_setcred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_issue/pam_issue.c",
    "lines": "124-129",
    "snippet": "int\npam_sm_setcred (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\tint argc UNUSED, const char **argv UNUSED)\n{\n     return PAM_IGNORE;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <utmp.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <syslog.h>\n#include <time.h>\n#include <utmp.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"config.h\"\n\nint\npam_sm_setcred (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\tint argc UNUSED, const char **argv UNUSED)\n{\n     return PAM_IGNORE;\n}"
  },
  {
    "function_name": "pam_sm_authenticate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_issue/pam_issue.c",
    "lines": "44-122",
    "snippet": "int\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    int retval = PAM_SERVICE_ERR;\n    FILE *fp;\n    const char *issue_file = NULL;\n    int parse_esc = 1;\n    const void *item = NULL;\n    const char *cur_prompt;\n    char *issue_prompt = NULL;\n\n   /* If we've already set the prompt, don't set it again */\n    if(_user_prompt_set)\n\treturn PAM_IGNORE;\n\n    /* We set this here so if we fail below, we won't get further\n       than this next time around (only one real failure) */\n    _user_prompt_set = 1;\n\n    for ( ; argc-- > 0 ; ++argv ) {\n\tconst char *str;\n\n\tif ((str = pam_str_skip_prefix(*argv, \"issue=\")) != NULL) {\n\t    issue_file = str;\n\t    D((\"set issue_file to: %s\", issue_file));\n\t} else if (!strcmp(*argv,\"noesc\")) {\n\t    parse_esc = 0;\n\t    D((\"turning off escape parsing by request\"));\n\t} else\n\t    D((\"unknown option passed: %s\", *argv));\n    }\n\n    if (issue_file == NULL)\n\tissue_file = \"/etc/issue\";\n\n    if ((fp = fopen(issue_file, \"r\")) == NULL) {\n\tpam_syslog(pamh, LOG_ERR, \"error opening %s: %m\", issue_file);\n\treturn PAM_SERVICE_ERR;\n    }\n\n    if ((retval = pam_get_item(pamh, PAM_USER_PROMPT, &item)) != PAM_SUCCESS) {\n\tfclose(fp);\n\treturn retval;\n    }\n\n    cur_prompt = item;\n    if (cur_prompt == NULL)\n\tcur_prompt = \"\";\n\n    if (parse_esc)\n\tretval = read_issue_quoted(pamh, fp, &issue_prompt);\n    else\n\tretval = read_issue_raw(pamh, fp, &issue_prompt);\n\n    fclose(fp);\n\n    if (retval != PAM_SUCCESS)\n\tgoto out;\n\n    {\n\tsize_t size = strlen(issue_prompt) + strlen(cur_prompt) + 1;\n\tchar *new_prompt = realloc(issue_prompt, size);\n\n\tif (new_prompt == NULL) {\n\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t    retval = PAM_BUF_ERR;\n\t    goto out;\n\t}\n\tissue_prompt = new_prompt;\n    }\n\n    strcat(issue_prompt, cur_prompt);\n    retval = pam_set_item(pamh, PAM_USER_PROMPT,\n\t\t\t      (const void *) issue_prompt);\n  out:\n    _pam_drop(issue_prompt);\n    return (retval == PAM_SUCCESS) ? PAM_IGNORE : retval;\n}",
    "includes": [
      "#include \"pam_inline.h\"",
      "#include <security/pam_ext.h>",
      "#include <security/pam_modules.h>",
      "#include <security/_pam_macros.h>",
      "#include <syslog.h>",
      "#include <time.h>",
      "#include <utmp.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _user_prompt_set = 0;",
      "static int read_issue_raw(pam_handle_t *pamh, FILE *fp, char **prompt);",
      "static int read_issue_quoted(pam_handle_t *pamh, FILE *fp, char **prompt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_pam_drop",
          "args": [
            "issue_prompt"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_set_item",
          "args": [
            "pamh",
            "PAM_USER_PROMPT",
            "(const void *) issue_prompt"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "issue_prompt",
            "cur_prompt"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_CRIT",
            "\"out of memory\""
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "issue_prompt",
            "size"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cur_prompt"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "issue_prompt"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_issue_raw",
          "args": [
            "pamh",
            "fp",
            "&issue_prompt"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "read_issue_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_issue/pam_issue.c",
          "lines": "131-158",
          "snippet": "static int\nread_issue_raw(pam_handle_t *pamh, FILE *fp, char **prompt)\n{\n    char *issue;\n    struct stat st;\n\n    *prompt = NULL;\n\n    if (fstat(fileno(fp), &st) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"stat error: %m\");\n\treturn PAM_SERVICE_ERR;\n    }\n\n    if ((issue = malloc(st.st_size + 1)) == NULL) {\n\tpam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\treturn PAM_BUF_ERR;\n    }\n\n    if ((off_t)fread(issue, 1, st.st_size, fp) != st.st_size) {\n\tpam_syslog(pamh, LOG_ERR, \"read error: %m\");\n\t_pam_drop(issue);\n\treturn PAM_SERVICE_ERR;\n    }\n\n    issue[st.st_size] = '\\0';\n    *prompt = issue;\n    return PAM_SUCCESS;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int read_issue_raw(pam_handle_t *pamh, FILE *fp, char **prompt);",
            "static int read_issue_quoted(pam_handle_t *pamh, FILE *fp, char **prompt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <syslog.h>\n#include <time.h>\n#include <utmp.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"config.h\"\n\nstatic int read_issue_raw(pam_handle_t *pamh, FILE *fp, char **prompt);\nstatic int read_issue_quoted(pam_handle_t *pamh, FILE *fp, char **prompt);\n\nstatic int\nread_issue_raw(pam_handle_t *pamh, FILE *fp, char **prompt)\n{\n    char *issue;\n    struct stat st;\n\n    *prompt = NULL;\n\n    if (fstat(fileno(fp), &st) < 0) {\n\tpam_syslog(pamh, LOG_ERR, \"stat error: %m\");\n\treturn PAM_SERVICE_ERR;\n    }\n\n    if ((issue = malloc(st.st_size + 1)) == NULL) {\n\tpam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\treturn PAM_BUF_ERR;\n    }\n\n    if ((off_t)fread(issue, 1, st.st_size, fp) != st.st_size) {\n\tpam_syslog(pamh, LOG_ERR, \"read error: %m\");\n\t_pam_drop(issue);\n\treturn PAM_SERVICE_ERR;\n    }\n\n    issue[st.st_size] = '\\0';\n    *prompt = issue;\n    return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_issue_quoted",
          "args": [
            "pamh",
            "fp",
            "&issue_prompt"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "read_issue_quoted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_issue/pam_issue.c",
          "lines": "160-304",
          "snippet": "static int\nread_issue_quoted(pam_handle_t *pamh, FILE *fp, char **prompt)\n{\n    int c;\n    size_t size = 1024;\n    size_t issue_len = 0;\n    char *issue;\n    struct utsname uts;\n\n    *prompt = NULL;\n\n    if ((issue = malloc(size)) == NULL) {\n\tpam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\treturn PAM_BUF_ERR;\n    }\n\n    (void) uname(&uts);\n\n    while ((c = getc(fp)) != EOF) {\n\tconst char *src = NULL;\n\tsize_t len = 0;\n\tchar buf[1024] = \"\";\n\n\tif (c == '\\\\') {\n\t    if ((c = getc(fp)) == EOF)\n\t\tbreak;\n\t    switch (c) {\n\t      case 's':\n\t\tsrc = uts.sysname;\n\t\tlen = strnlen(uts.sysname, sizeof(uts.sysname));\n\t\tbreak;\n\t      case 'n':\n\t\tsrc = uts.nodename;\n\t\tlen = strnlen(uts.nodename, sizeof(uts.nodename));\n\t\tbreak;\n\t      case 'r':\n\t\tsrc = uts.release;\n\t\tlen = strnlen(uts.release, sizeof(uts.release));\n\t\tbreak;\n\t      case 'v':\n\t\tsrc = uts.version;\n\t\tlen = strnlen(uts.version, sizeof(uts.version));\n\t\tbreak;\n\t      case 'm':\n\t\tsrc = uts.machine;\n\t\tlen = strnlen(uts.machine, sizeof(uts.machine));\n\t\tbreak;\n\t      case 'o':\n#ifdef HAVE_GETDOMAINNAME\n\t\tif (getdomainname(buf, sizeof(buf)) >= 0)\n\t\t    buf[sizeof(buf) - 1] = '\\0';\n#endif\n\t\tbreak;\n\t      case 'd':\n\t      case 't':\n\t\t{\n\t\t    const char *weekday[] = {\n\t\t\t\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\",\n\t\t\t\"Fri\", \"Sat\" };\n\t\t    const char *month[] = {\n\t\t\t\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\",\n\t\t\t\"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\",\n\t\t\t\"Nov\", \"Dec\" };\n\t\t    time_t now;\n\t\t    struct tm *tm;\n\n\t\t    (void) time (&now);\n\t\t    tm = localtime(&now);\n\n\t\t    if (c == 'd')\n\t\t\tsnprintf (buf, sizeof buf, \"%s %s %d  %d\",\n\t\t\t\tweekday[tm->tm_wday], month[tm->tm_mon],\n\t\t\t\ttm->tm_mday, tm->tm_year + 1900);\n\t\t    else\n\t\t\tsnprintf (buf, sizeof buf, \"%02d:%02d:%02d\",\n\t\t\t\ttm->tm_hour, tm->tm_min, tm->tm_sec);\n\t\t}\n\t\tbreak;\n\t      case 'l':\n\t\t{\n\t\t    const char *ttyn = ttyname(1);\n\t\t    if (ttyn) {\n\t\t\tconst char *str = pam_str_skip_prefix(ttyn, \"/dev/\");\n\t\t\tif (str != NULL)\n\t\t\t    ttyn = str;\n\t\t\tsrc = ttyn;\n\t\t\tlen = strlen(ttyn);\n\t\t    }\n\t\t}\n\t\tbreak;\n\t      case 'u':\n\t      case 'U':\n\t\t{\n\t\t    unsigned int users = 0;\n\t\t    struct utmp *ut;\n\t\t    setutent();\n\t\t    while ((ut = getutent())) {\n\t\t\tif (ut->ut_type == USER_PROCESS)\n\t\t\t    ++users;\n\t\t    }\n\t\t    endutent();\n\t\t    if (c == 'U')\n\t\t\tsnprintf (buf, sizeof buf, \"%u %s\", users,\n\t\t\t          (users == 1) ? \"user\" : \"users\");\n\t\t    else\n\t\t\tsnprintf (buf, sizeof buf, \"%u\", users);\n\t\t    break;\n\t\t}\n\t      default:\n\t\tbuf[0] = c; buf[1] = '\\0';\n\t    }\n\t} else {\n\t    buf[0] = c; buf[1] = '\\0';\n\t}\n\n\tif (src == NULL) {\n\t    src = buf;\n\t    len = strlen(buf);\n\t}\n\tif (issue_len + len + 1 > size) {\n\t    char *new_issue;\n\n\t    size += len + 1;\n\t    new_issue = realloc (issue, size);\n\t    if (new_issue == NULL) {\n\t\t_pam_drop(issue);\n\t\treturn PAM_BUF_ERR;\n\t    }\n\t    issue = new_issue;\n\t}\n\tmemcpy(issue + issue_len, src, len);\n\tissue_len += len;\n    }\n\n    issue[issue_len] = '\\0';\n\n    if (ferror(fp)) {\n\tpam_syslog(pamh, LOG_ERR, \"read error: %m\");\n\t_pam_drop(issue);\n\treturn PAM_SERVICE_ERR;\n    }\n\n    *prompt = issue;\n    return PAM_SUCCESS;\n}",
          "includes": [
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modules.h>",
            "#include <security/_pam_macros.h>",
            "#include <syslog.h>",
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int read_issue_raw(pam_handle_t *pamh, FILE *fp, char **prompt);",
            "static int read_issue_quoted(pam_handle_t *pamh, FILE *fp, char **prompt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <syslog.h>\n#include <time.h>\n#include <utmp.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"config.h\"\n\nstatic int read_issue_raw(pam_handle_t *pamh, FILE *fp, char **prompt);\nstatic int read_issue_quoted(pam_handle_t *pamh, FILE *fp, char **prompt);\n\nstatic int\nread_issue_quoted(pam_handle_t *pamh, FILE *fp, char **prompt)\n{\n    int c;\n    size_t size = 1024;\n    size_t issue_len = 0;\n    char *issue;\n    struct utsname uts;\n\n    *prompt = NULL;\n\n    if ((issue = malloc(size)) == NULL) {\n\tpam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\treturn PAM_BUF_ERR;\n    }\n\n    (void) uname(&uts);\n\n    while ((c = getc(fp)) != EOF) {\n\tconst char *src = NULL;\n\tsize_t len = 0;\n\tchar buf[1024] = \"\";\n\n\tif (c == '\\\\') {\n\t    if ((c = getc(fp)) == EOF)\n\t\tbreak;\n\t    switch (c) {\n\t      case 's':\n\t\tsrc = uts.sysname;\n\t\tlen = strnlen(uts.sysname, sizeof(uts.sysname));\n\t\tbreak;\n\t      case 'n':\n\t\tsrc = uts.nodename;\n\t\tlen = strnlen(uts.nodename, sizeof(uts.nodename));\n\t\tbreak;\n\t      case 'r':\n\t\tsrc = uts.release;\n\t\tlen = strnlen(uts.release, sizeof(uts.release));\n\t\tbreak;\n\t      case 'v':\n\t\tsrc = uts.version;\n\t\tlen = strnlen(uts.version, sizeof(uts.version));\n\t\tbreak;\n\t      case 'm':\n\t\tsrc = uts.machine;\n\t\tlen = strnlen(uts.machine, sizeof(uts.machine));\n\t\tbreak;\n\t      case 'o':\n#ifdef HAVE_GETDOMAINNAME\n\t\tif (getdomainname(buf, sizeof(buf)) >= 0)\n\t\t    buf[sizeof(buf) - 1] = '\\0';\n#endif\n\t\tbreak;\n\t      case 'd':\n\t      case 't':\n\t\t{\n\t\t    const char *weekday[] = {\n\t\t\t\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\",\n\t\t\t\"Fri\", \"Sat\" };\n\t\t    const char *month[] = {\n\t\t\t\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\",\n\t\t\t\"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\",\n\t\t\t\"Nov\", \"Dec\" };\n\t\t    time_t now;\n\t\t    struct tm *tm;\n\n\t\t    (void) time (&now);\n\t\t    tm = localtime(&now);\n\n\t\t    if (c == 'd')\n\t\t\tsnprintf (buf, sizeof buf, \"%s %s %d  %d\",\n\t\t\t\tweekday[tm->tm_wday], month[tm->tm_mon],\n\t\t\t\ttm->tm_mday, tm->tm_year + 1900);\n\t\t    else\n\t\t\tsnprintf (buf, sizeof buf, \"%02d:%02d:%02d\",\n\t\t\t\ttm->tm_hour, tm->tm_min, tm->tm_sec);\n\t\t}\n\t\tbreak;\n\t      case 'l':\n\t\t{\n\t\t    const char *ttyn = ttyname(1);\n\t\t    if (ttyn) {\n\t\t\tconst char *str = pam_str_skip_prefix(ttyn, \"/dev/\");\n\t\t\tif (str != NULL)\n\t\t\t    ttyn = str;\n\t\t\tsrc = ttyn;\n\t\t\tlen = strlen(ttyn);\n\t\t    }\n\t\t}\n\t\tbreak;\n\t      case 'u':\n\t      case 'U':\n\t\t{\n\t\t    unsigned int users = 0;\n\t\t    struct utmp *ut;\n\t\t    setutent();\n\t\t    while ((ut = getutent())) {\n\t\t\tif (ut->ut_type == USER_PROCESS)\n\t\t\t    ++users;\n\t\t    }\n\t\t    endutent();\n\t\t    if (c == 'U')\n\t\t\tsnprintf (buf, sizeof buf, \"%u %s\", users,\n\t\t\t          (users == 1) ? \"user\" : \"users\");\n\t\t    else\n\t\t\tsnprintf (buf, sizeof buf, \"%u\", users);\n\t\t    break;\n\t\t}\n\t      default:\n\t\tbuf[0] = c; buf[1] = '\\0';\n\t    }\n\t} else {\n\t    buf[0] = c; buf[1] = '\\0';\n\t}\n\n\tif (src == NULL) {\n\t    src = buf;\n\t    len = strlen(buf);\n\t}\n\tif (issue_len + len + 1 > size) {\n\t    char *new_issue;\n\n\t    size += len + 1;\n\t    new_issue = realloc (issue, size);\n\t    if (new_issue == NULL) {\n\t\t_pam_drop(issue);\n\t\treturn PAM_BUF_ERR;\n\t    }\n\t    issue = new_issue;\n\t}\n\tmemcpy(issue + issue_len, src, len);\n\tissue_len += len;\n    }\n\n    issue[issue_len] = '\\0';\n\n    if (ferror(fp)) {\n\tpam_syslog(pamh, LOG_ERR, \"read error: %m\");\n\t_pam_drop(issue);\n\treturn PAM_SERVICE_ERR;\n    }\n\n    *prompt = issue;\n    return PAM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_get_item",
          "args": [
            "pamh",
            "PAM_USER_PROMPT",
            "&item"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_syslog",
          "args": [
            "pamh",
            "LOG_ERR",
            "\"error opening %s: %m\"",
            "issue_file"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "issue_file",
            "\"r\""
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"unknown option passed: %s\", *argv)"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"noesc\""
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_str_skip_prefix",
          "args": [
            "*argv",
            "\"issue=\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <syslog.h>\n#include <time.h>\n#include <utmp.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"config.h\"\n\nstatic int _user_prompt_set = 0;\nstatic int read_issue_raw(pam_handle_t *pamh, FILE *fp, char **prompt);\nstatic int read_issue_quoted(pam_handle_t *pamh, FILE *fp, char **prompt);\n\nint\npam_sm_authenticate (pam_handle_t *pamh, int flags UNUSED,\n\t\t     int argc, const char **argv)\n{\n    int retval = PAM_SERVICE_ERR;\n    FILE *fp;\n    const char *issue_file = NULL;\n    int parse_esc = 1;\n    const void *item = NULL;\n    const char *cur_prompt;\n    char *issue_prompt = NULL;\n\n   /* If we've already set the prompt, don't set it again */\n    if(_user_prompt_set)\n\treturn PAM_IGNORE;\n\n    /* We set this here so if we fail below, we won't get further\n       than this next time around (only one real failure) */\n    _user_prompt_set = 1;\n\n    for ( ; argc-- > 0 ; ++argv ) {\n\tconst char *str;\n\n\tif ((str = pam_str_skip_prefix(*argv, \"issue=\")) != NULL) {\n\t    issue_file = str;\n\t    D((\"set issue_file to: %s\", issue_file));\n\t} else if (!strcmp(*argv,\"noesc\")) {\n\t    parse_esc = 0;\n\t    D((\"turning off escape parsing by request\"));\n\t} else\n\t    D((\"unknown option passed: %s\", *argv));\n    }\n\n    if (issue_file == NULL)\n\tissue_file = \"/etc/issue\";\n\n    if ((fp = fopen(issue_file, \"r\")) == NULL) {\n\tpam_syslog(pamh, LOG_ERR, \"error opening %s: %m\", issue_file);\n\treturn PAM_SERVICE_ERR;\n    }\n\n    if ((retval = pam_get_item(pamh, PAM_USER_PROMPT, &item)) != PAM_SUCCESS) {\n\tfclose(fp);\n\treturn retval;\n    }\n\n    cur_prompt = item;\n    if (cur_prompt == NULL)\n\tcur_prompt = \"\";\n\n    if (parse_esc)\n\tretval = read_issue_quoted(pamh, fp, &issue_prompt);\n    else\n\tretval = read_issue_raw(pamh, fp, &issue_prompt);\n\n    fclose(fp);\n\n    if (retval != PAM_SUCCESS)\n\tgoto out;\n\n    {\n\tsize_t size = strlen(issue_prompt) + strlen(cur_prompt) + 1;\n\tchar *new_prompt = realloc(issue_prompt, size);\n\n\tif (new_prompt == NULL) {\n\t    pam_syslog(pamh, LOG_CRIT, \"out of memory\");\n\t    retval = PAM_BUF_ERR;\n\t    goto out;\n\t}\n\tissue_prompt = new_prompt;\n    }\n\n    strcat(issue_prompt, cur_prompt);\n    retval = pam_set_item(pamh, PAM_USER_PROMPT,\n\t\t\t      (const void *) issue_prompt);\n  out:\n    _pam_drop(issue_prompt);\n    return (retval == PAM_SUCCESS) ? PAM_IGNORE : retval;\n}"
  }
]