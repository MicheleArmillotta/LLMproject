[
  {
    "function_name": "bigcrypt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/bigcrypt.c",
    "lines": "51-163",
    "snippet": "char *bigcrypt(const char *key, const char *salt)\n{\n\tchar *dec_c2_cryptbuf;\n#ifdef HAVE_CRYPT_R\n\tstruct crypt_data *cdata;\n#endif\n\tunsigned long int keylen, n_seg, j;\n\tchar *cipher_ptr, *plaintext_ptr, *tmp_ptr, *salt_ptr;\n\tchar keybuf[KEYBUF_SIZE + 1];\n\n\tD((\"called with key='%s', salt='%s'.\", key, salt));\n\n\t/* reset arrays */\n\tdec_c2_cryptbuf = malloc(CBUF_SIZE);\n\tif (!dec_c2_cryptbuf) {\n\t\treturn NULL;\n\t}\n#ifdef HAVE_CRYPT_R\n\tcdata = malloc(sizeof(*cdata));\n\tif(!cdata) {\n\t\tfree(dec_c2_cryptbuf);\n\t\treturn NULL;\n\t}\n\tcdata->initialized = 0;\n#endif\n\tmemset(keybuf, 0, KEYBUF_SIZE + 1);\n\tmemset(dec_c2_cryptbuf, 0, CBUF_SIZE);\n\n\t/* fill KEYBUF_SIZE with key */\n\tstrncpy(keybuf, key, KEYBUF_SIZE);\n\n\t/* deal with case that we are doing a password check for a\n\t   conventially encrypted password: the salt will be\n\t   SALT_SIZE+ESEGMENT_SIZE long. */\n\tif (strlen(salt) == (SALT_SIZE + ESEGMENT_SIZE))\n\t\tkeybuf[SEGMENT_SIZE] = '\\0';\t/* terminate password early(?) */\n\n\tkeylen = strlen(keybuf);\n\n\tif (!keylen) {\n\t\tn_seg = 1;\n\t} else {\n\t\t/* work out how many segments */\n\t\tn_seg = 1 + ((keylen - 1) / SEGMENT_SIZE);\n\t}\n\n\tif (n_seg > MAX_PASS_LEN)\n\t\tn_seg = MAX_PASS_LEN;\t/* truncate at max length */\n\n\t/* set up some pointers */\n\tcipher_ptr = dec_c2_cryptbuf;\n\tplaintext_ptr = keybuf;\n\n\t/* do the first block with supplied salt */\n#ifdef HAVE_CRYPT_R\n\ttmp_ptr = crypt_r(plaintext_ptr, salt, cdata);\t/* libc crypt_r() */\n#else\n\ttmp_ptr = crypt(plaintext_ptr, salt);\t/* libc crypt() */\n#endif\n\tif (tmp_ptr == NULL) {\n\t\tfree(dec_c2_cryptbuf);\n#ifdef HAVE_CRYPT_R\n\t\tfree(cdata);\n#endif\n\t\treturn NULL;\n\t}\n\t/* and place in the static area */\n\tstrncpy(cipher_ptr, tmp_ptr, 13);\n\tcipher_ptr += ESEGMENT_SIZE + SALT_SIZE;\n\tplaintext_ptr += SEGMENT_SIZE;\t/* first block of SEGMENT_SIZE */\n\n\t/* change the salt (1st 2 chars of previous block) - this was found\n\t   by dowsing */\n\n\tsalt_ptr = cipher_ptr - ESEGMENT_SIZE;\n\n\t/* so far this is identical to \"return crypt(key, salt);\", if\n\t   there is more than one block encrypt them... */\n\n\tif (n_seg > 1) {\n\t\tfor (j = 2; j <= n_seg; j++) {\n\n#ifdef HAVE_CRYPT_R\n\t\t\ttmp_ptr = crypt_r(plaintext_ptr, salt_ptr, cdata);\n#else\n\t\t\ttmp_ptr = crypt(plaintext_ptr, salt_ptr);\n#endif\n\t\t\tif (tmp_ptr == NULL) {\n\t\t\t\t_pam_overwrite(dec_c2_cryptbuf);\n\t\t\t\tfree(dec_c2_cryptbuf);\n#ifdef HAVE_CRYPT_R\n\t\t\t\tfree(cdata);\n#endif\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/* skip the salt for seg!=0 */\n\t\t\tstrncpy(cipher_ptr, (tmp_ptr + SALT_SIZE), ESEGMENT_SIZE);\n\n\t\t\tcipher_ptr += ESEGMENT_SIZE;\n\t\t\tplaintext_ptr += SEGMENT_SIZE;\n\t\t\tsalt_ptr = cipher_ptr - ESEGMENT_SIZE;\n\t\t}\n\t}\n\tD((\"key=|%s|, salt=|%s|\\nbuf=|%s|\\n\", key, salt, dec_c2_cryptbuf));\n\n#ifdef HAVE_CRYPT_R\n\tfree(cdata);\n#endif\n\n\t/* this is the <NUL> terminated encrypted password */\n\treturn dec_c2_cryptbuf;\n}",
    "includes": [
      "#include \"bigcrypt.h\"",
      "#include <crypt.h>",
      "#include <security/_pam_macros.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define CBUF_SIZE          ((MAX_PASS_LEN*ESEGMENT_SIZE)+SALT_SIZE+1)",
      "#define ESEGMENT_SIZE      11",
      "#define KEYBUF_SIZE        ((MAX_PASS_LEN*SEGMENT_SIZE)+SALT_SIZE)",
      "#define SALT_SIZE          2",
      "#define SEGMENT_SIZE       8",
      "#define MAX_PASS_LEN       16"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cdata"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_selinux/pam_selinux.c",
          "lines": "386-398",
          "snippet": "static void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}",
          "includes": [
            "#include <sys/select.h>",
            "#include <libaudit.h>",
            "#include <selinux/get_default_type.h>",
            "#include <selinux/context.h>",
            "#include <selinux/get_context_list.h>",
            "#include <selinux/selinux.h>",
            "#include \"pam_inline.h\"",
            "#include <security/pam_ext.h>",
            "#include <security/pam_modutil.h>",
            "#include <security/_pam_macros.h>",
            "#include <security/pam_modules.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/select.h>\n#include <libaudit.h>\n#include <selinux/get_default_type.h>\n#include <selinux/context.h>\n#include <selinux/get_context_list.h>\n#include <selinux/selinux.h>\n#include \"pam_inline.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/_pam_macros.h>\n#include <security/pam_modules.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include \"config.h\"\n\nstatic void\nfree_module_data(module_data_t *data)\n{\n  free(data->tty_path);\n  freecon(data->prev_tty_context);\n  freecon(data->tty_context);\n  freecon(data->default_user_context);\n  freecon(data->prev_exec_context);\n  if (data->exec_context != data->default_user_context)\n    freecon(data->exec_context);\n  memset(data, 0, sizeof(*data));\n  free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "D",
          "args": [
            "(\"key=|%s|, salt=|%s|\\nbuf=|%s|\\n\", key, salt, dec_c2_cryptbuf)"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/md5.c",
          "lines": "53-62",
          "snippet": "void MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include <string.h>\n\nvoid MD5Name(MD5Init)(struct MD5Context *ctx)\n{\n\tctx->buf.i[0] = 0x67452301U;\n\tctx->buf.i[1] = 0xefcdab89U;\n\tctx->buf.i[2] = 0x98badcfeU;\n\tctx->buf.i[3] = 0x10325476U;\n\n\tctx->bits[0] = 0;\n\tctx->bits[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "cipher_ptr",
            "(tmp_ptr + SALT_SIZE)",
            "ESEGMENT_SIZE"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_pam_overwrite",
          "args": [
            "dec_c2_cryptbuf"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypt",
          "args": [
            "plaintext_ptr",
            "salt_ptr"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "bigcrypt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_unix/bigcrypt.c",
          "lines": "51-163",
          "snippet": "char *bigcrypt(const char *key, const char *salt)\n{\n\tchar *dec_c2_cryptbuf;\n#ifdef HAVE_CRYPT_R\n\tstruct crypt_data *cdata;\n#endif\n\tunsigned long int keylen, n_seg, j;\n\tchar *cipher_ptr, *plaintext_ptr, *tmp_ptr, *salt_ptr;\n\tchar keybuf[KEYBUF_SIZE + 1];\n\n\tD((\"called with key='%s', salt='%s'.\", key, salt));\n\n\t/* reset arrays */\n\tdec_c2_cryptbuf = malloc(CBUF_SIZE);\n\tif (!dec_c2_cryptbuf) {\n\t\treturn NULL;\n\t}\n#ifdef HAVE_CRYPT_R\n\tcdata = malloc(sizeof(*cdata));\n\tif(!cdata) {\n\t\tfree(dec_c2_cryptbuf);\n\t\treturn NULL;\n\t}\n\tcdata->initialized = 0;\n#endif\n\tmemset(keybuf, 0, KEYBUF_SIZE + 1);\n\tmemset(dec_c2_cryptbuf, 0, CBUF_SIZE);\n\n\t/* fill KEYBUF_SIZE with key */\n\tstrncpy(keybuf, key, KEYBUF_SIZE);\n\n\t/* deal with case that we are doing a password check for a\n\t   conventially encrypted password: the salt will be\n\t   SALT_SIZE+ESEGMENT_SIZE long. */\n\tif (strlen(salt) == (SALT_SIZE + ESEGMENT_SIZE))\n\t\tkeybuf[SEGMENT_SIZE] = '\\0';\t/* terminate password early(?) */\n\n\tkeylen = strlen(keybuf);\n\n\tif (!keylen) {\n\t\tn_seg = 1;\n\t} else {\n\t\t/* work out how many segments */\n\t\tn_seg = 1 + ((keylen - 1) / SEGMENT_SIZE);\n\t}\n\n\tif (n_seg > MAX_PASS_LEN)\n\t\tn_seg = MAX_PASS_LEN;\t/* truncate at max length */\n\n\t/* set up some pointers */\n\tcipher_ptr = dec_c2_cryptbuf;\n\tplaintext_ptr = keybuf;\n\n\t/* do the first block with supplied salt */\n#ifdef HAVE_CRYPT_R\n\ttmp_ptr = crypt_r(plaintext_ptr, salt, cdata);\t/* libc crypt_r() */\n#else\n\ttmp_ptr = crypt(plaintext_ptr, salt);\t/* libc crypt() */\n#endif\n\tif (tmp_ptr == NULL) {\n\t\tfree(dec_c2_cryptbuf);\n#ifdef HAVE_CRYPT_R\n\t\tfree(cdata);\n#endif\n\t\treturn NULL;\n\t}\n\t/* and place in the static area */\n\tstrncpy(cipher_ptr, tmp_ptr, 13);\n\tcipher_ptr += ESEGMENT_SIZE + SALT_SIZE;\n\tplaintext_ptr += SEGMENT_SIZE;\t/* first block of SEGMENT_SIZE */\n\n\t/* change the salt (1st 2 chars of previous block) - this was found\n\t   by dowsing */\n\n\tsalt_ptr = cipher_ptr - ESEGMENT_SIZE;\n\n\t/* so far this is identical to \"return crypt(key, salt);\", if\n\t   there is more than one block encrypt them... */\n\n\tif (n_seg > 1) {\n\t\tfor (j = 2; j <= n_seg; j++) {\n\n#ifdef HAVE_CRYPT_R\n\t\t\ttmp_ptr = crypt_r(plaintext_ptr, salt_ptr, cdata);\n#else\n\t\t\ttmp_ptr = crypt(plaintext_ptr, salt_ptr);\n#endif\n\t\t\tif (tmp_ptr == NULL) {\n\t\t\t\t_pam_overwrite(dec_c2_cryptbuf);\n\t\t\t\tfree(dec_c2_cryptbuf);\n#ifdef HAVE_CRYPT_R\n\t\t\t\tfree(cdata);\n#endif\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/* skip the salt for seg!=0 */\n\t\t\tstrncpy(cipher_ptr, (tmp_ptr + SALT_SIZE), ESEGMENT_SIZE);\n\n\t\t\tcipher_ptr += ESEGMENT_SIZE;\n\t\t\tplaintext_ptr += SEGMENT_SIZE;\n\t\t\tsalt_ptr = cipher_ptr - ESEGMENT_SIZE;\n\t\t}\n\t}\n\tD((\"key=|%s|, salt=|%s|\\nbuf=|%s|\\n\", key, salt, dec_c2_cryptbuf));\n\n#ifdef HAVE_CRYPT_R\n\tfree(cdata);\n#endif\n\n\t/* this is the <NUL> terminated encrypted password */\n\treturn dec_c2_cryptbuf;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "crypt_r",
          "args": [
            "plaintext_ptr",
            "salt_ptr",
            "cdata"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "cipher_ptr",
            "tmp_ptr",
            "13"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypt_r",
          "args": [
            "plaintext_ptr",
            "salt",
            "cdata"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "keybuf"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "salt"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "keybuf",
            "key",
            "KEYBUF_SIZE"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dec_c2_cryptbuf",
            "0",
            "CBUF_SIZE"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "keybuf",
            "0",
            "KEYBUF_SIZE + 1"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*cdata)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "CBUF_SIZE"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bigcrypt.h\"\n#include <crypt.h>\n#include <security/_pam_macros.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"config.h\"\n\n#define CBUF_SIZE          ((MAX_PASS_LEN*ESEGMENT_SIZE)+SALT_SIZE+1)\n#define ESEGMENT_SIZE      11\n#define KEYBUF_SIZE        ((MAX_PASS_LEN*SEGMENT_SIZE)+SALT_SIZE)\n#define SALT_SIZE          2\n#define SEGMENT_SIZE       8\n#define MAX_PASS_LEN       16\n\nchar *bigcrypt(const char *key, const char *salt)\n{\n\tchar *dec_c2_cryptbuf;\n#ifdef HAVE_CRYPT_R\n\tstruct crypt_data *cdata;\n#endif\n\tunsigned long int keylen, n_seg, j;\n\tchar *cipher_ptr, *plaintext_ptr, *tmp_ptr, *salt_ptr;\n\tchar keybuf[KEYBUF_SIZE + 1];\n\n\tD((\"called with key='%s', salt='%s'.\", key, salt));\n\n\t/* reset arrays */\n\tdec_c2_cryptbuf = malloc(CBUF_SIZE);\n\tif (!dec_c2_cryptbuf) {\n\t\treturn NULL;\n\t}\n#ifdef HAVE_CRYPT_R\n\tcdata = malloc(sizeof(*cdata));\n\tif(!cdata) {\n\t\tfree(dec_c2_cryptbuf);\n\t\treturn NULL;\n\t}\n\tcdata->initialized = 0;\n#endif\n\tmemset(keybuf, 0, KEYBUF_SIZE + 1);\n\tmemset(dec_c2_cryptbuf, 0, CBUF_SIZE);\n\n\t/* fill KEYBUF_SIZE with key */\n\tstrncpy(keybuf, key, KEYBUF_SIZE);\n\n\t/* deal with case that we are doing a password check for a\n\t   conventially encrypted password: the salt will be\n\t   SALT_SIZE+ESEGMENT_SIZE long. */\n\tif (strlen(salt) == (SALT_SIZE + ESEGMENT_SIZE))\n\t\tkeybuf[SEGMENT_SIZE] = '\\0';\t/* terminate password early(?) */\n\n\tkeylen = strlen(keybuf);\n\n\tif (!keylen) {\n\t\tn_seg = 1;\n\t} else {\n\t\t/* work out how many segments */\n\t\tn_seg = 1 + ((keylen - 1) / SEGMENT_SIZE);\n\t}\n\n\tif (n_seg > MAX_PASS_LEN)\n\t\tn_seg = MAX_PASS_LEN;\t/* truncate at max length */\n\n\t/* set up some pointers */\n\tcipher_ptr = dec_c2_cryptbuf;\n\tplaintext_ptr = keybuf;\n\n\t/* do the first block with supplied salt */\n#ifdef HAVE_CRYPT_R\n\ttmp_ptr = crypt_r(plaintext_ptr, salt, cdata);\t/* libc crypt_r() */\n#else\n\ttmp_ptr = crypt(plaintext_ptr, salt);\t/* libc crypt() */\n#endif\n\tif (tmp_ptr == NULL) {\n\t\tfree(dec_c2_cryptbuf);\n#ifdef HAVE_CRYPT_R\n\t\tfree(cdata);\n#endif\n\t\treturn NULL;\n\t}\n\t/* and place in the static area */\n\tstrncpy(cipher_ptr, tmp_ptr, 13);\n\tcipher_ptr += ESEGMENT_SIZE + SALT_SIZE;\n\tplaintext_ptr += SEGMENT_SIZE;\t/* first block of SEGMENT_SIZE */\n\n\t/* change the salt (1st 2 chars of previous block) - this was found\n\t   by dowsing */\n\n\tsalt_ptr = cipher_ptr - ESEGMENT_SIZE;\n\n\t/* so far this is identical to \"return crypt(key, salt);\", if\n\t   there is more than one block encrypt them... */\n\n\tif (n_seg > 1) {\n\t\tfor (j = 2; j <= n_seg; j++) {\n\n#ifdef HAVE_CRYPT_R\n\t\t\ttmp_ptr = crypt_r(plaintext_ptr, salt_ptr, cdata);\n#else\n\t\t\ttmp_ptr = crypt(plaintext_ptr, salt_ptr);\n#endif\n\t\t\tif (tmp_ptr == NULL) {\n\t\t\t\t_pam_overwrite(dec_c2_cryptbuf);\n\t\t\t\tfree(dec_c2_cryptbuf);\n#ifdef HAVE_CRYPT_R\n\t\t\t\tfree(cdata);\n#endif\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t/* skip the salt for seg!=0 */\n\t\t\tstrncpy(cipher_ptr, (tmp_ptr + SALT_SIZE), ESEGMENT_SIZE);\n\n\t\t\tcipher_ptr += ESEGMENT_SIZE;\n\t\t\tplaintext_ptr += SEGMENT_SIZE;\n\t\t\tsalt_ptr = cipher_ptr - ESEGMENT_SIZE;\n\t\t}\n\t}\n\tD((\"key=|%s|, salt=|%s|\\nbuf=|%s|\\n\", key, salt, dec_c2_cryptbuf));\n\n#ifdef HAVE_CRYPT_R\n\tfree(cdata);\n#endif\n\n\t/* this is the <NUL> terminated encrypted password */\n\treturn dec_c2_cryptbuf;\n}"
  }
]