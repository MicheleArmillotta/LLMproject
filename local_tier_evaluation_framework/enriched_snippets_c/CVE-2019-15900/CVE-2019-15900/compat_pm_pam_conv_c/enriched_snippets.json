[
  {
    "function_name": "pam_tty_conv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/compat/pm_pam_conv.c",
    "lines": "133-214",
    "snippet": "int\npam_tty_conv(int num_msg, struct pam_message **mess,\n    struct pam_response **resp, void *my_data)\n{\n\tstruct pam_message *m = *mess;\n\tstruct pam_response *r = calloc(num_msg, sizeof (struct pam_response));\n\tint i;\n\n\tif (num_msg >= PAM_MAX_NUM_MSG) {\n\t\t(void) fprintf(stderr, \"too many messages %d >= %d\\n\",\n\t\t    num_msg, PAM_MAX_NUM_MSG);\n\t\tfree(r);\n\t\t*resp = NULL;\n\t\treturn (PAM_CONV_ERR);\n\t}\n\n\t/* Talk it out */\n\t*resp = r;\n\tfor (i = 0; i < num_msg; i++) {\n\t\tint echo_off;\n\n\t\t/* bad message from service module */\n\t\tif (m->msg == NULL) {\n\t\t\t(void) fprintf(stderr, \"message[%d]: %d/NULL\\n\",\n\t\t\t    i, m->msg_style);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/*\n\t\t * fix up final newline:\n\t\t * \tremoved for prompts\n\t\t * \tadded back for messages\n\t\t */\n\t\tif (m->msg[strlen(m->msg)] == '\\n')\n\t\t\tm->msg[strlen(m->msg)] = '\\0';\n\n\t\tr->resp = NULL;\n\t\tr->resp_retcode = 0;\n\t\techo_off = 0;\n\t\tswitch (m->msg_style) {\n\n\t\tcase PAM_PROMPT_ECHO_OFF:\n\t\t\techo_off = 1;\n\t\t\t/*FALLTHROUGH*/\n\n\t\tcase PAM_PROMPT_ECHO_ON:\n\t\t\t(void) fputs(m->msg, stdout);\n\n\t\t\tr->resp = getinput(echo_off);\n\t\t\tbreak;\n\n\t\tcase PAM_ERROR_MSG:\n\t\t\t(void) fputs(m->msg, stderr);\n\t\t\t(void) fputc('\\n', stderr);\n\t\t\tbreak;\n\n\t\tcase PAM_TEXT_INFO:\n\t\t\t(void) fputs(m->msg, stdout);\n\t\t\t(void) fputc('\\n', stdout);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t(void) fprintf(stderr, \"message[%d]: unknown type \"\n\t\t\t    \"%d/val=\\\"%s\\\"\\n\",\n\t\t\t    i, m->msg_style, m->msg);\n\t\t\t/* error, service module won't clean up */\n\t\t\tgoto err;\n\t\t}\n\t\tif (errno == EINTR)\n\t\t\tgoto err;\n\n\t\t/* next message/response */\n\t\tm++;\n\t\tr++;\n\t}\n\treturn (PAM_SUCCESS);\n\nerr:\n\tfree_resp(i, r);\n\t*resp = NULL;\n\treturn (PAM_CONV_ERR);\n}",
    "includes": [
      "#include <security/pam_appl.h>",
      "#include <termio.h>",
      "#include <unistd.h>",
      "#include <stropts.h>",
      "#include <strings.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <malloc.h>",
      "#include <libgen.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_resp",
          "args": [
            "i",
            "r"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "free_resp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/compat/pm_pam_conv.c",
          "lines": "111-130",
          "snippet": "static void\nfree_resp(int num_msg, struct pam_response *pr)\n{\n\tint i;\n\tstruct pam_response *r = pr;\n\n\tif (pr == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < num_msg; i++, r++) {\n\n\t\tif (r->resp) {\n\t\t\t/* clear before freeing -- may be a password */\n\t\t\tbzero(r->resp, strlen(r->resp));\n\t\t\tfree(r->resp);\n\t\t\tr->resp = NULL;\n\t\t}\n\t}\n\tfree(pr);\n}",
          "includes": [
            "#include <security/pam_appl.h>",
            "#include <termio.h>",
            "#include <unistd.h>",
            "#include <stropts.h>",
            "#include <strings.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <malloc.h>",
            "#include <libgen.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <security/pam_appl.h>\n#include <termio.h>\n#include <unistd.h>\n#include <stropts.h>\n#include <strings.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <malloc.h>\n#include <libgen.h>\n#include <errno.h>\n\nstatic void\nfree_resp(int num_msg, struct pam_response *pr)\n{\n\tint i;\n\tstruct pam_response *r = pr;\n\n\tif (pr == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < num_msg; i++, r++) {\n\n\t\tif (r->resp) {\n\t\t\t/* clear before freeing -- may be a password */\n\t\t\tbzero(r->resp, strlen(r->resp));\n\t\t\tfree(r->resp);\n\t\t\tr->resp = NULL;\n\t\t}\n\t}\n\tfree(pr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"message[%d]: unknown type \"\n\t\t\t    \"%d/val=\\\"%s\\\"\\n\"",
            "i",
            "m->msg_style",
            "m->msg"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fputc",
          "args": [
            "'\\n'",
            "stdout"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fputs",
          "args": [
            "m->msg",
            "stdout"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fputc",
          "args": [
            "'\\n'",
            "stderr"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fputs",
          "args": [
            "m->msg",
            "stderr"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getinput",
          "args": [
            "echo_off"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "getinput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/compat/pm_pam_conv.c",
          "lines": "65-105",
          "snippet": "static char *\ngetinput(int noecho)\n{\n\tstruct termio tty;\n\tunsigned short tty_flags = 0;\n\tchar input[PAM_MAX_RESP_SIZE + 1];\n\tint c;\n\tint i = 0;\n\tvoid (*sig)(int);\n\n\tctl_c = 0;\n\tsig = signal(SIGINT, interrupt);\n\tif (noecho) {\n\t\t(void) ioctl(fileno(stdin), TCGETA, &tty);\n\t\ttty_flags = tty.c_lflag;\n\t\ttty.c_lflag &= ~(ECHO | ECHOE | ECHOK | ECHONL);\n\t\t(void) ioctl(fileno(stdin), TCSETAF, &tty);\n\t}\n\t/* go to end, but don't overflow PAM_MAX_RESP_SIZE */\n\tflockfile(stdin);\n\twhile (ctl_c == 0 &&\n\t    (c = getchar_unlocked()) != '\\n' &&\n\t    c != '\\r' &&\n\t    c != EOF) {\n\t\tif (i < PAM_MAX_RESP_SIZE) {\n\t\t\tinput[i++] = (char)c;\n\t\t}\n\t}\n\tfunlockfile(stdin);\n\tinput[i] = '\\0';\n\tif (noecho) {\n\t\ttty.c_lflag = tty_flags;\n\t\t(void) ioctl(fileno(stdin), TCSETAW, &tty);\n\t\t(void) fputc('\\n', stdout);\n\t}\n\t(void) signal(SIGINT, sig);\n\tif (ctl_c == 1)\n\t\t(void) kill(getpid(), SIGINT);\n\n\treturn (strdup(input));\n}",
          "includes": [
            "#include <security/pam_appl.h>",
            "#include <termio.h>",
            "#include <unistd.h>",
            "#include <stropts.h>",
            "#include <strings.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <malloc.h>",
            "#include <libgen.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ctl_c;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <security/pam_appl.h>\n#include <termio.h>\n#include <unistd.h>\n#include <stropts.h>\n#include <strings.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <malloc.h>\n#include <libgen.h>\n#include <errno.h>\n\nstatic int ctl_c;\n\nstatic char *\ngetinput(int noecho)\n{\n\tstruct termio tty;\n\tunsigned short tty_flags = 0;\n\tchar input[PAM_MAX_RESP_SIZE + 1];\n\tint c;\n\tint i = 0;\n\tvoid (*sig)(int);\n\n\tctl_c = 0;\n\tsig = signal(SIGINT, interrupt);\n\tif (noecho) {\n\t\t(void) ioctl(fileno(stdin), TCGETA, &tty);\n\t\ttty_flags = tty.c_lflag;\n\t\ttty.c_lflag &= ~(ECHO | ECHOE | ECHOK | ECHONL);\n\t\t(void) ioctl(fileno(stdin), TCSETAF, &tty);\n\t}\n\t/* go to end, but don't overflow PAM_MAX_RESP_SIZE */\n\tflockfile(stdin);\n\twhile (ctl_c == 0 &&\n\t    (c = getchar_unlocked()) != '\\n' &&\n\t    c != '\\r' &&\n\t    c != EOF) {\n\t\tif (i < PAM_MAX_RESP_SIZE) {\n\t\t\tinput[i++] = (char)c;\n\t\t}\n\t}\n\tfunlockfile(stdin);\n\tinput[i] = '\\0';\n\tif (noecho) {\n\t\ttty.c_lflag = tty_flags;\n\t\t(void) ioctl(fileno(stdin), TCSETAW, &tty);\n\t\t(void) fputc('\\n', stdout);\n\t}\n\t(void) signal(SIGINT, sig);\n\tif (ctl_c == 1)\n\t\t(void) kill(getpid(), SIGINT);\n\n\treturn (strdup(input));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fputs",
          "args": [
            "m->msg",
            "stdout"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "m->msg"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "m->msg"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"message[%d]: %d/NULL\\n\"",
            "i",
            "m->msg_style"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "r"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "freenode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/env.c",
          "lines": "73-79",
          "snippet": "static void\nfreenode(struct envnode *node)\n{\n\tfree((char *)node->key);\n\tfree((char *)node->value);\n\tfree(node);\n}",
          "includes": [
            "#include \"doas.h\"",
            "#include \"tree.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <err.h>",
            "#include <pwd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/tree.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"doas.h\"\n#include \"tree.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <err.h>\n#include <pwd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/tree.h>\n#include <sys/types.h>\n\nstatic void\nfreenode(struct envnode *node)\n{\n\tfree((char *)node->key);\n\tfree((char *)node->value);\n\tfree(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"too many messages %d >= %d\\n\"",
            "num_msg",
            "PAM_MAX_NUM_MSG"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "num_msg",
            "sizeof (struct pam_response)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <security/pam_appl.h>\n#include <termio.h>\n#include <unistd.h>\n#include <stropts.h>\n#include <strings.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <malloc.h>\n#include <libgen.h>\n#include <errno.h>\n\nint\npam_tty_conv(int num_msg, struct pam_message **mess,\n    struct pam_response **resp, void *my_data)\n{\n\tstruct pam_message *m = *mess;\n\tstruct pam_response *r = calloc(num_msg, sizeof (struct pam_response));\n\tint i;\n\n\tif (num_msg >= PAM_MAX_NUM_MSG) {\n\t\t(void) fprintf(stderr, \"too many messages %d >= %d\\n\",\n\t\t    num_msg, PAM_MAX_NUM_MSG);\n\t\tfree(r);\n\t\t*resp = NULL;\n\t\treturn (PAM_CONV_ERR);\n\t}\n\n\t/* Talk it out */\n\t*resp = r;\n\tfor (i = 0; i < num_msg; i++) {\n\t\tint echo_off;\n\n\t\t/* bad message from service module */\n\t\tif (m->msg == NULL) {\n\t\t\t(void) fprintf(stderr, \"message[%d]: %d/NULL\\n\",\n\t\t\t    i, m->msg_style);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/*\n\t\t * fix up final newline:\n\t\t * \tremoved for prompts\n\t\t * \tadded back for messages\n\t\t */\n\t\tif (m->msg[strlen(m->msg)] == '\\n')\n\t\t\tm->msg[strlen(m->msg)] = '\\0';\n\n\t\tr->resp = NULL;\n\t\tr->resp_retcode = 0;\n\t\techo_off = 0;\n\t\tswitch (m->msg_style) {\n\n\t\tcase PAM_PROMPT_ECHO_OFF:\n\t\t\techo_off = 1;\n\t\t\t/*FALLTHROUGH*/\n\n\t\tcase PAM_PROMPT_ECHO_ON:\n\t\t\t(void) fputs(m->msg, stdout);\n\n\t\t\tr->resp = getinput(echo_off);\n\t\t\tbreak;\n\n\t\tcase PAM_ERROR_MSG:\n\t\t\t(void) fputs(m->msg, stderr);\n\t\t\t(void) fputc('\\n', stderr);\n\t\t\tbreak;\n\n\t\tcase PAM_TEXT_INFO:\n\t\t\t(void) fputs(m->msg, stdout);\n\t\t\t(void) fputc('\\n', stdout);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t(void) fprintf(stderr, \"message[%d]: unknown type \"\n\t\t\t    \"%d/val=\\\"%s\\\"\\n\",\n\t\t\t    i, m->msg_style, m->msg);\n\t\t\t/* error, service module won't clean up */\n\t\t\tgoto err;\n\t\t}\n\t\tif (errno == EINTR)\n\t\t\tgoto err;\n\n\t\t/* next message/response */\n\t\tm++;\n\t\tr++;\n\t}\n\treturn (PAM_SUCCESS);\n\nerr:\n\tfree_resp(i, r);\n\t*resp = NULL;\n\treturn (PAM_CONV_ERR);\n}"
  },
  {
    "function_name": "free_resp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/compat/pm_pam_conv.c",
    "lines": "111-130",
    "snippet": "static void\nfree_resp(int num_msg, struct pam_response *pr)\n{\n\tint i;\n\tstruct pam_response *r = pr;\n\n\tif (pr == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < num_msg; i++, r++) {\n\n\t\tif (r->resp) {\n\t\t\t/* clear before freeing -- may be a password */\n\t\t\tbzero(r->resp, strlen(r->resp));\n\t\t\tfree(r->resp);\n\t\t\tr->resp = NULL;\n\t\t}\n\t}\n\tfree(pr);\n}",
    "includes": [
      "#include <security/pam_appl.h>",
      "#include <termio.h>",
      "#include <unistd.h>",
      "#include <stropts.h>",
      "#include <strings.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <malloc.h>",
      "#include <libgen.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pr"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "freenode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/env.c",
          "lines": "73-79",
          "snippet": "static void\nfreenode(struct envnode *node)\n{\n\tfree((char *)node->key);\n\tfree((char *)node->value);\n\tfree(node);\n}",
          "includes": [
            "#include \"doas.h\"",
            "#include \"tree.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <err.h>",
            "#include <pwd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/tree.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"doas.h\"\n#include \"tree.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <err.h>\n#include <pwd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/tree.h>\n#include <sys/types.h>\n\nstatic void\nfreenode(struct envnode *node)\n{\n\tfree((char *)node->key);\n\tfree((char *)node->value);\n\tfree(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "r->resp",
            "strlen(r->resp)"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "r->resp"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <security/pam_appl.h>\n#include <termio.h>\n#include <unistd.h>\n#include <stropts.h>\n#include <strings.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <malloc.h>\n#include <libgen.h>\n#include <errno.h>\n\nstatic void\nfree_resp(int num_msg, struct pam_response *pr)\n{\n\tint i;\n\tstruct pam_response *r = pr;\n\n\tif (pr == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < num_msg; i++, r++) {\n\n\t\tif (r->resp) {\n\t\t\t/* clear before freeing -- may be a password */\n\t\t\tbzero(r->resp, strlen(r->resp));\n\t\t\tfree(r->resp);\n\t\t\tr->resp = NULL;\n\t\t}\n\t}\n\tfree(pr);\n}"
  },
  {
    "function_name": "getinput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/compat/pm_pam_conv.c",
    "lines": "65-105",
    "snippet": "static char *\ngetinput(int noecho)\n{\n\tstruct termio tty;\n\tunsigned short tty_flags = 0;\n\tchar input[PAM_MAX_RESP_SIZE + 1];\n\tint c;\n\tint i = 0;\n\tvoid (*sig)(int);\n\n\tctl_c = 0;\n\tsig = signal(SIGINT, interrupt);\n\tif (noecho) {\n\t\t(void) ioctl(fileno(stdin), TCGETA, &tty);\n\t\ttty_flags = tty.c_lflag;\n\t\ttty.c_lflag &= ~(ECHO | ECHOE | ECHOK | ECHONL);\n\t\t(void) ioctl(fileno(stdin), TCSETAF, &tty);\n\t}\n\t/* go to end, but don't overflow PAM_MAX_RESP_SIZE */\n\tflockfile(stdin);\n\twhile (ctl_c == 0 &&\n\t    (c = getchar_unlocked()) != '\\n' &&\n\t    c != '\\r' &&\n\t    c != EOF) {\n\t\tif (i < PAM_MAX_RESP_SIZE) {\n\t\t\tinput[i++] = (char)c;\n\t\t}\n\t}\n\tfunlockfile(stdin);\n\tinput[i] = '\\0';\n\tif (noecho) {\n\t\ttty.c_lflag = tty_flags;\n\t\t(void) ioctl(fileno(stdin), TCSETAW, &tty);\n\t\t(void) fputc('\\n', stdout);\n\t}\n\t(void) signal(SIGINT, sig);\n\tif (ctl_c == 1)\n\t\t(void) kill(getpid(), SIGINT);\n\n\treturn (strdup(input));\n}",
    "includes": [
      "#include <security/pam_appl.h>",
      "#include <termio.h>",
      "#include <unistd.h>",
      "#include <stropts.h>",
      "#include <strings.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <malloc.h>",
      "#include <libgen.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ctl_c;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "input"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "getpid()",
            "SIGINT"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGINT",
            "sig"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fputc",
          "args": [
            "'\\n'",
            "stdout"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fileno(stdin)",
            "TCSETAW",
            "&tty"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdin"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "funlockfile",
          "args": [
            "stdin"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getchar_unlocked",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flockfile",
          "args": [
            "stdin"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fileno(stdin)",
            "TCSETAF",
            "&tty"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdin"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fileno(stdin)",
            "TCGETA",
            "&tty"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdin"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGINT",
            "interrupt"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <security/pam_appl.h>\n#include <termio.h>\n#include <unistd.h>\n#include <stropts.h>\n#include <strings.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <malloc.h>\n#include <libgen.h>\n#include <errno.h>\n\nstatic int ctl_c;\n\nstatic char *\ngetinput(int noecho)\n{\n\tstruct termio tty;\n\tunsigned short tty_flags = 0;\n\tchar input[PAM_MAX_RESP_SIZE + 1];\n\tint c;\n\tint i = 0;\n\tvoid (*sig)(int);\n\n\tctl_c = 0;\n\tsig = signal(SIGINT, interrupt);\n\tif (noecho) {\n\t\t(void) ioctl(fileno(stdin), TCGETA, &tty);\n\t\ttty_flags = tty.c_lflag;\n\t\ttty.c_lflag &= ~(ECHO | ECHOE | ECHOK | ECHONL);\n\t\t(void) ioctl(fileno(stdin), TCSETAF, &tty);\n\t}\n\t/* go to end, but don't overflow PAM_MAX_RESP_SIZE */\n\tflockfile(stdin);\n\twhile (ctl_c == 0 &&\n\t    (c = getchar_unlocked()) != '\\n' &&\n\t    c != '\\r' &&\n\t    c != EOF) {\n\t\tif (i < PAM_MAX_RESP_SIZE) {\n\t\t\tinput[i++] = (char)c;\n\t\t}\n\t}\n\tfunlockfile(stdin);\n\tinput[i] = '\\0';\n\tif (noecho) {\n\t\ttty.c_lflag = tty_flags;\n\t\t(void) ioctl(fileno(stdin), TCSETAW, &tty);\n\t\t(void) fputc('\\n', stdout);\n\t}\n\t(void) signal(SIGINT, sig);\n\tif (ctl_c == 1)\n\t\t(void) kill(getpid(), SIGINT);\n\n\treturn (strdup(input));\n}"
  },
  {
    "function_name": "interrupt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/compat/pm_pam_conv.c",
    "lines": "51-55",
    "snippet": "static void\ninterrupt(int x)\n{\n\tctl_c = 1;\n}",
    "includes": [
      "#include <security/pam_appl.h>",
      "#include <termio.h>",
      "#include <unistd.h>",
      "#include <stropts.h>",
      "#include <strings.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <malloc.h>",
      "#include <libgen.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ctl_c;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <security/pam_appl.h>\n#include <termio.h>\n#include <unistd.h>\n#include <stropts.h>\n#include <strings.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <malloc.h>\n#include <libgen.h>\n#include <errno.h>\n\nstatic int ctl_c;\n\nstatic void\ninterrupt(int x)\n{\n\tctl_c = 1;\n}"
  }
]