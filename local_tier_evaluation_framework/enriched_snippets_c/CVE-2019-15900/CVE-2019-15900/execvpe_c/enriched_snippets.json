[
  {
    "function_name": "execvpe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/execvpe.c",
    "lines": "50-162",
    "snippet": "int\nexecvpe(const char *name, char *const *argv, char *const *envp)\n{\n\tchar **memp;\n\tint cnt;\n\tsize_t lp, ln, len;\n\tchar *p;\n\tint eacces = 0;\n\tchar *bp, *cur, *path, buf[PATH_MAX];\n\n\t/*\n\t * Do not allow null name\n\t */\n\tif (name == NULL || *name == '\\0') {\n\t\terrno = ENOENT;\n\t\treturn (-1);\n \t}\n\n\t/* If it's an absolute or relative path name, it's easy. */\n\tif (strchr(name, '/')) {\n\t\tbp = (char *)name;\n\t\tcur = path = NULL;\n\t\tgoto retry;\n\t}\n\tbp = buf;\n\n\t/* Get the path we're searching. */\n\tif (!(path = getenv(\"PATH\")))\n\t\tpath = _PATH_DEFPATH;\n\tlen = strlen(path) + 1;\n\tcur = alloca(len);\n\tif (cur == NULL) {\n\t\terrno = ENOMEM;\n\t\treturn (-1);\n\t}\n\tstrlcpy(cur, path, len);\n\twhile ((p = strsep(&cur, \":\"))) {\n\t\t/*\n\t\t * It's a SHELL path -- double, leading and trailing colons\n\t\t * mean the current directory.\n\t\t */\n\t\tif (!*p) {\n\t\t\tp = \".\";\n\t\t\tlp = 1;\n\t\t} else\n\t\t\tlp = strlen(p);\n\t\tln = strlen(name);\n\n\t\t/*\n\t\t * If the path is too long complain.  This is a possible\n\t\t * security issue; given a way to make the path too long\n\t\t * the user may execute the wrong program.\n\t\t */\n\t\tif (lp + ln + 2 > sizeof(buf)) {\n\t\t\tstruct iovec iov[3];\n\n\t\t\tiov[0].iov_base = \"execvp: \";\n\t\t\tiov[0].iov_len = 8;\n\t\t\tiov[1].iov_base = p;\n\t\t\tiov[1].iov_len = lp;\n\t\t\tiov[2].iov_base = \": path too long\\n\";\n\t\t\tiov[2].iov_len = 16;\n\t\t\t(void)writev(STDERR_FILENO, iov, 3);\n\t\t\tcontinue;\n\t\t}\n\t\tbcopy(p, buf, lp);\n\t\tbuf[lp] = '/';\n\t\tbcopy(name, buf + lp + 1, ln);\n\t\tbuf[lp + ln + 1] = '\\0';\n\nretry:\t\t(void)execve(bp, argv, envp);\n\t\tswitch(errno) {\n\t\tcase E2BIG:\n\t\t\tgoto done;\n\t\tcase EISDIR:\n\t\tcase ELOOP:\n\t\tcase ENAMETOOLONG:\n\t\tcase ENOENT:\n\t\t\tbreak;\n\t\tcase ENOEXEC:\n\t\t\tfor (cnt = 0; argv[cnt]; ++cnt)\n\t\t\t\t;\n\t\t\tmemp = alloca((cnt + 2) * sizeof(char *));\n\t\t\tif (memp == NULL)\n\t\t\t\tgoto done;\n\t\t\tmemp[0] = \"sh\";\n\t\t\tmemp[1] = bp;\n\t\t\tbcopy(argv + 1, memp + 2, cnt * sizeof(char *));\n\t\t\t(void)execve(_PATH_BSHELL, memp, envp);\n\t\t\tgoto done;\n\t\tcase ENOMEM:\n\t\t\tgoto done;\n\t\tcase ENOTDIR:\n\t\t\tbreak;\n\t\tcase ETXTBSY:\n\t\t\t/*\n\t\t\t * We used to retry here, but sh(1) doesn't.\n\t\t\t */\n\t\t\tgoto done;\n\t\tcase EACCES:\n\t\t\teacces = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto done;\n\t\t}\n\t}\n\tif (eacces)\n\t\terrno = EACCES;\n\telse if (!errno)\n\t\terrno = ENOENT;\ndone:\n\treturn (-1);\n}",
    "includes": [
      "#include \"doas.h\"",
      "#include <alloca.h>",
      "#include <strings.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <paths.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "execve",
          "args": [
            "_PATH_BSHELL",
            "memp",
            "envp"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "argv + 1",
            "memp + 2",
            "cnt * sizeof(char *)"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "(cnt + 2) * sizeof(char *)"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execve",
          "args": [
            "bp",
            "argv",
            "envp"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "name",
            "buf + lp + 1",
            "ln"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "p",
            "buf",
            "lp"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writev",
          "args": [
            "STDERR_FILENO",
            "iov",
            "3"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&cur",
            "\":\""
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "cur",
            "path",
            "len"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/strlcpy.c",
          "lines": "27-50",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t dsize)\n{\n\tconst char *osrc = src;\n\tsize_t nleft = dsize;\n\n\t/* Copy as many bytes as will fit. */\n\tif (nleft != 0) {\n\t\twhile (--nleft != 0) {\n\t\t\tif ((*dst++ = *src++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src. */\n\tif (nleft == 0) {\n\t\tif (dsize != 0)\n\t\t\t*dst = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*src++)\n\t\t\t;\n\t}\n\n\treturn(src - osrc - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t dsize)\n{\n\tconst char *osrc = src;\n\tsize_t nleft = dsize;\n\n\t/* Copy as many bytes as will fit. */\n\tif (nleft != 0) {\n\t\twhile (--nleft != 0) {\n\t\t\tif ((*dst++ = *src++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src. */\n\tif (nleft == 0) {\n\t\tif (dsize != 0)\n\t\t\t*dst = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*src++)\n\t\t\t;\n\t}\n\n\treturn(src - osrc - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "len"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"PATH\""
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "name",
            "'/'"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"doas.h\"\n#include <alloca.h>\n#include <strings.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <paths.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n\nint\nexecvpe(const char *name, char *const *argv, char *const *envp)\n{\n\tchar **memp;\n\tint cnt;\n\tsize_t lp, ln, len;\n\tchar *p;\n\tint eacces = 0;\n\tchar *bp, *cur, *path, buf[PATH_MAX];\n\n\t/*\n\t * Do not allow null name\n\t */\n\tif (name == NULL || *name == '\\0') {\n\t\terrno = ENOENT;\n\t\treturn (-1);\n \t}\n\n\t/* If it's an absolute or relative path name, it's easy. */\n\tif (strchr(name, '/')) {\n\t\tbp = (char *)name;\n\t\tcur = path = NULL;\n\t\tgoto retry;\n\t}\n\tbp = buf;\n\n\t/* Get the path we're searching. */\n\tif (!(path = getenv(\"PATH\")))\n\t\tpath = _PATH_DEFPATH;\n\tlen = strlen(path) + 1;\n\tcur = alloca(len);\n\tif (cur == NULL) {\n\t\terrno = ENOMEM;\n\t\treturn (-1);\n\t}\n\tstrlcpy(cur, path, len);\n\twhile ((p = strsep(&cur, \":\"))) {\n\t\t/*\n\t\t * It's a SHELL path -- double, leading and trailing colons\n\t\t * mean the current directory.\n\t\t */\n\t\tif (!*p) {\n\t\t\tp = \".\";\n\t\t\tlp = 1;\n\t\t} else\n\t\t\tlp = strlen(p);\n\t\tln = strlen(name);\n\n\t\t/*\n\t\t * If the path is too long complain.  This is a possible\n\t\t * security issue; given a way to make the path too long\n\t\t * the user may execute the wrong program.\n\t\t */\n\t\tif (lp + ln + 2 > sizeof(buf)) {\n\t\t\tstruct iovec iov[3];\n\n\t\t\tiov[0].iov_base = \"execvp: \";\n\t\t\tiov[0].iov_len = 8;\n\t\t\tiov[1].iov_base = p;\n\t\t\tiov[1].iov_len = lp;\n\t\t\tiov[2].iov_base = \": path too long\\n\";\n\t\t\tiov[2].iov_len = 16;\n\t\t\t(void)writev(STDERR_FILENO, iov, 3);\n\t\t\tcontinue;\n\t\t}\n\t\tbcopy(p, buf, lp);\n\t\tbuf[lp] = '/';\n\t\tbcopy(name, buf + lp + 1, ln);\n\t\tbuf[lp + ln + 1] = '\\0';\n\nretry:\t\t(void)execve(bp, argv, envp);\n\t\tswitch(errno) {\n\t\tcase E2BIG:\n\t\t\tgoto done;\n\t\tcase EISDIR:\n\t\tcase ELOOP:\n\t\tcase ENAMETOOLONG:\n\t\tcase ENOENT:\n\t\t\tbreak;\n\t\tcase ENOEXEC:\n\t\t\tfor (cnt = 0; argv[cnt]; ++cnt)\n\t\t\t\t;\n\t\t\tmemp = alloca((cnt + 2) * sizeof(char *));\n\t\t\tif (memp == NULL)\n\t\t\t\tgoto done;\n\t\t\tmemp[0] = \"sh\";\n\t\t\tmemp[1] = bp;\n\t\t\tbcopy(argv + 1, memp + 2, cnt * sizeof(char *));\n\t\t\t(void)execve(_PATH_BSHELL, memp, envp);\n\t\t\tgoto done;\n\t\tcase ENOMEM:\n\t\t\tgoto done;\n\t\tcase ENOTDIR:\n\t\t\tbreak;\n\t\tcase ETXTBSY:\n\t\t\t/*\n\t\t\t * We used to retry here, but sh(1) doesn't.\n\t\t\t */\n\t\t\tgoto done;\n\t\tcase EACCES:\n\t\t\teacces = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto done;\n\t\t}\n\t}\n\tif (eacces)\n\t\terrno = EACCES;\n\telse if (!errno)\n\t\terrno = ENOENT;\ndone:\n\treturn (-1);\n}"
  }
]