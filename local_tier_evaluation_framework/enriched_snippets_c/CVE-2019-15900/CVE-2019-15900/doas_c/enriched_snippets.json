[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/doas.c",
    "lines": "299-591",
    "snippet": "int\nmain(int argc, char **argv)\n{\n\tconst char *safepath = SAFE_PATH;\n\tconst char *confpath = NULL;\n\tchar *shargv[] = { NULL, NULL };\n\tchar *sh;\n\tconst char *cmd;\n\tchar cmdline[LINE_MAX];\n\tchar myname[_PW_NAME_LEN + 1];\n\tstruct passwd *original_pw, *target_pw;\n\tstruct rule *rule;\n\tuid_t uid;\n\tuid_t target = 0;\n\tgid_t groups[NGROUPS_MAX + 1];\n\tint ngroups;\n\tint i, ch;\n\tint sflag = 0;\n\tint nflag = 0;\n\tchar cwdpath[PATH_MAX];\n\tconst char *cwd;\n\tchar *login_style = NULL;\n\tchar **envp;\n\n\t#ifndef linux\n\tsetprogname(\"doas\");\n\t#endif\n\n\t#ifndef linux\n\tclosefrom(STDERR_FILENO + 1);\n\t#endif\n\n\tuid = getuid();\n\n\twhile ((ch = getopt(argc, argv, \"a:C:nsu:\")) != -1) {\n/*\twhile ((ch = getopt(argc, argv, \"a:C:Lnsu:\")) != -1) { */\n\t\tswitch (ch) {\n\t\tcase 'a':\n\t\t\tlogin_style = optarg;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tconfpath = optarg;\n\t\t\tbreak;\n/*\t\tcase 'L':\n\t\t\ti = open(\"/dev/tty\", O_RDWR);\n\t\t\tif (i != -1)\n\t\t\t\tioctl(i, TIOCCLRVERAUTH);\n\t\t\texit(i != -1);\n*/\n\t\tcase 'u':\n\t\t\tif (parseuid(optarg, &target) != 0)\n\t\t\t\terrx(1, \"unknown user\");\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnflag = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\targv += optind;\n\targc -= optind;\n\n\tif (confpath) {\n\t\tif (sflag)\n\t\t\tusage();\n\t} else if ((!sflag && !argc) || (sflag && argc))\n\t\tusage();\n\n\toriginal_pw = getpwuid(uid);\n\tif (! original_pw)\n\t\terr(1, \"getpwuid failed\");\n\tif (strlcpy(myname, original_pw->pw_name, sizeof(myname)) >= sizeof(myname))\n\t\terrx(1, \"pw_name too long\");\n\n\tngroups = getgroups(NGROUPS_MAX, groups);\n\tif (ngroups == -1)\n\t\terr(1, \"can't get groups\");\n\tgroups[ngroups++] = getgid();\n\n\tif (sflag) {\n\t\tsh = getenv(\"SHELL\");\n\t\tif (sh == NULL || *sh == '\\0') {\n\t\t\tshargv[0] = strdup(original_pw->pw_shell);\n\t\t\tif (shargv[0] == NULL)\n\t\t\t\terr(1, NULL);\n\t\t} else\n\t\t\tshargv[0] = sh;\n\t\targv = shargv;\n\t\targc = 1;\n\t}\n\n\tif (confpath) {\n\t\tcheckconfig(confpath, argc, argv, uid, groups, ngroups,\n\t\t    target);\n\t\texit(1);\t/* fail safe */\n\t}\n\n\tif (geteuid())\n\t\terrx(1, \"not installed setuid\");\n\n\tparseconfig(DOAS_CONF, 1);\n\n\t/* cmdline is used only for logging, no need to abort on truncate */\n\t(void)strlcpy(cmdline, argv[0], sizeof(cmdline));\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strlcat(cmdline, \" \", sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t\tif (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t}\n\n\tcmd = argv[0];\n\tif (!permit(uid, groups, ngroups, &rule, target, cmd,\n\t    (const char **)argv + 1)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"failed command for %s: %s\", myname, cmdline);\n\t\terrc(1, EPERM, NULL);\n\t}\n\n\tif (!(rule->options & NOPASS)) {\n\t\tif (nflag)\n\t\t\terrx(1, \"Authorization required\");\n\n#if defined(USE_BSD_AUTH) \n\t\tauthuser(myname, login_style, rule->options & PERSIST);\n#elif defined(USE_PAM)\n#define PAM_END(msg) do { \t\t\t\t\t\t\\\n\tsyslog(LOG_ERR, \"%s: %s\", msg, pam_strerror(pamh, pam_err)); \t\\\n\twarnx(\"%s: %s\", msg, pam_strerror(pamh, pam_err));\t\t\\\n\tpam_end(pamh, pam_err);\t\t\t\t\t\t\\\n\texit(EXIT_FAILURE);\t\t\t\t\t\t\\\n} while (/*CONSTCOND*/0)\n\t\tpam_handle_t *pamh = NULL;\n\t\tint pam_err;\n\n/* #ifndef linux */\n\t\tint temp_stdin;\n\n\t\t/* openpam_ttyconv checks if stdin is a terminal and\n\t\t * if it is then does not bother to open /dev/tty.\n\t\t * The result is that PAM writes the password prompt\n\t\t * directly to stdout.  In scenarios where stdin is a\n\t\t * terminal, but stdout is redirected to a file\n\t\t * e.g. by running doas ls &> ls.out interactively,\n\t\t * the password prompt gets written to ls.out as well.\n\t\t * By closing stdin first we forces PAM to read/write\n\t\t * to/from the terminal directly.  We restore stdin\n\t\t * after authenticating. */\n\t\ttemp_stdin = dup(STDIN_FILENO);\n\t\tif (temp_stdin == -1)\n\t\t\terr(1, \"dup\");\n\t\tclose(STDIN_FILENO);\n/* #else */\n\t\t/* force password prompt to display on stderr, not stdout */\n\t\tint temp_stdout = dup(1);\n\t\tif (temp_stdout == -1)\n\t\t\terr(1, \"dup\");\n\t\tclose(1);\n\t\tif (dup2(2, 1) == -1)\n\t\t\terr(1, \"dup2\");\n/* #endif */\n\n\t\tpam_err = pam_start(\"doas\", myname, &pamc, &pamh);\n\t\tif (pam_err != PAM_SUCCESS) {\n\t\t\tif (pamh != NULL)\n\t\t\t\tPAM_END(\"pam_start\");\n\t\t\tsyslog(LOG_ERR, \"pam_start failed: %s\",\n\t\t\t    pam_strerror(pamh, pam_err));\n\t\t\terrx(EXIT_FAILURE, \"pam_start failed\");\n\t\t}\n\n\t\tswitch (pam_err = pam_authenticate(pamh, PAM_SILENT)) {\n\t\tcase PAM_SUCCESS:\n\t\t\tswitch (pam_err = pam_acct_mgmt(pamh, PAM_SILENT)) {\n\t\t\tcase PAM_SUCCESS:\n\t\t\t\tbreak;\n\n\t\t\tcase PAM_NEW_AUTHTOK_REQD:\n\t\t\t\tpam_err = pam_chauthtok(pamh,\n\t\t\t\t    PAM_SILENT|PAM_CHANGE_EXPIRED_AUTHTOK);\n\t\t\t\tif (pam_err != PAM_SUCCESS)\n\t\t\t\t\tPAM_END(\"pam_chauthtok\");\n\t\t\t\tbreak;\n\n\t\t\tcase PAM_AUTH_ERR:\n\t\t\tcase PAM_USER_UNKNOWN:\n\t\t\tcase PAM_MAXTRIES:\n\t\t\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t\t\t    \"failed auth for %s\", myname);\n                                errx(EXIT_FAILURE, \"second authentication failed\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tPAM_END(\"pam_acct_mgmt\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PAM_AUTH_ERR:\n\t\tcase PAM_USER_UNKNOWN:\n\t\tcase PAM_MAXTRIES:\n\t\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t\t    \"failed auth for %s\", myname);\n                        errx(EXIT_FAILURE, \"authentication failed\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tPAM_END(\"pam_authenticate\");\n\t\t\tbreak;\n\t\t}\n\t\tpam_end(pamh, pam_err);\n\n#ifndef linux\n\t\t/* Re-establish stdin */\n\t\tif (dup2(temp_stdin, STDIN_FILENO) == -1)\n\t\t\terr(1, \"dup2\");\n\t\tclose(temp_stdin);\n#else \n\t\t/* Re-establish stdout */\n\t\tclose(1);\n\t\tif (dup2(temp_stdout, 1) == -1)\n\t\t\terr(1, \"dup2\");\n#endif\n#else\n#error\tNo auth module!\n#endif\n\t}\n\n        /*\n\tif (pledge(\"stdio rpath getpw exec id\", NULL) == -1)\n\t\terr(1, \"pledge\");\n        */\n\ttarget_pw = getpwuid(target);\n\tif (! target_pw)\n\t\terrx(1, \"no passwd entry for target\");\n\n#if defined(HAVE_LOGIN_CAP_H)\n\tif (setusercontext(NULL, target_pw, target, LOGIN_SETGROUP |\n\t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n\t    LOGIN_SETUSER) != 0)\n\t\terrx(1, \"failed to set user context for target\");\n#else\n\t#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)\n\tif (setresgid(target_pw->pw_gid, target_pw->pw_gid, target_pw->pw_gid) == -1)\n\t\terr(1, \"setresgid\");\n\t#else\n\tif (setregid(target_pw->pw_gid, target_pw->pw_gid) == -1)\n\t\terr(1, \"setregid\");\n\t#endif\n\tif (initgroups(target_pw->pw_name, target_pw->pw_gid) == -1)\n\t\terr(1, \"initgroups\");\n\t#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)\n\tif (setresuid(target, target, target) == -1)\n\t\terr(1, \"setresuid\");\n\t#else\n\tif (setreuid(target, target) == -1)\n\t\terr(1, \"setreuid\");\n\t#endif\n#endif\n        /*\n\tif (pledge(\"stdio rpath exec\", NULL) == -1)\n\t\terr(1, \"pledge\");\n        */\n\n\tif (getcwd(cwdpath, sizeof(cwdpath)) == NULL)\n\t\tcwd = \"(failed)\";\n\telse\n\t\tcwd = cwdpath;\n\n\t/*\n        if (pledge(\"stdio exec\", NULL) == -1)\n\t\terr(1, \"pledge\");\n        */\n\n\tsyslog(LOG_AUTHPRIV | LOG_INFO, \"%s ran command %s as %s from %s\",\n\t    myname, cmdline, target_pw->pw_name, cwd);\n\n\tenvp = prepenv(rule, original_pw, target_pw);\n\n\tif (rule->cmd) {\n\t\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n\t}\n\texecvpe(cmd, argv, envp);\n\tif (errno == ENOENT)\n\t\terrx(1, \"%s: command not found\", cmd);\n\terr(1, \"%s\", cmd);\n}",
    "includes": [
      "#include \"doas.h\"",
      "#include \"pm_pam_conv.h\"",
      "#include <security/pam_misc.h>",
      "#include <security/openpam.h>",
      "#include <security/pam_appl.h>",
      "#include <readpassphrase.h>",
      "#include <bsd_auth.h>",
      "#include <login_cap.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <unistd.h>",
      "#include <err.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define PAM_END(msg) do { \t\t\t\t\t\t\\\n\tsyslog(LOG_ERR, \"%s: %s\", msg, pam_strerror(pamh, pam_err)); \t\\\n\twarnx(\"%s: %s\", msg, pam_strerror(pamh, pam_err));\t\t\\\n\tpam_end(pamh, pam_err);\t\t\t\t\t\t\\\n\texit(EXIT_FAILURE);\t\t\t\t\t\t\\\n} while (/*CONSTCOND*/0)\n\t\tpam_handle_t *pamh = NULL;"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"%s\"",
            "cmd"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "errc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/doas.c",
          "lines": "76-81",
          "snippet": "void\nerrc(int eval, int code, const char *format)\n{\n   fprintf(stderr, \"%s\", format);\n   exit(code);\n}",
          "includes": [
            "#include \"doas.h\"",
            "#include \"pm_pam_conv.h\"",
            "#include <security/pam_misc.h>",
            "#include <security/openpam.h>",
            "#include <security/pam_appl.h>",
            "#include <readpassphrase.h>",
            "#include <bsd_auth.h>",
            "#include <login_cap.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <err.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"doas.h\"\n#include \"pm_pam_conv.h\"\n#include <security/pam_misc.h>\n#include <security/openpam.h>\n#include <security/pam_appl.h>\n#include <readpassphrase.h>\n#include <bsd_auth.h>\n#include <login_cap.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <syslog.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nvoid\nerrc(int eval, int code, const char *format)\n{\n   fprintf(stderr, \"%s\", format);\n   exit(code);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"%s: command not found\"",
            "cmd"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvpe",
          "args": [
            "cmd",
            "argv",
            "envp"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "execvpe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/execvpe.c",
          "lines": "50-162",
          "snippet": "int\nexecvpe(const char *name, char *const *argv, char *const *envp)\n{\n\tchar **memp;\n\tint cnt;\n\tsize_t lp, ln, len;\n\tchar *p;\n\tint eacces = 0;\n\tchar *bp, *cur, *path, buf[PATH_MAX];\n\n\t/*\n\t * Do not allow null name\n\t */\n\tif (name == NULL || *name == '\\0') {\n\t\terrno = ENOENT;\n\t\treturn (-1);\n \t}\n\n\t/* If it's an absolute or relative path name, it's easy. */\n\tif (strchr(name, '/')) {\n\t\tbp = (char *)name;\n\t\tcur = path = NULL;\n\t\tgoto retry;\n\t}\n\tbp = buf;\n\n\t/* Get the path we're searching. */\n\tif (!(path = getenv(\"PATH\")))\n\t\tpath = _PATH_DEFPATH;\n\tlen = strlen(path) + 1;\n\tcur = alloca(len);\n\tif (cur == NULL) {\n\t\terrno = ENOMEM;\n\t\treturn (-1);\n\t}\n\tstrlcpy(cur, path, len);\n\twhile ((p = strsep(&cur, \":\"))) {\n\t\t/*\n\t\t * It's a SHELL path -- double, leading and trailing colons\n\t\t * mean the current directory.\n\t\t */\n\t\tif (!*p) {\n\t\t\tp = \".\";\n\t\t\tlp = 1;\n\t\t} else\n\t\t\tlp = strlen(p);\n\t\tln = strlen(name);\n\n\t\t/*\n\t\t * If the path is too long complain.  This is a possible\n\t\t * security issue; given a way to make the path too long\n\t\t * the user may execute the wrong program.\n\t\t */\n\t\tif (lp + ln + 2 > sizeof(buf)) {\n\t\t\tstruct iovec iov[3];\n\n\t\t\tiov[0].iov_base = \"execvp: \";\n\t\t\tiov[0].iov_len = 8;\n\t\t\tiov[1].iov_base = p;\n\t\t\tiov[1].iov_len = lp;\n\t\t\tiov[2].iov_base = \": path too long\\n\";\n\t\t\tiov[2].iov_len = 16;\n\t\t\t(void)writev(STDERR_FILENO, iov, 3);\n\t\t\tcontinue;\n\t\t}\n\t\tbcopy(p, buf, lp);\n\t\tbuf[lp] = '/';\n\t\tbcopy(name, buf + lp + 1, ln);\n\t\tbuf[lp + ln + 1] = '\\0';\n\nretry:\t\t(void)execve(bp, argv, envp);\n\t\tswitch(errno) {\n\t\tcase E2BIG:\n\t\t\tgoto done;\n\t\tcase EISDIR:\n\t\tcase ELOOP:\n\t\tcase ENAMETOOLONG:\n\t\tcase ENOENT:\n\t\t\tbreak;\n\t\tcase ENOEXEC:\n\t\t\tfor (cnt = 0; argv[cnt]; ++cnt)\n\t\t\t\t;\n\t\t\tmemp = alloca((cnt + 2) * sizeof(char *));\n\t\t\tif (memp == NULL)\n\t\t\t\tgoto done;\n\t\t\tmemp[0] = \"sh\";\n\t\t\tmemp[1] = bp;\n\t\t\tbcopy(argv + 1, memp + 2, cnt * sizeof(char *));\n\t\t\t(void)execve(_PATH_BSHELL, memp, envp);\n\t\t\tgoto done;\n\t\tcase ENOMEM:\n\t\t\tgoto done;\n\t\tcase ENOTDIR:\n\t\t\tbreak;\n\t\tcase ETXTBSY:\n\t\t\t/*\n\t\t\t * We used to retry here, but sh(1) doesn't.\n\t\t\t */\n\t\t\tgoto done;\n\t\tcase EACCES:\n\t\t\teacces = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto done;\n\t\t}\n\t}\n\tif (eacces)\n\t\terrno = EACCES;\n\telse if (!errno)\n\t\terrno = ENOENT;\ndone:\n\treturn (-1);\n}",
          "includes": [
            "#include \"doas.h\"",
            "#include <alloca.h>",
            "#include <strings.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <paths.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"doas.h\"\n#include <alloca.h>\n#include <strings.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <paths.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n\nint\nexecvpe(const char *name, char *const *argv, char *const *envp)\n{\n\tchar **memp;\n\tint cnt;\n\tsize_t lp, ln, len;\n\tchar *p;\n\tint eacces = 0;\n\tchar *bp, *cur, *path, buf[PATH_MAX];\n\n\t/*\n\t * Do not allow null name\n\t */\n\tif (name == NULL || *name == '\\0') {\n\t\terrno = ENOENT;\n\t\treturn (-1);\n \t}\n\n\t/* If it's an absolute or relative path name, it's easy. */\n\tif (strchr(name, '/')) {\n\t\tbp = (char *)name;\n\t\tcur = path = NULL;\n\t\tgoto retry;\n\t}\n\tbp = buf;\n\n\t/* Get the path we're searching. */\n\tif (!(path = getenv(\"PATH\")))\n\t\tpath = _PATH_DEFPATH;\n\tlen = strlen(path) + 1;\n\tcur = alloca(len);\n\tif (cur == NULL) {\n\t\terrno = ENOMEM;\n\t\treturn (-1);\n\t}\n\tstrlcpy(cur, path, len);\n\twhile ((p = strsep(&cur, \":\"))) {\n\t\t/*\n\t\t * It's a SHELL path -- double, leading and trailing colons\n\t\t * mean the current directory.\n\t\t */\n\t\tif (!*p) {\n\t\t\tp = \".\";\n\t\t\tlp = 1;\n\t\t} else\n\t\t\tlp = strlen(p);\n\t\tln = strlen(name);\n\n\t\t/*\n\t\t * If the path is too long complain.  This is a possible\n\t\t * security issue; given a way to make the path too long\n\t\t * the user may execute the wrong program.\n\t\t */\n\t\tif (lp + ln + 2 > sizeof(buf)) {\n\t\t\tstruct iovec iov[3];\n\n\t\t\tiov[0].iov_base = \"execvp: \";\n\t\t\tiov[0].iov_len = 8;\n\t\t\tiov[1].iov_base = p;\n\t\t\tiov[1].iov_len = lp;\n\t\t\tiov[2].iov_base = \": path too long\\n\";\n\t\t\tiov[2].iov_len = 16;\n\t\t\t(void)writev(STDERR_FILENO, iov, 3);\n\t\t\tcontinue;\n\t\t}\n\t\tbcopy(p, buf, lp);\n\t\tbuf[lp] = '/';\n\t\tbcopy(name, buf + lp + 1, ln);\n\t\tbuf[lp + ln + 1] = '\\0';\n\nretry:\t\t(void)execve(bp, argv, envp);\n\t\tswitch(errno) {\n\t\tcase E2BIG:\n\t\t\tgoto done;\n\t\tcase EISDIR:\n\t\tcase ELOOP:\n\t\tcase ENAMETOOLONG:\n\t\tcase ENOENT:\n\t\t\tbreak;\n\t\tcase ENOEXEC:\n\t\t\tfor (cnt = 0; argv[cnt]; ++cnt)\n\t\t\t\t;\n\t\t\tmemp = alloca((cnt + 2) * sizeof(char *));\n\t\t\tif (memp == NULL)\n\t\t\t\tgoto done;\n\t\t\tmemp[0] = \"sh\";\n\t\t\tmemp[1] = bp;\n\t\t\tbcopy(argv + 1, memp + 2, cnt * sizeof(char *));\n\t\t\t(void)execve(_PATH_BSHELL, memp, envp);\n\t\t\tgoto done;\n\t\tcase ENOMEM:\n\t\t\tgoto done;\n\t\tcase ENOTDIR:\n\t\t\tbreak;\n\t\tcase ETXTBSY:\n\t\t\t/*\n\t\t\t * We used to retry here, but sh(1) doesn't.\n\t\t\t */\n\t\t\tgoto done;\n\t\tcase EACCES:\n\t\t\teacces = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto done;\n\t\t}\n\t}\n\tif (eacces)\n\t\terrno = EACCES;\n\telse if (!errno)\n\t\terrno = ENOENT;\ndone:\n\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"PATH\"",
            "safepath",
            "1"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepenv",
          "args": [
            "rule",
            "original_pw",
            "target_pw"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "prepenv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/env.c",
          "lines": "218-236",
          "snippet": "char **\nprepenv(struct rule *rule, struct passwd *original, struct passwd *target)\n{\n        static const char *safeset[] = {\n                \"DISPLAY\", \"TERM\", NULL\n        };\n\n\tstruct env *env;\n\n\tenv = createenv(rule, original, target);\n\n\t/* if we started with blank, fill some defaults then apply rules */\n\tif (!(rule->options & KEEPENV))\n\t\tfillenv(env, safeset);\n\tif (rule->envlist)\n\t\tfillenv(env, rule->envlist);\n\n\treturn flattenenv(env);\n}",
          "includes": [
            "#include \"doas.h\"",
            "#include \"tree.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <err.h>",
            "#include <pwd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/tree.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"doas.h\"\n#include \"tree.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <err.h>\n#include <pwd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/tree.h>\n#include <sys/types.h>\n\nchar **\nprepenv(struct rule *rule, struct passwd *original, struct passwd *target)\n{\n        static const char *safeset[] = {\n                \"DISPLAY\", \"TERM\", NULL\n        };\n\n\tstruct env *env;\n\n\tenv = createenv(rule, original, target);\n\n\t/* if we started with blank, fill some defaults then apply rules */\n\tif (!(rule->options & KEEPENV))\n\t\tfillenv(env, safeset);\n\tif (rule->envlist)\n\t\tfillenv(env, rule->envlist);\n\n\treturn flattenenv(env);\n}"
        }
      },
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "LOG_AUTHPRIV | LOG_INFO",
            "\"%s ran command %s as %s from %s\"",
            "myname",
            "cmdline",
            "target_pw->pw_name",
            "cwd"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getcwd",
          "args": [
            "cwdpath",
            "sizeof(cwdpath)"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"setreuid\""
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setreuid",
          "args": [
            "target",
            "target"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"setresuid\""
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresuid",
          "args": [
            "target",
            "target",
            "target"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "setresuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/compat/setresuid.c",
          "lines": "6-21",
          "snippet": "int\nsetresuid(uid_t ruid, uid_t euid, uid_t suid)\n{\n\tint ret = 0;\n\n\tif (ruid != suid) {\n\t\terrno = ENOSYS;\n\t\treturn -1;\n\t}\n\t\n\tif (setreuid(ruid, euid) < 0) {\n\t\tret = -1;\n\t}\n\t\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <unistd.h>\n#include <sys/types.h>\n\nint\nsetresuid(uid_t ruid, uid_t euid, uid_t suid)\n{\n\tint ret = 0;\n\n\tif (ruid != suid) {\n\t\terrno = ENOSYS;\n\t\treturn -1;\n\t}\n\t\n\tif (setreuid(ruid, euid) < 0) {\n\t\tret = -1;\n\t}\n\t\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"initgroups\""
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initgroups",
          "args": [
            "target_pw->pw_name",
            "target_pw->pw_gid"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"setregid\""
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setregid",
          "args": [
            "target_pw->pw_gid",
            "target_pw->pw_gid"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"setresgid\""
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresgid",
          "args": [
            "target_pw->pw_gid",
            "target_pw->pw_gid",
            "target_pw->pw_gid"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"failed to set user context for target\""
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setusercontext",
          "args": [
            "NULL",
            "target_pw",
            "target",
            "LOGIN_SETGROUP |\n\t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n\t    LOGIN_SETUSER"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"no passwd entry for target\""
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwuid",
          "args": [
            "target"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"dup2\""
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "temp_stdout",
            "1"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "1"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "temp_stdin"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"dup2\""
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "temp_stdin",
            "STDIN_FILENO"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_end",
          "args": [
            "pamh",
            "pam_err"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAM_END",
          "args": [
            "\"pam_authenticate\""
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "EXIT_FAILURE",
            "\"authentication failed\""
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "LOG_AUTHPRIV | LOG_NOTICE",
            "\"failed auth for %s\"",
            "myname"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAM_END",
          "args": [
            "\"pam_acct_mgmt\""
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "EXIT_FAILURE",
            "\"second authentication failed\""
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "LOG_AUTHPRIV | LOG_NOTICE",
            "\"failed auth for %s\"",
            "myname"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAM_END",
          "args": [
            "\"pam_chauthtok\""
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_chauthtok",
          "args": [
            "pamh",
            "PAM_SILENT|PAM_CHANGE_EXPIRED_AUTHTOK"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_acct_mgmt",
          "args": [
            "pamh",
            "PAM_SILENT"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_authenticate",
          "args": [
            "pamh",
            "PAM_SILENT"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "EXIT_FAILURE",
            "\"pam_start failed\""
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "LOG_ERR",
            "\"pam_start failed: %s\"",
            "pam_strerror(pamh, pam_err)"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_strerror",
          "args": [
            "pamh",
            "pam_err"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAM_END",
          "args": [
            "\"pam_start\""
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pam_start",
          "args": [
            "\"doas\"",
            "myname",
            "&pamc",
            "&pamh"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"dup2\""
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "2",
            "1"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "1"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"dup\""
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup",
          "args": [
            "1"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "STDIN_FILENO"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"dup\""
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup",
          "args": [
            "STDIN_FILENO"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "authuser",
          "args": [
            "myname",
            "login_style",
            "rule->options & PERSIST"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "authuser",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/doas.c",
          "lines": "252-296",
          "snippet": "static void\nauthuser(char *myname, char *login_style, int persist)\n{\n\tchar *challenge = NULL, *response, rbuf[1024], cbuf[128];\n\tauth_session_t *as;\n\tint fd = -1;\n\n\tif (persist)\n\t\tfd = open(\"/dev/tty\", O_RDWR);\n\tif (fd != -1) {\n\t\tif (ioctl(fd, TIOCCHKVERAUTH) == 0)\n\t\t\tgoto good;\n\t}\n\n\tif (!(as = auth_userchallenge(myname, login_style, \"auth-doas\",\n\t    &challenge)))\n\t\terrx(1, \"Authorization failed\");\n\tif (!challenge) {\n\t\tchar host[HOST_NAME_MAX + 1];\n\t\tif (gethostname(host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"?\");\n\t\tsnprintf(cbuf, sizeof(cbuf),\n\t\t    \"\\rdoas (%.32s@%.32s) password: \", myname, host);\n\t\tchallenge = cbuf;\n\t}\n\tresponse = readpassphrase(challenge, rbuf, sizeof(rbuf),\n\t    RPP_REQUIRE_TTY);\n\tif (response == NULL && errno == ENOTTY) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"tty required for %s\", myname);\n\t\terrx(1, \"a tty is required\");\n\t}\n\tif (!auth_userresponse(as, response, 0)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"failed auth for %s\", myname);\n\t\terrc(1, EPERM, NULL);\n\t}\n\texplicit_bzero(rbuf, sizeof(rbuf));\ngood:\n\tif (fd != -1) {\n\t\tint secs = 5 * 60;\n\t\tioctl(fd, TIOCSETVERAUTH, &secs);\n\t\tclose(fd);\n\t}\n}",
          "includes": [
            "#include \"doas.h\"",
            "#include \"pm_pam_conv.h\"",
            "#include <security/pam_misc.h>",
            "#include <security/openpam.h>",
            "#include <security/pam_appl.h>",
            "#include <readpassphrase.h>",
            "#include <bsd_auth.h>",
            "#include <login_cap.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <err.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"doas.h\"\n#include \"pm_pam_conv.h\"\n#include <security/pam_misc.h>\n#include <security/openpam.h>\n#include <security/pam_appl.h>\n#include <readpassphrase.h>\n#include <bsd_auth.h>\n#include <login_cap.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <syslog.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic void\nauthuser(char *myname, char *login_style, int persist)\n{\n\tchar *challenge = NULL, *response, rbuf[1024], cbuf[128];\n\tauth_session_t *as;\n\tint fd = -1;\n\n\tif (persist)\n\t\tfd = open(\"/dev/tty\", O_RDWR);\n\tif (fd != -1) {\n\t\tif (ioctl(fd, TIOCCHKVERAUTH) == 0)\n\t\t\tgoto good;\n\t}\n\n\tif (!(as = auth_userchallenge(myname, login_style, \"auth-doas\",\n\t    &challenge)))\n\t\terrx(1, \"Authorization failed\");\n\tif (!challenge) {\n\t\tchar host[HOST_NAME_MAX + 1];\n\t\tif (gethostname(host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"?\");\n\t\tsnprintf(cbuf, sizeof(cbuf),\n\t\t    \"\\rdoas (%.32s@%.32s) password: \", myname, host);\n\t\tchallenge = cbuf;\n\t}\n\tresponse = readpassphrase(challenge, rbuf, sizeof(rbuf),\n\t    RPP_REQUIRE_TTY);\n\tif (response == NULL && errno == ENOTTY) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"tty required for %s\", myname);\n\t\terrx(1, \"a tty is required\");\n\t}\n\tif (!auth_userresponse(as, response, 0)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"failed auth for %s\", myname);\n\t\terrc(1, EPERM, NULL);\n\t}\n\texplicit_bzero(rbuf, sizeof(rbuf));\ngood:\n\tif (fd != -1) {\n\t\tint secs = 5 * 60;\n\t\tioctl(fd, TIOCSETVERAUTH, &secs);\n\t\tclose(fd);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"Authorization required\""
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "LOG_AUTHPRIV | LOG_NOTICE",
            "\"failed command for %s: %s\"",
            "myname",
            "cmdline"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "permit",
          "args": [
            "uid",
            "groups",
            "ngroups",
            "&rule",
            "target",
            "cmd",
            "(const char **)argv + 1"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "permit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/doas.c",
          "lines": "176-191",
          "snippet": "static int\npermit(uid_t uid, gid_t *groups, int ngroups, struct rule **lastr,\n    uid_t target, const char *cmd, const char **cmdargs)\n{\n\tint i;\n\n\t*lastr = NULL;\n\tfor (i = 0; i < nrules; i++) {\n\t\tif (match(uid, groups, ngroups, target, cmd,\n\t\t    cmdargs, rules[i]))\n\t\t\t*lastr = rules[i];\n\t}\n\tif (!*lastr)\n\t\treturn 0;\n\treturn (*lastr)->action == PERMIT;\n}",
          "includes": [
            "#include \"doas.h\"",
            "#include \"pm_pam_conv.h\"",
            "#include <security/pam_misc.h>",
            "#include <security/openpam.h>",
            "#include <security/pam_appl.h>",
            "#include <readpassphrase.h>",
            "#include <bsd_auth.h>",
            "#include <login_cap.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <err.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"doas.h\"\n#include \"pm_pam_conv.h\"\n#include <security/pam_misc.h>\n#include <security/openpam.h>\n#include <security/pam_appl.h>\n#include <readpassphrase.h>\n#include <bsd_auth.h>\n#include <login_cap.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <syslog.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic int\npermit(uid_t uid, gid_t *groups, int ngroups, struct rule **lastr,\n    uid_t target, const char *cmd, const char **cmdargs)\n{\n\tint i;\n\n\t*lastr = NULL;\n\tfor (i = 0; i < nrules; i++) {\n\t\tif (match(uid, groups, ngroups, target, cmd,\n\t\t    cmdargs, rules[i]))\n\t\t\t*lastr = rules[i];\n\t}\n\tif (!*lastr)\n\t\treturn 0;\n\treturn (*lastr)->action == PERMIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcat",
          "args": [
            "cmdline",
            "argv[i]",
            "sizeof(cmdline)"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "strlcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/strlcat.c",
          "lines": "29-55",
          "snippet": "size_t\nstrlcat(char *dst, const char *src, size_t dsize)\n{\n\tconst char *odst = dst;\n\tconst char *osrc = src;\n\tsize_t n = dsize;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end. */\n\twhile (n-- != 0 && *dst != '\\0')\n\t\tdst++;\n\tdlen = dst - odst;\n\tn = dsize - dlen;\n\n\tif (n-- == 0)\n\t\treturn(dlen + strlen(src));\n\twhile (*src != '\\0') {\n\t\tif (n != 0) {\n\t\t\t*dst++ = *src;\n\t\t\tn--;\n\t\t}\n\t\tsrc++;\n\t}\n\t*dst = '\\0';\n\n\treturn(dlen + (src - osrc));\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n\nsize_t\nstrlcat(char *dst, const char *src, size_t dsize)\n{\n\tconst char *odst = dst;\n\tconst char *osrc = src;\n\tsize_t n = dsize;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end. */\n\twhile (n-- != 0 && *dst != '\\0')\n\t\tdst++;\n\tdlen = dst - odst;\n\tn = dsize - dlen;\n\n\tif (n-- == 0)\n\t\treturn(dlen + strlen(src));\n\twhile (*src != '\\0') {\n\t\tif (n != 0) {\n\t\t\t*dst++ = *src;\n\t\t\tn--;\n\t\t}\n\t\tsrc++;\n\t}\n\t*dst = '\\0';\n\n\treturn(dlen + (src - osrc));\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "cmdline",
            "argv[0]",
            "sizeof(cmdline)"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/strlcpy.c",
          "lines": "27-50",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t dsize)\n{\n\tconst char *osrc = src;\n\tsize_t nleft = dsize;\n\n\t/* Copy as many bytes as will fit. */\n\tif (nleft != 0) {\n\t\twhile (--nleft != 0) {\n\t\t\tif ((*dst++ = *src++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src. */\n\tif (nleft == 0) {\n\t\tif (dsize != 0)\n\t\t\t*dst = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*src++)\n\t\t\t;\n\t}\n\n\treturn(src - osrc - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t dsize)\n{\n\tconst char *osrc = src;\n\tsize_t nleft = dsize;\n\n\t/* Copy as many bytes as will fit. */\n\tif (nleft != 0) {\n\t\twhile (--nleft != 0) {\n\t\t\tif ((*dst++ = *src++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src. */\n\tif (nleft == 0) {\n\t\tif (dsize != 0)\n\t\t\t*dst = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*src++)\n\t\t\t;\n\t}\n\n\treturn(src - osrc - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseconfig",
          "args": [
            "DOAS_CONF",
            "1"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "parseconfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/doas.c",
          "lines": "193-218",
          "snippet": "static void\nparseconfig(const char *filename, int checkperms)\n{\n\textern FILE *yyfp;\n\textern int yyparse(void);\n\tstruct stat sb;\n\n\tyyfp = fopen(filename, \"r\");\n\tif (!yyfp)\n\t\terr(1, checkperms ? \"doas is not enabled, %s\" :\n\t\t    \"could not open config file %s\", filename);\n\n\tif (checkperms) {\n\t\tif (fstat(fileno(yyfp), &sb) != 0)\n\t\t\terr(1, \"fstat(\\\"%s\\\")\", filename);\n\t\tif ((sb.st_mode & (S_IWGRP|S_IWOTH)) != 0)\n\t\t\terrx(1, \"%s is writable by group or other\", filename);\n\t\tif (sb.st_uid != 0)\n\t\t\terrx(1, \"%s is not owned by root\", filename);\n\t}\n\n\tyyparse();\n\tfclose(yyfp);\n\tif (parse_errors)\n\t\texit(1);\n}",
          "includes": [
            "#include \"doas.h\"",
            "#include \"pm_pam_conv.h\"",
            "#include <security/pam_misc.h>",
            "#include <security/openpam.h>",
            "#include <security/pam_appl.h>",
            "#include <readpassphrase.h>",
            "#include <bsd_auth.h>",
            "#include <login_cap.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <err.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"doas.h\"\n#include \"pm_pam_conv.h\"\n#include <security/pam_misc.h>\n#include <security/openpam.h>\n#include <security/pam_appl.h>\n#include <readpassphrase.h>\n#include <bsd_auth.h>\n#include <login_cap.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <syslog.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic void\nparseconfig(const char *filename, int checkperms)\n{\n\textern FILE *yyfp;\n\textern int yyparse(void);\n\tstruct stat sb;\n\n\tyyfp = fopen(filename, \"r\");\n\tif (!yyfp)\n\t\terr(1, checkperms ? \"doas is not enabled, %s\" :\n\t\t    \"could not open config file %s\", filename);\n\n\tif (checkperms) {\n\t\tif (fstat(fileno(yyfp), &sb) != 0)\n\t\t\terr(1, \"fstat(\\\"%s\\\")\", filename);\n\t\tif ((sb.st_mode & (S_IWGRP|S_IWOTH)) != 0)\n\t\t\terrx(1, \"%s is writable by group or other\", filename);\n\t\tif (sb.st_uid != 0)\n\t\t\terrx(1, \"%s is not owned by root\", filename);\n\t}\n\n\tyyparse();\n\tfclose(yyfp);\n\tif (parse_errors)\n\t\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"not installed setuid\""
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkconfig",
          "args": [
            "confpath",
            "argc",
            "argv",
            "uid",
            "groups",
            "ngroups",
            "target"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "checkconfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/doas.c",
          "lines": "220-249",
          "snippet": "static void \ncheckconfig(const char *confpath, int argc, char **argv,\n    uid_t uid, gid_t *groups, int ngroups, uid_t target)\n{\n\tstruct rule *rule;\n        int status;\n\n\t#if defined(__linux__) || defined(__FreeBSD__)\n\tstatus = setresuid(uid, uid, uid);\n\t#else\n\tstatus = setreuid(uid, uid);\n\t#endif\n\tif (status == -1)\n\t{\n\t\tprintf(\"doas: Unable to set UID\\n\");\n\t\texit(1);\n\t}\n\tparseconfig(confpath, 0);\n\tif (!argc)\n\t\texit(0);\n\n\tif (permit(uid, groups, ngroups, &rule, target, argv[0],\n\t    (const char **)argv + 1)) {\n\t\tprintf(\"permit%s\\n\", (rule->options & NOPASS) ? \" nopass\" : \"\");\n\t\texit(0);\n\t} else {\n\t\tprintf(\"deny\\n\");\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include \"doas.h\"",
            "#include \"pm_pam_conv.h\"",
            "#include <security/pam_misc.h>",
            "#include <security/openpam.h>",
            "#include <security/pam_appl.h>",
            "#include <readpassphrase.h>",
            "#include <bsd_auth.h>",
            "#include <login_cap.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <err.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"doas.h\"\n#include \"pm_pam_conv.h\"\n#include <security/pam_misc.h>\n#include <security/openpam.h>\n#include <security/pam_appl.h>\n#include <readpassphrase.h>\n#include <bsd_auth.h>\n#include <login_cap.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <syslog.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic void \ncheckconfig(const char *confpath, int argc, char **argv,\n    uid_t uid, gid_t *groups, int ngroups, uid_t target)\n{\n\tstruct rule *rule;\n        int status;\n\n\t#if defined(__linux__) || defined(__FreeBSD__)\n\tstatus = setresuid(uid, uid, uid);\n\t#else\n\tstatus = setreuid(uid, uid);\n\t#endif\n\tif (status == -1)\n\t{\n\t\tprintf(\"doas: Unable to set UID\\n\");\n\t\texit(1);\n\t}\n\tparseconfig(confpath, 0);\n\tif (!argc)\n\t\texit(0);\n\n\tif (permit(uid, groups, ngroups, &rule, target, argv[0],\n\t    (const char **)argv + 1)) {\n\t\tprintf(\"permit%s\\n\", (rule->options & NOPASS) ? \" nopass\" : \"\");\n\t\texit(0);\n\t} else {\n\t\tprintf(\"deny\\n\");\n\t\texit(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "NULL"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "original_pw->pw_shell"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SHELL\""
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"can't get groups\""
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgroups",
          "args": [
            "NGROUPS_MAX",
            "groups"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"pw_name too long\""
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"getpwuid failed\""
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwuid",
          "args": [
            "uid"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/doas.c",
          "lines": "67-73",
          "snippet": "static void \nusage(void)\n{\n\tfprintf(stderr, \"usage: doas [-ns] [-a style] [-C config] [-u user]\"\n\t    \" command [args]\\n\");\n\texit(1);\n}",
          "includes": [
            "#include \"doas.h\"",
            "#include \"pm_pam_conv.h\"",
            "#include <security/pam_misc.h>",
            "#include <security/openpam.h>",
            "#include <security/pam_appl.h>",
            "#include <readpassphrase.h>",
            "#include <bsd_auth.h>",
            "#include <login_cap.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <err.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"doas.h\"\n#include \"pm_pam_conv.h\"\n#include <security/pam_misc.h>\n#include <security/openpam.h>\n#include <security/pam_appl.h>\n#include <readpassphrase.h>\n#include <bsd_auth.h>\n#include <login_cap.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <syslog.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic void \nusage(void)\n{\n\tfprintf(stderr, \"usage: doas [-ns] [-a style] [-C config] [-u user]\"\n\t    \" command [args]\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"unknown user\""
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseuid",
          "args": [
            "optarg",
            "&target"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "parseuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/doas.c",
          "lines": "84-102",
          "snippet": "static int\nparseuid(const char *s, uid_t *uid)\n{\n\tstruct passwd *pw;\n\tconst char *errstr;\n\n\tif ((pw = getpwnam(s)) != NULL) {\n\t\t*uid = pw->pw_uid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*uid = strtonum(s, 0, UID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", uid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include \"doas.h\"",
            "#include \"pm_pam_conv.h\"",
            "#include <security/pam_misc.h>",
            "#include <security/openpam.h>",
            "#include <security/pam_appl.h>",
            "#include <readpassphrase.h>",
            "#include <bsd_auth.h>",
            "#include <login_cap.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <err.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"doas.h\"\n#include \"pm_pam_conv.h\"\n#include <security/pam_misc.h>\n#include <security/openpam.h>\n#include <security/pam_appl.h>\n#include <readpassphrase.h>\n#include <bsd_auth.h>\n#include <login_cap.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <syslog.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic int\nparseuid(const char *s, uid_t *uid)\n{\n\tstruct passwd *pw;\n\tconst char *errstr;\n\n\tif ((pw = getpwnam(s)) != NULL) {\n\t\t*uid = pw->pw_uid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*uid = strtonum(s, 0, UID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", uid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getopt",
          "args": [
            "argc",
            "argv",
            "\"a:C:nsu:\""
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closefrom",
          "args": [
            "STDERR_FILENO + 1"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setprogname",
          "args": [
            "\"doas\""
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"doas.h\"\n#include \"pm_pam_conv.h\"\n#include <security/pam_misc.h>\n#include <security/openpam.h>\n#include <security/pam_appl.h>\n#include <readpassphrase.h>\n#include <bsd_auth.h>\n#include <login_cap.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <syslog.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#define PAM_END(msg) do { \t\t\t\t\t\t\\\n\tsyslog(LOG_ERR, \"%s: %s\", msg, pam_strerror(pamh, pam_err)); \t\\\n\twarnx(\"%s: %s\", msg, pam_strerror(pamh, pam_err));\t\t\\\n\tpam_end(pamh, pam_err);\t\t\t\t\t\t\\\n\texit(EXIT_FAILURE);\t\t\t\t\t\t\\\n} while (/*CONSTCOND*/0)\n\t\tpam_handle_t *pamh = NULL;\n\nint\nmain(int argc, char **argv)\n{\n\tconst char *safepath = SAFE_PATH;\n\tconst char *confpath = NULL;\n\tchar *shargv[] = { NULL, NULL };\n\tchar *sh;\n\tconst char *cmd;\n\tchar cmdline[LINE_MAX];\n\tchar myname[_PW_NAME_LEN + 1];\n\tstruct passwd *original_pw, *target_pw;\n\tstruct rule *rule;\n\tuid_t uid;\n\tuid_t target = 0;\n\tgid_t groups[NGROUPS_MAX + 1];\n\tint ngroups;\n\tint i, ch;\n\tint sflag = 0;\n\tint nflag = 0;\n\tchar cwdpath[PATH_MAX];\n\tconst char *cwd;\n\tchar *login_style = NULL;\n\tchar **envp;\n\n\t#ifndef linux\n\tsetprogname(\"doas\");\n\t#endif\n\n\t#ifndef linux\n\tclosefrom(STDERR_FILENO + 1);\n\t#endif\n\n\tuid = getuid();\n\n\twhile ((ch = getopt(argc, argv, \"a:C:nsu:\")) != -1) {\n/*\twhile ((ch = getopt(argc, argv, \"a:C:Lnsu:\")) != -1) { */\n\t\tswitch (ch) {\n\t\tcase 'a':\n\t\t\tlogin_style = optarg;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tconfpath = optarg;\n\t\t\tbreak;\n/*\t\tcase 'L':\n\t\t\ti = open(\"/dev/tty\", O_RDWR);\n\t\t\tif (i != -1)\n\t\t\t\tioctl(i, TIOCCLRVERAUTH);\n\t\t\texit(i != -1);\n*/\n\t\tcase 'u':\n\t\t\tif (parseuid(optarg, &target) != 0)\n\t\t\t\terrx(1, \"unknown user\");\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnflag = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\targv += optind;\n\targc -= optind;\n\n\tif (confpath) {\n\t\tif (sflag)\n\t\t\tusage();\n\t} else if ((!sflag && !argc) || (sflag && argc))\n\t\tusage();\n\n\toriginal_pw = getpwuid(uid);\n\tif (! original_pw)\n\t\terr(1, \"getpwuid failed\");\n\tif (strlcpy(myname, original_pw->pw_name, sizeof(myname)) >= sizeof(myname))\n\t\terrx(1, \"pw_name too long\");\n\n\tngroups = getgroups(NGROUPS_MAX, groups);\n\tif (ngroups == -1)\n\t\terr(1, \"can't get groups\");\n\tgroups[ngroups++] = getgid();\n\n\tif (sflag) {\n\t\tsh = getenv(\"SHELL\");\n\t\tif (sh == NULL || *sh == '\\0') {\n\t\t\tshargv[0] = strdup(original_pw->pw_shell);\n\t\t\tif (shargv[0] == NULL)\n\t\t\t\terr(1, NULL);\n\t\t} else\n\t\t\tshargv[0] = sh;\n\t\targv = shargv;\n\t\targc = 1;\n\t}\n\n\tif (confpath) {\n\t\tcheckconfig(confpath, argc, argv, uid, groups, ngroups,\n\t\t    target);\n\t\texit(1);\t/* fail safe */\n\t}\n\n\tif (geteuid())\n\t\terrx(1, \"not installed setuid\");\n\n\tparseconfig(DOAS_CONF, 1);\n\n\t/* cmdline is used only for logging, no need to abort on truncate */\n\t(void)strlcpy(cmdline, argv[0], sizeof(cmdline));\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strlcat(cmdline, \" \", sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t\tif (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t}\n\n\tcmd = argv[0];\n\tif (!permit(uid, groups, ngroups, &rule, target, cmd,\n\t    (const char **)argv + 1)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"failed command for %s: %s\", myname, cmdline);\n\t\terrc(1, EPERM, NULL);\n\t}\n\n\tif (!(rule->options & NOPASS)) {\n\t\tif (nflag)\n\t\t\terrx(1, \"Authorization required\");\n\n#if defined(USE_BSD_AUTH) \n\t\tauthuser(myname, login_style, rule->options & PERSIST);\n#elif defined(USE_PAM)\n#define PAM_END(msg) do { \t\t\t\t\t\t\\\n\tsyslog(LOG_ERR, \"%s: %s\", msg, pam_strerror(pamh, pam_err)); \t\\\n\twarnx(\"%s: %s\", msg, pam_strerror(pamh, pam_err));\t\t\\\n\tpam_end(pamh, pam_err);\t\t\t\t\t\t\\\n\texit(EXIT_FAILURE);\t\t\t\t\t\t\\\n} while (/*CONSTCOND*/0)\n\t\tpam_handle_t *pamh = NULL;\n\t\tint pam_err;\n\n/* #ifndef linux */\n\t\tint temp_stdin;\n\n\t\t/* openpam_ttyconv checks if stdin is a terminal and\n\t\t * if it is then does not bother to open /dev/tty.\n\t\t * The result is that PAM writes the password prompt\n\t\t * directly to stdout.  In scenarios where stdin is a\n\t\t * terminal, but stdout is redirected to a file\n\t\t * e.g. by running doas ls &> ls.out interactively,\n\t\t * the password prompt gets written to ls.out as well.\n\t\t * By closing stdin first we forces PAM to read/write\n\t\t * to/from the terminal directly.  We restore stdin\n\t\t * after authenticating. */\n\t\ttemp_stdin = dup(STDIN_FILENO);\n\t\tif (temp_stdin == -1)\n\t\t\terr(1, \"dup\");\n\t\tclose(STDIN_FILENO);\n/* #else */\n\t\t/* force password prompt to display on stderr, not stdout */\n\t\tint temp_stdout = dup(1);\n\t\tif (temp_stdout == -1)\n\t\t\terr(1, \"dup\");\n\t\tclose(1);\n\t\tif (dup2(2, 1) == -1)\n\t\t\terr(1, \"dup2\");\n/* #endif */\n\n\t\tpam_err = pam_start(\"doas\", myname, &pamc, &pamh);\n\t\tif (pam_err != PAM_SUCCESS) {\n\t\t\tif (pamh != NULL)\n\t\t\t\tPAM_END(\"pam_start\");\n\t\t\tsyslog(LOG_ERR, \"pam_start failed: %s\",\n\t\t\t    pam_strerror(pamh, pam_err));\n\t\t\terrx(EXIT_FAILURE, \"pam_start failed\");\n\t\t}\n\n\t\tswitch (pam_err = pam_authenticate(pamh, PAM_SILENT)) {\n\t\tcase PAM_SUCCESS:\n\t\t\tswitch (pam_err = pam_acct_mgmt(pamh, PAM_SILENT)) {\n\t\t\tcase PAM_SUCCESS:\n\t\t\t\tbreak;\n\n\t\t\tcase PAM_NEW_AUTHTOK_REQD:\n\t\t\t\tpam_err = pam_chauthtok(pamh,\n\t\t\t\t    PAM_SILENT|PAM_CHANGE_EXPIRED_AUTHTOK);\n\t\t\t\tif (pam_err != PAM_SUCCESS)\n\t\t\t\t\tPAM_END(\"pam_chauthtok\");\n\t\t\t\tbreak;\n\n\t\t\tcase PAM_AUTH_ERR:\n\t\t\tcase PAM_USER_UNKNOWN:\n\t\t\tcase PAM_MAXTRIES:\n\t\t\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t\t\t    \"failed auth for %s\", myname);\n                                errx(EXIT_FAILURE, \"second authentication failed\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tPAM_END(\"pam_acct_mgmt\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PAM_AUTH_ERR:\n\t\tcase PAM_USER_UNKNOWN:\n\t\tcase PAM_MAXTRIES:\n\t\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t\t    \"failed auth for %s\", myname);\n                        errx(EXIT_FAILURE, \"authentication failed\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tPAM_END(\"pam_authenticate\");\n\t\t\tbreak;\n\t\t}\n\t\tpam_end(pamh, pam_err);\n\n#ifndef linux\n\t\t/* Re-establish stdin */\n\t\tif (dup2(temp_stdin, STDIN_FILENO) == -1)\n\t\t\terr(1, \"dup2\");\n\t\tclose(temp_stdin);\n#else \n\t\t/* Re-establish stdout */\n\t\tclose(1);\n\t\tif (dup2(temp_stdout, 1) == -1)\n\t\t\terr(1, \"dup2\");\n#endif\n#else\n#error\tNo auth module!\n#endif\n\t}\n\n        /*\n\tif (pledge(\"stdio rpath getpw exec id\", NULL) == -1)\n\t\terr(1, \"pledge\");\n        */\n\ttarget_pw = getpwuid(target);\n\tif (! target_pw)\n\t\terrx(1, \"no passwd entry for target\");\n\n#if defined(HAVE_LOGIN_CAP_H)\n\tif (setusercontext(NULL, target_pw, target, LOGIN_SETGROUP |\n\t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n\t    LOGIN_SETUSER) != 0)\n\t\terrx(1, \"failed to set user context for target\");\n#else\n\t#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)\n\tif (setresgid(target_pw->pw_gid, target_pw->pw_gid, target_pw->pw_gid) == -1)\n\t\terr(1, \"setresgid\");\n\t#else\n\tif (setregid(target_pw->pw_gid, target_pw->pw_gid) == -1)\n\t\terr(1, \"setregid\");\n\t#endif\n\tif (initgroups(target_pw->pw_name, target_pw->pw_gid) == -1)\n\t\terr(1, \"initgroups\");\n\t#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)\n\tif (setresuid(target, target, target) == -1)\n\t\terr(1, \"setresuid\");\n\t#else\n\tif (setreuid(target, target) == -1)\n\t\terr(1, \"setreuid\");\n\t#endif\n#endif\n        /*\n\tif (pledge(\"stdio rpath exec\", NULL) == -1)\n\t\terr(1, \"pledge\");\n        */\n\n\tif (getcwd(cwdpath, sizeof(cwdpath)) == NULL)\n\t\tcwd = \"(failed)\";\n\telse\n\t\tcwd = cwdpath;\n\n\t/*\n        if (pledge(\"stdio exec\", NULL) == -1)\n\t\terr(1, \"pledge\");\n        */\n\n\tsyslog(LOG_AUTHPRIV | LOG_INFO, \"%s ran command %s as %s from %s\",\n\t    myname, cmdline, target_pw->pw_name, cwd);\n\n\tenvp = prepenv(rule, original_pw, target_pw);\n\n\tif (rule->cmd) {\n\t\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n\t}\n\texecvpe(cmd, argv, envp);\n\tif (errno == ENOENT)\n\t\terrx(1, \"%s: command not found\", cmd);\n\terr(1, \"%s\", cmd);\n}"
  },
  {
    "function_name": "authuser",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/doas.c",
    "lines": "252-296",
    "snippet": "static void\nauthuser(char *myname, char *login_style, int persist)\n{\n\tchar *challenge = NULL, *response, rbuf[1024], cbuf[128];\n\tauth_session_t *as;\n\tint fd = -1;\n\n\tif (persist)\n\t\tfd = open(\"/dev/tty\", O_RDWR);\n\tif (fd != -1) {\n\t\tif (ioctl(fd, TIOCCHKVERAUTH) == 0)\n\t\t\tgoto good;\n\t}\n\n\tif (!(as = auth_userchallenge(myname, login_style, \"auth-doas\",\n\t    &challenge)))\n\t\terrx(1, \"Authorization failed\");\n\tif (!challenge) {\n\t\tchar host[HOST_NAME_MAX + 1];\n\t\tif (gethostname(host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"?\");\n\t\tsnprintf(cbuf, sizeof(cbuf),\n\t\t    \"\\rdoas (%.32s@%.32s) password: \", myname, host);\n\t\tchallenge = cbuf;\n\t}\n\tresponse = readpassphrase(challenge, rbuf, sizeof(rbuf),\n\t    RPP_REQUIRE_TTY);\n\tif (response == NULL && errno == ENOTTY) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"tty required for %s\", myname);\n\t\terrx(1, \"a tty is required\");\n\t}\n\tif (!auth_userresponse(as, response, 0)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"failed auth for %s\", myname);\n\t\terrc(1, EPERM, NULL);\n\t}\n\texplicit_bzero(rbuf, sizeof(rbuf));\ngood:\n\tif (fd != -1) {\n\t\tint secs = 5 * 60;\n\t\tioctl(fd, TIOCSETVERAUTH, &secs);\n\t\tclose(fd);\n\t}\n}",
    "includes": [
      "#include \"doas.h\"",
      "#include \"pm_pam_conv.h\"",
      "#include <security/pam_misc.h>",
      "#include <security/openpam.h>",
      "#include <security/pam_appl.h>",
      "#include <readpassphrase.h>",
      "#include <bsd_auth.h>",
      "#include <login_cap.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <unistd.h>",
      "#include <err.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "TIOCSETVERAUTH",
            "&secs"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "rbuf",
            "sizeof(rbuf)"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errc",
          "args": [
            "1",
            "EPERM",
            "NULL"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "errc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/doas.c",
          "lines": "76-81",
          "snippet": "void\nerrc(int eval, int code, const char *format)\n{\n   fprintf(stderr, \"%s\", format);\n   exit(code);\n}",
          "includes": [
            "#include \"doas.h\"",
            "#include \"pm_pam_conv.h\"",
            "#include <security/pam_misc.h>",
            "#include <security/openpam.h>",
            "#include <security/pam_appl.h>",
            "#include <readpassphrase.h>",
            "#include <bsd_auth.h>",
            "#include <login_cap.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <err.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"doas.h\"\n#include \"pm_pam_conv.h\"\n#include <security/pam_misc.h>\n#include <security/openpam.h>\n#include <security/pam_appl.h>\n#include <readpassphrase.h>\n#include <bsd_auth.h>\n#include <login_cap.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <syslog.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nvoid\nerrc(int eval, int code, const char *format)\n{\n   fprintf(stderr, \"%s\", format);\n   exit(code);\n}"
        }
      },
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "LOG_AUTHPRIV | LOG_NOTICE",
            "\"failed auth for %s\"",
            "myname"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth_userresponse",
          "args": [
            "as",
            "response",
            "0"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"a tty is required\""
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "LOG_AUTHPRIV | LOG_NOTICE",
            "\"tty required for %s\"",
            "myname"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readpassphrase",
          "args": [
            "challenge",
            "rbuf",
            "sizeof(rbuf)",
            "RPP_REQUIRE_TTY"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "cbuf",
            "sizeof(cbuf)",
            "\"\\rdoas (%.32s@%.32s) password: \"",
            "myname",
            "host"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "host",
            "sizeof(host)",
            "\"?\""
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gethostname",
          "args": [
            "host",
            "sizeof(host)"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"Authorization failed\""
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth_userchallenge",
          "args": [
            "myname",
            "login_style",
            "\"auth-doas\"",
            "&challenge"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "TIOCCHKVERAUTH"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/tty\"",
            "O_RDWR"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"doas.h\"\n#include \"pm_pam_conv.h\"\n#include <security/pam_misc.h>\n#include <security/openpam.h>\n#include <security/pam_appl.h>\n#include <readpassphrase.h>\n#include <bsd_auth.h>\n#include <login_cap.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <syslog.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic void\nauthuser(char *myname, char *login_style, int persist)\n{\n\tchar *challenge = NULL, *response, rbuf[1024], cbuf[128];\n\tauth_session_t *as;\n\tint fd = -1;\n\n\tif (persist)\n\t\tfd = open(\"/dev/tty\", O_RDWR);\n\tif (fd != -1) {\n\t\tif (ioctl(fd, TIOCCHKVERAUTH) == 0)\n\t\t\tgoto good;\n\t}\n\n\tif (!(as = auth_userchallenge(myname, login_style, \"auth-doas\",\n\t    &challenge)))\n\t\terrx(1, \"Authorization failed\");\n\tif (!challenge) {\n\t\tchar host[HOST_NAME_MAX + 1];\n\t\tif (gethostname(host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"?\");\n\t\tsnprintf(cbuf, sizeof(cbuf),\n\t\t    \"\\rdoas (%.32s@%.32s) password: \", myname, host);\n\t\tchallenge = cbuf;\n\t}\n\tresponse = readpassphrase(challenge, rbuf, sizeof(rbuf),\n\t    RPP_REQUIRE_TTY);\n\tif (response == NULL && errno == ENOTTY) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"tty required for %s\", myname);\n\t\terrx(1, \"a tty is required\");\n\t}\n\tif (!auth_userresponse(as, response, 0)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"failed auth for %s\", myname);\n\t\terrc(1, EPERM, NULL);\n\t}\n\texplicit_bzero(rbuf, sizeof(rbuf));\ngood:\n\tif (fd != -1) {\n\t\tint secs = 5 * 60;\n\t\tioctl(fd, TIOCSETVERAUTH, &secs);\n\t\tclose(fd);\n\t}\n}"
  },
  {
    "function_name": "checkconfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/doas.c",
    "lines": "220-249",
    "snippet": "static void \ncheckconfig(const char *confpath, int argc, char **argv,\n    uid_t uid, gid_t *groups, int ngroups, uid_t target)\n{\n\tstruct rule *rule;\n        int status;\n\n\t#if defined(__linux__) || defined(__FreeBSD__)\n\tstatus = setresuid(uid, uid, uid);\n\t#else\n\tstatus = setreuid(uid, uid);\n\t#endif\n\tif (status == -1)\n\t{\n\t\tprintf(\"doas: Unable to set UID\\n\");\n\t\texit(1);\n\t}\n\tparseconfig(confpath, 0);\n\tif (!argc)\n\t\texit(0);\n\n\tif (permit(uid, groups, ngroups, &rule, target, argv[0],\n\t    (const char **)argv + 1)) {\n\t\tprintf(\"permit%s\\n\", (rule->options & NOPASS) ? \" nopass\" : \"\");\n\t\texit(0);\n\t} else {\n\t\tprintf(\"deny\\n\");\n\t\texit(1);\n\t}\n}",
    "includes": [
      "#include \"doas.h\"",
      "#include \"pm_pam_conv.h\"",
      "#include <security/pam_misc.h>",
      "#include <security/openpam.h>",
      "#include <security/pam_appl.h>",
      "#include <readpassphrase.h>",
      "#include <bsd_auth.h>",
      "#include <login_cap.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <unistd.h>",
      "#include <err.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"deny\\n\""
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"permit%s\\n\"",
            "(rule->options & NOPASS) ? \" nopass\" : \"\""
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "permit",
          "args": [
            "uid",
            "groups",
            "ngroups",
            "&rule",
            "target",
            "argv[0]",
            "(const char **)argv + 1"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "permit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/doas.c",
          "lines": "176-191",
          "snippet": "static int\npermit(uid_t uid, gid_t *groups, int ngroups, struct rule **lastr,\n    uid_t target, const char *cmd, const char **cmdargs)\n{\n\tint i;\n\n\t*lastr = NULL;\n\tfor (i = 0; i < nrules; i++) {\n\t\tif (match(uid, groups, ngroups, target, cmd,\n\t\t    cmdargs, rules[i]))\n\t\t\t*lastr = rules[i];\n\t}\n\tif (!*lastr)\n\t\treturn 0;\n\treturn (*lastr)->action == PERMIT;\n}",
          "includes": [
            "#include \"doas.h\"",
            "#include \"pm_pam_conv.h\"",
            "#include <security/pam_misc.h>",
            "#include <security/openpam.h>",
            "#include <security/pam_appl.h>",
            "#include <readpassphrase.h>",
            "#include <bsd_auth.h>",
            "#include <login_cap.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <err.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"doas.h\"\n#include \"pm_pam_conv.h\"\n#include <security/pam_misc.h>\n#include <security/openpam.h>\n#include <security/pam_appl.h>\n#include <readpassphrase.h>\n#include <bsd_auth.h>\n#include <login_cap.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <syslog.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic int\npermit(uid_t uid, gid_t *groups, int ngroups, struct rule **lastr,\n    uid_t target, const char *cmd, const char **cmdargs)\n{\n\tint i;\n\n\t*lastr = NULL;\n\tfor (i = 0; i < nrules; i++) {\n\t\tif (match(uid, groups, ngroups, target, cmd,\n\t\t    cmdargs, rules[i]))\n\t\t\t*lastr = rules[i];\n\t}\n\tif (!*lastr)\n\t\treturn 0;\n\treturn (*lastr)->action == PERMIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseconfig",
          "args": [
            "confpath",
            "0"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "parseconfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/doas.c",
          "lines": "193-218",
          "snippet": "static void\nparseconfig(const char *filename, int checkperms)\n{\n\textern FILE *yyfp;\n\textern int yyparse(void);\n\tstruct stat sb;\n\n\tyyfp = fopen(filename, \"r\");\n\tif (!yyfp)\n\t\terr(1, checkperms ? \"doas is not enabled, %s\" :\n\t\t    \"could not open config file %s\", filename);\n\n\tif (checkperms) {\n\t\tif (fstat(fileno(yyfp), &sb) != 0)\n\t\t\terr(1, \"fstat(\\\"%s\\\")\", filename);\n\t\tif ((sb.st_mode & (S_IWGRP|S_IWOTH)) != 0)\n\t\t\terrx(1, \"%s is writable by group or other\", filename);\n\t\tif (sb.st_uid != 0)\n\t\t\terrx(1, \"%s is not owned by root\", filename);\n\t}\n\n\tyyparse();\n\tfclose(yyfp);\n\tif (parse_errors)\n\t\texit(1);\n}",
          "includes": [
            "#include \"doas.h\"",
            "#include \"pm_pam_conv.h\"",
            "#include <security/pam_misc.h>",
            "#include <security/openpam.h>",
            "#include <security/pam_appl.h>",
            "#include <readpassphrase.h>",
            "#include <bsd_auth.h>",
            "#include <login_cap.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <err.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"doas.h\"\n#include \"pm_pam_conv.h\"\n#include <security/pam_misc.h>\n#include <security/openpam.h>\n#include <security/pam_appl.h>\n#include <readpassphrase.h>\n#include <bsd_auth.h>\n#include <login_cap.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <syslog.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic void\nparseconfig(const char *filename, int checkperms)\n{\n\textern FILE *yyfp;\n\textern int yyparse(void);\n\tstruct stat sb;\n\n\tyyfp = fopen(filename, \"r\");\n\tif (!yyfp)\n\t\terr(1, checkperms ? \"doas is not enabled, %s\" :\n\t\t    \"could not open config file %s\", filename);\n\n\tif (checkperms) {\n\t\tif (fstat(fileno(yyfp), &sb) != 0)\n\t\t\terr(1, \"fstat(\\\"%s\\\")\", filename);\n\t\tif ((sb.st_mode & (S_IWGRP|S_IWOTH)) != 0)\n\t\t\terrx(1, \"%s is writable by group or other\", filename);\n\t\tif (sb.st_uid != 0)\n\t\t\terrx(1, \"%s is not owned by root\", filename);\n\t}\n\n\tyyparse();\n\tfclose(yyfp);\n\tif (parse_errors)\n\t\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"doas: Unable to set UID\\n\""
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setreuid",
          "args": [
            "uid",
            "uid"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresuid",
          "args": [
            "uid",
            "uid",
            "uid"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "setresuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/compat/setresuid.c",
          "lines": "6-21",
          "snippet": "int\nsetresuid(uid_t ruid, uid_t euid, uid_t suid)\n{\n\tint ret = 0;\n\n\tif (ruid != suid) {\n\t\terrno = ENOSYS;\n\t\treturn -1;\n\t}\n\t\n\tif (setreuid(ruid, euid) < 0) {\n\t\tret = -1;\n\t}\n\t\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <unistd.h>\n#include <sys/types.h>\n\nint\nsetresuid(uid_t ruid, uid_t euid, uid_t suid)\n{\n\tint ret = 0;\n\n\tif (ruid != suid) {\n\t\terrno = ENOSYS;\n\t\treturn -1;\n\t}\n\t\n\tif (setreuid(ruid, euid) < 0) {\n\t\tret = -1;\n\t}\n\t\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"doas.h\"\n#include \"pm_pam_conv.h\"\n#include <security/pam_misc.h>\n#include <security/openpam.h>\n#include <security/pam_appl.h>\n#include <readpassphrase.h>\n#include <bsd_auth.h>\n#include <login_cap.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <syslog.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic void \ncheckconfig(const char *confpath, int argc, char **argv,\n    uid_t uid, gid_t *groups, int ngroups, uid_t target)\n{\n\tstruct rule *rule;\n        int status;\n\n\t#if defined(__linux__) || defined(__FreeBSD__)\n\tstatus = setresuid(uid, uid, uid);\n\t#else\n\tstatus = setreuid(uid, uid);\n\t#endif\n\tif (status == -1)\n\t{\n\t\tprintf(\"doas: Unable to set UID\\n\");\n\t\texit(1);\n\t}\n\tparseconfig(confpath, 0);\n\tif (!argc)\n\t\texit(0);\n\n\tif (permit(uid, groups, ngroups, &rule, target, argv[0],\n\t    (const char **)argv + 1)) {\n\t\tprintf(\"permit%s\\n\", (rule->options & NOPASS) ? \" nopass\" : \"\");\n\t\texit(0);\n\t} else {\n\t\tprintf(\"deny\\n\");\n\t\texit(1);\n\t}\n}"
  },
  {
    "function_name": "parseconfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/doas.c",
    "lines": "193-218",
    "snippet": "static void\nparseconfig(const char *filename, int checkperms)\n{\n\textern FILE *yyfp;\n\textern int yyparse(void);\n\tstruct stat sb;\n\n\tyyfp = fopen(filename, \"r\");\n\tif (!yyfp)\n\t\terr(1, checkperms ? \"doas is not enabled, %s\" :\n\t\t    \"could not open config file %s\", filename);\n\n\tif (checkperms) {\n\t\tif (fstat(fileno(yyfp), &sb) != 0)\n\t\t\terr(1, \"fstat(\\\"%s\\\")\", filename);\n\t\tif ((sb.st_mode & (S_IWGRP|S_IWOTH)) != 0)\n\t\t\terrx(1, \"%s is writable by group or other\", filename);\n\t\tif (sb.st_uid != 0)\n\t\t\terrx(1, \"%s is not owned by root\", filename);\n\t}\n\n\tyyparse();\n\tfclose(yyfp);\n\tif (parse_errors)\n\t\texit(1);\n}",
    "includes": [
      "#include \"doas.h\"",
      "#include \"pm_pam_conv.h\"",
      "#include <security/pam_misc.h>",
      "#include <security/openpam.h>",
      "#include <security/pam_appl.h>",
      "#include <readpassphrase.h>",
      "#include <bsd_auth.h>",
      "#include <login_cap.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <unistd.h>",
      "#include <err.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "yyfp"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yyparse",
          "args": [],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"%s is not owned by root\"",
            "filename"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"%s is writable by group or other\"",
            "filename"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"fstat(\\\"%s\\\")\"",
            "filename"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "errc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/doas.c",
          "lines": "76-81",
          "snippet": "void\nerrc(int eval, int code, const char *format)\n{\n   fprintf(stderr, \"%s\", format);\n   exit(code);\n}",
          "includes": [
            "#include \"doas.h\"",
            "#include \"pm_pam_conv.h\"",
            "#include <security/pam_misc.h>",
            "#include <security/openpam.h>",
            "#include <security/pam_appl.h>",
            "#include <readpassphrase.h>",
            "#include <bsd_auth.h>",
            "#include <login_cap.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <err.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"doas.h\"\n#include \"pm_pam_conv.h\"\n#include <security/pam_misc.h>\n#include <security/openpam.h>\n#include <security/pam_appl.h>\n#include <readpassphrase.h>\n#include <bsd_auth.h>\n#include <login_cap.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <syslog.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nvoid\nerrc(int eval, int code, const char *format)\n{\n   fprintf(stderr, \"%s\", format);\n   exit(code);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fileno(yyfp)",
            "&sb"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "yyfp"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "filename",
            "\"r\""
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"doas.h\"\n#include \"pm_pam_conv.h\"\n#include <security/pam_misc.h>\n#include <security/openpam.h>\n#include <security/pam_appl.h>\n#include <readpassphrase.h>\n#include <bsd_auth.h>\n#include <login_cap.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <syslog.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic void\nparseconfig(const char *filename, int checkperms)\n{\n\textern FILE *yyfp;\n\textern int yyparse(void);\n\tstruct stat sb;\n\n\tyyfp = fopen(filename, \"r\");\n\tif (!yyfp)\n\t\terr(1, checkperms ? \"doas is not enabled, %s\" :\n\t\t    \"could not open config file %s\", filename);\n\n\tif (checkperms) {\n\t\tif (fstat(fileno(yyfp), &sb) != 0)\n\t\t\terr(1, \"fstat(\\\"%s\\\")\", filename);\n\t\tif ((sb.st_mode & (S_IWGRP|S_IWOTH)) != 0)\n\t\t\terrx(1, \"%s is writable by group or other\", filename);\n\t\tif (sb.st_uid != 0)\n\t\t\terrx(1, \"%s is not owned by root\", filename);\n\t}\n\n\tyyparse();\n\tfclose(yyfp);\n\tif (parse_errors)\n\t\texit(1);\n}"
  },
  {
    "function_name": "permit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/doas.c",
    "lines": "176-191",
    "snippet": "static int\npermit(uid_t uid, gid_t *groups, int ngroups, struct rule **lastr,\n    uid_t target, const char *cmd, const char **cmdargs)\n{\n\tint i;\n\n\t*lastr = NULL;\n\tfor (i = 0; i < nrules; i++) {\n\t\tif (match(uid, groups, ngroups, target, cmd,\n\t\t    cmdargs, rules[i]))\n\t\t\t*lastr = rules[i];\n\t}\n\tif (!*lastr)\n\t\treturn 0;\n\treturn (*lastr)->action == PERMIT;\n}",
    "includes": [
      "#include \"doas.h\"",
      "#include \"pm_pam_conv.h\"",
      "#include <security/pam_misc.h>",
      "#include <security/openpam.h>",
      "#include <security/pam_appl.h>",
      "#include <readpassphrase.h>",
      "#include <bsd_auth.h>",
      "#include <login_cap.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <unistd.h>",
      "#include <err.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "match",
          "args": [
            "uid",
            "groups",
            "ngroups",
            "target",
            "cmd",
            "cmdargs",
            "rules[i]"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/doas.c",
          "lines": "136-174",
          "snippet": "static int\nmatch(uid_t uid, gid_t *groups, int ngroups, uid_t target, const char *cmd,\n    const char **cmdargs, struct rule *r)\n{\n\tint i;\n\n\tif (r->ident[0] == ':') {\n\t\tgid_t rgid;\n\t\tif (parsegid(r->ident + 1, &rgid) == -1)\n\t\t\treturn 0;\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\tif (rgid == groups[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == ngroups)\n\t\t\treturn 0;\n\t} else {\n\t\tif (uidcheck(r->ident, uid) != 0)\n\t\t\treturn 0;\n\t}\n\tif (r->target && uidcheck(r->target, target) != 0)\n\t\treturn 0;\n\tif (r->cmd) {\n\t\tif (strcmp(r->cmd, cmd))\n\t\t\treturn 0;\n\t\tif (r->cmdargs) {\n\t\t\t/* if arguments were given, they should match explicitly */\n\t\t\tfor (i = 0; r->cmdargs[i]; i++) {\n\t\t\t\tif (!cmdargs[i])\n\t\t\t\t\treturn 0;\n\t\t\t\tif (strcmp(r->cmdargs[i], cmdargs[i]))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (cmdargs[i])\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"doas.h\"",
            "#include \"pm_pam_conv.h\"",
            "#include <security/pam_misc.h>",
            "#include <security/openpam.h>",
            "#include <security/pam_appl.h>",
            "#include <readpassphrase.h>",
            "#include <bsd_auth.h>",
            "#include <login_cap.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <err.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"doas.h\"\n#include \"pm_pam_conv.h\"\n#include <security/pam_misc.h>\n#include <security/openpam.h>\n#include <security/pam_appl.h>\n#include <readpassphrase.h>\n#include <bsd_auth.h>\n#include <login_cap.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <syslog.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic int\nmatch(uid_t uid, gid_t *groups, int ngroups, uid_t target, const char *cmd,\n    const char **cmdargs, struct rule *r)\n{\n\tint i;\n\n\tif (r->ident[0] == ':') {\n\t\tgid_t rgid;\n\t\tif (parsegid(r->ident + 1, &rgid) == -1)\n\t\t\treturn 0;\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\tif (rgid == groups[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == ngroups)\n\t\t\treturn 0;\n\t} else {\n\t\tif (uidcheck(r->ident, uid) != 0)\n\t\t\treturn 0;\n\t}\n\tif (r->target && uidcheck(r->target, target) != 0)\n\t\treturn 0;\n\tif (r->cmd) {\n\t\tif (strcmp(r->cmd, cmd))\n\t\t\treturn 0;\n\t\tif (r->cmdargs) {\n\t\t\t/* if arguments were given, they should match explicitly */\n\t\t\tfor (i = 0; r->cmdargs[i]; i++) {\n\t\t\t\tif (!cmdargs[i])\n\t\t\t\t\treturn 0;\n\t\t\t\tif (strcmp(r->cmdargs[i], cmdargs[i]))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (cmdargs[i])\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"doas.h\"\n#include \"pm_pam_conv.h\"\n#include <security/pam_misc.h>\n#include <security/openpam.h>\n#include <security/pam_appl.h>\n#include <readpassphrase.h>\n#include <bsd_auth.h>\n#include <login_cap.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <syslog.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic int\npermit(uid_t uid, gid_t *groups, int ngroups, struct rule **lastr,\n    uid_t target, const char *cmd, const char **cmdargs)\n{\n\tint i;\n\n\t*lastr = NULL;\n\tfor (i = 0; i < nrules; i++) {\n\t\tif (match(uid, groups, ngroups, target, cmd,\n\t\t    cmdargs, rules[i]))\n\t\t\t*lastr = rules[i];\n\t}\n\tif (!*lastr)\n\t\treturn 0;\n\treturn (*lastr)->action == PERMIT;\n}"
  },
  {
    "function_name": "match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/doas.c",
    "lines": "136-174",
    "snippet": "static int\nmatch(uid_t uid, gid_t *groups, int ngroups, uid_t target, const char *cmd,\n    const char **cmdargs, struct rule *r)\n{\n\tint i;\n\n\tif (r->ident[0] == ':') {\n\t\tgid_t rgid;\n\t\tif (parsegid(r->ident + 1, &rgid) == -1)\n\t\t\treturn 0;\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\tif (rgid == groups[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == ngroups)\n\t\t\treturn 0;\n\t} else {\n\t\tif (uidcheck(r->ident, uid) != 0)\n\t\t\treturn 0;\n\t}\n\tif (r->target && uidcheck(r->target, target) != 0)\n\t\treturn 0;\n\tif (r->cmd) {\n\t\tif (strcmp(r->cmd, cmd))\n\t\t\treturn 0;\n\t\tif (r->cmdargs) {\n\t\t\t/* if arguments were given, they should match explicitly */\n\t\t\tfor (i = 0; r->cmdargs[i]; i++) {\n\t\t\t\tif (!cmdargs[i])\n\t\t\t\t\treturn 0;\n\t\t\t\tif (strcmp(r->cmdargs[i], cmdargs[i]))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (cmdargs[i])\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"doas.h\"",
      "#include \"pm_pam_conv.h\"",
      "#include <security/pam_misc.h>",
      "#include <security/openpam.h>",
      "#include <security/pam_appl.h>",
      "#include <readpassphrase.h>",
      "#include <bsd_auth.h>",
      "#include <login_cap.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <unistd.h>",
      "#include <err.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "r->cmdargs[i]",
            "cmdargs[i]"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "r->cmd",
            "cmd"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uidcheck",
          "args": [
            "r->target",
            "target"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "uidcheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/doas.c",
          "lines": "104-114",
          "snippet": "static int\nuidcheck(const char *s, uid_t desired)\n{\n\tuid_t uid;\n\n\tif (parseuid(s, &uid) != 0)\n\t\treturn -1;\n\tif (uid != desired)\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include \"doas.h\"",
            "#include \"pm_pam_conv.h\"",
            "#include <security/pam_misc.h>",
            "#include <security/openpam.h>",
            "#include <security/pam_appl.h>",
            "#include <readpassphrase.h>",
            "#include <bsd_auth.h>",
            "#include <login_cap.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <err.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"doas.h\"\n#include \"pm_pam_conv.h\"\n#include <security/pam_misc.h>\n#include <security/openpam.h>\n#include <security/pam_appl.h>\n#include <readpassphrase.h>\n#include <bsd_auth.h>\n#include <login_cap.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <syslog.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic int\nuidcheck(const char *s, uid_t desired)\n{\n\tuid_t uid;\n\n\tif (parseuid(s, &uid) != 0)\n\t\treturn -1;\n\tif (uid != desired)\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parsegid",
          "args": [
            "r->ident + 1",
            "&rgid"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "parsegid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/doas.c",
          "lines": "116-134",
          "snippet": "static int\nparsegid(const char *s, gid_t *gid)\n{\n\tstruct group *gr;\n\tconst char *errstr;\n\n\tif ((gr = getgrnam(s)) != NULL) {\n\t\t*gid = gr->gr_gid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*gid = strtonum(s, 0, GID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", gid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include \"doas.h\"",
            "#include \"pm_pam_conv.h\"",
            "#include <security/pam_misc.h>",
            "#include <security/openpam.h>",
            "#include <security/pam_appl.h>",
            "#include <readpassphrase.h>",
            "#include <bsd_auth.h>",
            "#include <login_cap.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <err.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"doas.h\"\n#include \"pm_pam_conv.h\"\n#include <security/pam_misc.h>\n#include <security/openpam.h>\n#include <security/pam_appl.h>\n#include <readpassphrase.h>\n#include <bsd_auth.h>\n#include <login_cap.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <syslog.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic int\nparsegid(const char *s, gid_t *gid)\n{\n\tstruct group *gr;\n\tconst char *errstr;\n\n\tif ((gr = getgrnam(s)) != NULL) {\n\t\t*gid = gr->gr_gid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*gid = strtonum(s, 0, GID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", gid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"doas.h\"\n#include \"pm_pam_conv.h\"\n#include <security/pam_misc.h>\n#include <security/openpam.h>\n#include <security/pam_appl.h>\n#include <readpassphrase.h>\n#include <bsd_auth.h>\n#include <login_cap.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <syslog.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic int\nmatch(uid_t uid, gid_t *groups, int ngroups, uid_t target, const char *cmd,\n    const char **cmdargs, struct rule *r)\n{\n\tint i;\n\n\tif (r->ident[0] == ':') {\n\t\tgid_t rgid;\n\t\tif (parsegid(r->ident + 1, &rgid) == -1)\n\t\t\treturn 0;\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\tif (rgid == groups[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == ngroups)\n\t\t\treturn 0;\n\t} else {\n\t\tif (uidcheck(r->ident, uid) != 0)\n\t\t\treturn 0;\n\t}\n\tif (r->target && uidcheck(r->target, target) != 0)\n\t\treturn 0;\n\tif (r->cmd) {\n\t\tif (strcmp(r->cmd, cmd))\n\t\t\treturn 0;\n\t\tif (r->cmdargs) {\n\t\t\t/* if arguments were given, they should match explicitly */\n\t\t\tfor (i = 0; r->cmdargs[i]; i++) {\n\t\t\t\tif (!cmdargs[i])\n\t\t\t\t\treturn 0;\n\t\t\t\tif (strcmp(r->cmdargs[i], cmdargs[i]))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (cmdargs[i])\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "parsegid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/doas.c",
    "lines": "116-134",
    "snippet": "static int\nparsegid(const char *s, gid_t *gid)\n{\n\tstruct group *gr;\n\tconst char *errstr;\n\n\tif ((gr = getgrnam(s)) != NULL) {\n\t\t*gid = gr->gr_gid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*gid = strtonum(s, 0, GID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", gid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}",
    "includes": [
      "#include \"doas.h\"",
      "#include \"pm_pam_conv.h\"",
      "#include <security/pam_misc.h>",
      "#include <security/openpam.h>",
      "#include <security/pam_appl.h>",
      "#include <readpassphrase.h>",
      "#include <bsd_auth.h>",
      "#include <login_cap.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <unistd.h>",
      "#include <err.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "s",
            "\"%d\"",
            "gid"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtonum",
          "args": [
            "s",
            "0",
            "GID_MAX",
            "&errstr"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgrnam",
          "args": [
            "s"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"doas.h\"\n#include \"pm_pam_conv.h\"\n#include <security/pam_misc.h>\n#include <security/openpam.h>\n#include <security/pam_appl.h>\n#include <readpassphrase.h>\n#include <bsd_auth.h>\n#include <login_cap.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <syslog.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic int\nparsegid(const char *s, gid_t *gid)\n{\n\tstruct group *gr;\n\tconst char *errstr;\n\n\tif ((gr = getgrnam(s)) != NULL) {\n\t\t*gid = gr->gr_gid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*gid = strtonum(s, 0, GID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", gid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "uidcheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/doas.c",
    "lines": "104-114",
    "snippet": "static int\nuidcheck(const char *s, uid_t desired)\n{\n\tuid_t uid;\n\n\tif (parseuid(s, &uid) != 0)\n\t\treturn -1;\n\tif (uid != desired)\n\t\treturn -1;\n\treturn 0;\n}",
    "includes": [
      "#include \"doas.h\"",
      "#include \"pm_pam_conv.h\"",
      "#include <security/pam_misc.h>",
      "#include <security/openpam.h>",
      "#include <security/pam_appl.h>",
      "#include <readpassphrase.h>",
      "#include <bsd_auth.h>",
      "#include <login_cap.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <unistd.h>",
      "#include <err.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parseuid",
          "args": [
            "s",
            "&uid"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "parseuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/doas.c",
          "lines": "84-102",
          "snippet": "static int\nparseuid(const char *s, uid_t *uid)\n{\n\tstruct passwd *pw;\n\tconst char *errstr;\n\n\tif ((pw = getpwnam(s)) != NULL) {\n\t\t*uid = pw->pw_uid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*uid = strtonum(s, 0, UID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", uid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include \"doas.h\"",
            "#include \"pm_pam_conv.h\"",
            "#include <security/pam_misc.h>",
            "#include <security/openpam.h>",
            "#include <security/pam_appl.h>",
            "#include <readpassphrase.h>",
            "#include <bsd_auth.h>",
            "#include <login_cap.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <grp.h>",
            "#include <pwd.h>",
            "#include <unistd.h>",
            "#include <err.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"doas.h\"\n#include \"pm_pam_conv.h\"\n#include <security/pam_misc.h>\n#include <security/openpam.h>\n#include <security/pam_appl.h>\n#include <readpassphrase.h>\n#include <bsd_auth.h>\n#include <login_cap.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <syslog.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic int\nparseuid(const char *s, uid_t *uid)\n{\n\tstruct passwd *pw;\n\tconst char *errstr;\n\n\tif ((pw = getpwnam(s)) != NULL) {\n\t\t*uid = pw->pw_uid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*uid = strtonum(s, 0, UID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", uid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"doas.h\"\n#include \"pm_pam_conv.h\"\n#include <security/pam_misc.h>\n#include <security/openpam.h>\n#include <security/pam_appl.h>\n#include <readpassphrase.h>\n#include <bsd_auth.h>\n#include <login_cap.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <syslog.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic int\nuidcheck(const char *s, uid_t desired)\n{\n\tuid_t uid;\n\n\tif (parseuid(s, &uid) != 0)\n\t\treturn -1;\n\tif (uid != desired)\n\t\treturn -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "parseuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/doas.c",
    "lines": "84-102",
    "snippet": "static int\nparseuid(const char *s, uid_t *uid)\n{\n\tstruct passwd *pw;\n\tconst char *errstr;\n\n\tif ((pw = getpwnam(s)) != NULL) {\n\t\t*uid = pw->pw_uid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*uid = strtonum(s, 0, UID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", uid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}",
    "includes": [
      "#include \"doas.h\"",
      "#include \"pm_pam_conv.h\"",
      "#include <security/pam_misc.h>",
      "#include <security/openpam.h>",
      "#include <security/pam_appl.h>",
      "#include <readpassphrase.h>",
      "#include <bsd_auth.h>",
      "#include <login_cap.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <unistd.h>",
      "#include <err.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "s",
            "\"%d\"",
            "uid"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtonum",
          "args": [
            "s",
            "0",
            "UID_MAX",
            "&errstr"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwnam",
          "args": [
            "s"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"doas.h\"\n#include \"pm_pam_conv.h\"\n#include <security/pam_misc.h>\n#include <security/openpam.h>\n#include <security/pam_appl.h>\n#include <readpassphrase.h>\n#include <bsd_auth.h>\n#include <login_cap.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <syslog.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic int\nparseuid(const char *s, uid_t *uid)\n{\n\tstruct passwd *pw;\n\tconst char *errstr;\n\n\tif ((pw = getpwnam(s)) != NULL) {\n\t\t*uid = pw->pw_uid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*uid = strtonum(s, 0, UID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", uid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "errc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/doas.c",
    "lines": "76-81",
    "snippet": "void\nerrc(int eval, int code, const char *format)\n{\n   fprintf(stderr, \"%s\", format);\n   exit(code);\n}",
    "includes": [
      "#include \"doas.h\"",
      "#include \"pm_pam_conv.h\"",
      "#include <security/pam_misc.h>",
      "#include <security/openpam.h>",
      "#include <security/pam_appl.h>",
      "#include <readpassphrase.h>",
      "#include <bsd_auth.h>",
      "#include <login_cap.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <unistd.h>",
      "#include <err.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "code"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\"",
            "format"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"doas.h\"\n#include \"pm_pam_conv.h\"\n#include <security/pam_misc.h>\n#include <security/openpam.h>\n#include <security/pam_appl.h>\n#include <readpassphrase.h>\n#include <bsd_auth.h>\n#include <login_cap.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <syslog.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nvoid\nerrc(int eval, int code, const char *format)\n{\n   fprintf(stderr, \"%s\", format);\n   exit(code);\n}"
  },
  {
    "function_name": "usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-15900/repo/doas.c",
    "lines": "67-73",
    "snippet": "static void \nusage(void)\n{\n\tfprintf(stderr, \"usage: doas [-ns] [-a style] [-C config] [-u user]\"\n\t    \" command [args]\\n\");\n\texit(1);\n}",
    "includes": [
      "#include \"doas.h\"",
      "#include \"pm_pam_conv.h\"",
      "#include <security/pam_misc.h>",
      "#include <security/openpam.h>",
      "#include <security/pam_appl.h>",
      "#include <readpassphrase.h>",
      "#include <bsd_auth.h>",
      "#include <login_cap.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <syslog.h>",
      "#include <grp.h>",
      "#include <pwd.h>",
      "#include <unistd.h>",
      "#include <err.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"usage: doas [-ns] [-a style] [-C config] [-u user]\"\n\t    \" command [args]\\n\""
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"doas.h\"\n#include \"pm_pam_conv.h\"\n#include <security/pam_misc.h>\n#include <security/openpam.h>\n#include <security/pam_appl.h>\n#include <readpassphrase.h>\n#include <bsd_auth.h>\n#include <login_cap.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <syslog.h>\n#include <grp.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic void \nusage(void)\n{\n\tfprintf(stderr, \"usage: doas [-ns] [-a style] [-C config] [-u user]\"\n\t    \" command [args]\\n\");\n\texit(1);\n}"
  }
]