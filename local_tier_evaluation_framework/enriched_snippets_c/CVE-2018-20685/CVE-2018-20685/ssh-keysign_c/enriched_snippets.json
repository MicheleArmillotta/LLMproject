[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keysign.c",
    "lines": "165-304",
    "snippet": "int\nmain(int argc, char **argv)\n{\n\tstruct sshbuf *b;\n\tOptions options;\n#define NUM_KEYTYPES 5\n\tstruct sshkey *keys[NUM_KEYTYPES], *key = NULL;\n\tstruct passwd *pw;\n\tint r, key_fd[NUM_KEYTYPES], i, found, version = 2, fd;\n\tu_char *signature, *data, rver;\n\tchar *host, *fp;\n\tsize_t slen, dlen;\n#ifdef WITH_OPENSSL\n\tu_int32_t rnd[256];\n#endif\n\n\tssh_malloc_init();\t/* must be called before any mallocs */\n\tif (pledge(\"stdio rpath getpw dns id\", NULL) != 0)\n\t\tfatal(\"%s: pledge: %s\", __progname, strerror(errno));\n\n\t/* Ensure that stdin and stdout are connected */\n\tif ((fd = open(_PATH_DEVNULL, O_RDWR)) < 2)\n\t\texit(1);\n\t/* Leave /dev/null fd iff it is attached to stderr */\n\tif (fd > 2)\n\t\tclose(fd);\n\n\ti = 0;\n\t/* XXX This really needs to read sshd_config for the paths */\n\tkey_fd[i++] = open(_PATH_HOST_DSA_KEY_FILE, O_RDONLY);\n\tkey_fd[i++] = open(_PATH_HOST_ECDSA_KEY_FILE, O_RDONLY);\n\tkey_fd[i++] = open(_PATH_HOST_ED25519_KEY_FILE, O_RDONLY);\n\tkey_fd[i++] = open(_PATH_HOST_XMSS_KEY_FILE, O_RDONLY);\n\tkey_fd[i++] = open(_PATH_HOST_RSA_KEY_FILE, O_RDONLY);\n\n\tif ((pw = getpwuid(getuid())) == NULL)\n\t\tfatal(\"getpwuid failed\");\n\tpw = pwcopy(pw);\n\n\tpermanently_set_uid(pw);\n\n\tseed_rng();\n\n#ifdef DEBUG_SSH_KEYSIGN\n\tlog_init(\"ssh-keysign\", SYSLOG_LEVEL_DEBUG3, SYSLOG_FACILITY_AUTH, 0);\n#endif\n\n\t/* verify that ssh-keysign is enabled by the admin */\n\tinitialize_options(&options);\n\t(void)read_config_file(_PATH_HOST_CONFIG_FILE, pw, \"\", \"\", &options, 0);\n\tfill_default_options(&options);\n\tif (options.enable_ssh_keysign != 1)\n\t\tfatal(\"ssh-keysign not enabled in %s\",\n\t\t    _PATH_HOST_CONFIG_FILE);\n\n\tfor (i = found = 0; i < NUM_KEYTYPES; i++) {\n\t\tif (key_fd[i] != -1)\n\t\t\tfound = 1;\n\t}\n\tif (found == 0)\n\t\tfatal(\"could not open any host key\");\n\n#ifdef WITH_OPENSSL\n\tOpenSSL_add_all_algorithms();\n\tarc4random_buf(rnd, sizeof(rnd));\n\tRAND_seed(rnd, sizeof(rnd));\n#endif\n\n\tfound = 0;\n\tfor (i = 0; i < NUM_KEYTYPES; i++) {\n\t\tkeys[i] = NULL;\n\t\tif (key_fd[i] == -1)\n\t\t\tcontinue;\n\t\tr = sshkey_load_private_type_fd(key_fd[i], KEY_UNSPEC,\n\t\t    NULL, &key, NULL);\n\t\tclose(key_fd[i]);\n\t\tif (r != 0)\n\t\t\tdebug(\"parse key %d: %s\", i, ssh_err(r));\n\t\telse if (key != NULL) {\n\t\t\tkeys[i] = key;\n\t\t\tfound = 1;\n\t\t}\n\t}\n\tif (!found)\n\t\tfatal(\"no hostkey found\");\n\n\tif (pledge(\"stdio dns\", NULL) != 0)\n\t\tfatal(\"%s: pledge: %s\", __progname, strerror(errno));\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __progname);\n\tif (ssh_msg_recv(STDIN_FILENO, b) < 0)\n\t\tfatal(\"ssh_msg_recv failed\");\n\tif ((r = sshbuf_get_u8(b, &rver)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __progname, ssh_err(r));\n\tif (rver != version)\n\t\tfatal(\"bad version: received %d, expected %d\", rver, version);\n\tif ((r = sshbuf_get_u32(b, (u_int *)&fd)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __progname, ssh_err(r));\n\tif (fd < 0 || fd == STDIN_FILENO || fd == STDOUT_FILENO)\n\t\tfatal(\"bad fd\");\n\tif ((host = get_local_name(fd)) == NULL)\n\t\tfatal(\"cannot get local name for fd\");\n\n\tif ((r = sshbuf_get_string(b, &data, &dlen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __progname, ssh_err(r));\n\tif (valid_request(pw, host, &key, data, dlen) < 0)\n\t\tfatal(\"not a valid request\");\n\tfree(host);\n\n\tfound = 0;\n\tfor (i = 0; i < NUM_KEYTYPES; i++) {\n\t\tif (keys[i] != NULL &&\n\t\t    sshkey_equal_public(key, keys[i])) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tif ((fp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal(\"%s: sshkey_fingerprint failed\", __progname);\n\t\tfatal(\"no matching hostkey found for key %s %s\",\n\t\t    sshkey_type(key), fp ? fp : \"\");\n\t}\n\n\tif ((r = sshkey_sign(keys[i], &signature, &slen, data, dlen, NULL, 0))\n\t    != 0)\n\t\tfatal(\"sshkey_sign failed: %s\", ssh_err(r));\n\tfree(data);\n\n\t/* send reply */\n\tsshbuf_reset(b);\n\tif ((r = sshbuf_put_string(b, signature, slen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __progname, ssh_err(r));\n\tif (ssh_msg_send(STDOUT_FILENO, version, b) == -1)\n\t\tfatal(\"ssh_msg_send failed\");\n\n\treturn (0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"sshkey.h\"",
      "#include \"uidswap.h\"",
      "#include \"readconf.h\"",
      "#include \"pathnames.h\"",
      "#include \"canohost.h\"",
      "#include \"msg.h\"",
      "#include \"authfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rsa.h>",
      "#include <openssl/rand.h>",
      "#include <openssl/evp.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <fcntl.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define NUM_KEYTYPES 5"
    ],
    "globals_used": [
      "extern char *__progname;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"ssh_msg_send failed\""
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_msg_send",
          "args": [
            "STDOUT_FILENO",
            "version",
            "b"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_msg_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/msg.c",
          "lines": "44-63",
          "snippet": "int\nssh_msg_send(int fd, u_char type, struct sshbuf *m)\n{\n\tu_char buf[5];\n\tu_int mlen = sshbuf_len(m);\n\n\tdebug3(\"ssh_msg_send: type %u\", (unsigned int)type & 0xff);\n\n\tput_u32(buf, mlen + 1);\n\tbuf[4] = type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, fd, buf, sizeof(buf)) != sizeof(buf)) {\n\t\terror(\"ssh_msg_send: write\");\n\t\treturn (-1);\n\t}\n\tif (atomicio(vwrite, fd, sshbuf_mutable_ptr(m), mlen) != mlen) {\n\t\terror(\"ssh_msg_send: write\");\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"msg.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"msg.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_msg_send(int fd, u_char type, struct sshbuf *m)\n{\n\tu_char buf[5];\n\tu_int mlen = sshbuf_len(m);\n\n\tdebug3(\"ssh_msg_send: type %u\", (unsigned int)type & 0xff);\n\n\tput_u32(buf, mlen + 1);\n\tbuf[4] = type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, fd, buf, sizeof(buf)) != sizeof(buf)) {\n\t\terror(\"ssh_msg_send: write\");\n\t\treturn (-1);\n\t}\n\tif (atomicio(vwrite, fd, sshbuf_mutable_ptr(m), mlen) != mlen) {\n\t\terror(\"ssh_msg_send: write\");\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "b",
            "signature",
            "slen"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "b"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "data"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"sshkey_sign failed: %s\"",
            "ssh_err(r)"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_sign",
          "args": [
            "keys[i]",
            "&signature",
            "&slen",
            "data",
            "dlen",
            "NULL",
            "0"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2385-2421",
          "snippet": "int\nsshkey_sign(const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_sign(key, sigp, lenp, data, datalen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_sign(key, sigp, lenp, data, datalen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_sign(key, sigp, lenp, data, datalen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_sign(key, sigp, lenp, data, datalen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_sign(key, sigp, lenp, data, datalen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_sign(const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_sign(key, sigp, lenp, data, datalen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_sign(key, sigp, lenp, data, datalen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_sign(key, sigp, lenp, data, datalen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_sign(key, sigp, lenp, data, datalen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_sign(key, sigp, lenp, data, datalen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "key"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "key",
            "options.fingerprint_hash",
            "SSH_FP_DEFAULT"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_equal_public",
          "args": [
            "key",
            "keys[i]"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_equal_public",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "627-702",
          "snippet": "int\nsshkey_equal_public(const struct sshkey *a, const struct sshkey *b)\n{\n#if defined(WITH_OPENSSL)\n\tconst BIGNUM *rsa_e_a, *rsa_n_a;\n\tconst BIGNUM *rsa_e_b, *rsa_n_b;\n\tconst BIGNUM *dsa_p_a, *dsa_q_a, *dsa_g_a, *dsa_pub_key_a;\n\tconst BIGNUM *dsa_p_b, *dsa_q_b, *dsa_g_b, *dsa_pub_key_b;\n# if defined(OPENSSL_HAS_ECC)\n\tBN_CTX *bnctx;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n\tif (a == NULL || b == NULL ||\n\t    sshkey_type_plain(a->type) != sshkey_type_plain(b->type))\n\t\treturn 0;\n\n\tswitch (a->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\tif (a->rsa == NULL || b->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(a->rsa, &rsa_n_a, &rsa_e_a, NULL);\n\t\tRSA_get0_key(b->rsa, &rsa_n_b, &rsa_e_b, NULL);\n\t\treturn BN_cmp(rsa_e_a, rsa_e_b) == 0 &&\n\t\t    BN_cmp(rsa_n_a, rsa_n_b) == 0;\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\tif (a->dsa == NULL || b->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(a->dsa, &dsa_p_a, &dsa_q_a, &dsa_g_a);\n\t\tDSA_get0_pqg(b->dsa, &dsa_p_b, &dsa_q_b, &dsa_g_b);\n\t\tDSA_get0_key(a->dsa, &dsa_pub_key_a, NULL);\n\t\tDSA_get0_key(b->dsa, &dsa_pub_key_b, NULL);\n\t\treturn BN_cmp(dsa_p_a, dsa_p_b) == 0 &&\n\t\t    BN_cmp(dsa_q_a, dsa_q_b) == 0 &&\n\t\t    BN_cmp(dsa_g_a, dsa_g_b) == 0 &&\n\t\t    BN_cmp(dsa_pub_key_a, dsa_pub_key_b) == 0;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\tif (a->ecdsa == NULL || b->ecdsa == NULL ||\n\t\t    EC_KEY_get0_public_key(a->ecdsa) == NULL ||\n\t\t    EC_KEY_get0_public_key(b->ecdsa) == NULL)\n\t\t\treturn 0;\n\t\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\t\treturn 0;\n\t\tif (EC_GROUP_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_group(b->ecdsa), bnctx) != 0 ||\n\t\t    EC_POINT_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(b->ecdsa), bnctx) != 0) {\n\t\t\tBN_CTX_free(bnctx);\n\t\t\treturn 0;\n\t\t}\n\t\tBN_CTX_free(bnctx);\n\t\treturn 1;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn a->ed25519_pk != NULL && b->ed25519_pk != NULL &&\n\t\t    memcmp(a->ed25519_pk, b->ed25519_pk, ED25519_PK_SZ) == 0;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn a->xmss_pk != NULL && b->xmss_pk != NULL &&\n\t\t    sshkey_xmss_pklen(a) == sshkey_xmss_pklen(b) &&\n\t\t    memcmp(a->xmss_pk, b->xmss_pk, sshkey_xmss_pklen(a)) == 0;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_equal_public(const struct sshkey *a, const struct sshkey *b)\n{\n#if defined(WITH_OPENSSL)\n\tconst BIGNUM *rsa_e_a, *rsa_n_a;\n\tconst BIGNUM *rsa_e_b, *rsa_n_b;\n\tconst BIGNUM *dsa_p_a, *dsa_q_a, *dsa_g_a, *dsa_pub_key_a;\n\tconst BIGNUM *dsa_p_b, *dsa_q_b, *dsa_g_b, *dsa_pub_key_b;\n# if defined(OPENSSL_HAS_ECC)\n\tBN_CTX *bnctx;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n\tif (a == NULL || b == NULL ||\n\t    sshkey_type_plain(a->type) != sshkey_type_plain(b->type))\n\t\treturn 0;\n\n\tswitch (a->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\tif (a->rsa == NULL || b->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(a->rsa, &rsa_n_a, &rsa_e_a, NULL);\n\t\tRSA_get0_key(b->rsa, &rsa_n_b, &rsa_e_b, NULL);\n\t\treturn BN_cmp(rsa_e_a, rsa_e_b) == 0 &&\n\t\t    BN_cmp(rsa_n_a, rsa_n_b) == 0;\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\tif (a->dsa == NULL || b->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(a->dsa, &dsa_p_a, &dsa_q_a, &dsa_g_a);\n\t\tDSA_get0_pqg(b->dsa, &dsa_p_b, &dsa_q_b, &dsa_g_b);\n\t\tDSA_get0_key(a->dsa, &dsa_pub_key_a, NULL);\n\t\tDSA_get0_key(b->dsa, &dsa_pub_key_b, NULL);\n\t\treturn BN_cmp(dsa_p_a, dsa_p_b) == 0 &&\n\t\t    BN_cmp(dsa_q_a, dsa_q_b) == 0 &&\n\t\t    BN_cmp(dsa_g_a, dsa_g_b) == 0 &&\n\t\t    BN_cmp(dsa_pub_key_a, dsa_pub_key_b) == 0;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\tif (a->ecdsa == NULL || b->ecdsa == NULL ||\n\t\t    EC_KEY_get0_public_key(a->ecdsa) == NULL ||\n\t\t    EC_KEY_get0_public_key(b->ecdsa) == NULL)\n\t\t\treturn 0;\n\t\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\t\treturn 0;\n\t\tif (EC_GROUP_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_group(b->ecdsa), bnctx) != 0 ||\n\t\t    EC_POINT_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(b->ecdsa), bnctx) != 0) {\n\t\t\tBN_CTX_free(bnctx);\n\t\t\treturn 0;\n\t\t}\n\t\tBN_CTX_free(bnctx);\n\t\treturn 1;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn a->ed25519_pk != NULL && b->ed25519_pk != NULL &&\n\t\t    memcmp(a->ed25519_pk, b->ed25519_pk, ED25519_PK_SZ) == 0;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn a->xmss_pk != NULL && b->xmss_pk != NULL &&\n\t\t    sshkey_xmss_pklen(a) == sshkey_xmss_pklen(b) &&\n\t\t    memcmp(a->xmss_pk, b->xmss_pk, sshkey_xmss_pklen(a)) == 0;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_request",
          "args": [
            "pw",
            "host",
            "&key",
            "data",
            "dlen"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "valid_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keysign.c",
          "lines": "66-163",
          "snippet": "static int\nvalid_request(struct passwd *pw, char *host, struct sshkey **ret,\n    u_char *data, size_t datalen)\n{\n\tstruct sshbuf *b;\n\tstruct sshkey *key = NULL;\n\tu_char type, *pkblob;\n\tchar *p;\n\tsize_t blen, len;\n\tchar *pkalg, *luser;\n\tint r, pktype, fail;\n\n\tif (ret != NULL)\n\t\t*ret = NULL;\n\tfail = 0;\n\n\tif ((b = sshbuf_from(data, datalen)) == NULL)\n\t\tfatal(\"%s: sshbuf_from failed\", __func__);\n\n\t/* session id, currently limited to SHA1 (20 bytes) or SHA256 (32) */\n\tif ((r = sshbuf_get_string(b, NULL, &len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (len != 20 && len != 32)\n\t\tfail++;\n\n\tif ((r = sshbuf_get_u8(b, &type)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (type != SSH2_MSG_USERAUTH_REQUEST)\n\t\tfail++;\n\n\t/* server user */\n\tif ((r = sshbuf_skip_string(b)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\t/* service */\n\tif ((r = sshbuf_get_cstring(b, &p, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (strcmp(\"ssh-connection\", p) != 0)\n\t\tfail++;\n\tfree(p);\n\n\t/* method */\n\tif ((r = sshbuf_get_cstring(b, &p, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (strcmp(\"hostbased\", p) != 0)\n\t\tfail++;\n\tfree(p);\n\n\t/* pubkey */\n\tif ((r = sshbuf_get_cstring(b, &pkalg, NULL)) != 0 ||\n\t    (r = sshbuf_get_string(b, &pkblob, &blen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tpktype = sshkey_type_from_name(pkalg);\n\tif (pktype == KEY_UNSPEC)\n\t\tfail++;\n\telse if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {\n\t\terror(\"%s: bad key blob: %s\", __func__, ssh_err(r));\n\t\tfail++;\n\t} else if (key->type != pktype)\n\t\tfail++;\n\tfree(pkalg);\n\tfree(pkblob);\n\n\t/* client host name, handle trailing dot */\n\tif ((r = sshbuf_get_cstring(b, &p, &len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tdebug2(\"%s: check expect chost %s got %s\", __func__, host, p);\n\tif (strlen(host) != len - 1)\n\t\tfail++;\n\telse if (p[len - 1] != '.')\n\t\tfail++;\n\telse if (strncasecmp(host, p, len - 1) != 0)\n\t\tfail++;\n\tfree(p);\n\n\t/* local user */\n\tif ((r = sshbuf_get_cstring(b, &luser, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (strcmp(pw->pw_name, luser) != 0)\n\t\tfail++;\n\tfree(luser);\n\n\t/* end of message */\n\tif (sshbuf_len(b) != 0)\n\t\tfail++;\n\tsshbuf_free(b);\n\n\tdebug3(\"%s: fail %d\", __func__, fail);\n\n\tif (fail)\n\t\tsshkey_free(key);\n\telse if (ret != NULL)\n\t\t*ret = key;\n\n\treturn (fail ? -1 : 0);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"sshkey.h\"",
            "#include \"uidswap.h\"",
            "#include \"readconf.h\"",
            "#include \"pathnames.h\"",
            "#include \"canohost.h\"",
            "#include \"msg.h\"",
            "#include \"authfile.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rsa.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/evp.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <fcntl.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"sshkey.h\"\n#include \"uidswap.h\"\n#include \"readconf.h\"\n#include \"pathnames.h\"\n#include \"canohost.h\"\n#include \"msg.h\"\n#include \"authfile.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <paths.h>\n#include <fcntl.h>\n#include \"includes.h\"\n\nstatic int\nvalid_request(struct passwd *pw, char *host, struct sshkey **ret,\n    u_char *data, size_t datalen)\n{\n\tstruct sshbuf *b;\n\tstruct sshkey *key = NULL;\n\tu_char type, *pkblob;\n\tchar *p;\n\tsize_t blen, len;\n\tchar *pkalg, *luser;\n\tint r, pktype, fail;\n\n\tif (ret != NULL)\n\t\t*ret = NULL;\n\tfail = 0;\n\n\tif ((b = sshbuf_from(data, datalen)) == NULL)\n\t\tfatal(\"%s: sshbuf_from failed\", __func__);\n\n\t/* session id, currently limited to SHA1 (20 bytes) or SHA256 (32) */\n\tif ((r = sshbuf_get_string(b, NULL, &len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (len != 20 && len != 32)\n\t\tfail++;\n\n\tif ((r = sshbuf_get_u8(b, &type)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (type != SSH2_MSG_USERAUTH_REQUEST)\n\t\tfail++;\n\n\t/* server user */\n\tif ((r = sshbuf_skip_string(b)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\t/* service */\n\tif ((r = sshbuf_get_cstring(b, &p, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (strcmp(\"ssh-connection\", p) != 0)\n\t\tfail++;\n\tfree(p);\n\n\t/* method */\n\tif ((r = sshbuf_get_cstring(b, &p, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (strcmp(\"hostbased\", p) != 0)\n\t\tfail++;\n\tfree(p);\n\n\t/* pubkey */\n\tif ((r = sshbuf_get_cstring(b, &pkalg, NULL)) != 0 ||\n\t    (r = sshbuf_get_string(b, &pkblob, &blen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tpktype = sshkey_type_from_name(pkalg);\n\tif (pktype == KEY_UNSPEC)\n\t\tfail++;\n\telse if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {\n\t\terror(\"%s: bad key blob: %s\", __func__, ssh_err(r));\n\t\tfail++;\n\t} else if (key->type != pktype)\n\t\tfail++;\n\tfree(pkalg);\n\tfree(pkblob);\n\n\t/* client host name, handle trailing dot */\n\tif ((r = sshbuf_get_cstring(b, &p, &len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tdebug2(\"%s: check expect chost %s got %s\", __func__, host, p);\n\tif (strlen(host) != len - 1)\n\t\tfail++;\n\telse if (p[len - 1] != '.')\n\t\tfail++;\n\telse if (strncasecmp(host, p, len - 1) != 0)\n\t\tfail++;\n\tfree(p);\n\n\t/* local user */\n\tif ((r = sshbuf_get_cstring(b, &luser, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (strcmp(pw->pw_name, luser) != 0)\n\t\tfail++;\n\tfree(luser);\n\n\t/* end of message */\n\tif (sshbuf_len(b) != 0)\n\t\tfail++;\n\tsshbuf_free(b);\n\n\tdebug3(\"%s: fail %d\", __func__, fail);\n\n\tif (fail)\n\t\tsshkey_free(key);\n\telse if (ret != NULL)\n\t\t*ret = key;\n\n\treturn (fail ? -1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string",
          "args": [
            "b",
            "&data",
            "&dlen"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_local_name",
          "args": [
            "fd"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "get_local_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "133-151",
          "snippet": "char *\nget_local_name(int fd)\n{\n\tchar *host, myname[NI_MAXHOST];\n\n\t/* Assume we were passed a socket */\n\tif ((host = get_socket_address(fd, 0, NI_NAMEREQD)) != NULL)\n\t\treturn host;\n\n\t/* Handle the case where we were passed a pipe */\n\tif (gethostname(myname, sizeof(myname)) == -1) {\n\t\tverbose(\"%s: gethostname: %s\", __func__, strerror(errno));\n\t\thost = xstrdup(\"UNKNOWN\");\n\t} else {\n\t\thost = xstrdup(myname);\n\t}\n\n\treturn host;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nget_local_name(int fd)\n{\n\tchar *host, myname[NI_MAXHOST];\n\n\t/* Assume we were passed a socket */\n\tif ((host = get_socket_address(fd, 0, NI_NAMEREQD)) != NULL)\n\t\treturn host;\n\n\t/* Handle the case where we were passed a pipe */\n\tif (gethostname(myname, sizeof(myname)) == -1) {\n\t\tverbose(\"%s: gethostname: %s\", __func__, strerror(errno));\n\t\thost = xstrdup(\"UNKNOWN\");\n\t} else {\n\t\thost = xstrdup(myname);\n\t}\n\n\treturn host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "b",
            "(u_int *)&fd"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "b",
            "&rver"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_msg_recv",
          "args": [
            "STDIN_FILENO",
            "b"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_msg_recv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/msg.c",
          "lines": "65-94",
          "snippet": "int\nssh_msg_recv(int fd, struct sshbuf *m)\n{\n\tu_char buf[4], *p;\n\tu_int msg_len;\n\tint r;\n\n\tdebug3(\"ssh_msg_recv entering\");\n\n\tif (atomicio(read, fd, buf, sizeof(buf)) != sizeof(buf)) {\n\t\tif (errno != EPIPE)\n\t\t\terror(\"ssh_msg_recv: read: header\");\n\t\treturn (-1);\n\t}\n\tmsg_len = get_u32(buf);\n\tif (msg_len > 256 * 1024) {\n\t\terror(\"ssh_msg_recv: read: bad msg_len %u\", msg_len);\n\t\treturn (-1);\n\t}\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_reserve(m, msg_len, &p)) != 0) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\treturn -1;\n\t}\n\tif (atomicio(read, fd, p, msg_len) != msg_len) {\n\t\terror(\"ssh_msg_recv: read: %s\", strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"msg.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"msg.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_msg_recv(int fd, struct sshbuf *m)\n{\n\tu_char buf[4], *p;\n\tu_int msg_len;\n\tint r;\n\n\tdebug3(\"ssh_msg_recv entering\");\n\n\tif (atomicio(read, fd, buf, sizeof(buf)) != sizeof(buf)) {\n\t\tif (errno != EPIPE)\n\t\t\terror(\"ssh_msg_recv: read: header\");\n\t\treturn (-1);\n\t}\n\tmsg_len = get_u32(buf);\n\tif (msg_len > 256 * 1024) {\n\t\terror(\"ssh_msg_recv: read: bad msg_len %u\", msg_len);\n\t\treturn (-1);\n\t}\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_reserve(m, msg_len, &p)) != 0) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\treturn -1;\n\t}\n\tif (atomicio(read, fd, p, msg_len) != msg_len) {\n\t\terror(\"ssh_msg_recv: read: %s\", strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pledge",
          "args": [
            "\"stdio dns\"",
            "NULL"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "pledge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "255-259",
          "snippet": "int\npledge(const char *promises, const char *paths[])\n{\n\treturn 0;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\npledge(const char *promises, const char *paths[])\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"parse key %d: %s\"",
            "i",
            "ssh_err(r)"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "key_fd[i]"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_load_private_type_fd",
          "args": [
            "key_fd[i]",
            "KEY_UNSPEC",
            "NULL",
            "&key",
            "NULL"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_load_private_type_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "201-224",
          "snippet": "int\nsshkey_load_private_type_fd(int fd, int type, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tstruct sshbuf *buffer = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif ((buffer = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_load_file(fd, buffer)) != 0 ||\n\t    (r = sshkey_parse_private_fileblob_type(buffer, type,\n\t    passphrase, keyp, commentp)) != 0)\n\t\tgoto out;\n\n\t/* success */\n\tr = 0;\n out:\n\tsshbuf_free(buffer);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_load_private_type_fd(int fd, int type, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tstruct sshbuf *buffer = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif ((buffer = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_load_file(fd, buffer)) != 0 ||\n\t    (r = sshkey_parse_private_fileblob_type(buffer, type,\n\t    passphrase, keyp, commentp)) != 0)\n\t\tgoto out;\n\n\t/* success */\n\tr = 0;\n out:\n\tsshbuf_free(buffer);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAND_seed",
          "args": [
            "rnd",
            "sizeof(rnd)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arc4random_buf",
          "args": [
            "rnd",
            "sizeof(rnd)"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "arc4random_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "263-277",
          "snippet": "void\narc4random_buf(void *_buf, size_t n)\n{\n\tsize_t i;\n\tu_int32_t r = 0;\n\tchar *buf = (char *)_buf;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (i % 4 == 0)\n\t\t\tr = arc4random();\n\t\tbuf[i] = r & 0xff;\n\t\tr >>= 8;\n\t}\n\texplicit_bzero(&r, sizeof(r));\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\narc4random_buf(void *_buf, size_t n)\n{\n\tsize_t i;\n\tu_int32_t r = 0;\n\tchar *buf = (char *)_buf;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (i % 4 == 0)\n\t\t\tr = arc4random();\n\t\tbuf[i] = r & 0xff;\n\t\tr >>= 8;\n\t}\n\texplicit_bzero(&r, sizeof(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "OpenSSL_add_all_algorithms",
          "args": [],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_OpenSSL_add_all_algorithms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/openssl-compat.c",
          "lines": "70-85",
          "snippet": "void\nssh_OpenSSL_add_all_algorithms(void)\n{\n\tOpenSSL_add_all_algorithms();\n\n\t/* Enable use of crypto hardware */\n\tENGINE_load_builtin_engines();\n\tENGINE_register_all_complete();\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tOPENSSL_config(NULL);\n#else\n\tOPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS |\n\t    OPENSSL_INIT_ADD_ALL_DIGESTS | OPENSSL_INIT_LOAD_CONFIG, NULL);\n#endif\n}",
          "includes": [
            "#include \"openssl-compat.h\"",
            "#include \"log.h\"",
            "# include <openssl/conf.h>",
            "# include <openssl/engine.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openssl-compat.h\"\n#include \"log.h\"\n# include <openssl/conf.h>\n# include <openssl/engine.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nssh_OpenSSL_add_all_algorithms(void)\n{\n\tOpenSSL_add_all_algorithms();\n\n\t/* Enable use of crypto hardware */\n\tENGINE_load_builtin_engines();\n\tENGINE_register_all_complete();\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tOPENSSL_config(NULL);\n#else\n\tOPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS |\n\t    OPENSSL_INIT_ADD_ALL_DIGESTS | OPENSSL_INIT_LOAD_CONFIG, NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_default_options",
          "args": [
            "&options"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "fill_default_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "1950-2149",
          "snippet": "void\nfill_default_options(Options * options)\n{\n\tchar *all_cipher, *all_mac, *all_kex, *all_key, *all_sig;\n\tint r;\n\n\tif (options->forward_agent == -1)\n\t\toptions->forward_agent = 0;\n\tif (options->forward_x11 == -1)\n\t\toptions->forward_x11 = 0;\n\tif (options->forward_x11_trusted == -1)\n\t\toptions->forward_x11_trusted = 0;\n\tif (options->forward_x11_timeout == -1)\n\t\toptions->forward_x11_timeout = 1200;\n\t/*\n\t * stdio forwarding (-W) changes the default for these but we defer\n\t * setting the values so they can be overridden.\n\t */\n\tif (options->exit_on_forward_failure == -1)\n\t\toptions->exit_on_forward_failure =\n\t\t    options->stdio_forward_host != NULL ? 1 : 0;\n\tif (options->clear_forwardings == -1)\n\t\toptions->clear_forwardings =\n\t\t    options->stdio_forward_host != NULL ? 1 : 0;\n\tif (options->clear_forwardings == 1)\n\t\tclear_forwardings(options);\n\n\tif (options->xauth_location == NULL)\n\t\toptions->xauth_location = _PATH_XAUTH;\n\tif (options->fwd_opts.gateway_ports == -1)\n\t\toptions->fwd_opts.gateway_ports = 0;\n\tif (options->fwd_opts.streamlocal_bind_mask == (mode_t)-1)\n\t\toptions->fwd_opts.streamlocal_bind_mask = 0177;\n\tif (options->fwd_opts.streamlocal_bind_unlink == -1)\n\t\toptions->fwd_opts.streamlocal_bind_unlink = 0;\n\tif (options->pubkey_authentication == -1)\n\t\toptions->pubkey_authentication = 1;\n\tif (options->challenge_response_authentication == -1)\n\t\toptions->challenge_response_authentication = 1;\n\tif (options->gss_authentication == -1)\n\t\toptions->gss_authentication = 0;\n\tif (options->gss_deleg_creds == -1)\n\t\toptions->gss_deleg_creds = 0;\n\tif (options->password_authentication == -1)\n\t\toptions->password_authentication = 1;\n\tif (options->kbd_interactive_authentication == -1)\n\t\toptions->kbd_interactive_authentication = 1;\n\tif (options->hostbased_authentication == -1)\n\t\toptions->hostbased_authentication = 0;\n\tif (options->batch_mode == -1)\n\t\toptions->batch_mode = 0;\n\tif (options->check_host_ip == -1)\n\t\toptions->check_host_ip = 1;\n\tif (options->strict_host_key_checking == -1)\n\t\toptions->strict_host_key_checking = SSH_STRICT_HOSTKEY_ASK;\n\tif (options->compression == -1)\n\t\toptions->compression = 0;\n\tif (options->tcp_keep_alive == -1)\n\t\toptions->tcp_keep_alive = 1;\n\tif (options->port == -1)\n\t\toptions->port = 0;\t/* Filled in ssh_connect. */\n\tif (options->address_family == -1)\n\t\toptions->address_family = AF_UNSPEC;\n\tif (options->connection_attempts == -1)\n\t\toptions->connection_attempts = 1;\n\tif (options->number_of_password_prompts == -1)\n\t\toptions->number_of_password_prompts = 3;\n\t/* options->hostkeyalgorithms, default set in myproposals.h */\n\tif (options->add_keys_to_agent == -1)\n\t\toptions->add_keys_to_agent = 0;\n\tif (options->num_identity_files == 0) {\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_RSA, 0);\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_DSA, 0);\n#ifdef OPENSSL_HAS_ECC\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_ECDSA, 0);\n#endif\n\t\tadd_identity_file(options, \"~/\",\n\t\t    _PATH_SSH_CLIENT_ID_ED25519, 0);\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_XMSS, 0);\n\t}\n\tif (options->escape_char == -1)\n\t\toptions->escape_char = '~';\n\tif (options->num_system_hostfiles == 0) {\n\t\toptions->system_hostfiles[options->num_system_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_SYSTEM_HOSTFILE);\n\t\toptions->system_hostfiles[options->num_system_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_SYSTEM_HOSTFILE2);\n\t}\n\tif (options->num_user_hostfiles == 0) {\n\t\toptions->user_hostfiles[options->num_user_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_USER_HOSTFILE);\n\t\toptions->user_hostfiles[options->num_user_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_USER_HOSTFILE2);\n\t}\n\tif (options->log_level == SYSLOG_LEVEL_NOT_SET)\n\t\toptions->log_level = SYSLOG_LEVEL_INFO;\n\tif (options->log_facility == SYSLOG_FACILITY_NOT_SET)\n\t\toptions->log_facility = SYSLOG_FACILITY_USER;\n\tif (options->no_host_authentication_for_localhost == - 1)\n\t\toptions->no_host_authentication_for_localhost = 0;\n\tif (options->identities_only == -1)\n\t\toptions->identities_only = 0;\n\tif (options->enable_ssh_keysign == -1)\n\t\toptions->enable_ssh_keysign = 0;\n\tif (options->rekey_limit == -1)\n\t\toptions->rekey_limit = 0;\n\tif (options->rekey_interval == -1)\n\t\toptions->rekey_interval = 0;\n\tif (options->verify_host_key_dns == -1)\n\t\toptions->verify_host_key_dns = 0;\n\tif (options->server_alive_interval == -1)\n\t\toptions->server_alive_interval = 0;\n\tif (options->server_alive_count_max == -1)\n\t\toptions->server_alive_count_max = 3;\n\tif (options->control_master == -1)\n\t\toptions->control_master = 0;\n\tif (options->control_persist == -1) {\n\t\toptions->control_persist = 0;\n\t\toptions->control_persist_timeout = 0;\n\t}\n\tif (options->hash_known_hosts == -1)\n\t\toptions->hash_known_hosts = 0;\n\tif (options->tun_open == -1)\n\t\toptions->tun_open = SSH_TUNMODE_NO;\n\tif (options->tun_local == -1)\n\t\toptions->tun_local = SSH_TUNID_ANY;\n\tif (options->tun_remote == -1)\n\t\toptions->tun_remote = SSH_TUNID_ANY;\n\tif (options->permit_local_command == -1)\n\t\toptions->permit_local_command = 0;\n\tif (options->visual_host_key == -1)\n\t\toptions->visual_host_key = 0;\n\tif (options->ip_qos_interactive == -1)\n\t\toptions->ip_qos_interactive = IPTOS_DSCP_AF21;\n\tif (options->ip_qos_bulk == -1)\n\t\toptions->ip_qos_bulk = IPTOS_DSCP_CS1;\n\tif (options->request_tty == -1)\n\t\toptions->request_tty = REQUEST_TTY_AUTO;\n\tif (options->proxy_use_fdpass == -1)\n\t\toptions->proxy_use_fdpass = 0;\n\tif (options->canonicalize_max_dots == -1)\n\t\toptions->canonicalize_max_dots = 1;\n\tif (options->canonicalize_fallback_local == -1)\n\t\toptions->canonicalize_fallback_local = 1;\n\tif (options->canonicalize_hostname == -1)\n\t\toptions->canonicalize_hostname = SSH_CANONICALISE_NO;\n\tif (options->fingerprint_hash == -1)\n\t\toptions->fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\tif (options->update_hostkeys == -1)\n\t\toptions->update_hostkeys = 0;\n\n\t/* Expand KEX name lists */\n\tall_cipher = cipher_alg_list(',', 0);\n\tall_mac = mac_alg_list(',');\n\tall_kex = kex_alg_list(',');\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tall_sig = sshkey_alg_list(0, 1, 1, ',');\n#define ASSEMBLE(what, defaults, all) \\\n\tdo { \\\n\t\tif ((r = kex_assemble_names(&options->what, \\\n\t\t    defaults, all)) != 0) \\\n\t\t\tfatal(\"%s: %s: %s\", __func__, #what, ssh_err(r)); \\\n\t} while (0)\n\tASSEMBLE(ciphers, KEX_SERVER_ENCRYPT, all_cipher);\n\tASSEMBLE(macs, KEX_SERVER_MAC, all_mac);\n\tASSEMBLE(kex_algorithms, KEX_SERVER_KEX, all_kex);\n\tASSEMBLE(hostbased_key_types, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(pubkey_key_types, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(ca_sign_algorithms, SSH_ALLOWED_CA_SIGALGS, all_sig);\n#undef ASSEMBLE\n\tfree(all_cipher);\n\tfree(all_mac);\n\tfree(all_kex);\n\tfree(all_key);\n\tfree(all_sig);\n\n#define CLEAR_ON_NONE(v) \\\n\tdo { \\\n\t\tif (option_clear_or_none(v)) { \\\n\t\t\tfree(v); \\\n\t\t\tv = NULL; \\\n\t\t} \\\n\t} while(0)\n\tCLEAR_ON_NONE(options->local_command);\n\tCLEAR_ON_NONE(options->remote_command);\n\tCLEAR_ON_NONE(options->proxy_command);\n\tCLEAR_ON_NONE(options->control_path);\n\tCLEAR_ON_NONE(options->revoked_host_keys);\n\tif (options->jump_host != NULL &&\n\t    strcmp(options->jump_host, \"none\") == 0 &&\n\t    options->jump_port == 0 && options->jump_user == NULL) {\n\t\tfree(options->jump_host);\n\t\toptions->jump_host = NULL;\n\t}\n\t/* options->identity_agent distinguishes NULL from 'none' */\n\t/* options->user will be set in the main program if appropriate */\n\t/* options->hostname will be set in the main program if appropriate */\n\t/* options->host_key_alias should not be set by default */\n\t/* options->preferred_authentications will be set in ssh */\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfill_default_options(Options * options)\n{\n\tchar *all_cipher, *all_mac, *all_kex, *all_key, *all_sig;\n\tint r;\n\n\tif (options->forward_agent == -1)\n\t\toptions->forward_agent = 0;\n\tif (options->forward_x11 == -1)\n\t\toptions->forward_x11 = 0;\n\tif (options->forward_x11_trusted == -1)\n\t\toptions->forward_x11_trusted = 0;\n\tif (options->forward_x11_timeout == -1)\n\t\toptions->forward_x11_timeout = 1200;\n\t/*\n\t * stdio forwarding (-W) changes the default for these but we defer\n\t * setting the values so they can be overridden.\n\t */\n\tif (options->exit_on_forward_failure == -1)\n\t\toptions->exit_on_forward_failure =\n\t\t    options->stdio_forward_host != NULL ? 1 : 0;\n\tif (options->clear_forwardings == -1)\n\t\toptions->clear_forwardings =\n\t\t    options->stdio_forward_host != NULL ? 1 : 0;\n\tif (options->clear_forwardings == 1)\n\t\tclear_forwardings(options);\n\n\tif (options->xauth_location == NULL)\n\t\toptions->xauth_location = _PATH_XAUTH;\n\tif (options->fwd_opts.gateway_ports == -1)\n\t\toptions->fwd_opts.gateway_ports = 0;\n\tif (options->fwd_opts.streamlocal_bind_mask == (mode_t)-1)\n\t\toptions->fwd_opts.streamlocal_bind_mask = 0177;\n\tif (options->fwd_opts.streamlocal_bind_unlink == -1)\n\t\toptions->fwd_opts.streamlocal_bind_unlink = 0;\n\tif (options->pubkey_authentication == -1)\n\t\toptions->pubkey_authentication = 1;\n\tif (options->challenge_response_authentication == -1)\n\t\toptions->challenge_response_authentication = 1;\n\tif (options->gss_authentication == -1)\n\t\toptions->gss_authentication = 0;\n\tif (options->gss_deleg_creds == -1)\n\t\toptions->gss_deleg_creds = 0;\n\tif (options->password_authentication == -1)\n\t\toptions->password_authentication = 1;\n\tif (options->kbd_interactive_authentication == -1)\n\t\toptions->kbd_interactive_authentication = 1;\n\tif (options->hostbased_authentication == -1)\n\t\toptions->hostbased_authentication = 0;\n\tif (options->batch_mode == -1)\n\t\toptions->batch_mode = 0;\n\tif (options->check_host_ip == -1)\n\t\toptions->check_host_ip = 1;\n\tif (options->strict_host_key_checking == -1)\n\t\toptions->strict_host_key_checking = SSH_STRICT_HOSTKEY_ASK;\n\tif (options->compression == -1)\n\t\toptions->compression = 0;\n\tif (options->tcp_keep_alive == -1)\n\t\toptions->tcp_keep_alive = 1;\n\tif (options->port == -1)\n\t\toptions->port = 0;\t/* Filled in ssh_connect. */\n\tif (options->address_family == -1)\n\t\toptions->address_family = AF_UNSPEC;\n\tif (options->connection_attempts == -1)\n\t\toptions->connection_attempts = 1;\n\tif (options->number_of_password_prompts == -1)\n\t\toptions->number_of_password_prompts = 3;\n\t/* options->hostkeyalgorithms, default set in myproposals.h */\n\tif (options->add_keys_to_agent == -1)\n\t\toptions->add_keys_to_agent = 0;\n\tif (options->num_identity_files == 0) {\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_RSA, 0);\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_DSA, 0);\n#ifdef OPENSSL_HAS_ECC\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_ECDSA, 0);\n#endif\n\t\tadd_identity_file(options, \"~/\",\n\t\t    _PATH_SSH_CLIENT_ID_ED25519, 0);\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_XMSS, 0);\n\t}\n\tif (options->escape_char == -1)\n\t\toptions->escape_char = '~';\n\tif (options->num_system_hostfiles == 0) {\n\t\toptions->system_hostfiles[options->num_system_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_SYSTEM_HOSTFILE);\n\t\toptions->system_hostfiles[options->num_system_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_SYSTEM_HOSTFILE2);\n\t}\n\tif (options->num_user_hostfiles == 0) {\n\t\toptions->user_hostfiles[options->num_user_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_USER_HOSTFILE);\n\t\toptions->user_hostfiles[options->num_user_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_USER_HOSTFILE2);\n\t}\n\tif (options->log_level == SYSLOG_LEVEL_NOT_SET)\n\t\toptions->log_level = SYSLOG_LEVEL_INFO;\n\tif (options->log_facility == SYSLOG_FACILITY_NOT_SET)\n\t\toptions->log_facility = SYSLOG_FACILITY_USER;\n\tif (options->no_host_authentication_for_localhost == - 1)\n\t\toptions->no_host_authentication_for_localhost = 0;\n\tif (options->identities_only == -1)\n\t\toptions->identities_only = 0;\n\tif (options->enable_ssh_keysign == -1)\n\t\toptions->enable_ssh_keysign = 0;\n\tif (options->rekey_limit == -1)\n\t\toptions->rekey_limit = 0;\n\tif (options->rekey_interval == -1)\n\t\toptions->rekey_interval = 0;\n\tif (options->verify_host_key_dns == -1)\n\t\toptions->verify_host_key_dns = 0;\n\tif (options->server_alive_interval == -1)\n\t\toptions->server_alive_interval = 0;\n\tif (options->server_alive_count_max == -1)\n\t\toptions->server_alive_count_max = 3;\n\tif (options->control_master == -1)\n\t\toptions->control_master = 0;\n\tif (options->control_persist == -1) {\n\t\toptions->control_persist = 0;\n\t\toptions->control_persist_timeout = 0;\n\t}\n\tif (options->hash_known_hosts == -1)\n\t\toptions->hash_known_hosts = 0;\n\tif (options->tun_open == -1)\n\t\toptions->tun_open = SSH_TUNMODE_NO;\n\tif (options->tun_local == -1)\n\t\toptions->tun_local = SSH_TUNID_ANY;\n\tif (options->tun_remote == -1)\n\t\toptions->tun_remote = SSH_TUNID_ANY;\n\tif (options->permit_local_command == -1)\n\t\toptions->permit_local_command = 0;\n\tif (options->visual_host_key == -1)\n\t\toptions->visual_host_key = 0;\n\tif (options->ip_qos_interactive == -1)\n\t\toptions->ip_qos_interactive = IPTOS_DSCP_AF21;\n\tif (options->ip_qos_bulk == -1)\n\t\toptions->ip_qos_bulk = IPTOS_DSCP_CS1;\n\tif (options->request_tty == -1)\n\t\toptions->request_tty = REQUEST_TTY_AUTO;\n\tif (options->proxy_use_fdpass == -1)\n\t\toptions->proxy_use_fdpass = 0;\n\tif (options->canonicalize_max_dots == -1)\n\t\toptions->canonicalize_max_dots = 1;\n\tif (options->canonicalize_fallback_local == -1)\n\t\toptions->canonicalize_fallback_local = 1;\n\tif (options->canonicalize_hostname == -1)\n\t\toptions->canonicalize_hostname = SSH_CANONICALISE_NO;\n\tif (options->fingerprint_hash == -1)\n\t\toptions->fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\tif (options->update_hostkeys == -1)\n\t\toptions->update_hostkeys = 0;\n\n\t/* Expand KEX name lists */\n\tall_cipher = cipher_alg_list(',', 0);\n\tall_mac = mac_alg_list(',');\n\tall_kex = kex_alg_list(',');\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tall_sig = sshkey_alg_list(0, 1, 1, ',');\n#define ASSEMBLE(what, defaults, all) \\\n\tdo { \\\n\t\tif ((r = kex_assemble_names(&options->what, \\\n\t\t    defaults, all)) != 0) \\\n\t\t\tfatal(\"%s: %s: %s\", __func__, #what, ssh_err(r)); \\\n\t} while (0)\n\tASSEMBLE(ciphers, KEX_SERVER_ENCRYPT, all_cipher);\n\tASSEMBLE(macs, KEX_SERVER_MAC, all_mac);\n\tASSEMBLE(kex_algorithms, KEX_SERVER_KEX, all_kex);\n\tASSEMBLE(hostbased_key_types, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(pubkey_key_types, KEX_DEFAULT_PK_ALG, all_key);\n\tASSEMBLE(ca_sign_algorithms, SSH_ALLOWED_CA_SIGALGS, all_sig);\n#undef ASSEMBLE\n\tfree(all_cipher);\n\tfree(all_mac);\n\tfree(all_kex);\n\tfree(all_key);\n\tfree(all_sig);\n\n#define CLEAR_ON_NONE(v) \\\n\tdo { \\\n\t\tif (option_clear_or_none(v)) { \\\n\t\t\tfree(v); \\\n\t\t\tv = NULL; \\\n\t\t} \\\n\t} while(0)\n\tCLEAR_ON_NONE(options->local_command);\n\tCLEAR_ON_NONE(options->remote_command);\n\tCLEAR_ON_NONE(options->proxy_command);\n\tCLEAR_ON_NONE(options->control_path);\n\tCLEAR_ON_NONE(options->revoked_host_keys);\n\tif (options->jump_host != NULL &&\n\t    strcmp(options->jump_host, \"none\") == 0 &&\n\t    options->jump_port == 0 && options->jump_user == NULL) {\n\t\tfree(options->jump_host);\n\t\toptions->jump_host = NULL;\n\t}\n\t/* options->identity_agent distinguishes NULL from 'none' */\n\t/* options->user will be set in the main program if appropriate */\n\t/* options->hostname will be set in the main program if appropriate */\n\t/* options->host_key_alias should not be set by default */\n\t/* options->preferred_authentications will be set in ssh */\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_config_file",
          "args": [
            "_PATH_HOST_CONFIG_FILE",
            "pw",
            "\"\"",
            "\"\"",
            "&options",
            "0"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "read_config_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "1752-1760",
          "snippet": "int\nread_config_file(const char *filename, struct passwd *pw, const char *host,\n    const char *original_host, Options *options, int flags)\n{\n\tint active = 1;\n\n\treturn read_config_file_depth(filename, pw, host, original_host,\n\t    options, flags, &active, 0);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nread_config_file(const char *filename, struct passwd *pw, const char *host,\n    const char *original_host, Options *options, int flags)\n{\n\tint active = 1;\n\n\treturn read_config_file_depth(filename, pw, host, original_host,\n\t    options, flags, &active, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_options",
          "args": [
            "&options"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readconf.c",
          "lines": "1826-1929",
          "snippet": "void\ninitialize_options(Options * options)\n{\n\tmemset(options, 'X', sizeof(*options));\n\toptions->forward_agent = -1;\n\toptions->forward_x11 = -1;\n\toptions->forward_x11_trusted = -1;\n\toptions->forward_x11_timeout = -1;\n\toptions->stdio_forward_host = NULL;\n\toptions->stdio_forward_port = 0;\n\toptions->clear_forwardings = -1;\n\toptions->exit_on_forward_failure = -1;\n\toptions->xauth_location = NULL;\n\toptions->fwd_opts.gateway_ports = -1;\n\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)-1;\n\toptions->fwd_opts.streamlocal_bind_unlink = -1;\n\toptions->pubkey_authentication = -1;\n\toptions->challenge_response_authentication = -1;\n\toptions->gss_authentication = -1;\n\toptions->gss_deleg_creds = -1;\n\toptions->password_authentication = -1;\n\toptions->kbd_interactive_authentication = -1;\n\toptions->kbd_interactive_devices = NULL;\n\toptions->hostbased_authentication = -1;\n\toptions->batch_mode = -1;\n\toptions->check_host_ip = -1;\n\toptions->strict_host_key_checking = -1;\n\toptions->compression = -1;\n\toptions->tcp_keep_alive = -1;\n\toptions->port = -1;\n\toptions->address_family = -1;\n\toptions->connection_attempts = -1;\n\toptions->connection_timeout = -1;\n\toptions->number_of_password_prompts = -1;\n\toptions->ciphers = NULL;\n\toptions->macs = NULL;\n\toptions->kex_algorithms = NULL;\n\toptions->hostkeyalgorithms = NULL;\n\toptions->ca_sign_algorithms = NULL;\n\toptions->num_identity_files = 0;\n\toptions->num_certificate_files = 0;\n\toptions->hostname = NULL;\n\toptions->host_key_alias = NULL;\n\toptions->proxy_command = NULL;\n\toptions->jump_user = NULL;\n\toptions->jump_host = NULL;\n\toptions->jump_port = -1;\n\toptions->jump_extra = NULL;\n\toptions->user = NULL;\n\toptions->escape_char = -1;\n\toptions->num_system_hostfiles = 0;\n\toptions->num_user_hostfiles = 0;\n\toptions->local_forwards = NULL;\n\toptions->num_local_forwards = 0;\n\toptions->remote_forwards = NULL;\n\toptions->num_remote_forwards = 0;\n\toptions->log_facility = SYSLOG_FACILITY_NOT_SET;\n\toptions->log_level = SYSLOG_LEVEL_NOT_SET;\n\toptions->preferred_authentications = NULL;\n\toptions->bind_address = NULL;\n\toptions->bind_interface = NULL;\n\toptions->pkcs11_provider = NULL;\n\toptions->enable_ssh_keysign = - 1;\n\toptions->no_host_authentication_for_localhost = - 1;\n\toptions->identities_only = - 1;\n\toptions->rekey_limit = - 1;\n\toptions->rekey_interval = -1;\n\toptions->verify_host_key_dns = -1;\n\toptions->server_alive_interval = -1;\n\toptions->server_alive_count_max = -1;\n\toptions->send_env = NULL;\n\toptions->num_send_env = 0;\n\toptions->setenv = NULL;\n\toptions->num_setenv = 0;\n\toptions->control_path = NULL;\n\toptions->control_master = -1;\n\toptions->control_persist = -1;\n\toptions->control_persist_timeout = 0;\n\toptions->hash_known_hosts = -1;\n\toptions->tun_open = -1;\n\toptions->tun_local = -1;\n\toptions->tun_remote = -1;\n\toptions->local_command = NULL;\n\toptions->permit_local_command = -1;\n\toptions->remote_command = NULL;\n\toptions->add_keys_to_agent = -1;\n\toptions->identity_agent = NULL;\n\toptions->visual_host_key = -1;\n\toptions->ip_qos_interactive = -1;\n\toptions->ip_qos_bulk = -1;\n\toptions->request_tty = -1;\n\toptions->proxy_use_fdpass = -1;\n\toptions->ignored_unknown = NULL;\n\toptions->num_canonical_domains = 0;\n\toptions->num_permitted_cnames = 0;\n\toptions->canonicalize_max_dots = -1;\n\toptions->canonicalize_fallback_local = -1;\n\toptions->canonicalize_hostname = -1;\n\toptions->revoked_host_keys = NULL;\n\toptions->fingerprint_hash = -1;\n\toptions->update_hostkeys = -1;\n\toptions->hostbased_key_types = NULL;\n\toptions->pubkey_key_types = NULL;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"uidswap.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <vis.h>",
            "#include <util.h>",
            "# include \"openbsd-compat/glob.h\"",
            "# include <glob.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"uidswap.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <vis.h>\n#include <util.h>\n# include \"openbsd-compat/glob.h\"\n# include <glob.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ninitialize_options(Options * options)\n{\n\tmemset(options, 'X', sizeof(*options));\n\toptions->forward_agent = -1;\n\toptions->forward_x11 = -1;\n\toptions->forward_x11_trusted = -1;\n\toptions->forward_x11_timeout = -1;\n\toptions->stdio_forward_host = NULL;\n\toptions->stdio_forward_port = 0;\n\toptions->clear_forwardings = -1;\n\toptions->exit_on_forward_failure = -1;\n\toptions->xauth_location = NULL;\n\toptions->fwd_opts.gateway_ports = -1;\n\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)-1;\n\toptions->fwd_opts.streamlocal_bind_unlink = -1;\n\toptions->pubkey_authentication = -1;\n\toptions->challenge_response_authentication = -1;\n\toptions->gss_authentication = -1;\n\toptions->gss_deleg_creds = -1;\n\toptions->password_authentication = -1;\n\toptions->kbd_interactive_authentication = -1;\n\toptions->kbd_interactive_devices = NULL;\n\toptions->hostbased_authentication = -1;\n\toptions->batch_mode = -1;\n\toptions->check_host_ip = -1;\n\toptions->strict_host_key_checking = -1;\n\toptions->compression = -1;\n\toptions->tcp_keep_alive = -1;\n\toptions->port = -1;\n\toptions->address_family = -1;\n\toptions->connection_attempts = -1;\n\toptions->connection_timeout = -1;\n\toptions->number_of_password_prompts = -1;\n\toptions->ciphers = NULL;\n\toptions->macs = NULL;\n\toptions->kex_algorithms = NULL;\n\toptions->hostkeyalgorithms = NULL;\n\toptions->ca_sign_algorithms = NULL;\n\toptions->num_identity_files = 0;\n\toptions->num_certificate_files = 0;\n\toptions->hostname = NULL;\n\toptions->host_key_alias = NULL;\n\toptions->proxy_command = NULL;\n\toptions->jump_user = NULL;\n\toptions->jump_host = NULL;\n\toptions->jump_port = -1;\n\toptions->jump_extra = NULL;\n\toptions->user = NULL;\n\toptions->escape_char = -1;\n\toptions->num_system_hostfiles = 0;\n\toptions->num_user_hostfiles = 0;\n\toptions->local_forwards = NULL;\n\toptions->num_local_forwards = 0;\n\toptions->remote_forwards = NULL;\n\toptions->num_remote_forwards = 0;\n\toptions->log_facility = SYSLOG_FACILITY_NOT_SET;\n\toptions->log_level = SYSLOG_LEVEL_NOT_SET;\n\toptions->preferred_authentications = NULL;\n\toptions->bind_address = NULL;\n\toptions->bind_interface = NULL;\n\toptions->pkcs11_provider = NULL;\n\toptions->enable_ssh_keysign = - 1;\n\toptions->no_host_authentication_for_localhost = - 1;\n\toptions->identities_only = - 1;\n\toptions->rekey_limit = - 1;\n\toptions->rekey_interval = -1;\n\toptions->verify_host_key_dns = -1;\n\toptions->server_alive_interval = -1;\n\toptions->server_alive_count_max = -1;\n\toptions->send_env = NULL;\n\toptions->num_send_env = 0;\n\toptions->setenv = NULL;\n\toptions->num_setenv = 0;\n\toptions->control_path = NULL;\n\toptions->control_master = -1;\n\toptions->control_persist = -1;\n\toptions->control_persist_timeout = 0;\n\toptions->hash_known_hosts = -1;\n\toptions->tun_open = -1;\n\toptions->tun_local = -1;\n\toptions->tun_remote = -1;\n\toptions->local_command = NULL;\n\toptions->permit_local_command = -1;\n\toptions->remote_command = NULL;\n\toptions->add_keys_to_agent = -1;\n\toptions->identity_agent = NULL;\n\toptions->visual_host_key = -1;\n\toptions->ip_qos_interactive = -1;\n\toptions->ip_qos_bulk = -1;\n\toptions->request_tty = -1;\n\toptions->proxy_use_fdpass = -1;\n\toptions->ignored_unknown = NULL;\n\toptions->num_canonical_domains = 0;\n\toptions->num_permitted_cnames = 0;\n\toptions->canonicalize_max_dots = -1;\n\toptions->canonicalize_fallback_local = -1;\n\toptions->canonicalize_hostname = -1;\n\toptions->revoked_host_keys = NULL;\n\toptions->fingerprint_hash = -1;\n\toptions->update_hostkeys = -1;\n\toptions->hostbased_key_types = NULL;\n\toptions->pubkey_key_types = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_init",
          "args": [
            "\"ssh-keysign\"",
            "SYSLOG_LEVEL_DEBUG3",
            "SYSLOG_FACILITY_AUTH",
            "0"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "log_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "256-336",
          "snippet": "void\nlog_init(char *av0, LogLevel level, SyslogFacility facility, int on_stderr)\n{\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\tstruct syslog_data sdata = SYSLOG_DATA_INIT;\n#endif\n\n\targv0 = av0;\n\n\tif (log_change_level(level) != 0) {\n\t\tfprintf(stderr, \"Unrecognized internal syslog level code %d\\n\",\n\t\t    (int) level);\n\t\texit(1);\n\t}\n\n\tlog_handler = NULL;\n\tlog_handler_ctx = NULL;\n\n\tlog_on_stderr = on_stderr;\n\tif (on_stderr)\n\t\treturn;\n\n\tswitch (facility) {\n\tcase SYSLOG_FACILITY_DAEMON:\n\t\tlog_facility = LOG_DAEMON;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_USER:\n\t\tlog_facility = LOG_USER;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_AUTH:\n\t\tlog_facility = LOG_AUTH;\n\t\tbreak;\n#ifdef LOG_AUTHPRIV\n\tcase SYSLOG_FACILITY_AUTHPRIV:\n\t\tlog_facility = LOG_AUTHPRIV;\n\t\tbreak;\n#endif\n\tcase SYSLOG_FACILITY_LOCAL0:\n\t\tlog_facility = LOG_LOCAL0;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL1:\n\t\tlog_facility = LOG_LOCAL1;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL2:\n\t\tlog_facility = LOG_LOCAL2;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL3:\n\t\tlog_facility = LOG_LOCAL3;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL4:\n\t\tlog_facility = LOG_LOCAL4;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL5:\n\t\tlog_facility = LOG_LOCAL5;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL6:\n\t\tlog_facility = LOG_LOCAL6;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL7:\n\t\tlog_facility = LOG_LOCAL7;\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr,\n\t\t    \"Unrecognized internal syslog facility code %d\\n\",\n\t\t    (int) facility);\n\t\texit(1);\n\t}\n\n\t/*\n\t * If an external library (eg libwrap) attempts to use syslog\n\t * immediately after reexec, syslog may be pointing to the wrong\n\t * facility, so we force an open/close of syslog here.\n\t */\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\topenlog_r(argv0 ? argv0 : __progname, LOG_PID, log_facility, &sdata);\n\tcloselog_r(&sdata);\n#else\n\topenlog(argv0 ? argv0 : __progname, LOG_PID, log_facility);\n\tcloselog();\n#endif\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int log_on_stderr = 1;",
            "static int log_facility = LOG_AUTH;",
            "static char *argv0;",
            "static log_handler_fn *log_handler;",
            "static void *log_handler_ctx;",
            "extern char *__progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int log_on_stderr = 1;\nstatic int log_facility = LOG_AUTH;\nstatic char *argv0;\nstatic log_handler_fn *log_handler;\nstatic void *log_handler_ctx;\nextern char *__progname;\n\nvoid\nlog_init(char *av0, LogLevel level, SyslogFacility facility, int on_stderr)\n{\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\tstruct syslog_data sdata = SYSLOG_DATA_INIT;\n#endif\n\n\targv0 = av0;\n\n\tif (log_change_level(level) != 0) {\n\t\tfprintf(stderr, \"Unrecognized internal syslog level code %d\\n\",\n\t\t    (int) level);\n\t\texit(1);\n\t}\n\n\tlog_handler = NULL;\n\tlog_handler_ctx = NULL;\n\n\tlog_on_stderr = on_stderr;\n\tif (on_stderr)\n\t\treturn;\n\n\tswitch (facility) {\n\tcase SYSLOG_FACILITY_DAEMON:\n\t\tlog_facility = LOG_DAEMON;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_USER:\n\t\tlog_facility = LOG_USER;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_AUTH:\n\t\tlog_facility = LOG_AUTH;\n\t\tbreak;\n#ifdef LOG_AUTHPRIV\n\tcase SYSLOG_FACILITY_AUTHPRIV:\n\t\tlog_facility = LOG_AUTHPRIV;\n\t\tbreak;\n#endif\n\tcase SYSLOG_FACILITY_LOCAL0:\n\t\tlog_facility = LOG_LOCAL0;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL1:\n\t\tlog_facility = LOG_LOCAL1;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL2:\n\t\tlog_facility = LOG_LOCAL2;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL3:\n\t\tlog_facility = LOG_LOCAL3;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL4:\n\t\tlog_facility = LOG_LOCAL4;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL5:\n\t\tlog_facility = LOG_LOCAL5;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL6:\n\t\tlog_facility = LOG_LOCAL6;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL7:\n\t\tlog_facility = LOG_LOCAL7;\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr,\n\t\t    \"Unrecognized internal syslog facility code %d\\n\",\n\t\t    (int) facility);\n\t\texit(1);\n\t}\n\n\t/*\n\t * If an external library (eg libwrap) attempts to use syslog\n\t * immediately after reexec, syslog may be pointing to the wrong\n\t * facility, so we force an open/close of syslog here.\n\t */\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\topenlog_r(argv0 ? argv0 : __progname, LOG_PID, log_facility, &sdata);\n\tcloselog_r(&sdata);\n#else\n\topenlog(argv0 ? argv0 : __progname, LOG_PID, log_facility);\n\tcloselog();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "seed_rng",
          "args": [],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "seed_rng",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/entropy.c",
          "lines": "247-250",
          "snippet": "void\nseed_rng(void)\n{\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"xmalloc.h\"",
            "#include \"misc.h\"",
            "#include \"ssh.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/crypto.h>",
            "#include <openssl/rand.h>",
            "#include <stddef.h> /* for offsetof */",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"xmalloc.h\"\n#include \"misc.h\"\n#include \"ssh.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/crypto.h>\n#include <openssl/rand.h>\n#include <stddef.h> /* for offsetof */\n#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nseed_rng(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "permanently_set_uid",
          "args": [
            "pw"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "permanently_set_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "178-236",
          "snippet": "void\npermanently_set_uid(struct passwd *pw)\n{\n#ifndef NO_UID_RESTORATION_TEST\n\tuid_t old_uid = getuid();\n\tgid_t old_gid = getgid();\n#endif\n\n\tif (pw == NULL)\n\t\tfatal(\"permanently_set_uid: no user given\");\n\tif (temporarily_use_uid_effective)\n\t\tfatal(\"permanently_set_uid: temporarily_use_uid effective\");\n\tdebug(\"permanently_set_uid: %u/%u\", (u_int)pw->pw_uid,\n\t    (u_int)pw->pw_gid);\n\n\tif (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) < 0)\n\t\tfatal(\"setresgid %u: %.100s\", (u_int)pw->pw_gid, strerror(errno));\n\n#ifdef __APPLE__\n\t/*\n\t * OS X requires initgroups after setgid to opt back into\n\t * memberd support for >16 supplemental groups.\n\t */\n\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\tfatal(\"initgroups %.100s %u: %.100s\",\n\t\t    pw->pw_name, (u_int)pw->pw_gid, strerror(errno));\n#endif\n\n\tif (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) < 0)\n\t\tfatal(\"setresuid %u: %.100s\", (u_int)pw->pw_uid, strerror(errno));\n\n#ifndef NO_UID_RESTORATION_TEST\n\t/* Try restoration of GID if changed (test clearing of saved gid) */\n\tif (old_gid != pw->pw_gid && pw->pw_uid != 0 &&\n\t    (setgid(old_gid) != -1 || setegid(old_gid) != -1))\n\t\tfatal(\"%s: was able to restore old [e]gid\", __func__);\n#endif\n\n\t/* Verify GID drop was successful */\n\tif (getgid() != pw->pw_gid || getegid() != pw->pw_gid) {\n\t\tfatal(\"%s: egid incorrect gid:%u egid:%u (should be %u)\",\n\t\t    __func__, (u_int)getgid(), (u_int)getegid(),\n\t\t    (u_int)pw->pw_gid);\n\t}\n\n#ifndef NO_UID_RESTORATION_TEST\n\t/* Try restoration of UID if changed (test clearing of saved uid) */\n\tif (old_uid != pw->pw_uid &&\n\t    (setuid(old_uid) != -1 || seteuid(old_uid) != -1))\n\t\tfatal(\"%s: was able to restore old [e]uid\", __func__);\n#endif\n\n\t/* Verify UID drop was successful */\n\tif (getuid() != pw->pw_uid || geteuid() != pw->pw_uid) {\n\t\tfatal(\"%s: euid incorrect uid:%u euid:%u (should be %u)\",\n\t\t    __func__, (u_int)getuid(), (u_int)geteuid(),\n\t\t    (u_int)pw->pw_uid);\n\t}\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttemporarily_use_uid_effective = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\nstatic int\ttemporarily_use_uid_effective = 0;\n\nvoid\npermanently_set_uid(struct passwd *pw)\n{\n#ifndef NO_UID_RESTORATION_TEST\n\tuid_t old_uid = getuid();\n\tgid_t old_gid = getgid();\n#endif\n\n\tif (pw == NULL)\n\t\tfatal(\"permanently_set_uid: no user given\");\n\tif (temporarily_use_uid_effective)\n\t\tfatal(\"permanently_set_uid: temporarily_use_uid effective\");\n\tdebug(\"permanently_set_uid: %u/%u\", (u_int)pw->pw_uid,\n\t    (u_int)pw->pw_gid);\n\n\tif (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) < 0)\n\t\tfatal(\"setresgid %u: %.100s\", (u_int)pw->pw_gid, strerror(errno));\n\n#ifdef __APPLE__\n\t/*\n\t * OS X requires initgroups after setgid to opt back into\n\t * memberd support for >16 supplemental groups.\n\t */\n\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\tfatal(\"initgroups %.100s %u: %.100s\",\n\t\t    pw->pw_name, (u_int)pw->pw_gid, strerror(errno));\n#endif\n\n\tif (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) < 0)\n\t\tfatal(\"setresuid %u: %.100s\", (u_int)pw->pw_uid, strerror(errno));\n\n#ifndef NO_UID_RESTORATION_TEST\n\t/* Try restoration of GID if changed (test clearing of saved gid) */\n\tif (old_gid != pw->pw_gid && pw->pw_uid != 0 &&\n\t    (setgid(old_gid) != -1 || setegid(old_gid) != -1))\n\t\tfatal(\"%s: was able to restore old [e]gid\", __func__);\n#endif\n\n\t/* Verify GID drop was successful */\n\tif (getgid() != pw->pw_gid || getegid() != pw->pw_gid) {\n\t\tfatal(\"%s: egid incorrect gid:%u egid:%u (should be %u)\",\n\t\t    __func__, (u_int)getgid(), (u_int)getegid(),\n\t\t    (u_int)pw->pw_gid);\n\t}\n\n#ifndef NO_UID_RESTORATION_TEST\n\t/* Try restoration of UID if changed (test clearing of saved uid) */\n\tif (old_uid != pw->pw_uid &&\n\t    (setuid(old_uid) != -1 || seteuid(old_uid) != -1))\n\t\tfatal(\"%s: was able to restore old [e]uid\", __func__);\n#endif\n\n\t/* Verify UID drop was successful */\n\tif (getuid() != pw->pw_uid || geteuid() != pw->pw_uid) {\n\t\tfatal(\"%s: euid incorrect uid:%u euid:%u (should be %u)\",\n\t\t    __func__, (u_int)getuid(), (u_int)geteuid(),\n\t\t    (u_int)pw->pw_uid);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwcopy",
          "args": [
            "pw"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "pwcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "302-326",
          "snippet": "struct passwd *\npwcopy(struct passwd *pw)\n{\n\tstruct passwd *copy = xcalloc(1, sizeof(*copy));\n\n\tcopy->pw_name = xstrdup(pw->pw_name);\n\tcopy->pw_passwd = xstrdup(pw->pw_passwd);\n#ifdef HAVE_STRUCT_PASSWD_PW_GECOS\n\tcopy->pw_gecos = xstrdup(pw->pw_gecos);\n#endif\n\tcopy->pw_uid = pw->pw_uid;\n\tcopy->pw_gid = pw->pw_gid;\n#ifdef HAVE_STRUCT_PASSWD_PW_EXPIRE\n\tcopy->pw_expire = pw->pw_expire;\n#endif\n#ifdef HAVE_STRUCT_PASSWD_PW_CHANGE\n\tcopy->pw_change = pw->pw_change;\n#endif\n#ifdef HAVE_STRUCT_PASSWD_PW_CLASS\n\tcopy->pw_class = xstrdup(pw->pw_class);\n#endif\n\tcopy->pw_dir = xstrdup(pw->pw_dir);\n\tcopy->pw_shell = xstrdup(pw->pw_shell);\n\treturn copy;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct passwd *\npwcopy(struct passwd *pw)\n{\n\tstruct passwd *copy = xcalloc(1, sizeof(*copy));\n\n\tcopy->pw_name = xstrdup(pw->pw_name);\n\tcopy->pw_passwd = xstrdup(pw->pw_passwd);\n#ifdef HAVE_STRUCT_PASSWD_PW_GECOS\n\tcopy->pw_gecos = xstrdup(pw->pw_gecos);\n#endif\n\tcopy->pw_uid = pw->pw_uid;\n\tcopy->pw_gid = pw->pw_gid;\n#ifdef HAVE_STRUCT_PASSWD_PW_EXPIRE\n\tcopy->pw_expire = pw->pw_expire;\n#endif\n#ifdef HAVE_STRUCT_PASSWD_PW_CHANGE\n\tcopy->pw_change = pw->pw_change;\n#endif\n#ifdef HAVE_STRUCT_PASSWD_PW_CLASS\n\tcopy->pw_class = xstrdup(pw->pw_class);\n#endif\n\tcopy->pw_dir = xstrdup(pw->pw_dir);\n\tcopy->pw_shell = xstrdup(pw->pw_shell);\n\treturn copy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpwuid",
          "args": [
            "getuid()"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "_PATH_HOST_RSA_KEY_FILE",
            "O_RDONLY"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "process_permitopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "901-909",
          "snippet": "void\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_malloc_init",
          "args": [],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_malloc_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "29-37",
          "snippet": "void\nssh_malloc_init(void)\n{\n#if defined(__OpenBSD__)\n\textern char *malloc_options;\n\n\tmalloc_options = \"S\";\n#endif /* __OpenBSD__ */\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nssh_malloc_init(void)\n{\n#if defined(__OpenBSD__)\n\textern char *malloc_options;\n\n\tmalloc_options = \"S\";\n#endif /* __OpenBSD__ */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"sshkey.h\"\n#include \"uidswap.h\"\n#include \"readconf.h\"\n#include \"pathnames.h\"\n#include \"canohost.h\"\n#include \"msg.h\"\n#include \"authfile.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <paths.h>\n#include <fcntl.h>\n#include \"includes.h\"\n\n#define NUM_KEYTYPES 5\n\nextern char *__progname;\n\nint\nmain(int argc, char **argv)\n{\n\tstruct sshbuf *b;\n\tOptions options;\n#define NUM_KEYTYPES 5\n\tstruct sshkey *keys[NUM_KEYTYPES], *key = NULL;\n\tstruct passwd *pw;\n\tint r, key_fd[NUM_KEYTYPES], i, found, version = 2, fd;\n\tu_char *signature, *data, rver;\n\tchar *host, *fp;\n\tsize_t slen, dlen;\n#ifdef WITH_OPENSSL\n\tu_int32_t rnd[256];\n#endif\n\n\tssh_malloc_init();\t/* must be called before any mallocs */\n\tif (pledge(\"stdio rpath getpw dns id\", NULL) != 0)\n\t\tfatal(\"%s: pledge: %s\", __progname, strerror(errno));\n\n\t/* Ensure that stdin and stdout are connected */\n\tif ((fd = open(_PATH_DEVNULL, O_RDWR)) < 2)\n\t\texit(1);\n\t/* Leave /dev/null fd iff it is attached to stderr */\n\tif (fd > 2)\n\t\tclose(fd);\n\n\ti = 0;\n\t/* XXX This really needs to read sshd_config for the paths */\n\tkey_fd[i++] = open(_PATH_HOST_DSA_KEY_FILE, O_RDONLY);\n\tkey_fd[i++] = open(_PATH_HOST_ECDSA_KEY_FILE, O_RDONLY);\n\tkey_fd[i++] = open(_PATH_HOST_ED25519_KEY_FILE, O_RDONLY);\n\tkey_fd[i++] = open(_PATH_HOST_XMSS_KEY_FILE, O_RDONLY);\n\tkey_fd[i++] = open(_PATH_HOST_RSA_KEY_FILE, O_RDONLY);\n\n\tif ((pw = getpwuid(getuid())) == NULL)\n\t\tfatal(\"getpwuid failed\");\n\tpw = pwcopy(pw);\n\n\tpermanently_set_uid(pw);\n\n\tseed_rng();\n\n#ifdef DEBUG_SSH_KEYSIGN\n\tlog_init(\"ssh-keysign\", SYSLOG_LEVEL_DEBUG3, SYSLOG_FACILITY_AUTH, 0);\n#endif\n\n\t/* verify that ssh-keysign is enabled by the admin */\n\tinitialize_options(&options);\n\t(void)read_config_file(_PATH_HOST_CONFIG_FILE, pw, \"\", \"\", &options, 0);\n\tfill_default_options(&options);\n\tif (options.enable_ssh_keysign != 1)\n\t\tfatal(\"ssh-keysign not enabled in %s\",\n\t\t    _PATH_HOST_CONFIG_FILE);\n\n\tfor (i = found = 0; i < NUM_KEYTYPES; i++) {\n\t\tif (key_fd[i] != -1)\n\t\t\tfound = 1;\n\t}\n\tif (found == 0)\n\t\tfatal(\"could not open any host key\");\n\n#ifdef WITH_OPENSSL\n\tOpenSSL_add_all_algorithms();\n\tarc4random_buf(rnd, sizeof(rnd));\n\tRAND_seed(rnd, sizeof(rnd));\n#endif\n\n\tfound = 0;\n\tfor (i = 0; i < NUM_KEYTYPES; i++) {\n\t\tkeys[i] = NULL;\n\t\tif (key_fd[i] == -1)\n\t\t\tcontinue;\n\t\tr = sshkey_load_private_type_fd(key_fd[i], KEY_UNSPEC,\n\t\t    NULL, &key, NULL);\n\t\tclose(key_fd[i]);\n\t\tif (r != 0)\n\t\t\tdebug(\"parse key %d: %s\", i, ssh_err(r));\n\t\telse if (key != NULL) {\n\t\t\tkeys[i] = key;\n\t\t\tfound = 1;\n\t\t}\n\t}\n\tif (!found)\n\t\tfatal(\"no hostkey found\");\n\n\tif (pledge(\"stdio dns\", NULL) != 0)\n\t\tfatal(\"%s: pledge: %s\", __progname, strerror(errno));\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __progname);\n\tif (ssh_msg_recv(STDIN_FILENO, b) < 0)\n\t\tfatal(\"ssh_msg_recv failed\");\n\tif ((r = sshbuf_get_u8(b, &rver)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __progname, ssh_err(r));\n\tif (rver != version)\n\t\tfatal(\"bad version: received %d, expected %d\", rver, version);\n\tif ((r = sshbuf_get_u32(b, (u_int *)&fd)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __progname, ssh_err(r));\n\tif (fd < 0 || fd == STDIN_FILENO || fd == STDOUT_FILENO)\n\t\tfatal(\"bad fd\");\n\tif ((host = get_local_name(fd)) == NULL)\n\t\tfatal(\"cannot get local name for fd\");\n\n\tif ((r = sshbuf_get_string(b, &data, &dlen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __progname, ssh_err(r));\n\tif (valid_request(pw, host, &key, data, dlen) < 0)\n\t\tfatal(\"not a valid request\");\n\tfree(host);\n\n\tfound = 0;\n\tfor (i = 0; i < NUM_KEYTYPES; i++) {\n\t\tif (keys[i] != NULL &&\n\t\t    sshkey_equal_public(key, keys[i])) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tif ((fp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal(\"%s: sshkey_fingerprint failed\", __progname);\n\t\tfatal(\"no matching hostkey found for key %s %s\",\n\t\t    sshkey_type(key), fp ? fp : \"\");\n\t}\n\n\tif ((r = sshkey_sign(keys[i], &signature, &slen, data, dlen, NULL, 0))\n\t    != 0)\n\t\tfatal(\"sshkey_sign failed: %s\", ssh_err(r));\n\tfree(data);\n\n\t/* send reply */\n\tsshbuf_reset(b);\n\tif ((r = sshbuf_put_string(b, signature, slen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __progname, ssh_err(r));\n\tif (ssh_msg_send(STDOUT_FILENO, version, b) == -1)\n\t\tfatal(\"ssh_msg_send failed\");\n\n\treturn (0);\n}"
  },
  {
    "function_name": "valid_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keysign.c",
    "lines": "66-163",
    "snippet": "static int\nvalid_request(struct passwd *pw, char *host, struct sshkey **ret,\n    u_char *data, size_t datalen)\n{\n\tstruct sshbuf *b;\n\tstruct sshkey *key = NULL;\n\tu_char type, *pkblob;\n\tchar *p;\n\tsize_t blen, len;\n\tchar *pkalg, *luser;\n\tint r, pktype, fail;\n\n\tif (ret != NULL)\n\t\t*ret = NULL;\n\tfail = 0;\n\n\tif ((b = sshbuf_from(data, datalen)) == NULL)\n\t\tfatal(\"%s: sshbuf_from failed\", __func__);\n\n\t/* session id, currently limited to SHA1 (20 bytes) or SHA256 (32) */\n\tif ((r = sshbuf_get_string(b, NULL, &len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (len != 20 && len != 32)\n\t\tfail++;\n\n\tif ((r = sshbuf_get_u8(b, &type)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (type != SSH2_MSG_USERAUTH_REQUEST)\n\t\tfail++;\n\n\t/* server user */\n\tif ((r = sshbuf_skip_string(b)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\t/* service */\n\tif ((r = sshbuf_get_cstring(b, &p, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (strcmp(\"ssh-connection\", p) != 0)\n\t\tfail++;\n\tfree(p);\n\n\t/* method */\n\tif ((r = sshbuf_get_cstring(b, &p, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (strcmp(\"hostbased\", p) != 0)\n\t\tfail++;\n\tfree(p);\n\n\t/* pubkey */\n\tif ((r = sshbuf_get_cstring(b, &pkalg, NULL)) != 0 ||\n\t    (r = sshbuf_get_string(b, &pkblob, &blen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tpktype = sshkey_type_from_name(pkalg);\n\tif (pktype == KEY_UNSPEC)\n\t\tfail++;\n\telse if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {\n\t\terror(\"%s: bad key blob: %s\", __func__, ssh_err(r));\n\t\tfail++;\n\t} else if (key->type != pktype)\n\t\tfail++;\n\tfree(pkalg);\n\tfree(pkblob);\n\n\t/* client host name, handle trailing dot */\n\tif ((r = sshbuf_get_cstring(b, &p, &len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tdebug2(\"%s: check expect chost %s got %s\", __func__, host, p);\n\tif (strlen(host) != len - 1)\n\t\tfail++;\n\telse if (p[len - 1] != '.')\n\t\tfail++;\n\telse if (strncasecmp(host, p, len - 1) != 0)\n\t\tfail++;\n\tfree(p);\n\n\t/* local user */\n\tif ((r = sshbuf_get_cstring(b, &luser, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (strcmp(pw->pw_name, luser) != 0)\n\t\tfail++;\n\tfree(luser);\n\n\t/* end of message */\n\tif (sshbuf_len(b) != 0)\n\t\tfail++;\n\tsshbuf_free(b);\n\n\tdebug3(\"%s: fail %d\", __func__, fail);\n\n\tif (fail)\n\t\tsshkey_free(key);\n\telse if (ret != NULL)\n\t\t*ret = key;\n\n\treturn (fail ? -1 : 0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"sshkey.h\"",
      "#include \"uidswap.h\"",
      "#include \"readconf.h\"",
      "#include \"pathnames.h\"",
      "#include \"canohost.h\"",
      "#include \"msg.h\"",
      "#include \"authfile.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"sshkey.h\"",
      "#include \"log.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rsa.h>",
      "#include <openssl/rand.h>",
      "#include <openssl/evp.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <paths.h>",
      "#include <fcntl.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "key"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: fail %d\"",
            "__func__",
            "fail"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "b"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "luser"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "pw->pw_name",
            "luser"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "b",
            "&luser",
            "NULL"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "host",
            "p",
            "len - 1"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "host"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: check expect chost %s got %s\"",
            "__func__",
            "host",
            "p"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: bad key blob: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_from_blob",
          "args": [
            "pkblob",
            "blen",
            "&key"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2263-2274",
          "snippet": "int\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_from_name",
          "args": [
            "pkalg"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "190-202",
          "snippet": "int\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string",
          "args": [
            "b",
            "&pkblob",
            "&blen"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_skip_string",
          "args": [
            "b"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "b",
            "&type"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_from failed\"",
            "__func__"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_from",
          "args": [
            "data",
            "datalen"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_from",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "87-102",
          "snippet": "struct sshbuf *\nsshbuf_from(const void *blob, size_t len)\n{\n\tstruct sshbuf *ret;\n\n\tif (blob == NULL || len > SSHBUF_SIZE_MAX ||\n\t    (ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = ret->size = ret->max_size = len;\n\tret->readonly = 1;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tret->cd = blob;\n\tret->d = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_from(const void *blob, size_t len)\n{\n\tstruct sshbuf *ret;\n\n\tif (blob == NULL || len > SSHBUF_SIZE_MAX ||\n\t    (ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = ret->size = ret->max_size = len;\n\tret->readonly = 1;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tret->cd = blob;\n\tret->d = NULL;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"sshkey.h\"\n#include \"uidswap.h\"\n#include \"readconf.h\"\n#include \"pathnames.h\"\n#include \"canohost.h\"\n#include \"msg.h\"\n#include \"authfile.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"sshkey.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <paths.h>\n#include <fcntl.h>\n#include \"includes.h\"\n\nstatic int\nvalid_request(struct passwd *pw, char *host, struct sshkey **ret,\n    u_char *data, size_t datalen)\n{\n\tstruct sshbuf *b;\n\tstruct sshkey *key = NULL;\n\tu_char type, *pkblob;\n\tchar *p;\n\tsize_t blen, len;\n\tchar *pkalg, *luser;\n\tint r, pktype, fail;\n\n\tif (ret != NULL)\n\t\t*ret = NULL;\n\tfail = 0;\n\n\tif ((b = sshbuf_from(data, datalen)) == NULL)\n\t\tfatal(\"%s: sshbuf_from failed\", __func__);\n\n\t/* session id, currently limited to SHA1 (20 bytes) or SHA256 (32) */\n\tif ((r = sshbuf_get_string(b, NULL, &len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (len != 20 && len != 32)\n\t\tfail++;\n\n\tif ((r = sshbuf_get_u8(b, &type)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (type != SSH2_MSG_USERAUTH_REQUEST)\n\t\tfail++;\n\n\t/* server user */\n\tif ((r = sshbuf_skip_string(b)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\t/* service */\n\tif ((r = sshbuf_get_cstring(b, &p, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (strcmp(\"ssh-connection\", p) != 0)\n\t\tfail++;\n\tfree(p);\n\n\t/* method */\n\tif ((r = sshbuf_get_cstring(b, &p, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (strcmp(\"hostbased\", p) != 0)\n\t\tfail++;\n\tfree(p);\n\n\t/* pubkey */\n\tif ((r = sshbuf_get_cstring(b, &pkalg, NULL)) != 0 ||\n\t    (r = sshbuf_get_string(b, &pkblob, &blen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tpktype = sshkey_type_from_name(pkalg);\n\tif (pktype == KEY_UNSPEC)\n\t\tfail++;\n\telse if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {\n\t\terror(\"%s: bad key blob: %s\", __func__, ssh_err(r));\n\t\tfail++;\n\t} else if (key->type != pktype)\n\t\tfail++;\n\tfree(pkalg);\n\tfree(pkblob);\n\n\t/* client host name, handle trailing dot */\n\tif ((r = sshbuf_get_cstring(b, &p, &len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tdebug2(\"%s: check expect chost %s got %s\", __func__, host, p);\n\tif (strlen(host) != len - 1)\n\t\tfail++;\n\telse if (p[len - 1] != '.')\n\t\tfail++;\n\telse if (strncasecmp(host, p, len - 1) != 0)\n\t\tfail++;\n\tfree(p);\n\n\t/* local user */\n\tif ((r = sshbuf_get_cstring(b, &luser, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (strcmp(pw->pw_name, luser) != 0)\n\t\tfail++;\n\tfree(luser);\n\n\t/* end of message */\n\tif (sshbuf_len(b) != 0)\n\t\tfail++;\n\tsshbuf_free(b);\n\n\tdebug3(\"%s: fail %d\", __func__, fail);\n\n\tif (fail)\n\t\tsshkey_free(key);\n\telse if (ret != NULL)\n\t\t*ret = key;\n\n\treturn (fail ? -1 : 0);\n}"
  }
]