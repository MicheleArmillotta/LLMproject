[
  {
    "function_name": "fuzz_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
    "lines": "417-437",
    "snippet": "u_char *\nfuzz_ptr(struct fuzz *fuzz)\n{\n\tassert(fuzz->fuzzed != NULL);\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\tcase FUZZ_2_BIT_FLIP:\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_2_BYTE_FLIP:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->fuzzed;\n\tcase FUZZ_TRUNCATE_START:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->fuzzed + fuzz->o1;\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->fuzzed;\n\tdefault:\n\t\tabort();\n\t}\n}",
    "includes": [
      "#include \"atomicio.h\"",
      "#include \"test_helper.h\"",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "# include <stdint.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fuzz->o1 <= fuzz->slen"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fuzz->o1 <= fuzz->slen"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fuzz->fuzzed != NULL"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_char *\nfuzz_ptr(struct fuzz *fuzz)\n{\n\tassert(fuzz->fuzzed != NULL);\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\tcase FUZZ_2_BIT_FLIP:\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_2_BYTE_FLIP:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->fuzzed;\n\tcase FUZZ_TRUNCATE_START:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->fuzzed + fuzz->o1;\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->fuzzed;\n\tdefault:\n\t\tabort();\n\t}\n}"
  },
  {
    "function_name": "fuzz_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
    "lines": "397-415",
    "snippet": "size_t\nfuzz_len(struct fuzz *fuzz)\n{\n\tassert(fuzz->fuzzed != NULL);\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\tcase FUZZ_2_BIT_FLIP:\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_2_BYTE_FLIP:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->slen;\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->slen - fuzz->o1;\n\tdefault:\n\t\tabort();\n\t}\n}",
    "includes": [
      "#include \"atomicio.h\"",
      "#include \"test_helper.h\"",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "# include <stdint.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fuzz->o1 <= fuzz->slen"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fuzz->fuzzed != NULL"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nfuzz_len(struct fuzz *fuzz)\n{\n\tassert(fuzz->fuzzed != NULL);\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\tcase FUZZ_2_BIT_FLIP:\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_2_BYTE_FLIP:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->slen;\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->slen - fuzz->o1;\n\tdefault:\n\t\tabort();\n\t}\n}"
  },
  {
    "function_name": "fuzz_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
    "lines": "388-395",
    "snippet": "int\nfuzz_done(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"fuzz = %p, strategies = 0x%lx\", fuzz,\n\t    (u_long)fuzz->strategies));\n\n\treturn fuzz_strategy_done(fuzz) && fuzz->strategies == 0;\n}",
    "includes": [
      "#include \"atomicio.h\"",
      "#include \"test_helper.h\"",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "# include <stdint.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuzz_strategy_done",
          "args": [
            "fuzz"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_strategy_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "260-281",
          "snippet": "static int\nfuzz_strategy_done(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"fuzz = %p, strategy = %s, o1 = %zu, o2 = %zu, slen = %zu\",\n\t    fuzz, fuzz_ntop(fuzz->strategy), fuzz->o1, fuzz->o2, fuzz->slen));\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\treturn fuzz->o1 >= fuzz->slen * 8;\n\tcase FUZZ_2_BIT_FLIP:\n\t\treturn fuzz->o2 >= fuzz->slen * 8;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\treturn fuzz->o2 >= fuzz->slen;\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->o1 >= fuzz->slen;\n\tdefault:\n\t\tabort();\n\t}\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nfuzz_strategy_done(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"fuzz = %p, strategy = %s, o1 = %zu, o2 = %zu, slen = %zu\",\n\t    fuzz, fuzz_ntop(fuzz->strategy), fuzz->o1, fuzz->o2, fuzz->slen));\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\treturn fuzz->o1 >= fuzz->slen * 8;\n\tcase FUZZ_2_BIT_FLIP:\n\t\treturn fuzz->o2 >= fuzz->slen * 8;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\treturn fuzz->o2 >= fuzz->slen;\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->o1 >= fuzz->slen;\n\tdefault:\n\t\tabort();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUZZ_DBG",
          "args": [
            "(\"fuzz = %p, strategies = 0x%lx\", fuzz,\n\t    (u_long)fuzz->strategies)"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nfuzz_done(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"fuzz = %p, strategies = 0x%lx\", fuzz,\n\t    (u_long)fuzz->strategies));\n\n\treturn fuzz_strategy_done(fuzz) && fuzz->strategies == 0;\n}"
  },
  {
    "function_name": "fuzz_matches_original",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
    "lines": "380-386",
    "snippet": "int\nfuzz_matches_original(struct fuzz *fuzz)\n{\n\tif (fuzz_len(fuzz) != fuzz->slen)\n\t\treturn 0;\n\treturn memcmp(fuzz_ptr(fuzz), fuzz->seed, fuzz->slen) == 0;\n}",
    "includes": [
      "#include \"atomicio.h\"",
      "#include \"test_helper.h\"",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "# include <stdint.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "fuzz_ptr(fuzz)",
            "fuzz->seed",
            "fuzz->slen"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuzz_ptr",
          "args": [
            "fuzz"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "417-437",
          "snippet": "u_char *\nfuzz_ptr(struct fuzz *fuzz)\n{\n\tassert(fuzz->fuzzed != NULL);\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\tcase FUZZ_2_BIT_FLIP:\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_2_BYTE_FLIP:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->fuzzed;\n\tcase FUZZ_TRUNCATE_START:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->fuzzed + fuzz->o1;\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->fuzzed;\n\tdefault:\n\t\tabort();\n\t}\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_char *\nfuzz_ptr(struct fuzz *fuzz)\n{\n\tassert(fuzz->fuzzed != NULL);\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\tcase FUZZ_2_BIT_FLIP:\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_2_BYTE_FLIP:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->fuzzed;\n\tcase FUZZ_TRUNCATE_START:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->fuzzed + fuzz->o1;\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->fuzzed;\n\tdefault:\n\t\tabort();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuzz_len",
          "args": [
            "fuzz"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "397-415",
          "snippet": "size_t\nfuzz_len(struct fuzz *fuzz)\n{\n\tassert(fuzz->fuzzed != NULL);\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\tcase FUZZ_2_BIT_FLIP:\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_2_BYTE_FLIP:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->slen;\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->slen - fuzz->o1;\n\tdefault:\n\t\tabort();\n\t}\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nfuzz_len(struct fuzz *fuzz)\n{\n\tassert(fuzz->fuzzed != NULL);\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\tcase FUZZ_2_BIT_FLIP:\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_2_BYTE_FLIP:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->slen;\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->slen - fuzz->o1;\n\tdefault:\n\t\tabort();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nfuzz_matches_original(struct fuzz *fuzz)\n{\n\tif (fuzz_len(fuzz) != fuzz->slen)\n\t\treturn 0;\n\treturn memcmp(fuzz_ptr(fuzz), fuzz->seed, fuzz->slen) == 0;\n}"
  },
  {
    "function_name": "fuzz_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
    "lines": "283-378",
    "snippet": "void\nfuzz_next(struct fuzz *fuzz)\n{\n\tu_int i;\n\n\tFUZZ_DBG((\"start, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen));\n\n\tif (fuzz->strategy == 0 || fuzz_strategy_done(fuzz)) {\n\t\t/* If we are just starting out, we need to allocate too */\n\t\tif (fuzz->fuzzed == NULL) {\n\t\t\tFUZZ_DBG((\"alloc\"));\n\t\t\tfuzz->fuzzed = calloc(fuzz->slen, 1);\n\t\t}\n\t\t/* Pick next strategy */\n\t\tFUZZ_DBG((\"advance\"));\n\t\tfor (i = 1; i <= FUZZ_MAX; i <<= 1) {\n\t\t\tif ((fuzz->strategies & i) != 0) {\n\t\t\t\tfuzz->strategy = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tFUZZ_DBG((\"selected = %u\", fuzz->strategy));\n\t\tif (fuzz->strategy == 0) {\n\t\t\tFUZZ_DBG((\"done, no more strategies\"));\n\t\t\treturn;\n\t\t}\n\t\tfuzz->strategies &= ~(fuzz->strategy);\n\t\tfuzz->o1 = fuzz->o2 = 0;\n\t}\n\n\tassert(fuzz->fuzzed != NULL);\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\tassert(fuzz->o1 / 8 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1 / 8] ^= 1 << (fuzz->o1 % 8);\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_2_BIT_FLIP:\n\t\tassert(fuzz->o1 / 8 < fuzz->slen);\n\t\tassert(fuzz->o2 / 8 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1 / 8] ^= 1 << (fuzz->o1 % 8);\n\t\tfuzz->fuzzed[fuzz->o2 / 8] ^= 1 << (fuzz->o2 % 8);\n\t\tfuzz->o1++;\n\t\tif (fuzz->o1 >= fuzz->slen * 8) {\n\t\t\tfuzz->o1 = 0;\n\t\t\tfuzz->o2++;\n\t\t}\n\t\tbreak;\n\tcase FUZZ_1_BYTE_FLIP:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] ^= 0xff;\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tassert(fuzz->o2 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] ^= 0xff;\n\t\tfuzz->fuzzed[fuzz->o2] ^= 0xff;\n\t\tfuzz->o1++;\n\t\tif (fuzz->o1 >= fuzz->slen) {\n\t\t\tfuzz->o1 = 0;\n\t\t\tfuzz->o2++;\n\t\t}\n\t\tbreak;\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_BASE64:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tassert(fuzz->o2 < sizeof(fuzz_b64chars) - 1);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] = fuzz_b64chars[fuzz->o2];\n\t\tfuzz->o2++;\n\t\tif (fuzz->o2 >= sizeof(fuzz_b64chars) - 1) {\n\t\t\tfuzz->o2 = 0;\n\t\t\tfuzz->o1++;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t}\n\n\tFUZZ_DBG((\"done, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen));\n}",
    "includes": [
      "#include \"atomicio.h\"",
      "#include \"test_helper.h\"",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "# include <stdint.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char fuzz_b64chars[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FUZZ_DBG",
          "args": [
            "(\"done, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen)"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuzz_ntop",
          "args": [
            "fuzz->strategy"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_ntop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "77-100",
          "snippet": "static const char *\nfuzz_ntop(u_int n)\n{\n\tswitch (n) {\n\tcase 0:\n\t\treturn \"NONE\";\n\tcase FUZZ_1_BIT_FLIP:\n\t\treturn \"FUZZ_1_BIT_FLIP\";\n\tcase FUZZ_2_BIT_FLIP:\n\t\treturn \"FUZZ_2_BIT_FLIP\";\n\tcase FUZZ_1_BYTE_FLIP:\n\t\treturn \"FUZZ_1_BYTE_FLIP\";\n\tcase FUZZ_2_BYTE_FLIP:\n\t\treturn \"FUZZ_2_BYTE_FLIP\";\n\tcase FUZZ_TRUNCATE_START:\n\t\treturn \"FUZZ_TRUNCATE_START\";\n\tcase FUZZ_TRUNCATE_END:\n\t\treturn \"FUZZ_TRUNCATE_END\";\n\tcase FUZZ_BASE64:\n\t\treturn \"FUZZ_BASE64\";\n\tdefault:\n\t\tabort();\n\t}\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfuzz_ntop(u_int n)\n{\n\tswitch (n) {\n\tcase 0:\n\t\treturn \"NONE\";\n\tcase FUZZ_1_BIT_FLIP:\n\t\treturn \"FUZZ_1_BIT_FLIP\";\n\tcase FUZZ_2_BIT_FLIP:\n\t\treturn \"FUZZ_2_BIT_FLIP\";\n\tcase FUZZ_1_BYTE_FLIP:\n\t\treturn \"FUZZ_1_BYTE_FLIP\";\n\tcase FUZZ_2_BYTE_FLIP:\n\t\treturn \"FUZZ_2_BYTE_FLIP\";\n\tcase FUZZ_TRUNCATE_START:\n\t\treturn \"FUZZ_TRUNCATE_START\";\n\tcase FUZZ_TRUNCATE_END:\n\t\treturn \"FUZZ_TRUNCATE_END\";\n\tcase FUZZ_BASE64:\n\t\treturn \"FUZZ_BASE64\";\n\tdefault:\n\t\tabort();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fuzz->fuzzed",
            "fuzz->seed",
            "fuzz->slen"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fuzz->o2 < sizeof(fuzz_b64chars) - 1"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fuzz->o1 < fuzz->slen"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fuzz->fuzzed",
            "fuzz->seed",
            "fuzz->slen"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fuzz->o1 < fuzz->slen"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fuzz->fuzzed",
            "fuzz->seed",
            "fuzz->slen"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fuzz->o2 < fuzz->slen"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fuzz->o1 < fuzz->slen"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fuzz->fuzzed",
            "fuzz->seed",
            "fuzz->slen"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fuzz->o1 < fuzz->slen"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fuzz->fuzzed",
            "fuzz->seed",
            "fuzz->slen"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fuzz->o2 / 8 < fuzz->slen"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fuzz->o1 / 8 < fuzz->slen"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fuzz->fuzzed",
            "fuzz->seed",
            "fuzz->slen"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fuzz->o1 / 8 < fuzz->slen"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fuzz->fuzzed != NULL"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUZZ_DBG",
          "args": [
            "(\"done, no more strategies\")"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUZZ_DBG",
          "args": [
            "(\"selected = %u\", fuzz->strategy)"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUZZ_DBG",
          "args": [
            "(\"advance\")"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "fuzz->slen",
            "1"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUZZ_DBG",
          "args": [
            "(\"alloc\")"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuzz_strategy_done",
          "args": [
            "fuzz"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_strategy_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "260-281",
          "snippet": "static int\nfuzz_strategy_done(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"fuzz = %p, strategy = %s, o1 = %zu, o2 = %zu, slen = %zu\",\n\t    fuzz, fuzz_ntop(fuzz->strategy), fuzz->o1, fuzz->o2, fuzz->slen));\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\treturn fuzz->o1 >= fuzz->slen * 8;\n\tcase FUZZ_2_BIT_FLIP:\n\t\treturn fuzz->o2 >= fuzz->slen * 8;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\treturn fuzz->o2 >= fuzz->slen;\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->o1 >= fuzz->slen;\n\tdefault:\n\t\tabort();\n\t}\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nfuzz_strategy_done(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"fuzz = %p, strategy = %s, o1 = %zu, o2 = %zu, slen = %zu\",\n\t    fuzz, fuzz_ntop(fuzz->strategy), fuzz->o1, fuzz->o2, fuzz->slen));\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\treturn fuzz->o1 >= fuzz->slen * 8;\n\tcase FUZZ_2_BIT_FLIP:\n\t\treturn fuzz->o2 >= fuzz->slen * 8;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\treturn fuzz->o2 >= fuzz->slen;\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->o1 >= fuzz->slen;\n\tdefault:\n\t\tabort();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUZZ_DBG",
          "args": [
            "(\"start, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen)"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char fuzz_b64chars[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nvoid\nfuzz_next(struct fuzz *fuzz)\n{\n\tu_int i;\n\n\tFUZZ_DBG((\"start, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen));\n\n\tif (fuzz->strategy == 0 || fuzz_strategy_done(fuzz)) {\n\t\t/* If we are just starting out, we need to allocate too */\n\t\tif (fuzz->fuzzed == NULL) {\n\t\t\tFUZZ_DBG((\"alloc\"));\n\t\t\tfuzz->fuzzed = calloc(fuzz->slen, 1);\n\t\t}\n\t\t/* Pick next strategy */\n\t\tFUZZ_DBG((\"advance\"));\n\t\tfor (i = 1; i <= FUZZ_MAX; i <<= 1) {\n\t\t\tif ((fuzz->strategies & i) != 0) {\n\t\t\t\tfuzz->strategy = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tFUZZ_DBG((\"selected = %u\", fuzz->strategy));\n\t\tif (fuzz->strategy == 0) {\n\t\t\tFUZZ_DBG((\"done, no more strategies\"));\n\t\t\treturn;\n\t\t}\n\t\tfuzz->strategies &= ~(fuzz->strategy);\n\t\tfuzz->o1 = fuzz->o2 = 0;\n\t}\n\n\tassert(fuzz->fuzzed != NULL);\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\tassert(fuzz->o1 / 8 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1 / 8] ^= 1 << (fuzz->o1 % 8);\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_2_BIT_FLIP:\n\t\tassert(fuzz->o1 / 8 < fuzz->slen);\n\t\tassert(fuzz->o2 / 8 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1 / 8] ^= 1 << (fuzz->o1 % 8);\n\t\tfuzz->fuzzed[fuzz->o2 / 8] ^= 1 << (fuzz->o2 % 8);\n\t\tfuzz->o1++;\n\t\tif (fuzz->o1 >= fuzz->slen * 8) {\n\t\t\tfuzz->o1 = 0;\n\t\t\tfuzz->o2++;\n\t\t}\n\t\tbreak;\n\tcase FUZZ_1_BYTE_FLIP:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] ^= 0xff;\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tassert(fuzz->o2 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] ^= 0xff;\n\t\tfuzz->fuzzed[fuzz->o2] ^= 0xff;\n\t\tfuzz->o1++;\n\t\tif (fuzz->o1 >= fuzz->slen) {\n\t\t\tfuzz->o1 = 0;\n\t\t\tfuzz->o2++;\n\t\t}\n\t\tbreak;\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_BASE64:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tassert(fuzz->o2 < sizeof(fuzz_b64chars) - 1);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] = fuzz_b64chars[fuzz->o2];\n\t\tfuzz->o2++;\n\t\tif (fuzz->o2 >= sizeof(fuzz_b64chars) - 1) {\n\t\t\tfuzz->o2 = 0;\n\t\t\tfuzz->o1++;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t}\n\n\tFUZZ_DBG((\"done, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen));\n}"
  },
  {
    "function_name": "fuzz_strategy_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
    "lines": "260-281",
    "snippet": "static int\nfuzz_strategy_done(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"fuzz = %p, strategy = %s, o1 = %zu, o2 = %zu, slen = %zu\",\n\t    fuzz, fuzz_ntop(fuzz->strategy), fuzz->o1, fuzz->o2, fuzz->slen));\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\treturn fuzz->o1 >= fuzz->slen * 8;\n\tcase FUZZ_2_BIT_FLIP:\n\t\treturn fuzz->o2 >= fuzz->slen * 8;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\treturn fuzz->o2 >= fuzz->slen;\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->o1 >= fuzz->slen;\n\tdefault:\n\t\tabort();\n\t}\n}",
    "includes": [
      "#include \"atomicio.h\"",
      "#include \"test_helper.h\"",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "# include <stdint.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUZZ_DBG",
          "args": [
            "(\"fuzz = %p, strategy = %s, o1 = %zu, o2 = %zu, slen = %zu\",\n\t    fuzz, fuzz_ntop(fuzz->strategy), fuzz->o1, fuzz->o2, fuzz->slen)"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuzz_ntop",
          "args": [
            "fuzz->strategy"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_ntop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "77-100",
          "snippet": "static const char *\nfuzz_ntop(u_int n)\n{\n\tswitch (n) {\n\tcase 0:\n\t\treturn \"NONE\";\n\tcase FUZZ_1_BIT_FLIP:\n\t\treturn \"FUZZ_1_BIT_FLIP\";\n\tcase FUZZ_2_BIT_FLIP:\n\t\treturn \"FUZZ_2_BIT_FLIP\";\n\tcase FUZZ_1_BYTE_FLIP:\n\t\treturn \"FUZZ_1_BYTE_FLIP\";\n\tcase FUZZ_2_BYTE_FLIP:\n\t\treturn \"FUZZ_2_BYTE_FLIP\";\n\tcase FUZZ_TRUNCATE_START:\n\t\treturn \"FUZZ_TRUNCATE_START\";\n\tcase FUZZ_TRUNCATE_END:\n\t\treturn \"FUZZ_TRUNCATE_END\";\n\tcase FUZZ_BASE64:\n\t\treturn \"FUZZ_BASE64\";\n\tdefault:\n\t\tabort();\n\t}\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfuzz_ntop(u_int n)\n{\n\tswitch (n) {\n\tcase 0:\n\t\treturn \"NONE\";\n\tcase FUZZ_1_BIT_FLIP:\n\t\treturn \"FUZZ_1_BIT_FLIP\";\n\tcase FUZZ_2_BIT_FLIP:\n\t\treturn \"FUZZ_2_BIT_FLIP\";\n\tcase FUZZ_1_BYTE_FLIP:\n\t\treturn \"FUZZ_1_BYTE_FLIP\";\n\tcase FUZZ_2_BYTE_FLIP:\n\t\treturn \"FUZZ_2_BYTE_FLIP\";\n\tcase FUZZ_TRUNCATE_START:\n\t\treturn \"FUZZ_TRUNCATE_START\";\n\tcase FUZZ_TRUNCATE_END:\n\t\treturn \"FUZZ_TRUNCATE_END\";\n\tcase FUZZ_BASE64:\n\t\treturn \"FUZZ_BASE64\";\n\tdefault:\n\t\tabort();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nfuzz_strategy_done(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"fuzz = %p, strategy = %s, o1 = %zu, o2 = %zu, slen = %zu\",\n\t    fuzz, fuzz_ntop(fuzz->strategy), fuzz->o1, fuzz->o2, fuzz->slen));\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\treturn fuzz->o1 >= fuzz->slen * 8;\n\tcase FUZZ_2_BIT_FLIP:\n\t\treturn fuzz->o2 >= fuzz->slen * 8;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\treturn fuzz->o2 >= fuzz->slen;\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->o1 >= fuzz->slen;\n\tdefault:\n\t\tabort();\n\t}\n}"
  },
  {
    "function_name": "fuzz_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
    "lines": "243-258",
    "snippet": "void\nfuzz_cleanup(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"cleanup, fuzz = %p\", fuzz));\n\tlast_fuzz = NULL;\n#ifdef SIGINFO\n\tsignal(SIGINFO, SIG_DFL);\n#endif\n\tsignal(SIGUSR1, SIG_DFL);\n\tassert(fuzz != NULL);\n\tassert(fuzz->seed != NULL);\n\tassert(fuzz->fuzzed != NULL);\n\tfree(fuzz->seed);\n\tfree(fuzz->fuzzed);\n\tfree(fuzz);\n}",
    "includes": [
      "#include \"atomicio.h\"",
      "#include \"test_helper.h\"",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "# include <stdint.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fuzz *last_fuzz;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fuzz"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fuzz->fuzzed != NULL"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fuzz->seed != NULL"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fuzz != NULL"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGUSR1",
            "SIG_DFL"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUZZ_DBG",
          "args": [
            "(\"cleanup, fuzz = %p\", fuzz)"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct fuzz *last_fuzz;\n\nvoid\nfuzz_cleanup(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"cleanup, fuzz = %p\", fuzz));\n\tlast_fuzz = NULL;\n#ifdef SIGINFO\n\tsignal(SIGINFO, SIG_DFL);\n#endif\n\tsignal(SIGUSR1, SIG_DFL);\n\tassert(fuzz != NULL);\n\tassert(fuzz->seed != NULL);\n\tassert(fuzz->fuzzed != NULL);\n\tfree(fuzz->seed);\n\tfree(fuzz->fuzzed);\n\tfree(fuzz);\n}"
  },
  {
    "function_name": "fuzz_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
    "lines": "214-241",
    "snippet": "struct fuzz *\nfuzz_begin(u_int strategies, const void *p, size_t l)\n{\n\tstruct fuzz *ret = calloc(sizeof(*ret), 1);\n\n\tassert(p != NULL);\n\tassert(ret != NULL);\n\tret->seed = malloc(l);\n\tassert(ret->seed != NULL);\n\tmemcpy(ret->seed, p, l);\n\tret->slen = l;\n\tret->strategies = strategies;\n\n\tassert(ret->slen < SIZE_MAX / 8);\n\tassert(ret->strategies <= (FUZZ_MAX|(FUZZ_MAX-1)));\n\n\tFUZZ_DBG((\"begin, ret = %p\", ret));\n\n\tfuzz_next(ret);\n\n\tlast_fuzz = ret;\n#ifdef SIGINFO\n\tsignal(SIGINFO, siginfo);\n#endif\n\tsignal(SIGUSR1, siginfo);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"atomicio.h\"",
      "#include \"test_helper.h\"",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "# include <stdint.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fuzz *last_fuzz;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGUSR1",
            "siginfo"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuzz_next",
          "args": [
            "ret"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "283-378",
          "snippet": "void\nfuzz_next(struct fuzz *fuzz)\n{\n\tu_int i;\n\n\tFUZZ_DBG((\"start, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen));\n\n\tif (fuzz->strategy == 0 || fuzz_strategy_done(fuzz)) {\n\t\t/* If we are just starting out, we need to allocate too */\n\t\tif (fuzz->fuzzed == NULL) {\n\t\t\tFUZZ_DBG((\"alloc\"));\n\t\t\tfuzz->fuzzed = calloc(fuzz->slen, 1);\n\t\t}\n\t\t/* Pick next strategy */\n\t\tFUZZ_DBG((\"advance\"));\n\t\tfor (i = 1; i <= FUZZ_MAX; i <<= 1) {\n\t\t\tif ((fuzz->strategies & i) != 0) {\n\t\t\t\tfuzz->strategy = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tFUZZ_DBG((\"selected = %u\", fuzz->strategy));\n\t\tif (fuzz->strategy == 0) {\n\t\t\tFUZZ_DBG((\"done, no more strategies\"));\n\t\t\treturn;\n\t\t}\n\t\tfuzz->strategies &= ~(fuzz->strategy);\n\t\tfuzz->o1 = fuzz->o2 = 0;\n\t}\n\n\tassert(fuzz->fuzzed != NULL);\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\tassert(fuzz->o1 / 8 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1 / 8] ^= 1 << (fuzz->o1 % 8);\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_2_BIT_FLIP:\n\t\tassert(fuzz->o1 / 8 < fuzz->slen);\n\t\tassert(fuzz->o2 / 8 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1 / 8] ^= 1 << (fuzz->o1 % 8);\n\t\tfuzz->fuzzed[fuzz->o2 / 8] ^= 1 << (fuzz->o2 % 8);\n\t\tfuzz->o1++;\n\t\tif (fuzz->o1 >= fuzz->slen * 8) {\n\t\t\tfuzz->o1 = 0;\n\t\t\tfuzz->o2++;\n\t\t}\n\t\tbreak;\n\tcase FUZZ_1_BYTE_FLIP:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] ^= 0xff;\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tassert(fuzz->o2 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] ^= 0xff;\n\t\tfuzz->fuzzed[fuzz->o2] ^= 0xff;\n\t\tfuzz->o1++;\n\t\tif (fuzz->o1 >= fuzz->slen) {\n\t\t\tfuzz->o1 = 0;\n\t\t\tfuzz->o2++;\n\t\t}\n\t\tbreak;\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_BASE64:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tassert(fuzz->o2 < sizeof(fuzz_b64chars) - 1);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] = fuzz_b64chars[fuzz->o2];\n\t\tfuzz->o2++;\n\t\tif (fuzz->o2 >= sizeof(fuzz_b64chars) - 1) {\n\t\t\tfuzz->o2 = 0;\n\t\t\tfuzz->o1++;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t}\n\n\tFUZZ_DBG((\"done, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen));\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char fuzz_b64chars[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char fuzz_b64chars[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nvoid\nfuzz_next(struct fuzz *fuzz)\n{\n\tu_int i;\n\n\tFUZZ_DBG((\"start, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen));\n\n\tif (fuzz->strategy == 0 || fuzz_strategy_done(fuzz)) {\n\t\t/* If we are just starting out, we need to allocate too */\n\t\tif (fuzz->fuzzed == NULL) {\n\t\t\tFUZZ_DBG((\"alloc\"));\n\t\t\tfuzz->fuzzed = calloc(fuzz->slen, 1);\n\t\t}\n\t\t/* Pick next strategy */\n\t\tFUZZ_DBG((\"advance\"));\n\t\tfor (i = 1; i <= FUZZ_MAX; i <<= 1) {\n\t\t\tif ((fuzz->strategies & i) != 0) {\n\t\t\t\tfuzz->strategy = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tFUZZ_DBG((\"selected = %u\", fuzz->strategy));\n\t\tif (fuzz->strategy == 0) {\n\t\t\tFUZZ_DBG((\"done, no more strategies\"));\n\t\t\treturn;\n\t\t}\n\t\tfuzz->strategies &= ~(fuzz->strategy);\n\t\tfuzz->o1 = fuzz->o2 = 0;\n\t}\n\n\tassert(fuzz->fuzzed != NULL);\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\tassert(fuzz->o1 / 8 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1 / 8] ^= 1 << (fuzz->o1 % 8);\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_2_BIT_FLIP:\n\t\tassert(fuzz->o1 / 8 < fuzz->slen);\n\t\tassert(fuzz->o2 / 8 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1 / 8] ^= 1 << (fuzz->o1 % 8);\n\t\tfuzz->fuzzed[fuzz->o2 / 8] ^= 1 << (fuzz->o2 % 8);\n\t\tfuzz->o1++;\n\t\tif (fuzz->o1 >= fuzz->slen * 8) {\n\t\t\tfuzz->o1 = 0;\n\t\t\tfuzz->o2++;\n\t\t}\n\t\tbreak;\n\tcase FUZZ_1_BYTE_FLIP:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] ^= 0xff;\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tassert(fuzz->o2 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] ^= 0xff;\n\t\tfuzz->fuzzed[fuzz->o2] ^= 0xff;\n\t\tfuzz->o1++;\n\t\tif (fuzz->o1 >= fuzz->slen) {\n\t\t\tfuzz->o1 = 0;\n\t\t\tfuzz->o2++;\n\t\t}\n\t\tbreak;\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_BASE64:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tassert(fuzz->o2 < sizeof(fuzz_b64chars) - 1);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] = fuzz_b64chars[fuzz->o2];\n\t\tfuzz->o2++;\n\t\tif (fuzz->o2 >= sizeof(fuzz_b64chars) - 1) {\n\t\t\tfuzz->o2 = 0;\n\t\t\tfuzz->o1++;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t}\n\n\tFUZZ_DBG((\"done, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen));\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUZZ_DBG",
          "args": [
            "(\"begin, ret = %p\", ret)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ret->strategies <= (FUZZ_MAX|(FUZZ_MAX-1))"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ret->slen < SIZE_MAX / 8"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ret->seed",
            "p",
            "l"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ret->seed != NULL"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "l"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ret != NULL"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "p != NULL"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "sizeof(*ret)",
            "1"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct fuzz *last_fuzz;\n\nstruct fuzz *\nfuzz_begin(u_int strategies, const void *p, size_t l)\n{\n\tstruct fuzz *ret = calloc(sizeof(*ret), 1);\n\n\tassert(p != NULL);\n\tassert(ret != NULL);\n\tret->seed = malloc(l);\n\tassert(ret->seed != NULL);\n\tmemcpy(ret->seed, p, l);\n\tret->slen = l;\n\tret->strategies = strategies;\n\n\tassert(ret->slen < SIZE_MAX / 8);\n\tassert(ret->strategies <= (FUZZ_MAX|(FUZZ_MAX-1)));\n\n\tFUZZ_DBG((\"begin, ret = %p\", ret));\n\n\tfuzz_next(ret);\n\n\tlast_fuzz = ret;\n#ifdef SIGINFO\n\tsignal(SIGINFO, siginfo);\n#endif\n\tsignal(SIGUSR1, siginfo);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "siginfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
    "lines": "201-212",
    "snippet": "static void\nsiginfo(int unused __attribute__((__unused__)))\n{\n\tchar buf[256];\n\n\ttest_info(buf, sizeof(buf));\n\tatomicio(vwrite, STDERR_FILENO, buf, strlen(buf));\n\tif (last_fuzz != NULL) {\n\t\tfuzz_fmt(last_fuzz, buf, sizeof(buf));\n\t\tatomicio(vwrite, STDERR_FILENO, buf, strlen(buf));\n\t}\n}",
    "includes": [
      "#include \"atomicio.h\"",
      "#include \"test_helper.h\"",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "# include <stdint.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fuzz *last_fuzz;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomicio",
          "args": [
            "vwrite",
            "STDERR_FILENO",
            "buf",
            "strlen(buf)"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "atomiciov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "165-170",
          "snippet": "size_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuzz_fmt",
          "args": [
            "last_fuzz",
            "buf",
            "sizeof(buf)"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "102-155",
          "snippet": "static int\nfuzz_fmt(struct fuzz *fuzz, char *s, size_t n)\n{\n\tif (fuzz == NULL)\n\t\treturn -1;\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (bit: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen * 8, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_2_BIT_FLIP:\n\t\tsnprintf(s, n, \"%s case %llu of %llu (bits: %zu, %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    (((fuzz_ullong)fuzz->o2) * fuzz->slen * 8) + fuzz->o1,\n\t\t    ((fuzz_ullong)fuzz->slen * 8) * fuzz->slen * 8,\n\t\t    fuzz->o1, fuzz->o2);\n\t\treturn 0;\n\tcase FUZZ_1_BYTE_FLIP:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (byte: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\tsnprintf(s, n, \"%s case %llu of %llu (bytes: %zu, %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    (((fuzz_ullong)fuzz->o2) * fuzz->slen) + fuzz->o1,\n\t\t    ((fuzz_ullong)fuzz->slen) * fuzz->slen,\n\t\t    fuzz->o1, fuzz->o2);\n\t\treturn 0;\n\tcase FUZZ_TRUNCATE_START:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (offset: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_TRUNCATE_END:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (offset: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_BASE64:\n\t\tassert(fuzz->o2 < sizeof(fuzz_b64chars) - 1);\n\t\tsnprintf(s, n, \"%s case %llu of %llu (offset: %zu char: %c)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    (fuzz->o1 * (fuzz_ullong)64) + fuzz->o2,\n\t\t    fuzz->slen * (fuzz_ullong)64, fuzz->o1,\n\t\t    fuzz_b64chars[fuzz->o2]);\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t\tabort();\n\t}\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char fuzz_b64chars[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char fuzz_b64chars[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nstatic int\nfuzz_fmt(struct fuzz *fuzz, char *s, size_t n)\n{\n\tif (fuzz == NULL)\n\t\treturn -1;\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (bit: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen * 8, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_2_BIT_FLIP:\n\t\tsnprintf(s, n, \"%s case %llu of %llu (bits: %zu, %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    (((fuzz_ullong)fuzz->o2) * fuzz->slen * 8) + fuzz->o1,\n\t\t    ((fuzz_ullong)fuzz->slen * 8) * fuzz->slen * 8,\n\t\t    fuzz->o1, fuzz->o2);\n\t\treturn 0;\n\tcase FUZZ_1_BYTE_FLIP:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (byte: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\tsnprintf(s, n, \"%s case %llu of %llu (bytes: %zu, %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    (((fuzz_ullong)fuzz->o2) * fuzz->slen) + fuzz->o1,\n\t\t    ((fuzz_ullong)fuzz->slen) * fuzz->slen,\n\t\t    fuzz->o1, fuzz->o2);\n\t\treturn 0;\n\tcase FUZZ_TRUNCATE_START:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (offset: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_TRUNCATE_END:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (offset: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_BASE64:\n\t\tassert(fuzz->o2 < sizeof(fuzz_b64chars) - 1);\n\t\tsnprintf(s, n, \"%s case %llu of %llu (offset: %zu char: %c)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    (fuzz->o1 * (fuzz_ullong)64) + fuzz->o2,\n\t\t    fuzz->slen * (fuzz_ullong)64, fuzz->o1,\n\t\t    fuzz_b64chars[fuzz->o2]);\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t\tabort();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_info",
          "args": [
            "buf",
            "sizeof(buf)"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "test_subtest_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/test_helper.c",
          "lines": "252-260",
          "snippet": "void\ntest_subtest_info(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvsnprintf(subtest_info, sizeof(subtest_info), fmt, ap);\n\tva_end(ap);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "# include <vis.h>",
            "#include <openssl/bn.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char subtest_info[512];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n# include <vis.h>\n#include <openssl/bn.h>\n#include <signal.h>\n#include <unistd.h>\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char subtest_info[512];\n\nvoid\ntest_subtest_info(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvsnprintf(subtest_info, sizeof(subtest_info), fmt, ap);\n\tva_end(ap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct fuzz *last_fuzz;\n\nstatic void\nsiginfo(int unused __attribute__((__unused__)))\n{\n\tchar buf[256];\n\n\ttest_info(buf, sizeof(buf));\n\tatomicio(vwrite, STDERR_FILENO, buf, strlen(buf));\n\tif (last_fuzz != NULL) {\n\t\tfuzz_fmt(last_fuzz, buf, sizeof(buf));\n\t\tatomicio(vwrite, STDERR_FILENO, buf, strlen(buf));\n\t}\n}"
  },
  {
    "function_name": "fuzz_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
    "lines": "183-197",
    "snippet": "void\nfuzz_dump(struct fuzz *fuzz)\n{\n\tchar buf[256];\n\n\tif (fuzz_fmt(fuzz, buf, sizeof(buf)) != 0) {\n\t\tfprintf(stderr, \"%s: fuzz invalid\\n\", __func__);\n\t\tabort();\n\t}\n\tfputs(buf, stderr);\n\tfprintf(stderr, \"fuzz original %p len = %zu\\n\", fuzz->seed, fuzz->slen);\n\tdump(fuzz->seed, fuzz->slen);\n\tfprintf(stderr, \"fuzz context %p len = %zu\\n\", fuzz, fuzz_len(fuzz));\n\tdump(fuzz_ptr(fuzz), fuzz_len(fuzz));\n}",
    "includes": [
      "#include \"atomicio.h\"",
      "#include \"test_helper.h\"",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "# include <stdint.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump",
          "args": [
            "fuzz_ptr(fuzz)",
            "fuzz_len(fuzz)"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "157-181",
          "snippet": "static void\ndump(u_char *p, size_t len)\n{\n\tsize_t i, j;\n\n\tfor (i = 0; i < len; i += 16) {\n\t\tfprintf(stderr, \"%.4zd: \", i);\n\t\tfor (j = i; j < i + 16; j++) {\n\t\t\tif (j < len)\n\t\t\t\tfprintf(stderr, \"%02x \", p[j]);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"   \");\n\t\t}\n\t\tfprintf(stderr, \" \");\n\t\tfor (j = i; j < i + 16; j++) {\n\t\t\tif (j < len) {\n\t\t\t\tif  (isascii(p[j]) && isprint(p[j]))\n\t\t\t\t\tfprintf(stderr, \"%c\", p[j]);\n\t\t\t\telse\n\t\t\t\t\tfprintf(stderr, \".\");\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndump(u_char *p, size_t len)\n{\n\tsize_t i, j;\n\n\tfor (i = 0; i < len; i += 16) {\n\t\tfprintf(stderr, \"%.4zd: \", i);\n\t\tfor (j = i; j < i + 16; j++) {\n\t\t\tif (j < len)\n\t\t\t\tfprintf(stderr, \"%02x \", p[j]);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"   \");\n\t\t}\n\t\tfprintf(stderr, \" \");\n\t\tfor (j = i; j < i + 16; j++) {\n\t\t\tif (j < len) {\n\t\t\t\tif  (isascii(p[j]) && isprint(p[j]))\n\t\t\t\t\tfprintf(stderr, \"%c\", p[j]);\n\t\t\t\telse\n\t\t\t\t\tfprintf(stderr, \".\");\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuzz_len",
          "args": [
            "fuzz"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "397-415",
          "snippet": "size_t\nfuzz_len(struct fuzz *fuzz)\n{\n\tassert(fuzz->fuzzed != NULL);\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\tcase FUZZ_2_BIT_FLIP:\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_2_BYTE_FLIP:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->slen;\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->slen - fuzz->o1;\n\tdefault:\n\t\tabort();\n\t}\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nfuzz_len(struct fuzz *fuzz)\n{\n\tassert(fuzz->fuzzed != NULL);\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\tcase FUZZ_2_BIT_FLIP:\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_2_BYTE_FLIP:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->slen;\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->slen - fuzz->o1;\n\tdefault:\n\t\tabort();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuzz_ptr",
          "args": [
            "fuzz"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "417-437",
          "snippet": "u_char *\nfuzz_ptr(struct fuzz *fuzz)\n{\n\tassert(fuzz->fuzzed != NULL);\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\tcase FUZZ_2_BIT_FLIP:\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_2_BYTE_FLIP:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->fuzzed;\n\tcase FUZZ_TRUNCATE_START:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->fuzzed + fuzz->o1;\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->fuzzed;\n\tdefault:\n\t\tabort();\n\t}\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_char *\nfuzz_ptr(struct fuzz *fuzz)\n{\n\tassert(fuzz->fuzzed != NULL);\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\tcase FUZZ_2_BIT_FLIP:\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_2_BYTE_FLIP:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->fuzzed;\n\tcase FUZZ_TRUNCATE_START:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->fuzzed + fuzz->o1;\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->fuzzed;\n\tdefault:\n\t\tabort();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"fuzz context %p len = %zu\\n\"",
            "fuzz",
            "fuzz_len(fuzz)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"fuzz original %p len = %zu\\n\"",
            "fuzz->seed",
            "fuzz->slen"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fputs",
          "args": [
            "buf",
            "stderr"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: fuzz invalid\\n\"",
            "__func__"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuzz_fmt",
          "args": [
            "fuzz",
            "buf",
            "sizeof(buf)"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "102-155",
          "snippet": "static int\nfuzz_fmt(struct fuzz *fuzz, char *s, size_t n)\n{\n\tif (fuzz == NULL)\n\t\treturn -1;\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (bit: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen * 8, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_2_BIT_FLIP:\n\t\tsnprintf(s, n, \"%s case %llu of %llu (bits: %zu, %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    (((fuzz_ullong)fuzz->o2) * fuzz->slen * 8) + fuzz->o1,\n\t\t    ((fuzz_ullong)fuzz->slen * 8) * fuzz->slen * 8,\n\t\t    fuzz->o1, fuzz->o2);\n\t\treturn 0;\n\tcase FUZZ_1_BYTE_FLIP:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (byte: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\tsnprintf(s, n, \"%s case %llu of %llu (bytes: %zu, %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    (((fuzz_ullong)fuzz->o2) * fuzz->slen) + fuzz->o1,\n\t\t    ((fuzz_ullong)fuzz->slen) * fuzz->slen,\n\t\t    fuzz->o1, fuzz->o2);\n\t\treturn 0;\n\tcase FUZZ_TRUNCATE_START:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (offset: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_TRUNCATE_END:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (offset: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_BASE64:\n\t\tassert(fuzz->o2 < sizeof(fuzz_b64chars) - 1);\n\t\tsnprintf(s, n, \"%s case %llu of %llu (offset: %zu char: %c)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    (fuzz->o1 * (fuzz_ullong)64) + fuzz->o2,\n\t\t    fuzz->slen * (fuzz_ullong)64, fuzz->o1,\n\t\t    fuzz_b64chars[fuzz->o2]);\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t\tabort();\n\t}\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char fuzz_b64chars[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char fuzz_b64chars[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nstatic int\nfuzz_fmt(struct fuzz *fuzz, char *s, size_t n)\n{\n\tif (fuzz == NULL)\n\t\treturn -1;\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (bit: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen * 8, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_2_BIT_FLIP:\n\t\tsnprintf(s, n, \"%s case %llu of %llu (bits: %zu, %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    (((fuzz_ullong)fuzz->o2) * fuzz->slen * 8) + fuzz->o1,\n\t\t    ((fuzz_ullong)fuzz->slen * 8) * fuzz->slen * 8,\n\t\t    fuzz->o1, fuzz->o2);\n\t\treturn 0;\n\tcase FUZZ_1_BYTE_FLIP:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (byte: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\tsnprintf(s, n, \"%s case %llu of %llu (bytes: %zu, %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    (((fuzz_ullong)fuzz->o2) * fuzz->slen) + fuzz->o1,\n\t\t    ((fuzz_ullong)fuzz->slen) * fuzz->slen,\n\t\t    fuzz->o1, fuzz->o2);\n\t\treturn 0;\n\tcase FUZZ_TRUNCATE_START:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (offset: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_TRUNCATE_END:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (offset: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_BASE64:\n\t\tassert(fuzz->o2 < sizeof(fuzz_b64chars) - 1);\n\t\tsnprintf(s, n, \"%s case %llu of %llu (offset: %zu char: %c)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    (fuzz->o1 * (fuzz_ullong)64) + fuzz->o2,\n\t\t    fuzz->slen * (fuzz_ullong)64, fuzz->o1,\n\t\t    fuzz_b64chars[fuzz->o2]);\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t\tabort();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfuzz_dump(struct fuzz *fuzz)\n{\n\tchar buf[256];\n\n\tif (fuzz_fmt(fuzz, buf, sizeof(buf)) != 0) {\n\t\tfprintf(stderr, \"%s: fuzz invalid\\n\", __func__);\n\t\tabort();\n\t}\n\tfputs(buf, stderr);\n\tfprintf(stderr, \"fuzz original %p len = %zu\\n\", fuzz->seed, fuzz->slen);\n\tdump(fuzz->seed, fuzz->slen);\n\tfprintf(stderr, \"fuzz context %p len = %zu\\n\", fuzz, fuzz_len(fuzz));\n\tdump(fuzz_ptr(fuzz), fuzz_len(fuzz));\n}"
  },
  {
    "function_name": "dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
    "lines": "157-181",
    "snippet": "static void\ndump(u_char *p, size_t len)\n{\n\tsize_t i, j;\n\n\tfor (i = 0; i < len; i += 16) {\n\t\tfprintf(stderr, \"%.4zd: \", i);\n\t\tfor (j = i; j < i + 16; j++) {\n\t\t\tif (j < len)\n\t\t\t\tfprintf(stderr, \"%02x \", p[j]);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"   \");\n\t\t}\n\t\tfprintf(stderr, \" \");\n\t\tfor (j = i; j < i + 16; j++) {\n\t\t\tif (j < len) {\n\t\t\t\tif  (isascii(p[j]) && isprint(p[j]))\n\t\t\t\t\tfprintf(stderr, \"%c\", p[j]);\n\t\t\t\telse\n\t\t\t\t\tfprintf(stderr, \".\");\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}",
    "includes": [
      "#include \"atomicio.h\"",
      "#include \"test_helper.h\"",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "# include <stdint.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\".\""
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%c\"",
            "p[j]"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isprint",
          "args": [
            "p[j]"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isascii",
          "args": [
            "p[j]"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" \""
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   \""
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%02x \"",
            "p[j]"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%.4zd: \"",
            "i"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndump(u_char *p, size_t len)\n{\n\tsize_t i, j;\n\n\tfor (i = 0; i < len; i += 16) {\n\t\tfprintf(stderr, \"%.4zd: \", i);\n\t\tfor (j = i; j < i + 16; j++) {\n\t\t\tif (j < len)\n\t\t\t\tfprintf(stderr, \"%02x \", p[j]);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"   \");\n\t\t}\n\t\tfprintf(stderr, \" \");\n\t\tfor (j = i; j < i + 16; j++) {\n\t\t\tif (j < len) {\n\t\t\t\tif  (isascii(p[j]) && isprint(p[j]))\n\t\t\t\t\tfprintf(stderr, \"%c\", p[j]);\n\t\t\t\telse\n\t\t\t\t\tfprintf(stderr, \".\");\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}"
  },
  {
    "function_name": "fuzz_fmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
    "lines": "102-155",
    "snippet": "static int\nfuzz_fmt(struct fuzz *fuzz, char *s, size_t n)\n{\n\tif (fuzz == NULL)\n\t\treturn -1;\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (bit: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen * 8, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_2_BIT_FLIP:\n\t\tsnprintf(s, n, \"%s case %llu of %llu (bits: %zu, %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    (((fuzz_ullong)fuzz->o2) * fuzz->slen * 8) + fuzz->o1,\n\t\t    ((fuzz_ullong)fuzz->slen * 8) * fuzz->slen * 8,\n\t\t    fuzz->o1, fuzz->o2);\n\t\treturn 0;\n\tcase FUZZ_1_BYTE_FLIP:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (byte: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\tsnprintf(s, n, \"%s case %llu of %llu (bytes: %zu, %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    (((fuzz_ullong)fuzz->o2) * fuzz->slen) + fuzz->o1,\n\t\t    ((fuzz_ullong)fuzz->slen) * fuzz->slen,\n\t\t    fuzz->o1, fuzz->o2);\n\t\treturn 0;\n\tcase FUZZ_TRUNCATE_START:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (offset: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_TRUNCATE_END:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (offset: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_BASE64:\n\t\tassert(fuzz->o2 < sizeof(fuzz_b64chars) - 1);\n\t\tsnprintf(s, n, \"%s case %llu of %llu (offset: %zu char: %c)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    (fuzz->o1 * (fuzz_ullong)64) + fuzz->o2,\n\t\t    fuzz->slen * (fuzz_ullong)64, fuzz->o1,\n\t\t    fuzz_b64chars[fuzz->o2]);\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t\tabort();\n\t}\n}",
    "includes": [
      "#include \"atomicio.h\"",
      "#include \"test_helper.h\"",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "# include <stdint.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char fuzz_b64chars[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "s",
            "n",
            "\"%s case %llu of %llu (offset: %zu char: %c)\\n\"",
            "fuzz_ntop(fuzz->strategy)",
            "(fuzz->o1 * (fuzz_ullong)64) + fuzz->o2",
            "fuzz->slen * (fuzz_ullong)64",
            "fuzz->o1",
            "fuzz_b64chars[fuzz->o2]"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuzz_ntop",
          "args": [
            "fuzz->strategy"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_ntop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "77-100",
          "snippet": "static const char *\nfuzz_ntop(u_int n)\n{\n\tswitch (n) {\n\tcase 0:\n\t\treturn \"NONE\";\n\tcase FUZZ_1_BIT_FLIP:\n\t\treturn \"FUZZ_1_BIT_FLIP\";\n\tcase FUZZ_2_BIT_FLIP:\n\t\treturn \"FUZZ_2_BIT_FLIP\";\n\tcase FUZZ_1_BYTE_FLIP:\n\t\treturn \"FUZZ_1_BYTE_FLIP\";\n\tcase FUZZ_2_BYTE_FLIP:\n\t\treturn \"FUZZ_2_BYTE_FLIP\";\n\tcase FUZZ_TRUNCATE_START:\n\t\treturn \"FUZZ_TRUNCATE_START\";\n\tcase FUZZ_TRUNCATE_END:\n\t\treturn \"FUZZ_TRUNCATE_END\";\n\tcase FUZZ_BASE64:\n\t\treturn \"FUZZ_BASE64\";\n\tdefault:\n\t\tabort();\n\t}\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfuzz_ntop(u_int n)\n{\n\tswitch (n) {\n\tcase 0:\n\t\treturn \"NONE\";\n\tcase FUZZ_1_BIT_FLIP:\n\t\treturn \"FUZZ_1_BIT_FLIP\";\n\tcase FUZZ_2_BIT_FLIP:\n\t\treturn \"FUZZ_2_BIT_FLIP\";\n\tcase FUZZ_1_BYTE_FLIP:\n\t\treturn \"FUZZ_1_BYTE_FLIP\";\n\tcase FUZZ_2_BYTE_FLIP:\n\t\treturn \"FUZZ_2_BYTE_FLIP\";\n\tcase FUZZ_TRUNCATE_START:\n\t\treturn \"FUZZ_TRUNCATE_START\";\n\tcase FUZZ_TRUNCATE_END:\n\t\treturn \"FUZZ_TRUNCATE_END\";\n\tcase FUZZ_BASE64:\n\t\treturn \"FUZZ_BASE64\";\n\tdefault:\n\t\tabort();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fuzz->o2 < sizeof(fuzz_b64chars) - 1"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char fuzz_b64chars[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nstatic int\nfuzz_fmt(struct fuzz *fuzz, char *s, size_t n)\n{\n\tif (fuzz == NULL)\n\t\treturn -1;\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (bit: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen * 8, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_2_BIT_FLIP:\n\t\tsnprintf(s, n, \"%s case %llu of %llu (bits: %zu, %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    (((fuzz_ullong)fuzz->o2) * fuzz->slen * 8) + fuzz->o1,\n\t\t    ((fuzz_ullong)fuzz->slen * 8) * fuzz->slen * 8,\n\t\t    fuzz->o1, fuzz->o2);\n\t\treturn 0;\n\tcase FUZZ_1_BYTE_FLIP:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (byte: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\tsnprintf(s, n, \"%s case %llu of %llu (bytes: %zu, %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    (((fuzz_ullong)fuzz->o2) * fuzz->slen) + fuzz->o1,\n\t\t    ((fuzz_ullong)fuzz->slen) * fuzz->slen,\n\t\t    fuzz->o1, fuzz->o2);\n\t\treturn 0;\n\tcase FUZZ_TRUNCATE_START:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (offset: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_TRUNCATE_END:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (offset: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_BASE64:\n\t\tassert(fuzz->o2 < sizeof(fuzz_b64chars) - 1);\n\t\tsnprintf(s, n, \"%s case %llu of %llu (offset: %zu char: %c)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    (fuzz->o1 * (fuzz_ullong)64) + fuzz->o2,\n\t\t    fuzz->slen * (fuzz_ullong)64, fuzz->o1,\n\t\t    fuzz_b64chars[fuzz->o2]);\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t\tabort();\n\t}\n}"
  },
  {
    "function_name": "fuzz_ntop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
    "lines": "77-100",
    "snippet": "static const char *\nfuzz_ntop(u_int n)\n{\n\tswitch (n) {\n\tcase 0:\n\t\treturn \"NONE\";\n\tcase FUZZ_1_BIT_FLIP:\n\t\treturn \"FUZZ_1_BIT_FLIP\";\n\tcase FUZZ_2_BIT_FLIP:\n\t\treturn \"FUZZ_2_BIT_FLIP\";\n\tcase FUZZ_1_BYTE_FLIP:\n\t\treturn \"FUZZ_1_BYTE_FLIP\";\n\tcase FUZZ_2_BYTE_FLIP:\n\t\treturn \"FUZZ_2_BYTE_FLIP\";\n\tcase FUZZ_TRUNCATE_START:\n\t\treturn \"FUZZ_TRUNCATE_START\";\n\tcase FUZZ_TRUNCATE_END:\n\t\treturn \"FUZZ_TRUNCATE_END\";\n\tcase FUZZ_BASE64:\n\t\treturn \"FUZZ_BASE64\";\n\tdefault:\n\t\tabort();\n\t}\n}",
    "includes": [
      "#include \"atomicio.h\"",
      "#include \"test_helper.h\"",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "# include <stdint.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <assert.h>",
      "#include <sys/uio.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfuzz_ntop(u_int n)\n{\n\tswitch (n) {\n\tcase 0:\n\t\treturn \"NONE\";\n\tcase FUZZ_1_BIT_FLIP:\n\t\treturn \"FUZZ_1_BIT_FLIP\";\n\tcase FUZZ_2_BIT_FLIP:\n\t\treturn \"FUZZ_2_BIT_FLIP\";\n\tcase FUZZ_1_BYTE_FLIP:\n\t\treturn \"FUZZ_1_BYTE_FLIP\";\n\tcase FUZZ_2_BYTE_FLIP:\n\t\treturn \"FUZZ_2_BYTE_FLIP\";\n\tcase FUZZ_TRUNCATE_START:\n\t\treturn \"FUZZ_TRUNCATE_START\";\n\tcase FUZZ_TRUNCATE_END:\n\t\treturn \"FUZZ_TRUNCATE_END\";\n\tcase FUZZ_BASE64:\n\t\treturn \"FUZZ_BASE64\";\n\tdefault:\n\t\tabort();\n\t}\n}"
  }
]