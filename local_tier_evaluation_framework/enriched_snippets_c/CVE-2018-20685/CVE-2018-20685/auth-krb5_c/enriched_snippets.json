[
  {
    "function_name": "ssh_krb5_cc_gen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-krb5.c",
    "lines": "241-270",
    "snippet": "krb5_error_code\nssh_krb5_cc_gen(krb5_context ctx, krb5_ccache *ccache) {\n\tint tmpfd, ret, oerrno;\n\tchar ccname[40];\n\tmode_t old_umask;\n\n\tret = snprintf(ccname, sizeof(ccname),\n\t    \"FILE:/tmp/krb5cc_%d_XXXXXXXXXX\", geteuid());\n\tif (ret < 0 || (size_t)ret >= sizeof(ccname))\n\t\treturn ENOMEM;\n\n\told_umask = umask(0177);\n\ttmpfd = mkstemp(ccname + strlen(\"FILE:\"));\n\toerrno = errno;\n\tumask(old_umask);\n\tif (tmpfd == -1) {\n\t\tlogit(\"mkstemp(): %.100s\", strerror(oerrno));\n\t\treturn oerrno;\n\t}\n\n\tif (fchmod(tmpfd,S_IRUSR | S_IWUSR) == -1) {\n\t\toerrno = errno;\n\t\tlogit(\"fchmod(): %.100s\", strerror(oerrno));\n\t\tclose(tmpfd);\n\t\treturn oerrno;\n\t}\n\tclose(tmpfd);\n\n\treturn (krb5_cc_resolve(ctx, ccname, ccache));\n}",
    "includes": [
      "#include <krb5.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_cc_resolve",
          "args": [
            "ctx",
            "ccname",
            "ccache"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "tmpfd"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"fchmod(): %.100s\"",
            "strerror(oerrno)"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "oerrno"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fchmod",
          "args": [
            "tmpfd",
            "S_IRUSR | S_IWUSR"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "old_umask"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "ccname + strlen(\"FILE:\")"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "mkstemp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/mktemp.c",
          "lines": "120-124",
          "snippet": "int\nmkstemp(char *path)\n{\n\treturn(mktemp_internal(path, 0, MKTEMP_FILE));\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MKTEMP_FILE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MKTEMP_FILE\t1\n\nint\nmkstemp(char *path)\n{\n\treturn(mktemp_internal(path, 0, MKTEMP_FILE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"FILE:\""
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "0177"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ccname",
            "sizeof(ccname)",
            "\"FILE:/tmp/krb5cc_%d_XXXXXXXXXX\"",
            "geteuid()"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <krb5.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nkrb5_error_code\nssh_krb5_cc_gen(krb5_context ctx, krb5_ccache *ccache) {\n\tint tmpfd, ret, oerrno;\n\tchar ccname[40];\n\tmode_t old_umask;\n\n\tret = snprintf(ccname, sizeof(ccname),\n\t    \"FILE:/tmp/krb5cc_%d_XXXXXXXXXX\", geteuid());\n\tif (ret < 0 || (size_t)ret >= sizeof(ccname))\n\t\treturn ENOMEM;\n\n\told_umask = umask(0177);\n\ttmpfd = mkstemp(ccname + strlen(\"FILE:\"));\n\toerrno = errno;\n\tumask(old_umask);\n\tif (tmpfd == -1) {\n\t\tlogit(\"mkstemp(): %.100s\", strerror(oerrno));\n\t\treturn oerrno;\n\t}\n\n\tif (fchmod(tmpfd,S_IRUSR | S_IWUSR) == -1) {\n\t\toerrno = errno;\n\t\tlogit(\"fchmod(): %.100s\", strerror(oerrno));\n\t\tclose(tmpfd);\n\t\treturn oerrno;\n\t}\n\tclose(tmpfd);\n\n\treturn (krb5_cc_resolve(ctx, ccname, ccache));\n}"
  },
  {
    "function_name": "krb5_cleanup_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-krb5.c",
    "lines": "222-238",
    "snippet": "void\nkrb5_cleanup_proc(Authctxt *authctxt)\n{\n\tdebug(\"krb5_cleanup_proc called\");\n\tif (authctxt->krb5_fwd_ccache) {\n\t\tkrb5_cc_destroy(authctxt->krb5_ctx, authctxt->krb5_fwd_ccache);\n\t\tauthctxt->krb5_fwd_ccache = NULL;\n\t}\n\tif (authctxt->krb5_user) {\n\t\tkrb5_free_principal(authctxt->krb5_ctx, authctxt->krb5_user);\n\t\tauthctxt->krb5_user = NULL;\n\t}\n\tif (authctxt->krb5_ctx) {\n\t\tkrb5_free_context(authctxt->krb5_ctx);\n\t\tauthctxt->krb5_ctx = NULL;\n\t}\n}",
    "includes": [
      "#include <krb5.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_free_context",
          "args": [
            "authctxt->krb5_ctx"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_principal",
          "args": [
            "authctxt->krb5_ctx",
            "authctxt->krb5_user"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_cc_destroy",
          "args": [
            "authctxt->krb5_ctx",
            "authctxt->krb5_fwd_ccache"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"krb5_cleanup_proc called\""
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <krb5.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nkrb5_cleanup_proc(Authctxt *authctxt)\n{\n\tdebug(\"krb5_cleanup_proc called\");\n\tif (authctxt->krb5_fwd_ccache) {\n\t\tkrb5_cc_destroy(authctxt->krb5_ctx, authctxt->krb5_fwd_ccache);\n\t\tauthctxt->krb5_fwd_ccache = NULL;\n\t}\n\tif (authctxt->krb5_user) {\n\t\tkrb5_free_principal(authctxt->krb5_ctx, authctxt->krb5_user);\n\t\tauthctxt->krb5_user = NULL;\n\t}\n\tif (authctxt->krb5_ctx) {\n\t\tkrb5_free_context(authctxt->krb5_ctx);\n\t\tauthctxt->krb5_ctx = NULL;\n\t}\n}"
  },
  {
    "function_name": "auth_krb5_password",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-krb5.c",
    "lines": "71-220",
    "snippet": "int\nauth_krb5_password(Authctxt *authctxt, const char *password)\n{\n#ifndef HEIMDAL\n\tkrb5_creds creds;\n\tkrb5_principal server;\n#endif\n\tkrb5_error_code problem;\n\tkrb5_ccache ccache = NULL;\n\tint len;\n\tchar *client, *platform_client;\n\tconst char *errmsg;\n\n\t/* get platform-specific kerberos client principal name (if it exists) */\n\tplatform_client = platform_krb5_get_principal_name(authctxt->pw->pw_name);\n\tclient = platform_client ? platform_client : authctxt->pw->pw_name;\n\n\ttemporarily_use_uid(authctxt->pw);\n\n\tproblem = krb5_init(authctxt);\n\tif (problem)\n\t\tgoto out;\n\n\tproblem = krb5_parse_name(authctxt->krb5_ctx, client,\n\t\t    &authctxt->krb5_user);\n\tif (problem)\n\t\tgoto out;\n\n#ifdef HEIMDAL\n# ifdef HAVE_KRB5_CC_NEW_UNIQUE\n\tproblem = krb5_cc_new_unique(authctxt->krb5_ctx,\n\t     krb5_mcc_ops.prefix, NULL, &ccache);\n# else\n\tproblem = krb5_cc_gen_new(authctxt->krb5_ctx, &krb5_mcc_ops, &ccache);\n# endif\n\tif (problem)\n\t\tgoto out;\n\n\tproblem = krb5_cc_initialize(authctxt->krb5_ctx, ccache,\n\t\tauthctxt->krb5_user);\n\tif (problem)\n\t\tgoto out;\n\n\trestore_uid();\n\n\tproblem = krb5_verify_user(authctxt->krb5_ctx, authctxt->krb5_user,\n\t    ccache, password, 1, NULL);\n\n\ttemporarily_use_uid(authctxt->pw);\n\n\tif (problem)\n\t\tgoto out;\n\n# ifdef HAVE_KRB5_CC_NEW_UNIQUE\n\tproblem = krb5_cc_new_unique(authctxt->krb5_ctx,\n\t     krb5_fcc_ops.prefix, NULL, &authctxt->krb5_fwd_ccache);\n# else\n\tproblem = krb5_cc_gen_new(authctxt->krb5_ctx, &krb5_fcc_ops,\n\t    &authctxt->krb5_fwd_ccache);\n# endif\n\tif (problem)\n\t\tgoto out;\n\n\tproblem = krb5_cc_copy_cache(authctxt->krb5_ctx, ccache,\n\t    authctxt->krb5_fwd_ccache);\n\tkrb5_cc_destroy(authctxt->krb5_ctx, ccache);\n\tccache = NULL;\n\tif (problem)\n\t\tgoto out;\n\n#else\n\tproblem = krb5_get_init_creds_password(authctxt->krb5_ctx, &creds,\n\t    authctxt->krb5_user, (char *)password, NULL, NULL, 0, NULL, NULL);\n\tif (problem)\n\t\tgoto out;\n\n\tproblem = krb5_sname_to_principal(authctxt->krb5_ctx, NULL, NULL,\n\t    KRB5_NT_SRV_HST, &server);\n\tif (problem)\n\t\tgoto out;\n\n\trestore_uid();\n\tproblem = krb5_verify_init_creds(authctxt->krb5_ctx, &creds, server,\n\t    NULL, NULL, NULL);\n\tkrb5_free_principal(authctxt->krb5_ctx, server);\n\ttemporarily_use_uid(authctxt->pw);\n\tif (problem)\n\t\tgoto out;\n\n\tif (!krb5_kuserok(authctxt->krb5_ctx, authctxt->krb5_user,\n\t    authctxt->pw->pw_name)) {\n\t\tproblem = -1;\n\t\tgoto out;\n\t}\n\n\tproblem = ssh_krb5_cc_gen(authctxt->krb5_ctx, &authctxt->krb5_fwd_ccache);\n\tif (problem)\n\t\tgoto out;\n\n\tproblem = krb5_cc_initialize(authctxt->krb5_ctx, authctxt->krb5_fwd_ccache,\n\t\t\t\t     authctxt->krb5_user);\n\tif (problem)\n\t\tgoto out;\n\n\tproblem= krb5_cc_store_cred(authctxt->krb5_ctx, authctxt->krb5_fwd_ccache,\n\t\t\t\t &creds);\n\tif (problem)\n\t\tgoto out;\n#endif\n\n\tauthctxt->krb5_ticket_file = (char *)krb5_cc_get_name(authctxt->krb5_ctx, authctxt->krb5_fwd_ccache);\n\n\tlen = strlen(authctxt->krb5_ticket_file) + 6;\n\tauthctxt->krb5_ccname = xmalloc(len);\n\tsnprintf(authctxt->krb5_ccname, len, \"FILE:%s\",\n\t    authctxt->krb5_ticket_file);\n\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\tdo_pam_putenv(\"KRB5CCNAME\", authctxt->krb5_ccname);\n#endif\n\n out:\n\trestore_uid();\n\t\n\tfree(platform_client);\n\n\tif (problem) {\n\t\tif (ccache)\n\t\t\tkrb5_cc_destroy(authctxt->krb5_ctx, ccache);\n\n\t\tif (authctxt->krb5_ctx != NULL && problem!=-1) {\n\t\t\terrmsg = krb5_get_error_message(authctxt->krb5_ctx,\n\t\t\t    problem);\n \t\t\tdebug(\"Kerberos password authentication failed: %s\",\n\t\t\t    errmsg);\n\t\t\tkrb5_free_error_message(authctxt->krb5_ctx, errmsg);\n\t\t} else\n\t\t\tdebug(\"Kerberos password authentication failed: %d\",\n\t\t\t    problem);\n\n\t\tkrb5_cleanup_proc(authctxt);\n\n\t\tif (options.kerberos_or_local_passwd)\n\t\t\treturn (-1);\n\t\telse\n\t\t\treturn (0);\n\t}\n\treturn (authctxt->valid ? 1 : 0);\n}",
    "includes": [
      "#include <krb5.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_cleanup_proc",
          "args": [
            "authctxt"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "krb5_cleanup_proc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-krb5.c",
          "lines": "222-238",
          "snippet": "void\nkrb5_cleanup_proc(Authctxt *authctxt)\n{\n\tdebug(\"krb5_cleanup_proc called\");\n\tif (authctxt->krb5_fwd_ccache) {\n\t\tkrb5_cc_destroy(authctxt->krb5_ctx, authctxt->krb5_fwd_ccache);\n\t\tauthctxt->krb5_fwd_ccache = NULL;\n\t}\n\tif (authctxt->krb5_user) {\n\t\tkrb5_free_principal(authctxt->krb5_ctx, authctxt->krb5_user);\n\t\tauthctxt->krb5_user = NULL;\n\t}\n\tif (authctxt->krb5_ctx) {\n\t\tkrb5_free_context(authctxt->krb5_ctx);\n\t\tauthctxt->krb5_ctx = NULL;\n\t}\n}",
          "includes": [
            "#include <krb5.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <krb5.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nkrb5_cleanup_proc(Authctxt *authctxt)\n{\n\tdebug(\"krb5_cleanup_proc called\");\n\tif (authctxt->krb5_fwd_ccache) {\n\t\tkrb5_cc_destroy(authctxt->krb5_ctx, authctxt->krb5_fwd_ccache);\n\t\tauthctxt->krb5_fwd_ccache = NULL;\n\t}\n\tif (authctxt->krb5_user) {\n\t\tkrb5_free_principal(authctxt->krb5_ctx, authctxt->krb5_user);\n\t\tauthctxt->krb5_user = NULL;\n\t}\n\tif (authctxt->krb5_ctx) {\n\t\tkrb5_free_context(authctxt->krb5_ctx);\n\t\tauthctxt->krb5_ctx = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Kerberos password authentication failed: %d\"",
            "problem"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_free_error_message",
          "args": [
            "authctxt->krb5_ctx",
            "errmsg"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_get_error_message",
          "args": [
            "authctxt->krb5_ctx",
            "problem"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_cc_destroy",
          "args": [
            "authctxt->krb5_ctx",
            "ccache"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "platform_client"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_uid",
          "args": [],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "restore_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "141-172",
          "snippet": "void\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_pam_putenv",
          "args": [
            "\"KRB5CCNAME\"",
            "authctxt->krb5_ccname"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "do_pam_putenv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "1178-1195",
          "snippet": "int\ndo_pam_putenv(char *name, char *value)\n{\n\tint ret = 1;\n#ifdef HAVE_PAM_PUTENV\n\tchar *compound;\n\tsize_t len;\n\n\tlen = strlen(name) + strlen(value) + 2;\n\tcompound = xmalloc(len);\n\n\tsnprintf(compound, len, \"%s=%s\", name, value);\n\tret = pam_putenv(sshpam_handle, compound);\n\tfree(compound);\n#endif\n\n\treturn (ret);\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_pam_putenv(char *name, char *value)\n{\n\tint ret = 1;\n#ifdef HAVE_PAM_PUTENV\n\tchar *compound;\n\tsize_t len;\n\n\tlen = strlen(name) + strlen(value) + 2;\n\tcompound = xmalloc(len);\n\n\tsnprintf(compound, len, \"%s=%s\", name, value);\n\tret = pam_putenv(sshpam_handle, compound);\n\tfree(compound);\n#endif\n\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "authctxt->krb5_ccname",
            "len",
            "\"FILE:%s\"",
            "authctxt->krb5_ticket_file"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "len"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "authctxt->krb5_ticket_file"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_cc_get_name",
          "args": [
            "authctxt->krb5_ctx",
            "authctxt->krb5_fwd_ccache"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_cc_store_cred",
          "args": [
            "authctxt->krb5_ctx",
            "authctxt->krb5_fwd_ccache",
            "&creds"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_cc_initialize",
          "args": [
            "authctxt->krb5_ctx",
            "authctxt->krb5_fwd_ccache",
            "authctxt->krb5_user"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_krb5_cc_gen",
          "args": [
            "authctxt->krb5_ctx",
            "&authctxt->krb5_fwd_ccache"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_krb5_cc_gen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-krb5.c",
          "lines": "241-270",
          "snippet": "krb5_error_code\nssh_krb5_cc_gen(krb5_context ctx, krb5_ccache *ccache) {\n\tint tmpfd, ret, oerrno;\n\tchar ccname[40];\n\tmode_t old_umask;\n\n\tret = snprintf(ccname, sizeof(ccname),\n\t    \"FILE:/tmp/krb5cc_%d_XXXXXXXXXX\", geteuid());\n\tif (ret < 0 || (size_t)ret >= sizeof(ccname))\n\t\treturn ENOMEM;\n\n\told_umask = umask(0177);\n\ttmpfd = mkstemp(ccname + strlen(\"FILE:\"));\n\toerrno = errno;\n\tumask(old_umask);\n\tif (tmpfd == -1) {\n\t\tlogit(\"mkstemp(): %.100s\", strerror(oerrno));\n\t\treturn oerrno;\n\t}\n\n\tif (fchmod(tmpfd,S_IRUSR | S_IWUSR) == -1) {\n\t\toerrno = errno;\n\t\tlogit(\"fchmod(): %.100s\", strerror(oerrno));\n\t\tclose(tmpfd);\n\t\treturn oerrno;\n\t}\n\tclose(tmpfd);\n\n\treturn (krb5_cc_resolve(ctx, ccname, ccache));\n}",
          "includes": [
            "#include <krb5.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <krb5.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nkrb5_error_code\nssh_krb5_cc_gen(krb5_context ctx, krb5_ccache *ccache) {\n\tint tmpfd, ret, oerrno;\n\tchar ccname[40];\n\tmode_t old_umask;\n\n\tret = snprintf(ccname, sizeof(ccname),\n\t    \"FILE:/tmp/krb5cc_%d_XXXXXXXXXX\", geteuid());\n\tif (ret < 0 || (size_t)ret >= sizeof(ccname))\n\t\treturn ENOMEM;\n\n\told_umask = umask(0177);\n\ttmpfd = mkstemp(ccname + strlen(\"FILE:\"));\n\toerrno = errno;\n\tumask(old_umask);\n\tif (tmpfd == -1) {\n\t\tlogit(\"mkstemp(): %.100s\", strerror(oerrno));\n\t\treturn oerrno;\n\t}\n\n\tif (fchmod(tmpfd,S_IRUSR | S_IWUSR) == -1) {\n\t\toerrno = errno;\n\t\tlogit(\"fchmod(): %.100s\", strerror(oerrno));\n\t\tclose(tmpfd);\n\t\treturn oerrno;\n\t}\n\tclose(tmpfd);\n\n\treturn (krb5_cc_resolve(ctx, ccname, ccache));\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_kuserok",
          "args": [
            "authctxt->krb5_ctx",
            "authctxt->krb5_user",
            "authctxt->pw->pw_name"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "temporarily_use_uid",
          "args": [
            "authctxt->pw"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "temporarily_use_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "60-136",
          "snippet": "void\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static uid_t\tuser_groups_uid;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic uid_t\tuser_groups_uid;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_free_principal",
          "args": [
            "authctxt->krb5_ctx",
            "server"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_verify_init_creds",
          "args": [
            "authctxt->krb5_ctx",
            "&creds",
            "server",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_sname_to_principal",
          "args": [
            "authctxt->krb5_ctx",
            "NULL",
            "NULL",
            "KRB5_NT_SRV_HST",
            "&server"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_get_init_creds_password",
          "args": [
            "authctxt->krb5_ctx",
            "&creds",
            "authctxt->krb5_user",
            "(char *)password",
            "NULL",
            "NULL",
            "0",
            "NULL",
            "NULL"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_cc_destroy",
          "args": [
            "authctxt->krb5_ctx",
            "ccache"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_cc_copy_cache",
          "args": [
            "authctxt->krb5_ctx",
            "ccache",
            "authctxt->krb5_fwd_ccache"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_cc_gen_new",
          "args": [
            "authctxt->krb5_ctx",
            "&krb5_fcc_ops",
            "&authctxt->krb5_fwd_ccache"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_cc_new_unique",
          "args": [
            "authctxt->krb5_ctx",
            "krb5_fcc_ops.prefix",
            "NULL",
            "&authctxt->krb5_fwd_ccache"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_verify_user",
          "args": [
            "authctxt->krb5_ctx",
            "authctxt->krb5_user",
            "ccache",
            "password",
            "1",
            "NULL"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_cc_initialize",
          "args": [
            "authctxt->krb5_ctx",
            "ccache",
            "authctxt->krb5_user"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_cc_gen_new",
          "args": [
            "authctxt->krb5_ctx",
            "&krb5_mcc_ops",
            "&ccache"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_cc_new_unique",
          "args": [
            "authctxt->krb5_ctx",
            "krb5_mcc_ops.prefix",
            "NULL",
            "&ccache"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_parse_name",
          "args": [
            "authctxt->krb5_ctx",
            "client",
            "&authctxt->krb5_user"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_init",
          "args": [
            "authctxt"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "krb5_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-krb5.c",
          "lines": "57-69",
          "snippet": "static int\nkrb5_init(void *context)\n{\n\tAuthctxt *authctxt = (Authctxt *)context;\n\tkrb5_error_code problem;\n\n\tif (authctxt->krb5_ctx == NULL) {\n\t\tproblem = krb5_init_context(&authctxt->krb5_ctx);\n\t\tif (problem)\n\t\t\treturn (problem);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <krb5.h>",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <krb5.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nkrb5_init(void *context)\n{\n\tAuthctxt *authctxt = (Authctxt *)context;\n\tkrb5_error_code problem;\n\n\tif (authctxt->krb5_ctx == NULL) {\n\t\tproblem = krb5_init_context(&authctxt->krb5_ctx);\n\t\tif (problem)\n\t\t\treturn (problem);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "platform_krb5_get_principal_name",
          "args": [
            "authctxt->pw->pw_name"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "platform_krb5_get_principal_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
          "lines": "190-198",
          "snippet": "char *\nplatform_krb5_get_principal_name(const char *pw_name)\n{\n#ifdef USE_AIX_KRB_NAME\n\treturn aix_krb5_get_principal_name(pw_name);\n#else\n\treturn NULL;\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nplatform_krb5_get_principal_name(const char *pw_name)\n{\n#ifdef USE_AIX_KRB_NAME\n\treturn aix_krb5_get_principal_name(pw_name);\n#else\n\treturn NULL;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <krb5.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nauth_krb5_password(Authctxt *authctxt, const char *password)\n{\n#ifndef HEIMDAL\n\tkrb5_creds creds;\n\tkrb5_principal server;\n#endif\n\tkrb5_error_code problem;\n\tkrb5_ccache ccache = NULL;\n\tint len;\n\tchar *client, *platform_client;\n\tconst char *errmsg;\n\n\t/* get platform-specific kerberos client principal name (if it exists) */\n\tplatform_client = platform_krb5_get_principal_name(authctxt->pw->pw_name);\n\tclient = platform_client ? platform_client : authctxt->pw->pw_name;\n\n\ttemporarily_use_uid(authctxt->pw);\n\n\tproblem = krb5_init(authctxt);\n\tif (problem)\n\t\tgoto out;\n\n\tproblem = krb5_parse_name(authctxt->krb5_ctx, client,\n\t\t    &authctxt->krb5_user);\n\tif (problem)\n\t\tgoto out;\n\n#ifdef HEIMDAL\n# ifdef HAVE_KRB5_CC_NEW_UNIQUE\n\tproblem = krb5_cc_new_unique(authctxt->krb5_ctx,\n\t     krb5_mcc_ops.prefix, NULL, &ccache);\n# else\n\tproblem = krb5_cc_gen_new(authctxt->krb5_ctx, &krb5_mcc_ops, &ccache);\n# endif\n\tif (problem)\n\t\tgoto out;\n\n\tproblem = krb5_cc_initialize(authctxt->krb5_ctx, ccache,\n\t\tauthctxt->krb5_user);\n\tif (problem)\n\t\tgoto out;\n\n\trestore_uid();\n\n\tproblem = krb5_verify_user(authctxt->krb5_ctx, authctxt->krb5_user,\n\t    ccache, password, 1, NULL);\n\n\ttemporarily_use_uid(authctxt->pw);\n\n\tif (problem)\n\t\tgoto out;\n\n# ifdef HAVE_KRB5_CC_NEW_UNIQUE\n\tproblem = krb5_cc_new_unique(authctxt->krb5_ctx,\n\t     krb5_fcc_ops.prefix, NULL, &authctxt->krb5_fwd_ccache);\n# else\n\tproblem = krb5_cc_gen_new(authctxt->krb5_ctx, &krb5_fcc_ops,\n\t    &authctxt->krb5_fwd_ccache);\n# endif\n\tif (problem)\n\t\tgoto out;\n\n\tproblem = krb5_cc_copy_cache(authctxt->krb5_ctx, ccache,\n\t    authctxt->krb5_fwd_ccache);\n\tkrb5_cc_destroy(authctxt->krb5_ctx, ccache);\n\tccache = NULL;\n\tif (problem)\n\t\tgoto out;\n\n#else\n\tproblem = krb5_get_init_creds_password(authctxt->krb5_ctx, &creds,\n\t    authctxt->krb5_user, (char *)password, NULL, NULL, 0, NULL, NULL);\n\tif (problem)\n\t\tgoto out;\n\n\tproblem = krb5_sname_to_principal(authctxt->krb5_ctx, NULL, NULL,\n\t    KRB5_NT_SRV_HST, &server);\n\tif (problem)\n\t\tgoto out;\n\n\trestore_uid();\n\tproblem = krb5_verify_init_creds(authctxt->krb5_ctx, &creds, server,\n\t    NULL, NULL, NULL);\n\tkrb5_free_principal(authctxt->krb5_ctx, server);\n\ttemporarily_use_uid(authctxt->pw);\n\tif (problem)\n\t\tgoto out;\n\n\tif (!krb5_kuserok(authctxt->krb5_ctx, authctxt->krb5_user,\n\t    authctxt->pw->pw_name)) {\n\t\tproblem = -1;\n\t\tgoto out;\n\t}\n\n\tproblem = ssh_krb5_cc_gen(authctxt->krb5_ctx, &authctxt->krb5_fwd_ccache);\n\tif (problem)\n\t\tgoto out;\n\n\tproblem = krb5_cc_initialize(authctxt->krb5_ctx, authctxt->krb5_fwd_ccache,\n\t\t\t\t     authctxt->krb5_user);\n\tif (problem)\n\t\tgoto out;\n\n\tproblem= krb5_cc_store_cred(authctxt->krb5_ctx, authctxt->krb5_fwd_ccache,\n\t\t\t\t &creds);\n\tif (problem)\n\t\tgoto out;\n#endif\n\n\tauthctxt->krb5_ticket_file = (char *)krb5_cc_get_name(authctxt->krb5_ctx, authctxt->krb5_fwd_ccache);\n\n\tlen = strlen(authctxt->krb5_ticket_file) + 6;\n\tauthctxt->krb5_ccname = xmalloc(len);\n\tsnprintf(authctxt->krb5_ccname, len, \"FILE:%s\",\n\t    authctxt->krb5_ticket_file);\n\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\tdo_pam_putenv(\"KRB5CCNAME\", authctxt->krb5_ccname);\n#endif\n\n out:\n\trestore_uid();\n\t\n\tfree(platform_client);\n\n\tif (problem) {\n\t\tif (ccache)\n\t\t\tkrb5_cc_destroy(authctxt->krb5_ctx, ccache);\n\n\t\tif (authctxt->krb5_ctx != NULL && problem!=-1) {\n\t\t\terrmsg = krb5_get_error_message(authctxt->krb5_ctx,\n\t\t\t    problem);\n \t\t\tdebug(\"Kerberos password authentication failed: %s\",\n\t\t\t    errmsg);\n\t\t\tkrb5_free_error_message(authctxt->krb5_ctx, errmsg);\n\t\t} else\n\t\t\tdebug(\"Kerberos password authentication failed: %d\",\n\t\t\t    problem);\n\n\t\tkrb5_cleanup_proc(authctxt);\n\n\t\tif (options.kerberos_or_local_passwd)\n\t\t\treturn (-1);\n\t\telse\n\t\t\treturn (0);\n\t}\n\treturn (authctxt->valid ? 1 : 0);\n}"
  },
  {
    "function_name": "krb5_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-krb5.c",
    "lines": "57-69",
    "snippet": "static int\nkrb5_init(void *context)\n{\n\tAuthctxt *authctxt = (Authctxt *)context;\n\tkrb5_error_code problem;\n\n\tif (authctxt->krb5_ctx == NULL) {\n\t\tproblem = krb5_init_context(&authctxt->krb5_ctx);\n\t\tif (problem)\n\t\t\treturn (problem);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <krb5.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_init_context",
          "args": [
            "&authctxt->krb5_ctx"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <krb5.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nkrb5_init(void *context)\n{\n\tAuthctxt *authctxt = (Authctxt *)context;\n\tkrb5_error_code problem;\n\n\tif (authctxt->krb5_ctx == NULL) {\n\t\tproblem = krb5_init_context(&authctxt->krb5_ctx);\n\t\tif (problem)\n\t\t\treturn (problem);\n\t}\n\treturn (0);\n}"
  }
]