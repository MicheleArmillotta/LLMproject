[
  {
    "function_name": "path_append",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "1906-1919",
    "snippet": "char *\npath_append(const char *p1, const char *p2)\n{\n\tchar *ret;\n\tsize_t len = strlen(p1) + strlen(p2) + 2;\n\n\tret = xmalloc(len);\n\tstrlcpy(ret, p1, len);\n\tif (p1[0] != '\\0' && p1[strlen(p1) - 1] != '/')\n\t\tstrlcat(ret, \"/\", len);\n\tstrlcat(ret, p2, len);\n\n\treturn(ret);\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcat",
          "args": [
            "ret",
            "p2",
            "len"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "strlcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcat.c",
          "lines": "34-60",
          "snippet": "size_t\nstrlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p1"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "ret",
            "p1",
            "len"
          ],
          "line": 1913
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "len"
          ],
          "line": 1912
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p2"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p1"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\npath_append(const char *p1, const char *p2)\n{\n\tchar *ret;\n\tsize_t len = strlen(p1) + strlen(p2) + 2;\n\n\tret = xmalloc(len);\n\tstrlcpy(ret, p1, len);\n\tif (p1[0] != '\\0' && p1[strlen(p1) - 1] != '/')\n\t\tstrlcat(ret, \"/\", len);\n\tstrlcat(ret, p2, len);\n\n\treturn(ret);\n}"
  },
  {
    "function_name": "upload_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "1887-1904",
    "snippet": "int\nupload_dir(struct sftp_conn *conn, const char *src, const char *dst,\n    int preserve_flag, int print_flag, int resume, int fsync_flag)\n{\n\tchar *dst_canon;\n\tint ret;\n\n\tif ((dst_canon = do_realpath(conn, dst)) == NULL) {\n\t\terror(\"Unable to canonicalize path \\\"%s\\\"\", dst);\n\t\treturn -1;\n\t}\n\n\tret = upload_dir_internal(conn, src, dst_canon, 0, preserve_flag,\n\t    print_flag, resume, fsync_flag);\n\n\tfree(dst_canon);\n\treturn ret;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dst_canon"
          ],
          "line": 1902
        },
        "resolved": true,
        "details": {
          "function_name": "free_sftp_dirents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "681-693",
          "snippet": "void free_sftp_dirents(SFTP_DIRENT **s)\n{\n\tint i;\n\n\tif (s == NULL)\n\t\treturn;\n\tfor (i = 0; s[i]; i++) {\n\t\tfree(s[i]->filename);\n\t\tfree(s[i]->longname);\n\t\tfree(s[i]);\n\t}\n\tfree(s);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid free_sftp_dirents(SFTP_DIRENT **s)\n{\n\tint i;\n\n\tif (s == NULL)\n\t\treturn;\n\tfor (i = 0; s[i]; i++) {\n\t\tfree(s[i]->filename);\n\t\tfree(s[i]->longname);\n\t\tfree(s[i]);\n\t}\n\tfree(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "upload_dir_internal",
          "args": [
            "conn",
            "src",
            "dst_canon",
            "0",
            "preserve_flag",
            "print_flag",
            "resume",
            "fsync_flag"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "upload_dir_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "1791-1885",
          "snippet": "static int\nupload_dir_internal(struct sftp_conn *conn, const char *src, const char *dst,\n    int depth, int preserve_flag, int print_flag, int resume, int fsync_flag)\n{\n\tint ret = 0;\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *filename, *new_src = NULL, *new_dst = NULL;\n\tstruct stat sb;\n\tAttrib a, *dirattrib;\n\n\tif (depth >= MAX_DIR_DEPTH) {\n\t\terror(\"Maximum directory depth exceeded: %d levels\", depth);\n\t\treturn -1;\n\t}\n\n\tif (stat(src, &sb) == -1) {\n\t\terror(\"Couldn't stat directory \\\"%s\\\": %s\",\n\t\t    src, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (!S_ISDIR(sb.st_mode)) {\n\t\terror(\"\\\"%s\\\" is not a directory\", src);\n\t\treturn -1;\n\t}\n\tif (print_flag)\n\t\tmprintf(\"Entering %s\\n\", src);\n\n\tattrib_clear(&a);\n\tstat_to_attrib(&sb, &a);\n\ta.flags &= ~SSH2_FILEXFER_ATTR_SIZE;\n\ta.flags &= ~SSH2_FILEXFER_ATTR_UIDGID;\n\ta.perm &= 01777;\n\tif (!preserve_flag)\n\t\ta.flags &= ~SSH2_FILEXFER_ATTR_ACMODTIME;\n\n\t/*\n\t * sftp lacks a portable status value to match errno EEXIST,\n\t * so if we get a failure back then we must check whether\n\t * the path already existed and is a directory.\n\t */\n\tif (do_mkdir(conn, dst, &a, 0) != 0) {\n\t\tif ((dirattrib = do_stat(conn, dst, 0)) == NULL)\n\t\t\treturn -1;\n\t\tif (!S_ISDIR(dirattrib->perm)) {\n\t\t\terror(\"\\\"%s\\\" exists but is not a directory\", dst);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ((dirp = opendir(src)) == NULL) {\n\t\terror(\"Failed to open dir \\\"%s\\\": %s\", src, strerror(errno));\n\t\treturn -1;\n\t}\n\n\twhile (((dp = readdir(dirp)) != NULL) && !interrupted) {\n\t\tif (dp->d_ino == 0)\n\t\t\tcontinue;\n\t\tfree(new_dst);\n\t\tfree(new_src);\n\t\tfilename = dp->d_name;\n\t\tnew_dst = path_append(dst, filename);\n\t\tnew_src = path_append(src, filename);\n\n\t\tif (lstat(new_src, &sb) == -1) {\n\t\t\tlogit(\"%s: lstat failed: %s\", filename,\n\t\t\t    strerror(errno));\n\t\t\tret = -1;\n\t\t} else if (S_ISDIR(sb.st_mode)) {\n\t\t\tif (strcmp(filename, \".\") == 0 ||\n\t\t\t    strcmp(filename, \"..\") == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (upload_dir_internal(conn, new_src, new_dst,\n\t\t\t    depth + 1, preserve_flag, print_flag, resume,\n\t\t\t    fsync_flag) == -1)\n\t\t\t\tret = -1;\n\t\t} else if (S_ISREG(sb.st_mode)) {\n\t\t\tif (do_upload(conn, new_src, new_dst,\n\t\t\t    preserve_flag, resume, fsync_flag) == -1) {\n\t\t\t\terror(\"Uploading of file %s to %s failed!\",\n\t\t\t\t    new_src, new_dst);\n\t\t\t\tret = -1;\n\t\t\t}\n\t\t} else\n\t\t\tlogit(\"%s: not a regular file\\n\", filename);\n\t}\n\tfree(new_dst);\n\tfree(new_src);\n\n\tdo_setstat(conn, dst, &a);\n\n\t(void) closedir(dirp);\n\treturn ret;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MAX_DIR_DEPTH 64"
          ],
          "globals_used": [
            "extern volatile sig_atomic_t interrupted;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MAX_DIR_DEPTH 64\n\nextern volatile sig_atomic_t interrupted;\n\nstatic int\nupload_dir_internal(struct sftp_conn *conn, const char *src, const char *dst,\n    int depth, int preserve_flag, int print_flag, int resume, int fsync_flag)\n{\n\tint ret = 0;\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *filename, *new_src = NULL, *new_dst = NULL;\n\tstruct stat sb;\n\tAttrib a, *dirattrib;\n\n\tif (depth >= MAX_DIR_DEPTH) {\n\t\terror(\"Maximum directory depth exceeded: %d levels\", depth);\n\t\treturn -1;\n\t}\n\n\tif (stat(src, &sb) == -1) {\n\t\terror(\"Couldn't stat directory \\\"%s\\\": %s\",\n\t\t    src, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (!S_ISDIR(sb.st_mode)) {\n\t\terror(\"\\\"%s\\\" is not a directory\", src);\n\t\treturn -1;\n\t}\n\tif (print_flag)\n\t\tmprintf(\"Entering %s\\n\", src);\n\n\tattrib_clear(&a);\n\tstat_to_attrib(&sb, &a);\n\ta.flags &= ~SSH2_FILEXFER_ATTR_SIZE;\n\ta.flags &= ~SSH2_FILEXFER_ATTR_UIDGID;\n\ta.perm &= 01777;\n\tif (!preserve_flag)\n\t\ta.flags &= ~SSH2_FILEXFER_ATTR_ACMODTIME;\n\n\t/*\n\t * sftp lacks a portable status value to match errno EEXIST,\n\t * so if we get a failure back then we must check whether\n\t * the path already existed and is a directory.\n\t */\n\tif (do_mkdir(conn, dst, &a, 0) != 0) {\n\t\tif ((dirattrib = do_stat(conn, dst, 0)) == NULL)\n\t\t\treturn -1;\n\t\tif (!S_ISDIR(dirattrib->perm)) {\n\t\t\terror(\"\\\"%s\\\" exists but is not a directory\", dst);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ((dirp = opendir(src)) == NULL) {\n\t\terror(\"Failed to open dir \\\"%s\\\": %s\", src, strerror(errno));\n\t\treturn -1;\n\t}\n\n\twhile (((dp = readdir(dirp)) != NULL) && !interrupted) {\n\t\tif (dp->d_ino == 0)\n\t\t\tcontinue;\n\t\tfree(new_dst);\n\t\tfree(new_src);\n\t\tfilename = dp->d_name;\n\t\tnew_dst = path_append(dst, filename);\n\t\tnew_src = path_append(src, filename);\n\n\t\tif (lstat(new_src, &sb) == -1) {\n\t\t\tlogit(\"%s: lstat failed: %s\", filename,\n\t\t\t    strerror(errno));\n\t\t\tret = -1;\n\t\t} else if (S_ISDIR(sb.st_mode)) {\n\t\t\tif (strcmp(filename, \".\") == 0 ||\n\t\t\t    strcmp(filename, \"..\") == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (upload_dir_internal(conn, new_src, new_dst,\n\t\t\t    depth + 1, preserve_flag, print_flag, resume,\n\t\t\t    fsync_flag) == -1)\n\t\t\t\tret = -1;\n\t\t} else if (S_ISREG(sb.st_mode)) {\n\t\t\tif (do_upload(conn, new_src, new_dst,\n\t\t\t    preserve_flag, resume, fsync_flag) == -1) {\n\t\t\t\terror(\"Uploading of file %s to %s failed!\",\n\t\t\t\t    new_src, new_dst);\n\t\t\t\tret = -1;\n\t\t\t}\n\t\t} else\n\t\t\tlogit(\"%s: not a regular file\\n\", filename);\n\t}\n\tfree(new_dst);\n\tfree(new_src);\n\n\tdo_setstat(conn, dst, &a);\n\n\t(void) closedir(dirp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Unable to canonicalize path \\\"%s\\\"\"",
            "dst"
          ],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_realpath",
          "args": [
            "conn",
            "dst"
          ],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "do_realpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "825-880",
          "snippet": "char *\ndo_realpath(struct sftp_conn *conn, const char *path)\n{\n\tstruct sshbuf *msg;\n\tu_int expected_id, count, id;\n\tchar *filename, *longname;\n\tAttrib a;\n\tu_char type;\n\tint r;\n\n\texpected_id = id = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_REALPATH, path,\n\t    strlen(path));\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\terror(\"Couldn't canonicalize: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn NULL;\n\t} else if (type != SSH2_FXP_NAME)\n\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t    SSH2_FXP_NAME, type);\n\n\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (count != 1)\n\t\tfatal(\"Got multiple names (%d) from SSH_FXP_REALPATH\", count);\n\n\tif ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||\n\t    (r = decode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"SSH_FXP_REALPATH %s -> %s size %lu\", path, filename,\n\t    (unsigned long)a.size);\n\n\tfree(longname);\n\n\tsshbuf_free(msg);\n\n\treturn(filename);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ndo_realpath(struct sftp_conn *conn, const char *path)\n{\n\tstruct sshbuf *msg;\n\tu_int expected_id, count, id;\n\tchar *filename, *longname;\n\tAttrib a;\n\tu_char type;\n\tint r;\n\n\texpected_id = id = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_REALPATH, path,\n\t    strlen(path));\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\terror(\"Couldn't canonicalize: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn NULL;\n\t} else if (type != SSH2_FXP_NAME)\n\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t    SSH2_FXP_NAME, type);\n\n\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (count != 1)\n\t\tfatal(\"Got multiple names (%d) from SSH_FXP_REALPATH\", count);\n\n\tif ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||\n\t    (r = decode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"SSH_FXP_REALPATH %s -> %s size %lu\", path, filename,\n\t    (unsigned long)a.size);\n\n\tfree(longname);\n\n\tsshbuf_free(msg);\n\n\treturn(filename);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nupload_dir(struct sftp_conn *conn, const char *src, const char *dst,\n    int preserve_flag, int print_flag, int resume, int fsync_flag)\n{\n\tchar *dst_canon;\n\tint ret;\n\n\tif ((dst_canon = do_realpath(conn, dst)) == NULL) {\n\t\terror(\"Unable to canonicalize path \\\"%s\\\"\", dst);\n\t\treturn -1;\n\t}\n\n\tret = upload_dir_internal(conn, src, dst_canon, 0, preserve_flag,\n\t    print_flag, resume, fsync_flag);\n\n\tfree(dst_canon);\n\treturn ret;\n}"
  },
  {
    "function_name": "upload_dir_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "1791-1885",
    "snippet": "static int\nupload_dir_internal(struct sftp_conn *conn, const char *src, const char *dst,\n    int depth, int preserve_flag, int print_flag, int resume, int fsync_flag)\n{\n\tint ret = 0;\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *filename, *new_src = NULL, *new_dst = NULL;\n\tstruct stat sb;\n\tAttrib a, *dirattrib;\n\n\tif (depth >= MAX_DIR_DEPTH) {\n\t\terror(\"Maximum directory depth exceeded: %d levels\", depth);\n\t\treturn -1;\n\t}\n\n\tif (stat(src, &sb) == -1) {\n\t\terror(\"Couldn't stat directory \\\"%s\\\": %s\",\n\t\t    src, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (!S_ISDIR(sb.st_mode)) {\n\t\terror(\"\\\"%s\\\" is not a directory\", src);\n\t\treturn -1;\n\t}\n\tif (print_flag)\n\t\tmprintf(\"Entering %s\\n\", src);\n\n\tattrib_clear(&a);\n\tstat_to_attrib(&sb, &a);\n\ta.flags &= ~SSH2_FILEXFER_ATTR_SIZE;\n\ta.flags &= ~SSH2_FILEXFER_ATTR_UIDGID;\n\ta.perm &= 01777;\n\tif (!preserve_flag)\n\t\ta.flags &= ~SSH2_FILEXFER_ATTR_ACMODTIME;\n\n\t/*\n\t * sftp lacks a portable status value to match errno EEXIST,\n\t * so if we get a failure back then we must check whether\n\t * the path already existed and is a directory.\n\t */\n\tif (do_mkdir(conn, dst, &a, 0) != 0) {\n\t\tif ((dirattrib = do_stat(conn, dst, 0)) == NULL)\n\t\t\treturn -1;\n\t\tif (!S_ISDIR(dirattrib->perm)) {\n\t\t\terror(\"\\\"%s\\\" exists but is not a directory\", dst);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ((dirp = opendir(src)) == NULL) {\n\t\terror(\"Failed to open dir \\\"%s\\\": %s\", src, strerror(errno));\n\t\treturn -1;\n\t}\n\n\twhile (((dp = readdir(dirp)) != NULL) && !interrupted) {\n\t\tif (dp->d_ino == 0)\n\t\t\tcontinue;\n\t\tfree(new_dst);\n\t\tfree(new_src);\n\t\tfilename = dp->d_name;\n\t\tnew_dst = path_append(dst, filename);\n\t\tnew_src = path_append(src, filename);\n\n\t\tif (lstat(new_src, &sb) == -1) {\n\t\t\tlogit(\"%s: lstat failed: %s\", filename,\n\t\t\t    strerror(errno));\n\t\t\tret = -1;\n\t\t} else if (S_ISDIR(sb.st_mode)) {\n\t\t\tif (strcmp(filename, \".\") == 0 ||\n\t\t\t    strcmp(filename, \"..\") == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (upload_dir_internal(conn, new_src, new_dst,\n\t\t\t    depth + 1, preserve_flag, print_flag, resume,\n\t\t\t    fsync_flag) == -1)\n\t\t\t\tret = -1;\n\t\t} else if (S_ISREG(sb.st_mode)) {\n\t\t\tif (do_upload(conn, new_src, new_dst,\n\t\t\t    preserve_flag, resume, fsync_flag) == -1) {\n\t\t\t\terror(\"Uploading of file %s to %s failed!\",\n\t\t\t\t    new_src, new_dst);\n\t\t\t\tret = -1;\n\t\t\t}\n\t\t} else\n\t\t\tlogit(\"%s: not a regular file\\n\", filename);\n\t}\n\tfree(new_dst);\n\tfree(new_src);\n\n\tdo_setstat(conn, dst, &a);\n\n\t(void) closedir(dirp);\n\treturn ret;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MAX_DIR_DEPTH 64"
    ],
    "globals_used": [
      "extern volatile sig_atomic_t interrupted;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dirp"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "fudge_closedir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-glob.c",
          "lines": "103-108",
          "snippet": "static void\nfudge_closedir(struct SFTP_OPENDIR *od)\n{\n\tfree_sftp_dirents(od->dir);\n\tfree(od);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <dirent.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdlib.h>\n#include <dirent.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nfudge_closedir(struct SFTP_OPENDIR *od)\n{\n\tfree_sftp_dirents(od->dir);\n\tfree(od);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_setstat",
          "args": [
            "conn",
            "dst",
            "&a"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "do_setstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "791-806",
          "snippet": "int\ndo_setstat(struct sftp_conn *conn, const char *path, Attrib *a)\n{\n\tu_int status, id;\n\n\tid = conn->msg_id++;\n\tsend_string_attrs_request(conn, id, SSH2_FXP_SETSTAT, path,\n\t    strlen(path), a);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't setstat on \\\"%s\\\": %s\", path,\n\t\t    fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_setstat(struct sftp_conn *conn, const char *path, Attrib *a)\n{\n\tu_int status, id;\n\n\tid = conn->msg_id++;\n\tsend_string_attrs_request(conn, id, SSH2_FXP_SETSTAT, path,\n\t    strlen(path), a);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't setstat on \\\"%s\\\": %s\", path,\n\t\t    fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "new_src"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "free_sftp_dirents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "681-693",
          "snippet": "void free_sftp_dirents(SFTP_DIRENT **s)\n{\n\tint i;\n\n\tif (s == NULL)\n\t\treturn;\n\tfor (i = 0; s[i]; i++) {\n\t\tfree(s[i]->filename);\n\t\tfree(s[i]->longname);\n\t\tfree(s[i]);\n\t}\n\tfree(s);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid free_sftp_dirents(SFTP_DIRENT **s)\n{\n\tint i;\n\n\tif (s == NULL)\n\t\treturn;\n\tfor (i = 0; s[i]; i++) {\n\t\tfree(s[i]->filename);\n\t\tfree(s[i]->longname);\n\t\tfree(s[i]);\n\t}\n\tfree(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"%s: not a regular file\\n\"",
            "filename"
          ],
          "line": 1876
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Uploading of file %s to %s failed!\"",
            "new_src",
            "new_dst"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_upload",
          "args": [
            "conn",
            "new_src",
            "new_dst",
            "preserve_flag",
            "resume",
            "fsync_flag"
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "do_upload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "1570-1789",
          "snippet": "int\ndo_upload(struct sftp_conn *conn, const char *local_path,\n    const char *remote_path, int preserve_flag, int resume, int fsync_flag)\n{\n\tint r, local_fd;\n\tu_int status = SSH2_FX_OK;\n\tu_int id;\n\tu_char type;\n\toff_t offset, progress_counter;\n\tu_char *handle, *data;\n\tstruct sshbuf *msg;\n\tstruct stat sb;\n\tAttrib a, *c = NULL;\n\tu_int32_t startid;\n\tu_int32_t ackid;\n\tstruct outstanding_ack {\n\t\tu_int id;\n\t\tu_int len;\n\t\toff_t offset;\n\t\tTAILQ_ENTRY(outstanding_ack) tq;\n\t};\n\tTAILQ_HEAD(ackhead, outstanding_ack) acks;\n\tstruct outstanding_ack *ack = NULL;\n\tsize_t handle_len;\n\n\tTAILQ_INIT(&acks);\n\n\tif ((local_fd = open(local_path, O_RDONLY, 0)) == -1) {\n\t\terror(\"Couldn't open local file \\\"%s\\\" for reading: %s\",\n\t\t    local_path, strerror(errno));\n\t\treturn(-1);\n\t}\n\tif (fstat(local_fd, &sb) == -1) {\n\t\terror(\"Couldn't fstat local file \\\"%s\\\": %s\",\n\t\t    local_path, strerror(errno));\n\t\tclose(local_fd);\n\t\treturn(-1);\n\t}\n\tif (!S_ISREG(sb.st_mode)) {\n\t\terror(\"%s is not a regular file\", local_path);\n\t\tclose(local_fd);\n\t\treturn(-1);\n\t}\n\tstat_to_attrib(&sb, &a);\n\n\ta.flags &= ~SSH2_FILEXFER_ATTR_SIZE;\n\ta.flags &= ~SSH2_FILEXFER_ATTR_UIDGID;\n\ta.perm &= 0777;\n\tif (!preserve_flag)\n\t\ta.flags &= ~SSH2_FILEXFER_ATTR_ACMODTIME;\n\n\tif (resume) {\n\t\t/* Get remote file size if it exists */\n\t\tif ((c = do_stat(conn, remote_path, 0)) == NULL) {\n\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((off_t)c->size >= sb.st_size) {\n\t\t\terror(\"destination file bigger or same size as \"\n\t\t\t      \"source file\");\n\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (lseek(local_fd, (off_t)c->size, SEEK_SET) == -1) {\n\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\t/* Send open request */\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_OPEN)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, remote_path)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, SSH2_FXF_WRITE|SSH2_FXF_CREAT|\n\t    (resume ? SSH2_FXF_APPEND : SSH2_FXF_TRUNC))) != 0 ||\n\t    (r = encode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message SSH2_FXP_OPEN I:%u P:%s\", id, remote_path);\n\n\tsshbuf_reset(msg);\n\n\thandle = get_handle(conn, id, &handle_len,\n\t    \"remote open(\\\"%s\\\")\", remote_path);\n\tif (handle == NULL) {\n\t\tclose(local_fd);\n\t\tsshbuf_free(msg);\n\t\treturn -1;\n\t}\n\n\tstartid = ackid = id + 1;\n\tdata = xmalloc(conn->transfer_buflen);\n\n\t/* Read from local and write to remote */\n\toffset = progress_counter = (resume ? c->size : 0);\n\tif (showprogress)\n\t\tstart_progress_meter(local_path, sb.st_size,\n\t\t    &progress_counter);\n\n\tfor (;;) {\n\t\tint len;\n\n\t\t/*\n\t\t * Can't use atomicio here because it returns 0 on EOF,\n\t\t * thus losing the last block of the file.\n\t\t * Simulate an EOF on interrupt, allowing ACKs from the\n\t\t * server to drain.\n\t\t */\n\t\tif (interrupted || status != SSH2_FX_OK)\n\t\t\tlen = 0;\n\t\telse do\n\t\t\tlen = read(local_fd, data, conn->transfer_buflen);\n\t\twhile ((len == -1) &&\n\t\t    (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK));\n\n\t\tif (len == -1)\n\t\t\tfatal(\"Couldn't read from \\\"%s\\\": %s\", local_path,\n\t\t\t    strerror(errno));\n\n\t\tif (len != 0) {\n\t\t\tack = xcalloc(1, sizeof(*ack));\n\t\t\tack->id = ++id;\n\t\t\tack->offset = offset;\n\t\t\tack->len = len;\n\t\t\tTAILQ_INSERT_TAIL(&acks, ack, tq);\n\n\t\t\tsshbuf_reset(msg);\n\t\t\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_WRITE)) != 0 ||\n\t\t\t    (r = sshbuf_put_u32(msg, ack->id)) != 0 ||\n\t\t\t    (r = sshbuf_put_string(msg, handle,\n\t\t\t    handle_len)) != 0 ||\n\t\t\t    (r = sshbuf_put_u64(msg, offset)) != 0 ||\n\t\t\t    (r = sshbuf_put_string(msg, data, len)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tsend_msg(conn, msg);\n\t\t\tdebug3(\"Sent message SSH2_FXP_WRITE I:%u O:%llu S:%u\",\n\t\t\t    id, (unsigned long long)offset, len);\n\t\t} else if (TAILQ_FIRST(&acks) == NULL)\n\t\t\tbreak;\n\n\t\tif (ack == NULL)\n\t\t\tfatal(\"Unexpected ACK %u\", id);\n\n\t\tif (id == startid || len == 0 ||\n\t\t    id - ackid >= conn->num_requests) {\n\t\t\tu_int rid;\n\n\t\t\tsshbuf_reset(msg);\n\t\t\tget_msg(conn, msg);\n\t\t\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t\t\t    (r = sshbuf_get_u32(msg, &rid)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\n\t\t\tif (type != SSH2_FXP_STATUS)\n\t\t\t\tfatal(\"Expected SSH2_FXP_STATUS(%d) packet, \"\n\t\t\t\t    \"got %d\", SSH2_FXP_STATUS, type);\n\n\t\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\t\t\t/* Find the request in our queue */\n\t\t\tfor (ack = TAILQ_FIRST(&acks);\n\t\t\t    ack != NULL && ack->id != rid;\n\t\t\t    ack = TAILQ_NEXT(ack, tq))\n\t\t\t\t;\n\t\t\tif (ack == NULL)\n\t\t\t\tfatal(\"Can't find request for ID %u\", rid);\n\t\t\tTAILQ_REMOVE(&acks, ack, tq);\n\t\t\tdebug3(\"In write loop, ack for %u %u bytes at %lld\",\n\t\t\t    ack->id, ack->len, (long long)ack->offset);\n\t\t\t++ackid;\n\t\t\tprogress_counter += ack->len;\n\t\t\tfree(ack);\n\t\t}\n\t\toffset += len;\n\t\tif (offset < 0)\n\t\t\tfatal(\"%s: offset < 0\", __func__);\n\t}\n\tsshbuf_free(msg);\n\n\tif (showprogress)\n\t\tstop_progress_meter();\n\tfree(data);\n\n\tif (status != SSH2_FX_OK) {\n\t\terror(\"Couldn't write to remote file \\\"%s\\\": %s\",\n\t\t    remote_path, fx2txt(status));\n\t\tstatus = SSH2_FX_FAILURE;\n\t}\n\n\tif (close(local_fd) == -1) {\n\t\terror(\"Couldn't close local file \\\"%s\\\": %s\", local_path,\n\t\t    strerror(errno));\n\t\tstatus = SSH2_FX_FAILURE;\n\t}\n\n\t/* Override umask and utimes if asked */\n\tif (preserve_flag)\n\t\tdo_fsetstat(conn, handle, handle_len, &a);\n\n\tif (fsync_flag)\n\t\t(void)do_fsync(conn, handle, handle_len);\n\n\tif (do_close(conn, handle, handle_len) != 0)\n\t\tstatus = SSH2_FX_FAILURE;\n\n\tfree(handle);\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern volatile sig_atomic_t interrupted;",
            "extern int showprogress;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern volatile sig_atomic_t interrupted;\nextern int showprogress;\n\nint\ndo_upload(struct sftp_conn *conn, const char *local_path,\n    const char *remote_path, int preserve_flag, int resume, int fsync_flag)\n{\n\tint r, local_fd;\n\tu_int status = SSH2_FX_OK;\n\tu_int id;\n\tu_char type;\n\toff_t offset, progress_counter;\n\tu_char *handle, *data;\n\tstruct sshbuf *msg;\n\tstruct stat sb;\n\tAttrib a, *c = NULL;\n\tu_int32_t startid;\n\tu_int32_t ackid;\n\tstruct outstanding_ack {\n\t\tu_int id;\n\t\tu_int len;\n\t\toff_t offset;\n\t\tTAILQ_ENTRY(outstanding_ack) tq;\n\t};\n\tTAILQ_HEAD(ackhead, outstanding_ack) acks;\n\tstruct outstanding_ack *ack = NULL;\n\tsize_t handle_len;\n\n\tTAILQ_INIT(&acks);\n\n\tif ((local_fd = open(local_path, O_RDONLY, 0)) == -1) {\n\t\terror(\"Couldn't open local file \\\"%s\\\" for reading: %s\",\n\t\t    local_path, strerror(errno));\n\t\treturn(-1);\n\t}\n\tif (fstat(local_fd, &sb) == -1) {\n\t\terror(\"Couldn't fstat local file \\\"%s\\\": %s\",\n\t\t    local_path, strerror(errno));\n\t\tclose(local_fd);\n\t\treturn(-1);\n\t}\n\tif (!S_ISREG(sb.st_mode)) {\n\t\terror(\"%s is not a regular file\", local_path);\n\t\tclose(local_fd);\n\t\treturn(-1);\n\t}\n\tstat_to_attrib(&sb, &a);\n\n\ta.flags &= ~SSH2_FILEXFER_ATTR_SIZE;\n\ta.flags &= ~SSH2_FILEXFER_ATTR_UIDGID;\n\ta.perm &= 0777;\n\tif (!preserve_flag)\n\t\ta.flags &= ~SSH2_FILEXFER_ATTR_ACMODTIME;\n\n\tif (resume) {\n\t\t/* Get remote file size if it exists */\n\t\tif ((c = do_stat(conn, remote_path, 0)) == NULL) {\n\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((off_t)c->size >= sb.st_size) {\n\t\t\terror(\"destination file bigger or same size as \"\n\t\t\t      \"source file\");\n\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (lseek(local_fd, (off_t)c->size, SEEK_SET) == -1) {\n\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\t/* Send open request */\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_OPEN)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, remote_path)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, SSH2_FXF_WRITE|SSH2_FXF_CREAT|\n\t    (resume ? SSH2_FXF_APPEND : SSH2_FXF_TRUNC))) != 0 ||\n\t    (r = encode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message SSH2_FXP_OPEN I:%u P:%s\", id, remote_path);\n\n\tsshbuf_reset(msg);\n\n\thandle = get_handle(conn, id, &handle_len,\n\t    \"remote open(\\\"%s\\\")\", remote_path);\n\tif (handle == NULL) {\n\t\tclose(local_fd);\n\t\tsshbuf_free(msg);\n\t\treturn -1;\n\t}\n\n\tstartid = ackid = id + 1;\n\tdata = xmalloc(conn->transfer_buflen);\n\n\t/* Read from local and write to remote */\n\toffset = progress_counter = (resume ? c->size : 0);\n\tif (showprogress)\n\t\tstart_progress_meter(local_path, sb.st_size,\n\t\t    &progress_counter);\n\n\tfor (;;) {\n\t\tint len;\n\n\t\t/*\n\t\t * Can't use atomicio here because it returns 0 on EOF,\n\t\t * thus losing the last block of the file.\n\t\t * Simulate an EOF on interrupt, allowing ACKs from the\n\t\t * server to drain.\n\t\t */\n\t\tif (interrupted || status != SSH2_FX_OK)\n\t\t\tlen = 0;\n\t\telse do\n\t\t\tlen = read(local_fd, data, conn->transfer_buflen);\n\t\twhile ((len == -1) &&\n\t\t    (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK));\n\n\t\tif (len == -1)\n\t\t\tfatal(\"Couldn't read from \\\"%s\\\": %s\", local_path,\n\t\t\t    strerror(errno));\n\n\t\tif (len != 0) {\n\t\t\tack = xcalloc(1, sizeof(*ack));\n\t\t\tack->id = ++id;\n\t\t\tack->offset = offset;\n\t\t\tack->len = len;\n\t\t\tTAILQ_INSERT_TAIL(&acks, ack, tq);\n\n\t\t\tsshbuf_reset(msg);\n\t\t\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_WRITE)) != 0 ||\n\t\t\t    (r = sshbuf_put_u32(msg, ack->id)) != 0 ||\n\t\t\t    (r = sshbuf_put_string(msg, handle,\n\t\t\t    handle_len)) != 0 ||\n\t\t\t    (r = sshbuf_put_u64(msg, offset)) != 0 ||\n\t\t\t    (r = sshbuf_put_string(msg, data, len)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tsend_msg(conn, msg);\n\t\t\tdebug3(\"Sent message SSH2_FXP_WRITE I:%u O:%llu S:%u\",\n\t\t\t    id, (unsigned long long)offset, len);\n\t\t} else if (TAILQ_FIRST(&acks) == NULL)\n\t\t\tbreak;\n\n\t\tif (ack == NULL)\n\t\t\tfatal(\"Unexpected ACK %u\", id);\n\n\t\tif (id == startid || len == 0 ||\n\t\t    id - ackid >= conn->num_requests) {\n\t\t\tu_int rid;\n\n\t\t\tsshbuf_reset(msg);\n\t\t\tget_msg(conn, msg);\n\t\t\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t\t\t    (r = sshbuf_get_u32(msg, &rid)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\n\t\t\tif (type != SSH2_FXP_STATUS)\n\t\t\t\tfatal(\"Expected SSH2_FXP_STATUS(%d) packet, \"\n\t\t\t\t    \"got %d\", SSH2_FXP_STATUS, type);\n\n\t\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\t\t\t/* Find the request in our queue */\n\t\t\tfor (ack = TAILQ_FIRST(&acks);\n\t\t\t    ack != NULL && ack->id != rid;\n\t\t\t    ack = TAILQ_NEXT(ack, tq))\n\t\t\t\t;\n\t\t\tif (ack == NULL)\n\t\t\t\tfatal(\"Can't find request for ID %u\", rid);\n\t\t\tTAILQ_REMOVE(&acks, ack, tq);\n\t\t\tdebug3(\"In write loop, ack for %u %u bytes at %lld\",\n\t\t\t    ack->id, ack->len, (long long)ack->offset);\n\t\t\t++ackid;\n\t\t\tprogress_counter += ack->len;\n\t\t\tfree(ack);\n\t\t}\n\t\toffset += len;\n\t\tif (offset < 0)\n\t\t\tfatal(\"%s: offset < 0\", __func__);\n\t}\n\tsshbuf_free(msg);\n\n\tif (showprogress)\n\t\tstop_progress_meter();\n\tfree(data);\n\n\tif (status != SSH2_FX_OK) {\n\t\terror(\"Couldn't write to remote file \\\"%s\\\": %s\",\n\t\t    remote_path, fx2txt(status));\n\t\tstatus = SSH2_FX_FAILURE;\n\t}\n\n\tif (close(local_fd) == -1) {\n\t\terror(\"Couldn't close local file \\\"%s\\\": %s\", local_path,\n\t\t    strerror(errno));\n\t\tstatus = SSH2_FX_FAILURE;\n\t}\n\n\t/* Override umask and utimes if asked */\n\tif (preserve_flag)\n\t\tdo_fsetstat(conn, handle, handle_len, &a);\n\n\tif (fsync_flag)\n\t\t(void)do_fsync(conn, handle, handle_len);\n\n\tif (do_close(conn, handle, handle_len) != 0)\n\t\tstatus = SSH2_FX_FAILURE;\n\n\tfree(handle);\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "sb.st_mode"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "upload_dir_internal",
          "args": [
            "conn",
            "new_src",
            "new_dst",
            "depth + 1",
            "preserve_flag",
            "print_flag",
            "resume",
            "fsync_flag"
          ],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "upload_dir_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "1791-1885",
          "snippet": "static int\nupload_dir_internal(struct sftp_conn *conn, const char *src, const char *dst,\n    int depth, int preserve_flag, int print_flag, int resume, int fsync_flag)\n{\n\tint ret = 0;\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *filename, *new_src = NULL, *new_dst = NULL;\n\tstruct stat sb;\n\tAttrib a, *dirattrib;\n\n\tif (depth >= MAX_DIR_DEPTH) {\n\t\terror(\"Maximum directory depth exceeded: %d levels\", depth);\n\t\treturn -1;\n\t}\n\n\tif (stat(src, &sb) == -1) {\n\t\terror(\"Couldn't stat directory \\\"%s\\\": %s\",\n\t\t    src, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (!S_ISDIR(sb.st_mode)) {\n\t\terror(\"\\\"%s\\\" is not a directory\", src);\n\t\treturn -1;\n\t}\n\tif (print_flag)\n\t\tmprintf(\"Entering %s\\n\", src);\n\n\tattrib_clear(&a);\n\tstat_to_attrib(&sb, &a);\n\ta.flags &= ~SSH2_FILEXFER_ATTR_SIZE;\n\ta.flags &= ~SSH2_FILEXFER_ATTR_UIDGID;\n\ta.perm &= 01777;\n\tif (!preserve_flag)\n\t\ta.flags &= ~SSH2_FILEXFER_ATTR_ACMODTIME;\n\n\t/*\n\t * sftp lacks a portable status value to match errno EEXIST,\n\t * so if we get a failure back then we must check whether\n\t * the path already existed and is a directory.\n\t */\n\tif (do_mkdir(conn, dst, &a, 0) != 0) {\n\t\tif ((dirattrib = do_stat(conn, dst, 0)) == NULL)\n\t\t\treturn -1;\n\t\tif (!S_ISDIR(dirattrib->perm)) {\n\t\t\terror(\"\\\"%s\\\" exists but is not a directory\", dst);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ((dirp = opendir(src)) == NULL) {\n\t\terror(\"Failed to open dir \\\"%s\\\": %s\", src, strerror(errno));\n\t\treturn -1;\n\t}\n\n\twhile (((dp = readdir(dirp)) != NULL) && !interrupted) {\n\t\tif (dp->d_ino == 0)\n\t\t\tcontinue;\n\t\tfree(new_dst);\n\t\tfree(new_src);\n\t\tfilename = dp->d_name;\n\t\tnew_dst = path_append(dst, filename);\n\t\tnew_src = path_append(src, filename);\n\n\t\tif (lstat(new_src, &sb) == -1) {\n\t\t\tlogit(\"%s: lstat failed: %s\", filename,\n\t\t\t    strerror(errno));\n\t\t\tret = -1;\n\t\t} else if (S_ISDIR(sb.st_mode)) {\n\t\t\tif (strcmp(filename, \".\") == 0 ||\n\t\t\t    strcmp(filename, \"..\") == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (upload_dir_internal(conn, new_src, new_dst,\n\t\t\t    depth + 1, preserve_flag, print_flag, resume,\n\t\t\t    fsync_flag) == -1)\n\t\t\t\tret = -1;\n\t\t} else if (S_ISREG(sb.st_mode)) {\n\t\t\tif (do_upload(conn, new_src, new_dst,\n\t\t\t    preserve_flag, resume, fsync_flag) == -1) {\n\t\t\t\terror(\"Uploading of file %s to %s failed!\",\n\t\t\t\t    new_src, new_dst);\n\t\t\t\tret = -1;\n\t\t\t}\n\t\t} else\n\t\t\tlogit(\"%s: not a regular file\\n\", filename);\n\t}\n\tfree(new_dst);\n\tfree(new_src);\n\n\tdo_setstat(conn, dst, &a);\n\n\t(void) closedir(dirp);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "filename",
            "\"..\""
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sb.st_mode"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "new_src",
            "&sb"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "fudge_lstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-glob.c",
          "lines": "110-121",
          "snippet": "static int\nfudge_lstat(const char *path, struct stat *st)\n{\n\tAttrib *a;\n\n\tif (!(a = do_lstat(cur.conn, (char *)path, 1)))\n\t\treturn(-1);\n\n\tattrib_to_stat(a, st);\n\n\treturn(0);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <dirent.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tstruct sftp_conn *conn;\n} cur;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdlib.h>\n#include <dirent.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tstruct sftp_conn *conn;\n} cur;\n\nstatic int\nfudge_lstat(const char *path, struct stat *st)\n{\n\tAttrib *a;\n\n\tif (!(a = do_lstat(cur.conn, (char *)path, 1)))\n\t\treturn(-1);\n\n\tattrib_to_stat(a, st);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_append",
          "args": [
            "src",
            "filename"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "path_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "1906-1919",
          "snippet": "char *\npath_append(const char *p1, const char *p2)\n{\n\tchar *ret;\n\tsize_t len = strlen(p1) + strlen(p2) + 2;\n\n\tret = xmalloc(len);\n\tstrlcpy(ret, p1, len);\n\tif (p1[0] != '\\0' && p1[strlen(p1) - 1] != '/')\n\t\tstrlcat(ret, \"/\", len);\n\tstrlcat(ret, p2, len);\n\n\treturn(ret);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\npath_append(const char *p1, const char *p2)\n{\n\tchar *ret;\n\tsize_t len = strlen(p1) + strlen(p2) + 2;\n\n\tret = xmalloc(len);\n\tstrlcpy(ret, p1, len);\n\tif (p1[0] != '\\0' && p1[strlen(p1) - 1] != '/')\n\t\tstrlcat(ret, \"/\", len);\n\tstrlcat(ret, p2, len);\n\n\treturn(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dirp"
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "process_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1034-1088",
          "snippet": "static void\nprocess_readdir(u_int32_t id)\n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *path;\n\tint r, handle;\n\n\tif ((r = get_handle(iqueue, &handle)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug(\"request %u: readdir \\\"%s\\\" (handle %d)\", id,\n\t    handle_to_name(handle), handle);\n\tdirp = handle_to_dir(handle);\n\tpath = handle_to_name(handle);\n\tif (dirp == NULL || path == NULL) {\n\t\tsend_status(id, SSH2_FX_FAILURE);\n\t} else {\n\t\tstruct stat st;\n\t\tchar pathname[PATH_MAX];\n\t\tStat *stats;\n\t\tint nstats = 10, count = 0, i;\n\n\t\tstats = xcalloc(nstats, sizeof(Stat));\n\t\twhile ((dp = readdir(dirp)) != NULL) {\n\t\t\tif (count >= nstats) {\n\t\t\t\tnstats *= 2;\n\t\t\t\tstats = xreallocarray(stats, nstats, sizeof(Stat));\n\t\t\t}\n/* XXX OVERFLOW ? */\n\t\t\tsnprintf(pathname, sizeof pathname, \"%s%s%s\", path,\n\t\t\t    strcmp(path, \"/\") ? \"/\" : \"\", dp->d_name);\n\t\t\tif (lstat(pathname, &st) < 0)\n\t\t\t\tcontinue;\n\t\t\tstat_to_attrib(&st, &(stats[count].attrib));\n\t\t\tstats[count].name = xstrdup(dp->d_name);\n\t\t\tstats[count].long_name = ls_file(dp->d_name, &st, 0, 0);\n\t\t\tcount++;\n\t\t\t/* send up to 100 entries in one message */\n\t\t\t/* XXX check packet size instead */\n\t\t\tif (count == 100)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (count > 0) {\n\t\t\tsend_names(id, count, stats);\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tfree(stats[i].name);\n\t\t\t\tfree(stats[i].long_name);\n\t\t\t}\n\t\t} else {\n\t\t\tsend_status(id, SSH2_FX_EOF);\n\t\t}\n\t\tfree(stats);\n\t}\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct sshbuf *iqueue;",
            "static void process_open(u_int32_t id);",
            "static void process_close(u_int32_t id);",
            "static void process_read(u_int32_t id);",
            "static void process_write(u_int32_t id);",
            "static void process_stat(u_int32_t id);",
            "static void process_lstat(u_int32_t id);",
            "static void process_fstat(u_int32_t id);",
            "static void process_setstat(u_int32_t id);",
            "static void process_fsetstat(u_int32_t id);",
            "static void process_opendir(u_int32_t id);",
            "static void process_readdir(u_int32_t id);",
            "static void process_remove(u_int32_t id);",
            "static void process_mkdir(u_int32_t id);",
            "static void process_rmdir(u_int32_t id);",
            "static void process_realpath(u_int32_t id);",
            "static void process_rename(u_int32_t id);",
            "static void process_readlink(u_int32_t id);",
            "static void process_symlink(u_int32_t id);",
            "static void process_extended_posix_rename(u_int32_t id);",
            "static void process_extended_statvfs(u_int32_t id);",
            "static void process_extended_fstatvfs(u_int32_t id);",
            "static void process_extended_hardlink(u_int32_t id);",
            "static void process_extended_fsync(u_int32_t id);",
            "static void process_extended(u_int32_t id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *iqueue;\nstatic void process_open(u_int32_t id);\nstatic void process_close(u_int32_t id);\nstatic void process_read(u_int32_t id);\nstatic void process_write(u_int32_t id);\nstatic void process_stat(u_int32_t id);\nstatic void process_lstat(u_int32_t id);\nstatic void process_fstat(u_int32_t id);\nstatic void process_setstat(u_int32_t id);\nstatic void process_fsetstat(u_int32_t id);\nstatic void process_opendir(u_int32_t id);\nstatic void process_readdir(u_int32_t id);\nstatic void process_remove(u_int32_t id);\nstatic void process_mkdir(u_int32_t id);\nstatic void process_rmdir(u_int32_t id);\nstatic void process_realpath(u_int32_t id);\nstatic void process_rename(u_int32_t id);\nstatic void process_readlink(u_int32_t id);\nstatic void process_symlink(u_int32_t id);\nstatic void process_extended_posix_rename(u_int32_t id);\nstatic void process_extended_statvfs(u_int32_t id);\nstatic void process_extended_fstatvfs(u_int32_t id);\nstatic void process_extended_hardlink(u_int32_t id);\nstatic void process_extended_fsync(u_int32_t id);\nstatic void process_extended(u_int32_t id);\n\nstatic void\nprocess_readdir(u_int32_t id)\n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *path;\n\tint r, handle;\n\n\tif ((r = get_handle(iqueue, &handle)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug(\"request %u: readdir \\\"%s\\\" (handle %d)\", id,\n\t    handle_to_name(handle), handle);\n\tdirp = handle_to_dir(handle);\n\tpath = handle_to_name(handle);\n\tif (dirp == NULL || path == NULL) {\n\t\tsend_status(id, SSH2_FX_FAILURE);\n\t} else {\n\t\tstruct stat st;\n\t\tchar pathname[PATH_MAX];\n\t\tStat *stats;\n\t\tint nstats = 10, count = 0, i;\n\n\t\tstats = xcalloc(nstats, sizeof(Stat));\n\t\twhile ((dp = readdir(dirp)) != NULL) {\n\t\t\tif (count >= nstats) {\n\t\t\t\tnstats *= 2;\n\t\t\t\tstats = xreallocarray(stats, nstats, sizeof(Stat));\n\t\t\t}\n/* XXX OVERFLOW ? */\n\t\t\tsnprintf(pathname, sizeof pathname, \"%s%s%s\", path,\n\t\t\t    strcmp(path, \"/\") ? \"/\" : \"\", dp->d_name);\n\t\t\tif (lstat(pathname, &st) < 0)\n\t\t\t\tcontinue;\n\t\t\tstat_to_attrib(&st, &(stats[count].attrib));\n\t\t\tstats[count].name = xstrdup(dp->d_name);\n\t\t\tstats[count].long_name = ls_file(dp->d_name, &st, 0, 0);\n\t\t\tcount++;\n\t\t\t/* send up to 100 entries in one message */\n\t\t\t/* XXX check packet size instead */\n\t\t\tif (count == 100)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (count > 0) {\n\t\t\tsend_names(id, count, stats);\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tfree(stats[i].name);\n\t\t\t\tfree(stats[i].long_name);\n\t\t\t}\n\t\t} else {\n\t\t\tsend_status(id, SSH2_FX_EOF);\n\t\t}\n\t\tfree(stats);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "src"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "process_opendir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1004-1032",
          "snippet": "static void\nprocess_opendir(u_int32_t id)\n{\n\tDIR *dirp = NULL;\n\tchar *path;\n\tint r, handle, status = SSH2_FX_FAILURE;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"request %u: opendir\", id);\n\tlogit(\"opendir \\\"%s\\\"\", path);\n\tdirp = opendir(path);\n\tif (dirp == NULL) {\n\t\tstatus = errno_to_portable(errno);\n\t} else {\n\t\thandle = handle_new(HANDLE_DIR, path, 0, 0, dirp);\n\t\tif (handle < 0) {\n\t\t\tclosedir(dirp);\n\t\t} else {\n\t\t\tsend_handle(id, handle);\n\t\t\tstatus = SSH2_FX_OK;\n\t\t}\n\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(path);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct sshbuf *iqueue;",
            "static void process_open(u_int32_t id);",
            "static void process_close(u_int32_t id);",
            "static void process_read(u_int32_t id);",
            "static void process_write(u_int32_t id);",
            "static void process_stat(u_int32_t id);",
            "static void process_lstat(u_int32_t id);",
            "static void process_fstat(u_int32_t id);",
            "static void process_setstat(u_int32_t id);",
            "static void process_fsetstat(u_int32_t id);",
            "static void process_opendir(u_int32_t id);",
            "static void process_readdir(u_int32_t id);",
            "static void process_remove(u_int32_t id);",
            "static void process_mkdir(u_int32_t id);",
            "static void process_rmdir(u_int32_t id);",
            "static void process_realpath(u_int32_t id);",
            "static void process_rename(u_int32_t id);",
            "static void process_readlink(u_int32_t id);",
            "static void process_symlink(u_int32_t id);",
            "static void process_extended_posix_rename(u_int32_t id);",
            "static void process_extended_statvfs(u_int32_t id);",
            "static void process_extended_fstatvfs(u_int32_t id);",
            "static void process_extended_hardlink(u_int32_t id);",
            "static void process_extended_fsync(u_int32_t id);",
            "static void process_extended(u_int32_t id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *iqueue;\nstatic void process_open(u_int32_t id);\nstatic void process_close(u_int32_t id);\nstatic void process_read(u_int32_t id);\nstatic void process_write(u_int32_t id);\nstatic void process_stat(u_int32_t id);\nstatic void process_lstat(u_int32_t id);\nstatic void process_fstat(u_int32_t id);\nstatic void process_setstat(u_int32_t id);\nstatic void process_fsetstat(u_int32_t id);\nstatic void process_opendir(u_int32_t id);\nstatic void process_readdir(u_int32_t id);\nstatic void process_remove(u_int32_t id);\nstatic void process_mkdir(u_int32_t id);\nstatic void process_rmdir(u_int32_t id);\nstatic void process_realpath(u_int32_t id);\nstatic void process_rename(u_int32_t id);\nstatic void process_readlink(u_int32_t id);\nstatic void process_symlink(u_int32_t id);\nstatic void process_extended_posix_rename(u_int32_t id);\nstatic void process_extended_statvfs(u_int32_t id);\nstatic void process_extended_fstatvfs(u_int32_t id);\nstatic void process_extended_hardlink(u_int32_t id);\nstatic void process_extended_fsync(u_int32_t id);\nstatic void process_extended(u_int32_t id);\n\nstatic void\nprocess_opendir(u_int32_t id)\n{\n\tDIR *dirp = NULL;\n\tchar *path;\n\tint r, handle, status = SSH2_FX_FAILURE;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"request %u: opendir\", id);\n\tlogit(\"opendir \\\"%s\\\"\", path);\n\tdirp = opendir(path);\n\tif (dirp == NULL) {\n\t\tstatus = errno_to_portable(errno);\n\t} else {\n\t\thandle = handle_new(HANDLE_DIR, path, 0, 0, dirp);\n\t\tif (handle < 0) {\n\t\t\tclosedir(dirp);\n\t\t} else {\n\t\t\tsend_handle(id, handle);\n\t\t\tstatus = SSH2_FX_OK;\n\t\t}\n\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "dirattrib->perm"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_stat",
          "args": [
            "conn",
            "dst",
            "0"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "do_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "742-754",
          "snippet": "Attrib *\ndo_stat(struct sftp_conn *conn, const char *path, int quiet)\n{\n\tu_int id;\n\n\tid = conn->msg_id++;\n\n\tsend_string_request(conn, id,\n\t    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT,\n\t    path, strlen(path));\n\n\treturn(get_decode_stat(conn, id, quiet));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nAttrib *\ndo_stat(struct sftp_conn *conn, const char *path, int quiet)\n{\n\tu_int id;\n\n\tid = conn->msg_id++;\n\n\tsend_string_request(conn, id,\n\t    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT,\n\t    path, strlen(path));\n\n\treturn(get_decode_stat(conn, id, quiet));\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_mkdir",
          "args": [
            "conn",
            "dst",
            "&a",
            "0"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "do_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "710-724",
          "snippet": "int\ndo_mkdir(struct sftp_conn *conn, const char *path, Attrib *a, int print_flag)\n{\n\tu_int status, id;\n\n\tid = conn->msg_id++;\n\tsend_string_attrs_request(conn, id, SSH2_FXP_MKDIR, path,\n\t    strlen(path), a);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK && print_flag)\n\t\terror(\"Couldn't create directory: %s\", fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_mkdir(struct sftp_conn *conn, const char *path, Attrib *a, int print_flag)\n{\n\tu_int status, id;\n\n\tid = conn->msg_id++;\n\tsend_string_attrs_request(conn, id, SSH2_FXP_MKDIR, path,\n\t    strlen(path), a);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK && print_flag)\n\t\terror(\"Couldn't create directory: %s\", fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat_to_attrib",
          "args": [
            "&sb",
            "&a"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "stat_to_attrib",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "66-81",
          "snippet": "void\nstat_to_attrib(const struct stat *st, Attrib *a)\n{\n\tattrib_clear(a);\n\ta->flags = 0;\n\ta->flags |= SSH2_FILEXFER_ATTR_SIZE;\n\ta->size = st->st_size;\n\ta->flags |= SSH2_FILEXFER_ATTR_UIDGID;\n\ta->uid = st->st_uid;\n\ta->gid = st->st_gid;\n\ta->flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;\n\ta->perm = st->st_mode;\n\ta->flags |= SSH2_FILEXFER_ATTR_ACMODTIME;\n\ta->atime = st->st_atime;\n\ta->mtime = st->st_mtime;\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nstat_to_attrib(const struct stat *st, Attrib *a)\n{\n\tattrib_clear(a);\n\ta->flags = 0;\n\ta->flags |= SSH2_FILEXFER_ATTR_SIZE;\n\ta->size = st->st_size;\n\ta->flags |= SSH2_FILEXFER_ATTR_UIDGID;\n\ta->uid = st->st_uid;\n\ta->gid = st->st_gid;\n\ta->flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;\n\ta->perm = st->st_mode;\n\ta->flags |= SSH2_FILEXFER_ATTR_ACMODTIME;\n\ta->atime = st->st_atime;\n\ta->mtime = st->st_mtime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "attrib_clear",
          "args": [
            "&a"
          ],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "attrib_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "53-63",
          "snippet": "void\nattrib_clear(Attrib *a)\n{\n\ta->flags = 0;\n\ta->size = 0;\n\ta->uid = 0;\n\ta->gid = 0;\n\ta->perm = 0;\n\ta->atime = 0;\n\ta->mtime = 0;\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nattrib_clear(Attrib *a)\n{\n\ta->flags = 0;\n\ta->size = 0;\n\ta->uid = 0;\n\ta->gid = 0;\n\ta->perm = 0;\n\ta->atime = 0;\n\ta->mtime = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mprintf",
          "args": [
            "\"Entering %s\\n\"",
            "src"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sb.st_mode"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "src",
            "&sb"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "get_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "213-241",
          "snippet": "static u_int\nget_status(struct sftp_conn *conn, u_int expected_id)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id, status;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type != SSH2_FXP_STATUS)\n\t\tfatal(\"Expected SSH2_FXP_STATUS(%u) packet, got %u\",\n\t\t    SSH2_FXP_STATUS, type);\n\n\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic u_int\nget_status(struct sftp_conn *conn, u_int expected_id)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id, status;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type != SSH2_FXP_STATUS)\n\t\tfatal(\"Expected SSH2_FXP_STATUS(%u) packet, got %u\",\n\t\t    SSH2_FXP_STATUS, type);\n\n\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MAX_DIR_DEPTH 64\n\nextern volatile sig_atomic_t interrupted;\n\nstatic int\nupload_dir_internal(struct sftp_conn *conn, const char *src, const char *dst,\n    int depth, int preserve_flag, int print_flag, int resume, int fsync_flag)\n{\n\tint ret = 0;\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *filename, *new_src = NULL, *new_dst = NULL;\n\tstruct stat sb;\n\tAttrib a, *dirattrib;\n\n\tif (depth >= MAX_DIR_DEPTH) {\n\t\terror(\"Maximum directory depth exceeded: %d levels\", depth);\n\t\treturn -1;\n\t}\n\n\tif (stat(src, &sb) == -1) {\n\t\terror(\"Couldn't stat directory \\\"%s\\\": %s\",\n\t\t    src, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (!S_ISDIR(sb.st_mode)) {\n\t\terror(\"\\\"%s\\\" is not a directory\", src);\n\t\treturn -1;\n\t}\n\tif (print_flag)\n\t\tmprintf(\"Entering %s\\n\", src);\n\n\tattrib_clear(&a);\n\tstat_to_attrib(&sb, &a);\n\ta.flags &= ~SSH2_FILEXFER_ATTR_SIZE;\n\ta.flags &= ~SSH2_FILEXFER_ATTR_UIDGID;\n\ta.perm &= 01777;\n\tif (!preserve_flag)\n\t\ta.flags &= ~SSH2_FILEXFER_ATTR_ACMODTIME;\n\n\t/*\n\t * sftp lacks a portable status value to match errno EEXIST,\n\t * so if we get a failure back then we must check whether\n\t * the path already existed and is a directory.\n\t */\n\tif (do_mkdir(conn, dst, &a, 0) != 0) {\n\t\tif ((dirattrib = do_stat(conn, dst, 0)) == NULL)\n\t\t\treturn -1;\n\t\tif (!S_ISDIR(dirattrib->perm)) {\n\t\t\terror(\"\\\"%s\\\" exists but is not a directory\", dst);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ((dirp = opendir(src)) == NULL) {\n\t\terror(\"Failed to open dir \\\"%s\\\": %s\", src, strerror(errno));\n\t\treturn -1;\n\t}\n\n\twhile (((dp = readdir(dirp)) != NULL) && !interrupted) {\n\t\tif (dp->d_ino == 0)\n\t\t\tcontinue;\n\t\tfree(new_dst);\n\t\tfree(new_src);\n\t\tfilename = dp->d_name;\n\t\tnew_dst = path_append(dst, filename);\n\t\tnew_src = path_append(src, filename);\n\n\t\tif (lstat(new_src, &sb) == -1) {\n\t\t\tlogit(\"%s: lstat failed: %s\", filename,\n\t\t\t    strerror(errno));\n\t\t\tret = -1;\n\t\t} else if (S_ISDIR(sb.st_mode)) {\n\t\t\tif (strcmp(filename, \".\") == 0 ||\n\t\t\t    strcmp(filename, \"..\") == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (upload_dir_internal(conn, new_src, new_dst,\n\t\t\t    depth + 1, preserve_flag, print_flag, resume,\n\t\t\t    fsync_flag) == -1)\n\t\t\t\tret = -1;\n\t\t} else if (S_ISREG(sb.st_mode)) {\n\t\t\tif (do_upload(conn, new_src, new_dst,\n\t\t\t    preserve_flag, resume, fsync_flag) == -1) {\n\t\t\t\terror(\"Uploading of file %s to %s failed!\",\n\t\t\t\t    new_src, new_dst);\n\t\t\t\tret = -1;\n\t\t\t}\n\t\t} else\n\t\t\tlogit(\"%s: not a regular file\\n\", filename);\n\t}\n\tfree(new_dst);\n\tfree(new_src);\n\n\tdo_setstat(conn, dst, &a);\n\n\t(void) closedir(dirp);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_upload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "1570-1789",
    "snippet": "int\ndo_upload(struct sftp_conn *conn, const char *local_path,\n    const char *remote_path, int preserve_flag, int resume, int fsync_flag)\n{\n\tint r, local_fd;\n\tu_int status = SSH2_FX_OK;\n\tu_int id;\n\tu_char type;\n\toff_t offset, progress_counter;\n\tu_char *handle, *data;\n\tstruct sshbuf *msg;\n\tstruct stat sb;\n\tAttrib a, *c = NULL;\n\tu_int32_t startid;\n\tu_int32_t ackid;\n\tstruct outstanding_ack {\n\t\tu_int id;\n\t\tu_int len;\n\t\toff_t offset;\n\t\tTAILQ_ENTRY(outstanding_ack) tq;\n\t};\n\tTAILQ_HEAD(ackhead, outstanding_ack) acks;\n\tstruct outstanding_ack *ack = NULL;\n\tsize_t handle_len;\n\n\tTAILQ_INIT(&acks);\n\n\tif ((local_fd = open(local_path, O_RDONLY, 0)) == -1) {\n\t\terror(\"Couldn't open local file \\\"%s\\\" for reading: %s\",\n\t\t    local_path, strerror(errno));\n\t\treturn(-1);\n\t}\n\tif (fstat(local_fd, &sb) == -1) {\n\t\terror(\"Couldn't fstat local file \\\"%s\\\": %s\",\n\t\t    local_path, strerror(errno));\n\t\tclose(local_fd);\n\t\treturn(-1);\n\t}\n\tif (!S_ISREG(sb.st_mode)) {\n\t\terror(\"%s is not a regular file\", local_path);\n\t\tclose(local_fd);\n\t\treturn(-1);\n\t}\n\tstat_to_attrib(&sb, &a);\n\n\ta.flags &= ~SSH2_FILEXFER_ATTR_SIZE;\n\ta.flags &= ~SSH2_FILEXFER_ATTR_UIDGID;\n\ta.perm &= 0777;\n\tif (!preserve_flag)\n\t\ta.flags &= ~SSH2_FILEXFER_ATTR_ACMODTIME;\n\n\tif (resume) {\n\t\t/* Get remote file size if it exists */\n\t\tif ((c = do_stat(conn, remote_path, 0)) == NULL) {\n\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((off_t)c->size >= sb.st_size) {\n\t\t\terror(\"destination file bigger or same size as \"\n\t\t\t      \"source file\");\n\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (lseek(local_fd, (off_t)c->size, SEEK_SET) == -1) {\n\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\t/* Send open request */\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_OPEN)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, remote_path)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, SSH2_FXF_WRITE|SSH2_FXF_CREAT|\n\t    (resume ? SSH2_FXF_APPEND : SSH2_FXF_TRUNC))) != 0 ||\n\t    (r = encode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message SSH2_FXP_OPEN I:%u P:%s\", id, remote_path);\n\n\tsshbuf_reset(msg);\n\n\thandle = get_handle(conn, id, &handle_len,\n\t    \"remote open(\\\"%s\\\")\", remote_path);\n\tif (handle == NULL) {\n\t\tclose(local_fd);\n\t\tsshbuf_free(msg);\n\t\treturn -1;\n\t}\n\n\tstartid = ackid = id + 1;\n\tdata = xmalloc(conn->transfer_buflen);\n\n\t/* Read from local and write to remote */\n\toffset = progress_counter = (resume ? c->size : 0);\n\tif (showprogress)\n\t\tstart_progress_meter(local_path, sb.st_size,\n\t\t    &progress_counter);\n\n\tfor (;;) {\n\t\tint len;\n\n\t\t/*\n\t\t * Can't use atomicio here because it returns 0 on EOF,\n\t\t * thus losing the last block of the file.\n\t\t * Simulate an EOF on interrupt, allowing ACKs from the\n\t\t * server to drain.\n\t\t */\n\t\tif (interrupted || status != SSH2_FX_OK)\n\t\t\tlen = 0;\n\t\telse do\n\t\t\tlen = read(local_fd, data, conn->transfer_buflen);\n\t\twhile ((len == -1) &&\n\t\t    (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK));\n\n\t\tif (len == -1)\n\t\t\tfatal(\"Couldn't read from \\\"%s\\\": %s\", local_path,\n\t\t\t    strerror(errno));\n\n\t\tif (len != 0) {\n\t\t\tack = xcalloc(1, sizeof(*ack));\n\t\t\tack->id = ++id;\n\t\t\tack->offset = offset;\n\t\t\tack->len = len;\n\t\t\tTAILQ_INSERT_TAIL(&acks, ack, tq);\n\n\t\t\tsshbuf_reset(msg);\n\t\t\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_WRITE)) != 0 ||\n\t\t\t    (r = sshbuf_put_u32(msg, ack->id)) != 0 ||\n\t\t\t    (r = sshbuf_put_string(msg, handle,\n\t\t\t    handle_len)) != 0 ||\n\t\t\t    (r = sshbuf_put_u64(msg, offset)) != 0 ||\n\t\t\t    (r = sshbuf_put_string(msg, data, len)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tsend_msg(conn, msg);\n\t\t\tdebug3(\"Sent message SSH2_FXP_WRITE I:%u O:%llu S:%u\",\n\t\t\t    id, (unsigned long long)offset, len);\n\t\t} else if (TAILQ_FIRST(&acks) == NULL)\n\t\t\tbreak;\n\n\t\tif (ack == NULL)\n\t\t\tfatal(\"Unexpected ACK %u\", id);\n\n\t\tif (id == startid || len == 0 ||\n\t\t    id - ackid >= conn->num_requests) {\n\t\t\tu_int rid;\n\n\t\t\tsshbuf_reset(msg);\n\t\t\tget_msg(conn, msg);\n\t\t\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t\t\t    (r = sshbuf_get_u32(msg, &rid)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\n\t\t\tif (type != SSH2_FXP_STATUS)\n\t\t\t\tfatal(\"Expected SSH2_FXP_STATUS(%d) packet, \"\n\t\t\t\t    \"got %d\", SSH2_FXP_STATUS, type);\n\n\t\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\t\t\t/* Find the request in our queue */\n\t\t\tfor (ack = TAILQ_FIRST(&acks);\n\t\t\t    ack != NULL && ack->id != rid;\n\t\t\t    ack = TAILQ_NEXT(ack, tq))\n\t\t\t\t;\n\t\t\tif (ack == NULL)\n\t\t\t\tfatal(\"Can't find request for ID %u\", rid);\n\t\t\tTAILQ_REMOVE(&acks, ack, tq);\n\t\t\tdebug3(\"In write loop, ack for %u %u bytes at %lld\",\n\t\t\t    ack->id, ack->len, (long long)ack->offset);\n\t\t\t++ackid;\n\t\t\tprogress_counter += ack->len;\n\t\t\tfree(ack);\n\t\t}\n\t\toffset += len;\n\t\tif (offset < 0)\n\t\t\tfatal(\"%s: offset < 0\", __func__);\n\t}\n\tsshbuf_free(msg);\n\n\tif (showprogress)\n\t\tstop_progress_meter();\n\tfree(data);\n\n\tif (status != SSH2_FX_OK) {\n\t\terror(\"Couldn't write to remote file \\\"%s\\\": %s\",\n\t\t    remote_path, fx2txt(status));\n\t\tstatus = SSH2_FX_FAILURE;\n\t}\n\n\tif (close(local_fd) == -1) {\n\t\terror(\"Couldn't close local file \\\"%s\\\": %s\", local_path,\n\t\t    strerror(errno));\n\t\tstatus = SSH2_FX_FAILURE;\n\t}\n\n\t/* Override umask and utimes if asked */\n\tif (preserve_flag)\n\t\tdo_fsetstat(conn, handle, handle_len, &a);\n\n\tif (fsync_flag)\n\t\t(void)do_fsync(conn, handle, handle_len);\n\n\tif (do_close(conn, handle, handle_len) != 0)\n\t\tstatus = SSH2_FX_FAILURE;\n\n\tfree(handle);\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern volatile sig_atomic_t interrupted;",
      "extern int showprogress;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "handle"
          ],
          "line": 1786
        },
        "resolved": true,
        "details": {
          "function_name": "free_sftp_dirents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "681-693",
          "snippet": "void free_sftp_dirents(SFTP_DIRENT **s)\n{\n\tint i;\n\n\tif (s == NULL)\n\t\treturn;\n\tfor (i = 0; s[i]; i++) {\n\t\tfree(s[i]->filename);\n\t\tfree(s[i]->longname);\n\t\tfree(s[i]);\n\t}\n\tfree(s);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid free_sftp_dirents(SFTP_DIRENT **s)\n{\n\tint i;\n\n\tif (s == NULL)\n\t\treturn;\n\tfor (i = 0; s[i]; i++) {\n\t\tfree(s[i]->filename);\n\t\tfree(s[i]->longname);\n\t\tfree(s[i]);\n\t}\n\tfree(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_close",
          "args": [
            "conn",
            "handle",
            "handle_len"
          ],
          "line": 1783
        },
        "resolved": true,
        "details": {
          "function_name": "do_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "500-525",
          "snippet": "int\ndo_close(struct sftp_conn *conn, const u_char *handle, u_int handle_len)\n{\n\tu_int id, status;\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_CLOSE)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message SSH2_FXP_CLOSE I:%u\", id);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't close file: %s\", fx2txt(status));\n\n\tsshbuf_free(msg);\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_close(struct sftp_conn *conn, const u_char *handle, u_int handle_len)\n{\n\tu_int id, status;\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_CLOSE)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message SSH2_FXP_CLOSE I:%u\", id);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't close file: %s\", fx2txt(status));\n\n\tsshbuf_free(msg);\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_fsync",
          "args": [
            "conn",
            "handle",
            "handle_len"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "do_fsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "994-1023",
          "snippet": "int\ndo_fsync(struct sftp_conn *conn, u_char *handle, u_int handle_len)\n{\n\tstruct sshbuf *msg;\n\tu_int status, id;\n\tint r;\n\n\t/* Silently return if the extension is not supported */\n\tif ((conn->exts & SFTP_EXT_FSYNC) == 0)\n\t\treturn -1;\n\n\t/* Send fsync request */\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, \"fsync@openssh.com\")) != 0 ||\n\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fsync@openssh.com I:%u\", id);\n\tsshbuf_free(msg);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't sync file: %s\", fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SFTP_EXT_FSYNC\t\t0x00000010"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SFTP_EXT_FSYNC\t\t0x00000010\n\nint\ndo_fsync(struct sftp_conn *conn, u_char *handle, u_int handle_len)\n{\n\tstruct sshbuf *msg;\n\tu_int status, id;\n\tint r;\n\n\t/* Silently return if the extension is not supported */\n\tif ((conn->exts & SFTP_EXT_FSYNC) == 0)\n\t\treturn -1;\n\n\t/* Send fsync request */\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, \"fsync@openssh.com\")) != 0 ||\n\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fsync@openssh.com I:%u\", id);\n\tsshbuf_free(msg);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't sync file: %s\", fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_fsetstat",
          "args": [
            "conn",
            "handle",
            "handle_len",
            "&a"
          ],
          "line": 1778
        },
        "resolved": true,
        "details": {
          "function_name": "do_fsetstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "808-823",
          "snippet": "int\ndo_fsetstat(struct sftp_conn *conn, const u_char *handle, u_int handle_len,\n    Attrib *a)\n{\n\tu_int status, id;\n\n\tid = conn->msg_id++;\n\tsend_string_attrs_request(conn, id, SSH2_FXP_FSETSTAT, handle,\n\t    handle_len, a);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't fsetstat: %s\", fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_fsetstat(struct sftp_conn *conn, const u_char *handle, u_int handle_len,\n    Attrib *a)\n{\n\tu_int status, id;\n\n\tid = conn->msg_id++;\n\tsend_string_attrs_request(conn, id, SSH2_FXP_FSETSTAT, handle,\n\t    handle_len, a);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't fsetstat: %s\", fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Couldn't close local file \\\"%s\\\": %s\"",
            "local_path",
            "strerror(errno)"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "local_fd"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fx2txt",
          "args": [
            "status"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "fx2txt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "182-208",
          "snippet": "const char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop_progress_meter",
          "args": [],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "stop_progress_meter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/progressmeter.c",
          "lines": "270-283",
          "snippet": "void\nstop_progress_meter(void)\n{\n\talarm(0);\n\n\tif (!can_output())\n\t\treturn;\n\n\t/* Ensure we complete the progress */\n\tif (cur_pos != end_pos)\n\t\trefresh_progress_meter();\n\n\tatomicio(vwrite, STDOUT_FILENO, \"\\n\", 1);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"progressmeter.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_output(void);",
            "void refresh_progress_meter(void);",
            "static off_t end_pos;",
            "static off_t cur_pos;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"progressmeter.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int can_output(void);\nvoid refresh_progress_meter(void);\nstatic off_t end_pos;\nstatic off_t cur_pos;\n\nvoid\nstop_progress_meter(void)\n{\n\talarm(0);\n\n\tif (!can_output())\n\t\treturn;\n\n\t/* Ensure we complete the progress */\n\tif (cur_pos != end_pos)\n\t\trefresh_progress_meter();\n\n\tatomicio(vwrite, STDOUT_FILENO, \"\\n\", 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 1758
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: offset < 0\"",
            "__func__"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"In write loop, ack for %u %u bytes at %lld\"",
            "ack->id",
            "ack->len",
            "(long long)ack->offset"
          ],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&acks",
            "ack",
            "tq"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_NEXT",
          "args": [
            "ack",
            "tq"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&acks"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "msg",
            "&status"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "msg",
            "&type"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_msg",
          "args": [
            "conn",
            "msg"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "get_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "170-174",
          "snippet": "static void\nget_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tget_msg_extended(conn, m, 0);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nget_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tget_msg_extended(conn, m, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "msg"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&acks"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_msg",
          "args": [
            "conn",
            "msg"
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "send_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "108-130",
          "snippet": "static void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "msg",
            "data",
            "len"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u64",
          "args": [
            "msg",
            "offset"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "299-309",
          "snippet": "int\nsshbuf_put_u64(struct sshbuf *buf, u_int64_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 8, &p)) < 0)\n\t\treturn r;\n\tPOKE_U64(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u64(struct sshbuf *buf, u_int64_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 8, &p)) < 0)\n\t\treturn r;\n\tPOKE_U64(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "msg",
            "ack->id"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "SSH2_FXP_WRITE"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&acks",
            "ack",
            "tq"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "1",
            "sizeof(*ack)"
          ],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "local_fd",
            "data",
            "conn->transfer_buflen"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "do_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "675-679",
          "snippet": "int\ndo_readdir(struct sftp_conn *conn, const char *path, SFTP_DIRENT ***dir)\n{\n\treturn(do_lsreaddir(conn, path, 0, dir));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_readdir(struct sftp_conn *conn, const char *path, SFTP_DIRENT ***dir)\n{\n\treturn(do_lsreaddir(conn, path, 0, dir));\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_progress_meter",
          "args": [
            "local_path",
            "sb.st_size",
            "&progress_counter"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "start_progress_meter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/progressmeter.c",
          "lines": "249-268",
          "snippet": "void\nstart_progress_meter(const char *f, off_t filesize, off_t *ctr)\n{\n\tstart = last_update = monotime_double();\n\tfile = f;\n\tstart_pos = *ctr;\n\tend_pos = filesize;\n\tcur_pos = 0;\n\tcounter = ctr;\n\tstalled = 0;\n\tbytes_per_second = 0;\n\n\tsetscreensize();\n\tif (can_output())\n\t\trefresh_progress_meter();\n\n\tsignal(SIGALRM, update_progress_meter);\n\tsignal(SIGWINCH, sig_winch);\n\talarm(UPDATE_INTERVAL);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"progressmeter.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define UPDATE_INTERVAL 1\t/* update the progress meter every second */"
          ],
          "globals_used": [
            "static int can_output(void);",
            "static void format_size(char *, int, off_t);",
            "static void format_rate(char *, int, off_t);",
            "static void sig_winch(int);",
            "static void setscreensize(void);",
            "void refresh_progress_meter(void);",
            "static void update_progress_meter(int);",
            "static double start;",
            "static double last_update;",
            "static const char *file;",
            "static off_t start_pos;",
            "static off_t end_pos;",
            "static off_t cur_pos;",
            "static volatile off_t *counter;",
            "static long stalled;",
            "static int bytes_per_second;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"progressmeter.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define UPDATE_INTERVAL 1\t/* update the progress meter every second */\n\nstatic int can_output(void);\nstatic void format_size(char *, int, off_t);\nstatic void format_rate(char *, int, off_t);\nstatic void sig_winch(int);\nstatic void setscreensize(void);\nvoid refresh_progress_meter(void);\nstatic void update_progress_meter(int);\nstatic double start;\nstatic double last_update;\nstatic const char *file;\nstatic off_t start_pos;\nstatic off_t end_pos;\nstatic off_t cur_pos;\nstatic volatile off_t *counter;\nstatic long stalled;\nstatic int bytes_per_second;\n\nvoid\nstart_progress_meter(const char *f, off_t filesize, off_t *ctr)\n{\n\tstart = last_update = monotime_double();\n\tfile = f;\n\tstart_pos = *ctr;\n\tend_pos = filesize;\n\tcur_pos = 0;\n\tcounter = ctr;\n\tstalled = 0;\n\tbytes_per_second = 0;\n\n\tsetscreensize();\n\tif (can_output())\n\t\trefresh_progress_meter();\n\n\tsignal(SIGALRM, update_progress_meter);\n\tsignal(SIGWINCH, sig_winch);\n\talarm(UPDATE_INTERVAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "conn->transfer_buflen"
          ],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_handle",
          "args": [
            "conn",
            "id",
            "&handle_len",
            "\"remote open(\\\"%s\\\")\"",
            "remote_path"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "get_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "243-286",
          "snippet": "static u_char *\nget_handle(struct sftp_conn *conn, u_int expected_id, size_t *len,\n    const char *errfmt, ...)\n{\n\tstruct sshbuf *msg;\n\tu_int id, status;\n\tu_char type;\n\tu_char *handle;\n\tchar errmsg[256];\n\tva_list args;\n\tint r;\n\n\tva_start(args, errfmt);\n\tif (errfmt != NULL)\n\t\tvsnprintf(errmsg, sizeof(errmsg), errfmt, args);\n\tva_end(args);\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"%s: ID mismatch (%u != %u)\",\n\t\t    errfmt == NULL ? __func__ : errmsg, id, expected_id);\n\tif (type == SSH2_FXP_STATUS) {\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (errfmt != NULL)\n\t\t\terror(\"%s: %s\", errmsg, fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn(NULL);\n\t} else if (type != SSH2_FXP_HANDLE)\n\t\tfatal(\"%s: Expected SSH2_FXP_HANDLE(%u) packet, got %u\",\n\t\t    errfmt == NULL ? __func__ : errmsg, SSH2_FXP_HANDLE, type);\n\n\tif ((r = sshbuf_get_string(msg, &handle, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\treturn handle;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic u_char *\nget_handle(struct sftp_conn *conn, u_int expected_id, size_t *len,\n    const char *errfmt, ...)\n{\n\tstruct sshbuf *msg;\n\tu_int id, status;\n\tu_char type;\n\tu_char *handle;\n\tchar errmsg[256];\n\tva_list args;\n\tint r;\n\n\tva_start(args, errfmt);\n\tif (errfmt != NULL)\n\t\tvsnprintf(errmsg, sizeof(errmsg), errfmt, args);\n\tva_end(args);\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"%s: ID mismatch (%u != %u)\",\n\t\t    errfmt == NULL ? __func__ : errmsg, id, expected_id);\n\tif (type == SSH2_FXP_STATUS) {\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (errfmt != NULL)\n\t\t\terror(\"%s: %s\", errmsg, fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn(NULL);\n\t} else if (type != SSH2_FXP_HANDLE)\n\t\tfatal(\"%s: Expected SSH2_FXP_HANDLE(%u) packet, got %u\",\n\t\t    errfmt == NULL ? __func__ : errmsg, SSH2_FXP_HANDLE, type);\n\n\tif ((r = sshbuf_get_string(msg, &handle, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_attrib",
          "args": [
            "msg",
            "&a"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "encode_attrib",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "153-179",
          "snippet": "int\nencode_attrib(struct sshbuf *b, const Attrib *a)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(b, a->flags)) != 0)\n\t\treturn r;\n\tif (a->flags & SSH2_FILEXFER_ATTR_SIZE) {\n\t\tif ((r = sshbuf_put_u64(b, a->size)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {\n\t\tif ((r = sshbuf_put_u32(b, a->uid)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, a->gid)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {\n\t\tif ((r = sshbuf_put_u32(b, a->perm)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {\n\t\tif ((r = sshbuf_put_u32(b, a->atime)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, a->mtime)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nencode_attrib(struct sshbuf *b, const Attrib *a)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(b, a->flags)) != 0)\n\t\treturn r;\n\tif (a->flags & SSH2_FILEXFER_ATTR_SIZE) {\n\t\tif ((r = sshbuf_put_u64(b, a->size)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {\n\t\tif ((r = sshbuf_put_u32(b, a->uid)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, a->gid)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {\n\t\tif ((r = sshbuf_put_u32(b, a->perm)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {\n\t\tif ((r = sshbuf_put_u32(b, a->atime)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, a->mtime)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "msg",
            "remote_path"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "local_fd",
            "(off_t)c->size",
            "SEEK_SET"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_stat",
          "args": [
            "conn",
            "remote_path",
            "0"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "do_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "742-754",
          "snippet": "Attrib *\ndo_stat(struct sftp_conn *conn, const char *path, int quiet)\n{\n\tu_int id;\n\n\tid = conn->msg_id++;\n\n\tsend_string_request(conn, id,\n\t    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT,\n\t    path, strlen(path));\n\n\treturn(get_decode_stat(conn, id, quiet));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nAttrib *\ndo_stat(struct sftp_conn *conn, const char *path, int quiet)\n{\n\tu_int id;\n\n\tid = conn->msg_id++;\n\n\tsend_string_request(conn, id,\n\t    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT,\n\t    path, strlen(path));\n\n\treturn(get_decode_stat(conn, id, quiet));\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat_to_attrib",
          "args": [
            "&sb",
            "&a"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "stat_to_attrib",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "66-81",
          "snippet": "void\nstat_to_attrib(const struct stat *st, Attrib *a)\n{\n\tattrib_clear(a);\n\ta->flags = 0;\n\ta->flags |= SSH2_FILEXFER_ATTR_SIZE;\n\ta->size = st->st_size;\n\ta->flags |= SSH2_FILEXFER_ATTR_UIDGID;\n\ta->uid = st->st_uid;\n\ta->gid = st->st_gid;\n\ta->flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;\n\ta->perm = st->st_mode;\n\ta->flags |= SSH2_FILEXFER_ATTR_ACMODTIME;\n\ta->atime = st->st_atime;\n\ta->mtime = st->st_mtime;\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nstat_to_attrib(const struct stat *st, Attrib *a)\n{\n\tattrib_clear(a);\n\ta->flags = 0;\n\ta->flags |= SSH2_FILEXFER_ATTR_SIZE;\n\ta->size = st->st_size;\n\ta->flags |= SSH2_FILEXFER_ATTR_UIDGID;\n\ta->uid = st->st_uid;\n\ta->gid = st->st_gid;\n\ta->flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;\n\ta->perm = st->st_mode;\n\ta->flags |= SSH2_FILEXFER_ATTR_ACMODTIME;\n\ta->atime = st->st_atime;\n\ta->mtime = st->st_mtime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "sb.st_mode"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "local_fd",
            "&sb"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "fstatvfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-statvfs.c",
          "lines": "71-85",
          "snippet": "int fstatvfs(int fd, struct statvfs *buf)\n{\n#  ifdef HAVE_FSTATFS\n\tstruct statfs fs;\n\n\tmemset(&fs, 0, sizeof(fs));\n\tif (fstatfs(fd, &fs) == -1)\n\t\treturn -1;\n\tcopy_statfs_to_statvfs(buf, &fs);\n\treturn 0;\n#  else\n\terrno = ENOSYS;\n\treturn -1;\n#  endif\n}",
          "includes": [
            "#include <errno.h>",
            "# include <sys/mount.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n# include <sys/mount.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nint fstatvfs(int fd, struct statvfs *buf)\n{\n#  ifdef HAVE_FSTATFS\n\tstruct statfs fs;\n\n\tmemset(&fs, 0, sizeof(fs));\n\tif (fstatfs(fd, &fs) == -1)\n\t\treturn -1;\n\tcopy_statfs_to_statvfs(buf, &fs);\n\treturn 0;\n#  else\n\terrno = ENOSYS;\n\treturn -1;\n#  endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "local_path",
            "O_RDONLY",
            "0"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "lastlog_openseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/loginrec.c",
          "lines": "1471-1514",
          "snippet": "static int\nlastlog_openseek(struct logininfo *li, int *fd, int filemode)\n{\n\toff_t offset;\n\tchar lastlog_file[1024];\n\tstruct stat st;\n\n\tif (stat(LASTLOG_FILE, &st) != 0) {\n\t\tlogit(\"%s: Couldn't stat %s: %s\", __func__,\n\t\t    LASTLOG_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (S_ISDIR(st.st_mode)) {\n\t\tsnprintf(lastlog_file, sizeof(lastlog_file), \"%s/%s\",\n\t\t    LASTLOG_FILE, li->username);\n\t} else if (S_ISREG(st.st_mode)) {\n\t\tstrlcpy(lastlog_file, LASTLOG_FILE, sizeof(lastlog_file));\n\t} else {\n\t\tlogit(\"%s: %.100s is not a file or directory!\", __func__,\n\t\t    LASTLOG_FILE);\n\t\treturn (0);\n\t}\n\n\t*fd = open(lastlog_file, filemode, 0600);\n\tif (*fd < 0) {\n\t\tdebug(\"%s: Couldn't open %s: %s\", __func__,\n\t\t    lastlog_file, strerror(errno));\n\t\treturn (0);\n\t}\n\n\tif (S_ISREG(st.st_mode)) {\n\t\t/* find this uid's offset in the lastlog file */\n\t\toffset = (off_t) ((u_long)li->uid * sizeof(struct lastlog));\n\n\t\tif (lseek(*fd, offset, SEEK_SET) != offset) {\n\t\t\tlogit(\"%s: %s->lseek(): %s\", __func__,\n\t\t\t    lastlog_file, strerror(errno));\n\t\t\tclose(*fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}",
          "includes": [
            "# include <util.h>",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"canohost.h\"",
            "#include \"packet.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"loginrec.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int utmp_write_entry(struct logininfo *li);",
            "int utmpx_write_entry(struct logininfo *li);",
            "int wtmp_write_entry(struct logininfo *li);",
            "int wtmpx_write_entry(struct logininfo *li);",
            "int lastlog_write_entry(struct logininfo *li);",
            "int syslogin_write_entry(struct logininfo *li);",
            "int getlast_entry(struct logininfo *li);",
            "int lastlog_get_entry(struct logininfo *li);",
            "int utmpx_get_entry(struct logininfo *li);",
            "int wtmp_get_entry(struct logininfo *li);",
            "int wtmpx_get_entry(struct logininfo *li);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <util.h>\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"canohost.h\"\n#include \"packet.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"loginrec.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint utmp_write_entry(struct logininfo *li);\nint utmpx_write_entry(struct logininfo *li);\nint wtmp_write_entry(struct logininfo *li);\nint wtmpx_write_entry(struct logininfo *li);\nint lastlog_write_entry(struct logininfo *li);\nint syslogin_write_entry(struct logininfo *li);\nint getlast_entry(struct logininfo *li);\nint lastlog_get_entry(struct logininfo *li);\nint utmpx_get_entry(struct logininfo *li);\nint wtmp_get_entry(struct logininfo *li);\nint wtmpx_get_entry(struct logininfo *li);\n\nstatic int\nlastlog_openseek(struct logininfo *li, int *fd, int filemode)\n{\n\toff_t offset;\n\tchar lastlog_file[1024];\n\tstruct stat st;\n\n\tif (stat(LASTLOG_FILE, &st) != 0) {\n\t\tlogit(\"%s: Couldn't stat %s: %s\", __func__,\n\t\t    LASTLOG_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (S_ISDIR(st.st_mode)) {\n\t\tsnprintf(lastlog_file, sizeof(lastlog_file), \"%s/%s\",\n\t\t    LASTLOG_FILE, li->username);\n\t} else if (S_ISREG(st.st_mode)) {\n\t\tstrlcpy(lastlog_file, LASTLOG_FILE, sizeof(lastlog_file));\n\t} else {\n\t\tlogit(\"%s: %.100s is not a file or directory!\", __func__,\n\t\t    LASTLOG_FILE);\n\t\treturn (0);\n\t}\n\n\t*fd = open(lastlog_file, filemode, 0600);\n\tif (*fd < 0) {\n\t\tdebug(\"%s: Couldn't open %s: %s\", __func__,\n\t\t    lastlog_file, strerror(errno));\n\t\treturn (0);\n\t}\n\n\tif (S_ISREG(st.st_mode)) {\n\t\t/* find this uid's offset in the lastlog file */\n\t\toffset = (off_t) ((u_long)li->uid * sizeof(struct lastlog));\n\n\t\tif (lseek(*fd, offset, SEEK_SET) != offset) {\n\t\t\tlogit(\"%s: %s->lseek(): %s\", __func__,\n\t\t\t    lastlog_file, strerror(errno));\n\t\t\tclose(*fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&acks"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_HEAD",
          "args": [
            "ackhead",
            "outstanding_ack"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern volatile sig_atomic_t interrupted;\nextern int showprogress;\n\nint\ndo_upload(struct sftp_conn *conn, const char *local_path,\n    const char *remote_path, int preserve_flag, int resume, int fsync_flag)\n{\n\tint r, local_fd;\n\tu_int status = SSH2_FX_OK;\n\tu_int id;\n\tu_char type;\n\toff_t offset, progress_counter;\n\tu_char *handle, *data;\n\tstruct sshbuf *msg;\n\tstruct stat sb;\n\tAttrib a, *c = NULL;\n\tu_int32_t startid;\n\tu_int32_t ackid;\n\tstruct outstanding_ack {\n\t\tu_int id;\n\t\tu_int len;\n\t\toff_t offset;\n\t\tTAILQ_ENTRY(outstanding_ack) tq;\n\t};\n\tTAILQ_HEAD(ackhead, outstanding_ack) acks;\n\tstruct outstanding_ack *ack = NULL;\n\tsize_t handle_len;\n\n\tTAILQ_INIT(&acks);\n\n\tif ((local_fd = open(local_path, O_RDONLY, 0)) == -1) {\n\t\terror(\"Couldn't open local file \\\"%s\\\" for reading: %s\",\n\t\t    local_path, strerror(errno));\n\t\treturn(-1);\n\t}\n\tif (fstat(local_fd, &sb) == -1) {\n\t\terror(\"Couldn't fstat local file \\\"%s\\\": %s\",\n\t\t    local_path, strerror(errno));\n\t\tclose(local_fd);\n\t\treturn(-1);\n\t}\n\tif (!S_ISREG(sb.st_mode)) {\n\t\terror(\"%s is not a regular file\", local_path);\n\t\tclose(local_fd);\n\t\treturn(-1);\n\t}\n\tstat_to_attrib(&sb, &a);\n\n\ta.flags &= ~SSH2_FILEXFER_ATTR_SIZE;\n\ta.flags &= ~SSH2_FILEXFER_ATTR_UIDGID;\n\ta.perm &= 0777;\n\tif (!preserve_flag)\n\t\ta.flags &= ~SSH2_FILEXFER_ATTR_ACMODTIME;\n\n\tif (resume) {\n\t\t/* Get remote file size if it exists */\n\t\tif ((c = do_stat(conn, remote_path, 0)) == NULL) {\n\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((off_t)c->size >= sb.st_size) {\n\t\t\terror(\"destination file bigger or same size as \"\n\t\t\t      \"source file\");\n\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (lseek(local_fd, (off_t)c->size, SEEK_SET) == -1) {\n\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\t/* Send open request */\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_OPEN)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, remote_path)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, SSH2_FXF_WRITE|SSH2_FXF_CREAT|\n\t    (resume ? SSH2_FXF_APPEND : SSH2_FXF_TRUNC))) != 0 ||\n\t    (r = encode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message SSH2_FXP_OPEN I:%u P:%s\", id, remote_path);\n\n\tsshbuf_reset(msg);\n\n\thandle = get_handle(conn, id, &handle_len,\n\t    \"remote open(\\\"%s\\\")\", remote_path);\n\tif (handle == NULL) {\n\t\tclose(local_fd);\n\t\tsshbuf_free(msg);\n\t\treturn -1;\n\t}\n\n\tstartid = ackid = id + 1;\n\tdata = xmalloc(conn->transfer_buflen);\n\n\t/* Read from local and write to remote */\n\toffset = progress_counter = (resume ? c->size : 0);\n\tif (showprogress)\n\t\tstart_progress_meter(local_path, sb.st_size,\n\t\t    &progress_counter);\n\n\tfor (;;) {\n\t\tint len;\n\n\t\t/*\n\t\t * Can't use atomicio here because it returns 0 on EOF,\n\t\t * thus losing the last block of the file.\n\t\t * Simulate an EOF on interrupt, allowing ACKs from the\n\t\t * server to drain.\n\t\t */\n\t\tif (interrupted || status != SSH2_FX_OK)\n\t\t\tlen = 0;\n\t\telse do\n\t\t\tlen = read(local_fd, data, conn->transfer_buflen);\n\t\twhile ((len == -1) &&\n\t\t    (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK));\n\n\t\tif (len == -1)\n\t\t\tfatal(\"Couldn't read from \\\"%s\\\": %s\", local_path,\n\t\t\t    strerror(errno));\n\n\t\tif (len != 0) {\n\t\t\tack = xcalloc(1, sizeof(*ack));\n\t\t\tack->id = ++id;\n\t\t\tack->offset = offset;\n\t\t\tack->len = len;\n\t\t\tTAILQ_INSERT_TAIL(&acks, ack, tq);\n\n\t\t\tsshbuf_reset(msg);\n\t\t\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_WRITE)) != 0 ||\n\t\t\t    (r = sshbuf_put_u32(msg, ack->id)) != 0 ||\n\t\t\t    (r = sshbuf_put_string(msg, handle,\n\t\t\t    handle_len)) != 0 ||\n\t\t\t    (r = sshbuf_put_u64(msg, offset)) != 0 ||\n\t\t\t    (r = sshbuf_put_string(msg, data, len)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tsend_msg(conn, msg);\n\t\t\tdebug3(\"Sent message SSH2_FXP_WRITE I:%u O:%llu S:%u\",\n\t\t\t    id, (unsigned long long)offset, len);\n\t\t} else if (TAILQ_FIRST(&acks) == NULL)\n\t\t\tbreak;\n\n\t\tif (ack == NULL)\n\t\t\tfatal(\"Unexpected ACK %u\", id);\n\n\t\tif (id == startid || len == 0 ||\n\t\t    id - ackid >= conn->num_requests) {\n\t\t\tu_int rid;\n\n\t\t\tsshbuf_reset(msg);\n\t\t\tget_msg(conn, msg);\n\t\t\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t\t\t    (r = sshbuf_get_u32(msg, &rid)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\n\t\t\tif (type != SSH2_FXP_STATUS)\n\t\t\t\tfatal(\"Expected SSH2_FXP_STATUS(%d) packet, \"\n\t\t\t\t    \"got %d\", SSH2_FXP_STATUS, type);\n\n\t\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\t\t\t/* Find the request in our queue */\n\t\t\tfor (ack = TAILQ_FIRST(&acks);\n\t\t\t    ack != NULL && ack->id != rid;\n\t\t\t    ack = TAILQ_NEXT(ack, tq))\n\t\t\t\t;\n\t\t\tif (ack == NULL)\n\t\t\t\tfatal(\"Can't find request for ID %u\", rid);\n\t\t\tTAILQ_REMOVE(&acks, ack, tq);\n\t\t\tdebug3(\"In write loop, ack for %u %u bytes at %lld\",\n\t\t\t    ack->id, ack->len, (long long)ack->offset);\n\t\t\t++ackid;\n\t\t\tprogress_counter += ack->len;\n\t\t\tfree(ack);\n\t\t}\n\t\toffset += len;\n\t\tif (offset < 0)\n\t\t\tfatal(\"%s: offset < 0\", __func__);\n\t}\n\tsshbuf_free(msg);\n\n\tif (showprogress)\n\t\tstop_progress_meter();\n\tfree(data);\n\n\tif (status != SSH2_FX_OK) {\n\t\terror(\"Couldn't write to remote file \\\"%s\\\": %s\",\n\t\t    remote_path, fx2txt(status));\n\t\tstatus = SSH2_FX_FAILURE;\n\t}\n\n\tif (close(local_fd) == -1) {\n\t\terror(\"Couldn't close local file \\\"%s\\\": %s\", local_path,\n\t\t    strerror(errno));\n\t\tstatus = SSH2_FX_FAILURE;\n\t}\n\n\t/* Override umask and utimes if asked */\n\tif (preserve_flag)\n\t\tdo_fsetstat(conn, handle, handle_len, &a);\n\n\tif (fsync_flag)\n\t\t(void)do_fsync(conn, handle, handle_len);\n\n\tif (do_close(conn, handle, handle_len) != 0)\n\t\tstatus = SSH2_FX_FAILURE;\n\n\tfree(handle);\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
  },
  {
    "function_name": "download_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "1551-1568",
    "snippet": "int\ndownload_dir(struct sftp_conn *conn, const char *src, const char *dst,\n    Attrib *dirattrib, int preserve_flag, int print_flag, int resume_flag,\n    int fsync_flag)\n{\n\tchar *src_canon;\n\tint ret;\n\n\tif ((src_canon = do_realpath(conn, src)) == NULL) {\n\t\terror(\"Unable to canonicalize path \\\"%s\\\"\", src);\n\t\treturn -1;\n\t}\n\n\tret = download_dir_internal(conn, src_canon, dst, 0,\n\t    dirattrib, preserve_flag, print_flag, resume_flag, fsync_flag);\n\tfree(src_canon);\n\treturn ret;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "src_canon"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "free_sftp_dirents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "681-693",
          "snippet": "void free_sftp_dirents(SFTP_DIRENT **s)\n{\n\tint i;\n\n\tif (s == NULL)\n\t\treturn;\n\tfor (i = 0; s[i]; i++) {\n\t\tfree(s[i]->filename);\n\t\tfree(s[i]->longname);\n\t\tfree(s[i]);\n\t}\n\tfree(s);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid free_sftp_dirents(SFTP_DIRENT **s)\n{\n\tint i;\n\n\tif (s == NULL)\n\t\treturn;\n\tfor (i = 0; s[i]; i++) {\n\t\tfree(s[i]->filename);\n\t\tfree(s[i]->longname);\n\t\tfree(s[i]);\n\t}\n\tfree(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "download_dir_internal",
          "args": [
            "conn",
            "src_canon",
            "dst",
            "0",
            "dirattrib",
            "preserve_flag",
            "print_flag",
            "resume_flag",
            "fsync_flag"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "download_dir_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "1457-1549",
          "snippet": "static int\ndownload_dir_internal(struct sftp_conn *conn, const char *src, const char *dst,\n    int depth, Attrib *dirattrib, int preserve_flag, int print_flag,\n    int resume_flag, int fsync_flag)\n{\n\tint i, ret = 0;\n\tSFTP_DIRENT **dir_entries;\n\tchar *filename, *new_src = NULL, *new_dst = NULL;\n\tmode_t mode = 0777;\n\n\tif (depth >= MAX_DIR_DEPTH) {\n\t\terror(\"Maximum directory depth exceeded: %d levels\", depth);\n\t\treturn -1;\n\t}\n\n\tif (dirattrib == NULL &&\n\t    (dirattrib = do_stat(conn, src, 1)) == NULL) {\n\t\terror(\"Unable to stat remote directory \\\"%s\\\"\", src);\n\t\treturn -1;\n\t}\n\tif (!S_ISDIR(dirattrib->perm)) {\n\t\terror(\"\\\"%s\\\" is not a directory\", src);\n\t\treturn -1;\n\t}\n\tif (print_flag)\n\t\tmprintf(\"Retrieving %s\\n\", src);\n\n\tif (dirattrib->flags & SSH2_FILEXFER_ATTR_PERMISSIONS)\n\t\tmode = dirattrib->perm & 01777;\n\telse {\n\t\tdebug(\"Server did not send permissions for \"\n\t\t    \"directory \\\"%s\\\"\", dst);\n\t}\n\n\tif (mkdir(dst, mode) == -1 && errno != EEXIST) {\n\t\terror(\"mkdir %s: %s\", dst, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (do_readdir(conn, src, &dir_entries) == -1) {\n\t\terror(\"%s: Failed to get directory contents\", src);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; dir_entries[i] != NULL && !interrupted; i++) {\n\t\tfree(new_dst);\n\t\tfree(new_src);\n\n\t\tfilename = dir_entries[i]->filename;\n\t\tnew_dst = path_append(dst, filename);\n\t\tnew_src = path_append(src, filename);\n\n\t\tif (S_ISDIR(dir_entries[i]->a.perm)) {\n\t\t\tif (strcmp(filename, \".\") == 0 ||\n\t\t\t    strcmp(filename, \"..\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (download_dir_internal(conn, new_src, new_dst,\n\t\t\t    depth + 1, &(dir_entries[i]->a), preserve_flag,\n\t\t\t    print_flag, resume_flag, fsync_flag) == -1)\n\t\t\t\tret = -1;\n\t\t} else if (S_ISREG(dir_entries[i]->a.perm) ) {\n\t\t\tif (do_download(conn, new_src, new_dst,\n\t\t\t    &(dir_entries[i]->a), preserve_flag,\n\t\t\t    resume_flag, fsync_flag) == -1) {\n\t\t\t\terror(\"Download of file %s to %s failed\",\n\t\t\t\t    new_src, new_dst);\n\t\t\t\tret = -1;\n\t\t\t}\n\t\t} else\n\t\t\tlogit(\"%s: not a regular file\\n\", new_src);\n\n\t}\n\tfree(new_dst);\n\tfree(new_src);\n\n\tif (preserve_flag) {\n\t\tif (dirattrib->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {\n\t\t\tstruct timeval tv[2];\n\t\t\ttv[0].tv_sec = dirattrib->atime;\n\t\t\ttv[1].tv_sec = dirattrib->mtime;\n\t\t\ttv[0].tv_usec = tv[1].tv_usec = 0;\n\t\t\tif (utimes(dst, tv) == -1)\n\t\t\t\terror(\"Can't set times on \\\"%s\\\": %s\",\n\t\t\t\t    dst, strerror(errno));\n\t\t} else\n\t\t\tdebug(\"Server did not send times for directory \"\n\t\t\t    \"\\\"%s\\\"\", dst);\n\t}\n\n\tfree_sftp_dirents(dir_entries);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MAX_DIR_DEPTH 64"
          ],
          "globals_used": [
            "extern volatile sig_atomic_t interrupted;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MAX_DIR_DEPTH 64\n\nextern volatile sig_atomic_t interrupted;\n\nstatic int\ndownload_dir_internal(struct sftp_conn *conn, const char *src, const char *dst,\n    int depth, Attrib *dirattrib, int preserve_flag, int print_flag,\n    int resume_flag, int fsync_flag)\n{\n\tint i, ret = 0;\n\tSFTP_DIRENT **dir_entries;\n\tchar *filename, *new_src = NULL, *new_dst = NULL;\n\tmode_t mode = 0777;\n\n\tif (depth >= MAX_DIR_DEPTH) {\n\t\terror(\"Maximum directory depth exceeded: %d levels\", depth);\n\t\treturn -1;\n\t}\n\n\tif (dirattrib == NULL &&\n\t    (dirattrib = do_stat(conn, src, 1)) == NULL) {\n\t\terror(\"Unable to stat remote directory \\\"%s\\\"\", src);\n\t\treturn -1;\n\t}\n\tif (!S_ISDIR(dirattrib->perm)) {\n\t\terror(\"\\\"%s\\\" is not a directory\", src);\n\t\treturn -1;\n\t}\n\tif (print_flag)\n\t\tmprintf(\"Retrieving %s\\n\", src);\n\n\tif (dirattrib->flags & SSH2_FILEXFER_ATTR_PERMISSIONS)\n\t\tmode = dirattrib->perm & 01777;\n\telse {\n\t\tdebug(\"Server did not send permissions for \"\n\t\t    \"directory \\\"%s\\\"\", dst);\n\t}\n\n\tif (mkdir(dst, mode) == -1 && errno != EEXIST) {\n\t\terror(\"mkdir %s: %s\", dst, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (do_readdir(conn, src, &dir_entries) == -1) {\n\t\terror(\"%s: Failed to get directory contents\", src);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; dir_entries[i] != NULL && !interrupted; i++) {\n\t\tfree(new_dst);\n\t\tfree(new_src);\n\n\t\tfilename = dir_entries[i]->filename;\n\t\tnew_dst = path_append(dst, filename);\n\t\tnew_src = path_append(src, filename);\n\n\t\tif (S_ISDIR(dir_entries[i]->a.perm)) {\n\t\t\tif (strcmp(filename, \".\") == 0 ||\n\t\t\t    strcmp(filename, \"..\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (download_dir_internal(conn, new_src, new_dst,\n\t\t\t    depth + 1, &(dir_entries[i]->a), preserve_flag,\n\t\t\t    print_flag, resume_flag, fsync_flag) == -1)\n\t\t\t\tret = -1;\n\t\t} else if (S_ISREG(dir_entries[i]->a.perm) ) {\n\t\t\tif (do_download(conn, new_src, new_dst,\n\t\t\t    &(dir_entries[i]->a), preserve_flag,\n\t\t\t    resume_flag, fsync_flag) == -1) {\n\t\t\t\terror(\"Download of file %s to %s failed\",\n\t\t\t\t    new_src, new_dst);\n\t\t\t\tret = -1;\n\t\t\t}\n\t\t} else\n\t\t\tlogit(\"%s: not a regular file\\n\", new_src);\n\n\t}\n\tfree(new_dst);\n\tfree(new_src);\n\n\tif (preserve_flag) {\n\t\tif (dirattrib->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {\n\t\t\tstruct timeval tv[2];\n\t\t\ttv[0].tv_sec = dirattrib->atime;\n\t\t\ttv[1].tv_sec = dirattrib->mtime;\n\t\t\ttv[0].tv_usec = tv[1].tv_usec = 0;\n\t\t\tif (utimes(dst, tv) == -1)\n\t\t\t\terror(\"Can't set times on \\\"%s\\\": %s\",\n\t\t\t\t    dst, strerror(errno));\n\t\t} else\n\t\t\tdebug(\"Server did not send times for directory \"\n\t\t\t    \"\\\"%s\\\"\", dst);\n\t}\n\n\tfree_sftp_dirents(dir_entries);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Unable to canonicalize path \\\"%s\\\"\"",
            "src"
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_realpath",
          "args": [
            "conn",
            "src"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "do_realpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "825-880",
          "snippet": "char *\ndo_realpath(struct sftp_conn *conn, const char *path)\n{\n\tstruct sshbuf *msg;\n\tu_int expected_id, count, id;\n\tchar *filename, *longname;\n\tAttrib a;\n\tu_char type;\n\tint r;\n\n\texpected_id = id = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_REALPATH, path,\n\t    strlen(path));\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\terror(\"Couldn't canonicalize: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn NULL;\n\t} else if (type != SSH2_FXP_NAME)\n\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t    SSH2_FXP_NAME, type);\n\n\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (count != 1)\n\t\tfatal(\"Got multiple names (%d) from SSH_FXP_REALPATH\", count);\n\n\tif ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||\n\t    (r = decode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"SSH_FXP_REALPATH %s -> %s size %lu\", path, filename,\n\t    (unsigned long)a.size);\n\n\tfree(longname);\n\n\tsshbuf_free(msg);\n\n\treturn(filename);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ndo_realpath(struct sftp_conn *conn, const char *path)\n{\n\tstruct sshbuf *msg;\n\tu_int expected_id, count, id;\n\tchar *filename, *longname;\n\tAttrib a;\n\tu_char type;\n\tint r;\n\n\texpected_id = id = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_REALPATH, path,\n\t    strlen(path));\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\terror(\"Couldn't canonicalize: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn NULL;\n\t} else if (type != SSH2_FXP_NAME)\n\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t    SSH2_FXP_NAME, type);\n\n\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (count != 1)\n\t\tfatal(\"Got multiple names (%d) from SSH_FXP_REALPATH\", count);\n\n\tif ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||\n\t    (r = decode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"SSH_FXP_REALPATH %s -> %s size %lu\", path, filename,\n\t    (unsigned long)a.size);\n\n\tfree(longname);\n\n\tsshbuf_free(msg);\n\n\treturn(filename);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndownload_dir(struct sftp_conn *conn, const char *src, const char *dst,\n    Attrib *dirattrib, int preserve_flag, int print_flag, int resume_flag,\n    int fsync_flag)\n{\n\tchar *src_canon;\n\tint ret;\n\n\tif ((src_canon = do_realpath(conn, src)) == NULL) {\n\t\terror(\"Unable to canonicalize path \\\"%s\\\"\", src);\n\t\treturn -1;\n\t}\n\n\tret = download_dir_internal(conn, src_canon, dst, 0,\n\t    dirattrib, preserve_flag, print_flag, resume_flag, fsync_flag);\n\tfree(src_canon);\n\treturn ret;\n}"
  },
  {
    "function_name": "download_dir_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "1457-1549",
    "snippet": "static int\ndownload_dir_internal(struct sftp_conn *conn, const char *src, const char *dst,\n    int depth, Attrib *dirattrib, int preserve_flag, int print_flag,\n    int resume_flag, int fsync_flag)\n{\n\tint i, ret = 0;\n\tSFTP_DIRENT **dir_entries;\n\tchar *filename, *new_src = NULL, *new_dst = NULL;\n\tmode_t mode = 0777;\n\n\tif (depth >= MAX_DIR_DEPTH) {\n\t\terror(\"Maximum directory depth exceeded: %d levels\", depth);\n\t\treturn -1;\n\t}\n\n\tif (dirattrib == NULL &&\n\t    (dirattrib = do_stat(conn, src, 1)) == NULL) {\n\t\terror(\"Unable to stat remote directory \\\"%s\\\"\", src);\n\t\treturn -1;\n\t}\n\tif (!S_ISDIR(dirattrib->perm)) {\n\t\terror(\"\\\"%s\\\" is not a directory\", src);\n\t\treturn -1;\n\t}\n\tif (print_flag)\n\t\tmprintf(\"Retrieving %s\\n\", src);\n\n\tif (dirattrib->flags & SSH2_FILEXFER_ATTR_PERMISSIONS)\n\t\tmode = dirattrib->perm & 01777;\n\telse {\n\t\tdebug(\"Server did not send permissions for \"\n\t\t    \"directory \\\"%s\\\"\", dst);\n\t}\n\n\tif (mkdir(dst, mode) == -1 && errno != EEXIST) {\n\t\terror(\"mkdir %s: %s\", dst, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (do_readdir(conn, src, &dir_entries) == -1) {\n\t\terror(\"%s: Failed to get directory contents\", src);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; dir_entries[i] != NULL && !interrupted; i++) {\n\t\tfree(new_dst);\n\t\tfree(new_src);\n\n\t\tfilename = dir_entries[i]->filename;\n\t\tnew_dst = path_append(dst, filename);\n\t\tnew_src = path_append(src, filename);\n\n\t\tif (S_ISDIR(dir_entries[i]->a.perm)) {\n\t\t\tif (strcmp(filename, \".\") == 0 ||\n\t\t\t    strcmp(filename, \"..\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (download_dir_internal(conn, new_src, new_dst,\n\t\t\t    depth + 1, &(dir_entries[i]->a), preserve_flag,\n\t\t\t    print_flag, resume_flag, fsync_flag) == -1)\n\t\t\t\tret = -1;\n\t\t} else if (S_ISREG(dir_entries[i]->a.perm) ) {\n\t\t\tif (do_download(conn, new_src, new_dst,\n\t\t\t    &(dir_entries[i]->a), preserve_flag,\n\t\t\t    resume_flag, fsync_flag) == -1) {\n\t\t\t\terror(\"Download of file %s to %s failed\",\n\t\t\t\t    new_src, new_dst);\n\t\t\t\tret = -1;\n\t\t\t}\n\t\t} else\n\t\t\tlogit(\"%s: not a regular file\\n\", new_src);\n\n\t}\n\tfree(new_dst);\n\tfree(new_src);\n\n\tif (preserve_flag) {\n\t\tif (dirattrib->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {\n\t\t\tstruct timeval tv[2];\n\t\t\ttv[0].tv_sec = dirattrib->atime;\n\t\t\ttv[1].tv_sec = dirattrib->mtime;\n\t\t\ttv[0].tv_usec = tv[1].tv_usec = 0;\n\t\t\tif (utimes(dst, tv) == -1)\n\t\t\t\terror(\"Can't set times on \\\"%s\\\": %s\",\n\t\t\t\t    dst, strerror(errno));\n\t\t} else\n\t\t\tdebug(\"Server did not send times for directory \"\n\t\t\t    \"\\\"%s\\\"\", dst);\n\t}\n\n\tfree_sftp_dirents(dir_entries);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MAX_DIR_DEPTH 64"
    ],
    "globals_used": [
      "extern volatile sig_atomic_t interrupted;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_sftp_dirents",
          "args": [
            "dir_entries"
          ],
          "line": 1546
        },
        "resolved": true,
        "details": {
          "function_name": "free_sftp_dirents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "681-693",
          "snippet": "void free_sftp_dirents(SFTP_DIRENT **s)\n{\n\tint i;\n\n\tif (s == NULL)\n\t\treturn;\n\tfor (i = 0; s[i]; i++) {\n\t\tfree(s[i]->filename);\n\t\tfree(s[i]->longname);\n\t\tfree(s[i]);\n\t}\n\tfree(s);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid free_sftp_dirents(SFTP_DIRENT **s)\n{\n\tint i;\n\n\tif (s == NULL)\n\t\treturn;\n\tfor (i = 0; s[i]; i++) {\n\t\tfree(s[i]->filename);\n\t\tfree(s[i]->longname);\n\t\tfree(s[i]);\n\t}\n\tfree(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Server did not send times for directory \"\n\t\t\t    \"\\\"%s\\\"\"",
            "dst"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Can't set times on \\\"%s\\\": %s\"",
            "dst",
            "strerror(errno)"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "utimes",
          "args": [
            "dst",
            "tv"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "utimes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "109-117",
          "snippet": "int utimes(char *filename, struct timeval *tvp)\n{\n\tstruct utimbuf ub;\n\n\tub.actime = tvp[0].tv_sec;\n\tub.modtime = tvp[1].tv_sec;\n\n\treturn (utime(filename, &ub));\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint utimes(char *filename, struct timeval *tvp)\n{\n\tstruct utimbuf ub;\n\n\tub.actime = tvp[0].tv_sec;\n\tub.modtime = tvp[1].tv_sec;\n\n\treturn (utime(filename, &ub));\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"%s: not a regular file\\n\"",
            "new_src"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_download",
          "args": [
            "conn",
            "new_src",
            "new_dst",
            "&(dir_entries[i]->a)",
            "preserve_flag",
            "resume_flag",
            "fsync_flag"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "do_download",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "1161-1455",
          "snippet": "int\ndo_download(struct sftp_conn *conn, const char *remote_path,\n    const char *local_path, Attrib *a, int preserve_flag, int resume_flag,\n    int fsync_flag)\n{\n\tAttrib junk;\n\tstruct sshbuf *msg;\n\tu_char *handle;\n\tint local_fd = -1, write_error;\n\tint read_error, write_errno, reordered = 0, r;\n\tu_int64_t offset = 0, size, highwater;\n\tu_int mode, id, buflen, num_req, max_req, status = SSH2_FX_OK;\n\toff_t progress_counter;\n\tsize_t handle_len;\n\tstruct stat st;\n\tstruct request {\n\t\tu_int id;\n\t\tsize_t len;\n\t\tu_int64_t offset;\n\t\tTAILQ_ENTRY(request) tq;\n\t};\n\tTAILQ_HEAD(reqhead, request) requests;\n\tstruct request *req;\n\tu_char type;\n\n\tTAILQ_INIT(&requests);\n\n\tif (a == NULL && (a = do_stat(conn, remote_path, 0)) == NULL)\n\t\treturn -1;\n\n\t/* Do not preserve set[ug]id here, as we do not preserve ownership */\n\tif (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS)\n\t\tmode = a->perm & 0777;\n\telse\n\t\tmode = 0666;\n\n\tif ((a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) &&\n\t    (!S_ISREG(a->perm))) {\n\t\terror(\"Cannot download non-regular file: %s\", remote_path);\n\t\treturn(-1);\n\t}\n\n\tif (a->flags & SSH2_FILEXFER_ATTR_SIZE)\n\t\tsize = a->size;\n\telse\n\t\tsize = 0;\n\n\tbuflen = conn->transfer_buflen;\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tattrib_clear(&junk); /* Send empty attributes */\n\n\t/* Send open request */\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_OPEN)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, remote_path)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, SSH2_FXF_READ)) != 0 ||\n\t    (r = encode_attrib(msg, &junk)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message SSH2_FXP_OPEN I:%u P:%s\", id, remote_path);\n\n\thandle = get_handle(conn, id, &handle_len,\n\t    \"remote open(\\\"%s\\\")\", remote_path);\n\tif (handle == NULL) {\n\t\tsshbuf_free(msg);\n\t\treturn(-1);\n\t}\n\n\tlocal_fd = open(local_path,\n\t    O_WRONLY | O_CREAT | (resume_flag ? 0 : O_TRUNC), mode | S_IWUSR);\n\tif (local_fd == -1) {\n\t\terror(\"Couldn't open local file \\\"%s\\\" for writing: %s\",\n\t\t    local_path, strerror(errno));\n\t\tgoto fail;\n\t}\n\toffset = highwater = 0;\n\tif (resume_flag) {\n\t\tif (fstat(local_fd, &st) == -1) {\n\t\t\terror(\"Unable to stat local file \\\"%s\\\": %s\",\n\t\t\t    local_path, strerror(errno));\n\t\t\tgoto fail;\n\t\t}\n\t\tif (st.st_size < 0) {\n\t\t\terror(\"\\\"%s\\\" has negative size\", local_path);\n\t\t\tgoto fail;\n\t\t}\n\t\tif ((u_int64_t)st.st_size > size) {\n\t\t\terror(\"Unable to resume download of \\\"%s\\\": \"\n\t\t\t    \"local file is larger than remote\", local_path);\n fail:\n\t\t\tdo_close(conn, handle, handle_len);\n\t\t\tsshbuf_free(msg);\n\t\t\tfree(handle);\n\t\t\tif (local_fd != -1)\n\t\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\t\toffset = highwater = st.st_size;\n\t}\n\n\t/* Read from remote and write to local */\n\twrite_error = read_error = write_errno = num_req = 0;\n\tmax_req = 1;\n\tprogress_counter = offset;\n\n\tif (showprogress && size != 0)\n\t\tstart_progress_meter(remote_path, size, &progress_counter);\n\n\twhile (num_req > 0 || max_req > 0) {\n\t\tu_char *data;\n\t\tsize_t len;\n\n\t\t/*\n\t\t * Simulate EOF on interrupt: stop sending new requests and\n\t\t * allow outstanding requests to drain gracefully\n\t\t */\n\t\tif (interrupted) {\n\t\t\tif (num_req == 0) /* If we haven't started yet... */\n\t\t\t\tbreak;\n\t\t\tmax_req = 0;\n\t\t}\n\n\t\t/* Send some more requests */\n\t\twhile (num_req < max_req) {\n\t\t\tdebug3(\"Request range %llu -> %llu (%d/%d)\",\n\t\t\t    (unsigned long long)offset,\n\t\t\t    (unsigned long long)offset + buflen - 1,\n\t\t\t    num_req, max_req);\n\t\t\treq = xcalloc(1, sizeof(*req));\n\t\t\treq->id = conn->msg_id++;\n\t\t\treq->len = buflen;\n\t\t\treq->offset = offset;\n\t\t\toffset += buflen;\n\t\t\tnum_req++;\n\t\t\tTAILQ_INSERT_TAIL(&requests, req, tq);\n\t\t\tsend_read_request(conn, req->id, req->offset,\n\t\t\t    req->len, handle, handle_len);\n\t\t}\n\n\t\tsshbuf_reset(msg);\n\t\tget_msg(conn, msg);\n\t\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tdebug3(\"Received reply T:%u I:%u R:%d\", type, id, max_req);\n\n\t\t/* Find the request in our queue */\n\t\tfor (req = TAILQ_FIRST(&requests);\n\t\t    req != NULL && req->id != id;\n\t\t    req = TAILQ_NEXT(req, tq))\n\t\t\t;\n\t\tif (req == NULL)\n\t\t\tfatal(\"Unexpected reply %u\", id);\n\n\t\tswitch (type) {\n\t\tcase SSH2_FXP_STATUS:\n\t\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif (status != SSH2_FX_EOF)\n\t\t\t\tread_error = 1;\n\t\t\tmax_req = 0;\n\t\t\tTAILQ_REMOVE(&requests, req, tq);\n\t\t\tfree(req);\n\t\t\tnum_req--;\n\t\t\tbreak;\n\t\tcase SSH2_FXP_DATA:\n\t\t\tif ((r = sshbuf_get_string(msg, &data, &len)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdebug3(\"Received data %llu -> %llu\",\n\t\t\t    (unsigned long long)req->offset,\n\t\t\t    (unsigned long long)req->offset + len - 1);\n\t\t\tif (len > req->len)\n\t\t\t\tfatal(\"Received more data than asked for \"\n\t\t\t\t    \"%zu > %zu\", len, req->len);\n\t\t\tif ((lseek(local_fd, req->offset, SEEK_SET) == -1 ||\n\t\t\t    atomicio(vwrite, local_fd, data, len) != len) &&\n\t\t\t    !write_error) {\n\t\t\t\twrite_errno = errno;\n\t\t\t\twrite_error = 1;\n\t\t\t\tmax_req = 0;\n\t\t\t}\n\t\t\telse if (!reordered && req->offset <= highwater)\n\t\t\t\thighwater = req->offset + len;\n\t\t\telse if (!reordered && req->offset > highwater)\n\t\t\t\treordered = 1;\n\t\t\tprogress_counter += len;\n\t\t\tfree(data);\n\n\t\t\tif (len == req->len) {\n\t\t\t\tTAILQ_REMOVE(&requests, req, tq);\n\t\t\t\tfree(req);\n\t\t\t\tnum_req--;\n\t\t\t} else {\n\t\t\t\t/* Resend the request for the missing data */\n\t\t\t\tdebug3(\"Short data block, re-requesting \"\n\t\t\t\t    \"%llu -> %llu (%2d)\",\n\t\t\t\t    (unsigned long long)req->offset + len,\n\t\t\t\t    (unsigned long long)req->offset +\n\t\t\t\t    req->len - 1, num_req);\n\t\t\t\treq->id = conn->msg_id++;\n\t\t\t\treq->len -= len;\n\t\t\t\treq->offset += len;\n\t\t\t\tsend_read_request(conn, req->id,\n\t\t\t\t    req->offset, req->len, handle, handle_len);\n\t\t\t\t/* Reduce the request size */\n\t\t\t\tif (len < buflen)\n\t\t\t\t\tbuflen = MAXIMUM(MIN_READ_SIZE, len);\n\t\t\t}\n\t\t\tif (max_req > 0) { /* max_req = 0 iff EOF received */\n\t\t\t\tif (size > 0 && offset > size) {\n\t\t\t\t\t/* Only one request at a time\n\t\t\t\t\t * after the expected EOF */\n\t\t\t\t\tdebug3(\"Finish at %llu (%2d)\",\n\t\t\t\t\t    (unsigned long long)offset,\n\t\t\t\t\t    num_req);\n\t\t\t\t\tmax_req = 1;\n\t\t\t\t} else if (max_req <= conn->num_requests) {\n\t\t\t\t\t++max_req;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Expected SSH2_FXP_DATA(%u) packet, got %u\",\n\t\t\t    SSH2_FXP_DATA, type);\n\t\t}\n\t}\n\n\tif (showprogress && size)\n\t\tstop_progress_meter();\n\n\t/* Sanity check */\n\tif (TAILQ_FIRST(&requests) != NULL)\n\t\tfatal(\"Transfer complete, but requests still in queue\");\n\t/* Truncate at highest contiguous point to avoid holes on interrupt */\n\tif (read_error || write_error || interrupted) {\n\t\tif (reordered && resume_flag) {\n\t\t\terror(\"Unable to resume download of \\\"%s\\\": \"\n\t\t\t    \"server reordered requests\", local_path);\n\t\t}\n\t\tdebug(\"truncating at %llu\", (unsigned long long)highwater);\n\t\tif (ftruncate(local_fd, highwater) == -1)\n\t\t\terror(\"ftruncate \\\"%s\\\": %s\", local_path,\n\t\t\t    strerror(errno));\n\t}\n\tif (read_error) {\n\t\terror(\"Couldn't read from remote file \\\"%s\\\" : %s\",\n\t\t    remote_path, fx2txt(status));\n\t\tstatus = -1;\n\t\tdo_close(conn, handle, handle_len);\n\t} else if (write_error) {\n\t\terror(\"Couldn't write to \\\"%s\\\": %s\", local_path,\n\t\t    strerror(write_errno));\n\t\tstatus = SSH2_FX_FAILURE;\n\t\tdo_close(conn, handle, handle_len);\n\t} else {\n\t\tif (do_close(conn, handle, handle_len) != 0 || interrupted)\n\t\t\tstatus = SSH2_FX_FAILURE;\n\t\telse\n\t\t\tstatus = SSH2_FX_OK;\n\t\t/* Override umask and utimes if asked */\n#ifdef HAVE_FCHMOD\n\t\tif (preserve_flag && fchmod(local_fd, mode) == -1)\n#else\n\t\tif (preserve_flag && chmod(local_path, mode) == -1)\n#endif /* HAVE_FCHMOD */\n\t\t\terror(\"Couldn't set mode on \\\"%s\\\": %s\", local_path,\n\t\t\t    strerror(errno));\n\t\tif (preserve_flag &&\n\t\t    (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME)) {\n\t\t\tstruct timeval tv[2];\n\t\t\ttv[0].tv_sec = a->atime;\n\t\t\ttv[1].tv_sec = a->mtime;\n\t\t\ttv[0].tv_usec = tv[1].tv_usec = 0;\n\t\t\tif (utimes(local_path, tv) == -1)\n\t\t\t\terror(\"Can't set times on \\\"%s\\\": %s\",\n\t\t\t\t    local_path, strerror(errno));\n\t\t}\n\t\tif (fsync_flag) {\n\t\t\tdebug(\"syncing \\\"%s\\\"\", local_path);\n\t\t\tif (fsync(local_fd) == -1)\n\t\t\t\terror(\"Couldn't sync file \\\"%s\\\": %s\",\n\t\t\t\t    local_path, strerror(errno));\n\t\t}\n\t}\n\tclose(local_fd);\n\tsshbuf_free(msg);\n\tfree(handle);\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MIN_READ_SIZE\t512"
          ],
          "globals_used": [
            "extern volatile sig_atomic_t interrupted;",
            "extern int showprogress;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MIN_READ_SIZE\t512\n\nextern volatile sig_atomic_t interrupted;\nextern int showprogress;\n\nint\ndo_download(struct sftp_conn *conn, const char *remote_path,\n    const char *local_path, Attrib *a, int preserve_flag, int resume_flag,\n    int fsync_flag)\n{\n\tAttrib junk;\n\tstruct sshbuf *msg;\n\tu_char *handle;\n\tint local_fd = -1, write_error;\n\tint read_error, write_errno, reordered = 0, r;\n\tu_int64_t offset = 0, size, highwater;\n\tu_int mode, id, buflen, num_req, max_req, status = SSH2_FX_OK;\n\toff_t progress_counter;\n\tsize_t handle_len;\n\tstruct stat st;\n\tstruct request {\n\t\tu_int id;\n\t\tsize_t len;\n\t\tu_int64_t offset;\n\t\tTAILQ_ENTRY(request) tq;\n\t};\n\tTAILQ_HEAD(reqhead, request) requests;\n\tstruct request *req;\n\tu_char type;\n\n\tTAILQ_INIT(&requests);\n\n\tif (a == NULL && (a = do_stat(conn, remote_path, 0)) == NULL)\n\t\treturn -1;\n\n\t/* Do not preserve set[ug]id here, as we do not preserve ownership */\n\tif (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS)\n\t\tmode = a->perm & 0777;\n\telse\n\t\tmode = 0666;\n\n\tif ((a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) &&\n\t    (!S_ISREG(a->perm))) {\n\t\terror(\"Cannot download non-regular file: %s\", remote_path);\n\t\treturn(-1);\n\t}\n\n\tif (a->flags & SSH2_FILEXFER_ATTR_SIZE)\n\t\tsize = a->size;\n\telse\n\t\tsize = 0;\n\n\tbuflen = conn->transfer_buflen;\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tattrib_clear(&junk); /* Send empty attributes */\n\n\t/* Send open request */\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_OPEN)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, remote_path)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, SSH2_FXF_READ)) != 0 ||\n\t    (r = encode_attrib(msg, &junk)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message SSH2_FXP_OPEN I:%u P:%s\", id, remote_path);\n\n\thandle = get_handle(conn, id, &handle_len,\n\t    \"remote open(\\\"%s\\\")\", remote_path);\n\tif (handle == NULL) {\n\t\tsshbuf_free(msg);\n\t\treturn(-1);\n\t}\n\n\tlocal_fd = open(local_path,\n\t    O_WRONLY | O_CREAT | (resume_flag ? 0 : O_TRUNC), mode | S_IWUSR);\n\tif (local_fd == -1) {\n\t\terror(\"Couldn't open local file \\\"%s\\\" for writing: %s\",\n\t\t    local_path, strerror(errno));\n\t\tgoto fail;\n\t}\n\toffset = highwater = 0;\n\tif (resume_flag) {\n\t\tif (fstat(local_fd, &st) == -1) {\n\t\t\terror(\"Unable to stat local file \\\"%s\\\": %s\",\n\t\t\t    local_path, strerror(errno));\n\t\t\tgoto fail;\n\t\t}\n\t\tif (st.st_size < 0) {\n\t\t\terror(\"\\\"%s\\\" has negative size\", local_path);\n\t\t\tgoto fail;\n\t\t}\n\t\tif ((u_int64_t)st.st_size > size) {\n\t\t\terror(\"Unable to resume download of \\\"%s\\\": \"\n\t\t\t    \"local file is larger than remote\", local_path);\n fail:\n\t\t\tdo_close(conn, handle, handle_len);\n\t\t\tsshbuf_free(msg);\n\t\t\tfree(handle);\n\t\t\tif (local_fd != -1)\n\t\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\t\toffset = highwater = st.st_size;\n\t}\n\n\t/* Read from remote and write to local */\n\twrite_error = read_error = write_errno = num_req = 0;\n\tmax_req = 1;\n\tprogress_counter = offset;\n\n\tif (showprogress && size != 0)\n\t\tstart_progress_meter(remote_path, size, &progress_counter);\n\n\twhile (num_req > 0 || max_req > 0) {\n\t\tu_char *data;\n\t\tsize_t len;\n\n\t\t/*\n\t\t * Simulate EOF on interrupt: stop sending new requests and\n\t\t * allow outstanding requests to drain gracefully\n\t\t */\n\t\tif (interrupted) {\n\t\t\tif (num_req == 0) /* If we haven't started yet... */\n\t\t\t\tbreak;\n\t\t\tmax_req = 0;\n\t\t}\n\n\t\t/* Send some more requests */\n\t\twhile (num_req < max_req) {\n\t\t\tdebug3(\"Request range %llu -> %llu (%d/%d)\",\n\t\t\t    (unsigned long long)offset,\n\t\t\t    (unsigned long long)offset + buflen - 1,\n\t\t\t    num_req, max_req);\n\t\t\treq = xcalloc(1, sizeof(*req));\n\t\t\treq->id = conn->msg_id++;\n\t\t\treq->len = buflen;\n\t\t\treq->offset = offset;\n\t\t\toffset += buflen;\n\t\t\tnum_req++;\n\t\t\tTAILQ_INSERT_TAIL(&requests, req, tq);\n\t\t\tsend_read_request(conn, req->id, req->offset,\n\t\t\t    req->len, handle, handle_len);\n\t\t}\n\n\t\tsshbuf_reset(msg);\n\t\tget_msg(conn, msg);\n\t\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tdebug3(\"Received reply T:%u I:%u R:%d\", type, id, max_req);\n\n\t\t/* Find the request in our queue */\n\t\tfor (req = TAILQ_FIRST(&requests);\n\t\t    req != NULL && req->id != id;\n\t\t    req = TAILQ_NEXT(req, tq))\n\t\t\t;\n\t\tif (req == NULL)\n\t\t\tfatal(\"Unexpected reply %u\", id);\n\n\t\tswitch (type) {\n\t\tcase SSH2_FXP_STATUS:\n\t\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif (status != SSH2_FX_EOF)\n\t\t\t\tread_error = 1;\n\t\t\tmax_req = 0;\n\t\t\tTAILQ_REMOVE(&requests, req, tq);\n\t\t\tfree(req);\n\t\t\tnum_req--;\n\t\t\tbreak;\n\t\tcase SSH2_FXP_DATA:\n\t\t\tif ((r = sshbuf_get_string(msg, &data, &len)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdebug3(\"Received data %llu -> %llu\",\n\t\t\t    (unsigned long long)req->offset,\n\t\t\t    (unsigned long long)req->offset + len - 1);\n\t\t\tif (len > req->len)\n\t\t\t\tfatal(\"Received more data than asked for \"\n\t\t\t\t    \"%zu > %zu\", len, req->len);\n\t\t\tif ((lseek(local_fd, req->offset, SEEK_SET) == -1 ||\n\t\t\t    atomicio(vwrite, local_fd, data, len) != len) &&\n\t\t\t    !write_error) {\n\t\t\t\twrite_errno = errno;\n\t\t\t\twrite_error = 1;\n\t\t\t\tmax_req = 0;\n\t\t\t}\n\t\t\telse if (!reordered && req->offset <= highwater)\n\t\t\t\thighwater = req->offset + len;\n\t\t\telse if (!reordered && req->offset > highwater)\n\t\t\t\treordered = 1;\n\t\t\tprogress_counter += len;\n\t\t\tfree(data);\n\n\t\t\tif (len == req->len) {\n\t\t\t\tTAILQ_REMOVE(&requests, req, tq);\n\t\t\t\tfree(req);\n\t\t\t\tnum_req--;\n\t\t\t} else {\n\t\t\t\t/* Resend the request for the missing data */\n\t\t\t\tdebug3(\"Short data block, re-requesting \"\n\t\t\t\t    \"%llu -> %llu (%2d)\",\n\t\t\t\t    (unsigned long long)req->offset + len,\n\t\t\t\t    (unsigned long long)req->offset +\n\t\t\t\t    req->len - 1, num_req);\n\t\t\t\treq->id = conn->msg_id++;\n\t\t\t\treq->len -= len;\n\t\t\t\treq->offset += len;\n\t\t\t\tsend_read_request(conn, req->id,\n\t\t\t\t    req->offset, req->len, handle, handle_len);\n\t\t\t\t/* Reduce the request size */\n\t\t\t\tif (len < buflen)\n\t\t\t\t\tbuflen = MAXIMUM(MIN_READ_SIZE, len);\n\t\t\t}\n\t\t\tif (max_req > 0) { /* max_req = 0 iff EOF received */\n\t\t\t\tif (size > 0 && offset > size) {\n\t\t\t\t\t/* Only one request at a time\n\t\t\t\t\t * after the expected EOF */\n\t\t\t\t\tdebug3(\"Finish at %llu (%2d)\",\n\t\t\t\t\t    (unsigned long long)offset,\n\t\t\t\t\t    num_req);\n\t\t\t\t\tmax_req = 1;\n\t\t\t\t} else if (max_req <= conn->num_requests) {\n\t\t\t\t\t++max_req;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Expected SSH2_FXP_DATA(%u) packet, got %u\",\n\t\t\t    SSH2_FXP_DATA, type);\n\t\t}\n\t}\n\n\tif (showprogress && size)\n\t\tstop_progress_meter();\n\n\t/* Sanity check */\n\tif (TAILQ_FIRST(&requests) != NULL)\n\t\tfatal(\"Transfer complete, but requests still in queue\");\n\t/* Truncate at highest contiguous point to avoid holes on interrupt */\n\tif (read_error || write_error || interrupted) {\n\t\tif (reordered && resume_flag) {\n\t\t\terror(\"Unable to resume download of \\\"%s\\\": \"\n\t\t\t    \"server reordered requests\", local_path);\n\t\t}\n\t\tdebug(\"truncating at %llu\", (unsigned long long)highwater);\n\t\tif (ftruncate(local_fd, highwater) == -1)\n\t\t\terror(\"ftruncate \\\"%s\\\": %s\", local_path,\n\t\t\t    strerror(errno));\n\t}\n\tif (read_error) {\n\t\terror(\"Couldn't read from remote file \\\"%s\\\" : %s\",\n\t\t    remote_path, fx2txt(status));\n\t\tstatus = -1;\n\t\tdo_close(conn, handle, handle_len);\n\t} else if (write_error) {\n\t\terror(\"Couldn't write to \\\"%s\\\": %s\", local_path,\n\t\t    strerror(write_errno));\n\t\tstatus = SSH2_FX_FAILURE;\n\t\tdo_close(conn, handle, handle_len);\n\t} else {\n\t\tif (do_close(conn, handle, handle_len) != 0 || interrupted)\n\t\t\tstatus = SSH2_FX_FAILURE;\n\t\telse\n\t\t\tstatus = SSH2_FX_OK;\n\t\t/* Override umask and utimes if asked */\n#ifdef HAVE_FCHMOD\n\t\tif (preserve_flag && fchmod(local_fd, mode) == -1)\n#else\n\t\tif (preserve_flag && chmod(local_path, mode) == -1)\n#endif /* HAVE_FCHMOD */\n\t\t\terror(\"Couldn't set mode on \\\"%s\\\": %s\", local_path,\n\t\t\t    strerror(errno));\n\t\tif (preserve_flag &&\n\t\t    (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME)) {\n\t\t\tstruct timeval tv[2];\n\t\t\ttv[0].tv_sec = a->atime;\n\t\t\ttv[1].tv_sec = a->mtime;\n\t\t\ttv[0].tv_usec = tv[1].tv_usec = 0;\n\t\t\tif (utimes(local_path, tv) == -1)\n\t\t\t\terror(\"Can't set times on \\\"%s\\\": %s\",\n\t\t\t\t    local_path, strerror(errno));\n\t\t}\n\t\tif (fsync_flag) {\n\t\t\tdebug(\"syncing \\\"%s\\\"\", local_path);\n\t\t\tif (fsync(local_fd) == -1)\n\t\t\t\terror(\"Couldn't sync file \\\"%s\\\": %s\",\n\t\t\t\t    local_path, strerror(errno));\n\t\t}\n\t}\n\tclose(local_fd);\n\tsshbuf_free(msg);\n\tfree(handle);\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "dir_entries[i]->a.perm"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "download_dir_internal",
          "args": [
            "conn",
            "new_src",
            "new_dst",
            "depth + 1",
            "&(dir_entries[i]->a)",
            "preserve_flag",
            "print_flag",
            "resume_flag",
            "fsync_flag"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "download_dir_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "1457-1549",
          "snippet": "static int\ndownload_dir_internal(struct sftp_conn *conn, const char *src, const char *dst,\n    int depth, Attrib *dirattrib, int preserve_flag, int print_flag,\n    int resume_flag, int fsync_flag)\n{\n\tint i, ret = 0;\n\tSFTP_DIRENT **dir_entries;\n\tchar *filename, *new_src = NULL, *new_dst = NULL;\n\tmode_t mode = 0777;\n\n\tif (depth >= MAX_DIR_DEPTH) {\n\t\terror(\"Maximum directory depth exceeded: %d levels\", depth);\n\t\treturn -1;\n\t}\n\n\tif (dirattrib == NULL &&\n\t    (dirattrib = do_stat(conn, src, 1)) == NULL) {\n\t\terror(\"Unable to stat remote directory \\\"%s\\\"\", src);\n\t\treturn -1;\n\t}\n\tif (!S_ISDIR(dirattrib->perm)) {\n\t\terror(\"\\\"%s\\\" is not a directory\", src);\n\t\treturn -1;\n\t}\n\tif (print_flag)\n\t\tmprintf(\"Retrieving %s\\n\", src);\n\n\tif (dirattrib->flags & SSH2_FILEXFER_ATTR_PERMISSIONS)\n\t\tmode = dirattrib->perm & 01777;\n\telse {\n\t\tdebug(\"Server did not send permissions for \"\n\t\t    \"directory \\\"%s\\\"\", dst);\n\t}\n\n\tif (mkdir(dst, mode) == -1 && errno != EEXIST) {\n\t\terror(\"mkdir %s: %s\", dst, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (do_readdir(conn, src, &dir_entries) == -1) {\n\t\terror(\"%s: Failed to get directory contents\", src);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; dir_entries[i] != NULL && !interrupted; i++) {\n\t\tfree(new_dst);\n\t\tfree(new_src);\n\n\t\tfilename = dir_entries[i]->filename;\n\t\tnew_dst = path_append(dst, filename);\n\t\tnew_src = path_append(src, filename);\n\n\t\tif (S_ISDIR(dir_entries[i]->a.perm)) {\n\t\t\tif (strcmp(filename, \".\") == 0 ||\n\t\t\t    strcmp(filename, \"..\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (download_dir_internal(conn, new_src, new_dst,\n\t\t\t    depth + 1, &(dir_entries[i]->a), preserve_flag,\n\t\t\t    print_flag, resume_flag, fsync_flag) == -1)\n\t\t\t\tret = -1;\n\t\t} else if (S_ISREG(dir_entries[i]->a.perm) ) {\n\t\t\tif (do_download(conn, new_src, new_dst,\n\t\t\t    &(dir_entries[i]->a), preserve_flag,\n\t\t\t    resume_flag, fsync_flag) == -1) {\n\t\t\t\terror(\"Download of file %s to %s failed\",\n\t\t\t\t    new_src, new_dst);\n\t\t\t\tret = -1;\n\t\t\t}\n\t\t} else\n\t\t\tlogit(\"%s: not a regular file\\n\", new_src);\n\n\t}\n\tfree(new_dst);\n\tfree(new_src);\n\n\tif (preserve_flag) {\n\t\tif (dirattrib->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {\n\t\t\tstruct timeval tv[2];\n\t\t\ttv[0].tv_sec = dirattrib->atime;\n\t\t\ttv[1].tv_sec = dirattrib->mtime;\n\t\t\ttv[0].tv_usec = tv[1].tv_usec = 0;\n\t\t\tif (utimes(dst, tv) == -1)\n\t\t\t\terror(\"Can't set times on \\\"%s\\\": %s\",\n\t\t\t\t    dst, strerror(errno));\n\t\t} else\n\t\t\tdebug(\"Server did not send times for directory \"\n\t\t\t    \"\\\"%s\\\"\", dst);\n\t}\n\n\tfree_sftp_dirents(dir_entries);\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "filename",
            "\"..\""
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "dir_entries[i]->a.perm"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_append",
          "args": [
            "src",
            "filename"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "path_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "1906-1919",
          "snippet": "char *\npath_append(const char *p1, const char *p2)\n{\n\tchar *ret;\n\tsize_t len = strlen(p1) + strlen(p2) + 2;\n\n\tret = xmalloc(len);\n\tstrlcpy(ret, p1, len);\n\tif (p1[0] != '\\0' && p1[strlen(p1) - 1] != '/')\n\t\tstrlcat(ret, \"/\", len);\n\tstrlcat(ret, p2, len);\n\n\treturn(ret);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\npath_append(const char *p1, const char *p2)\n{\n\tchar *ret;\n\tsize_t len = strlen(p1) + strlen(p2) + 2;\n\n\tret = xmalloc(len);\n\tstrlcpy(ret, p1, len);\n\tif (p1[0] != '\\0' && p1[strlen(p1) - 1] != '/')\n\t\tstrlcat(ret, \"/\", len);\n\tstrlcat(ret, p2, len);\n\n\treturn(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_readdir",
          "args": [
            "conn",
            "src",
            "&dir_entries"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "do_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "675-679",
          "snippet": "int\ndo_readdir(struct sftp_conn *conn, const char *path, SFTP_DIRENT ***dir)\n{\n\treturn(do_lsreaddir(conn, path, 0, dir));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_readdir(struct sftp_conn *conn, const char *path, SFTP_DIRENT ***dir)\n{\n\treturn(do_lsreaddir(conn, path, 0, dir));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "dst",
            "mode"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mprintf",
          "args": [
            "\"Retrieving %s\\n\"",
            "src"
          ],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "dirattrib->perm"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_stat",
          "args": [
            "conn",
            "src",
            "1"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "do_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "742-754",
          "snippet": "Attrib *\ndo_stat(struct sftp_conn *conn, const char *path, int quiet)\n{\n\tu_int id;\n\n\tid = conn->msg_id++;\n\n\tsend_string_request(conn, id,\n\t    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT,\n\t    path, strlen(path));\n\n\treturn(get_decode_stat(conn, id, quiet));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nAttrib *\ndo_stat(struct sftp_conn *conn, const char *path, int quiet)\n{\n\tu_int id;\n\n\tid = conn->msg_id++;\n\n\tsend_string_request(conn, id,\n\t    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT,\n\t    path, strlen(path));\n\n\treturn(get_decode_stat(conn, id, quiet));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MAX_DIR_DEPTH 64\n\nextern volatile sig_atomic_t interrupted;\n\nstatic int\ndownload_dir_internal(struct sftp_conn *conn, const char *src, const char *dst,\n    int depth, Attrib *dirattrib, int preserve_flag, int print_flag,\n    int resume_flag, int fsync_flag)\n{\n\tint i, ret = 0;\n\tSFTP_DIRENT **dir_entries;\n\tchar *filename, *new_src = NULL, *new_dst = NULL;\n\tmode_t mode = 0777;\n\n\tif (depth >= MAX_DIR_DEPTH) {\n\t\terror(\"Maximum directory depth exceeded: %d levels\", depth);\n\t\treturn -1;\n\t}\n\n\tif (dirattrib == NULL &&\n\t    (dirattrib = do_stat(conn, src, 1)) == NULL) {\n\t\terror(\"Unable to stat remote directory \\\"%s\\\"\", src);\n\t\treturn -1;\n\t}\n\tif (!S_ISDIR(dirattrib->perm)) {\n\t\terror(\"\\\"%s\\\" is not a directory\", src);\n\t\treturn -1;\n\t}\n\tif (print_flag)\n\t\tmprintf(\"Retrieving %s\\n\", src);\n\n\tif (dirattrib->flags & SSH2_FILEXFER_ATTR_PERMISSIONS)\n\t\tmode = dirattrib->perm & 01777;\n\telse {\n\t\tdebug(\"Server did not send permissions for \"\n\t\t    \"directory \\\"%s\\\"\", dst);\n\t}\n\n\tif (mkdir(dst, mode) == -1 && errno != EEXIST) {\n\t\terror(\"mkdir %s: %s\", dst, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (do_readdir(conn, src, &dir_entries) == -1) {\n\t\terror(\"%s: Failed to get directory contents\", src);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; dir_entries[i] != NULL && !interrupted; i++) {\n\t\tfree(new_dst);\n\t\tfree(new_src);\n\n\t\tfilename = dir_entries[i]->filename;\n\t\tnew_dst = path_append(dst, filename);\n\t\tnew_src = path_append(src, filename);\n\n\t\tif (S_ISDIR(dir_entries[i]->a.perm)) {\n\t\t\tif (strcmp(filename, \".\") == 0 ||\n\t\t\t    strcmp(filename, \"..\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (download_dir_internal(conn, new_src, new_dst,\n\t\t\t    depth + 1, &(dir_entries[i]->a), preserve_flag,\n\t\t\t    print_flag, resume_flag, fsync_flag) == -1)\n\t\t\t\tret = -1;\n\t\t} else if (S_ISREG(dir_entries[i]->a.perm) ) {\n\t\t\tif (do_download(conn, new_src, new_dst,\n\t\t\t    &(dir_entries[i]->a), preserve_flag,\n\t\t\t    resume_flag, fsync_flag) == -1) {\n\t\t\t\terror(\"Download of file %s to %s failed\",\n\t\t\t\t    new_src, new_dst);\n\t\t\t\tret = -1;\n\t\t\t}\n\t\t} else\n\t\t\tlogit(\"%s: not a regular file\\n\", new_src);\n\n\t}\n\tfree(new_dst);\n\tfree(new_src);\n\n\tif (preserve_flag) {\n\t\tif (dirattrib->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {\n\t\t\tstruct timeval tv[2];\n\t\t\ttv[0].tv_sec = dirattrib->atime;\n\t\t\ttv[1].tv_sec = dirattrib->mtime;\n\t\t\ttv[0].tv_usec = tv[1].tv_usec = 0;\n\t\t\tif (utimes(dst, tv) == -1)\n\t\t\t\terror(\"Can't set times on \\\"%s\\\": %s\",\n\t\t\t\t    dst, strerror(errno));\n\t\t} else\n\t\t\tdebug(\"Server did not send times for directory \"\n\t\t\t    \"\\\"%s\\\"\", dst);\n\t}\n\n\tfree_sftp_dirents(dir_entries);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "do_download",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "1161-1455",
    "snippet": "int\ndo_download(struct sftp_conn *conn, const char *remote_path,\n    const char *local_path, Attrib *a, int preserve_flag, int resume_flag,\n    int fsync_flag)\n{\n\tAttrib junk;\n\tstruct sshbuf *msg;\n\tu_char *handle;\n\tint local_fd = -1, write_error;\n\tint read_error, write_errno, reordered = 0, r;\n\tu_int64_t offset = 0, size, highwater;\n\tu_int mode, id, buflen, num_req, max_req, status = SSH2_FX_OK;\n\toff_t progress_counter;\n\tsize_t handle_len;\n\tstruct stat st;\n\tstruct request {\n\t\tu_int id;\n\t\tsize_t len;\n\t\tu_int64_t offset;\n\t\tTAILQ_ENTRY(request) tq;\n\t};\n\tTAILQ_HEAD(reqhead, request) requests;\n\tstruct request *req;\n\tu_char type;\n\n\tTAILQ_INIT(&requests);\n\n\tif (a == NULL && (a = do_stat(conn, remote_path, 0)) == NULL)\n\t\treturn -1;\n\n\t/* Do not preserve set[ug]id here, as we do not preserve ownership */\n\tif (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS)\n\t\tmode = a->perm & 0777;\n\telse\n\t\tmode = 0666;\n\n\tif ((a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) &&\n\t    (!S_ISREG(a->perm))) {\n\t\terror(\"Cannot download non-regular file: %s\", remote_path);\n\t\treturn(-1);\n\t}\n\n\tif (a->flags & SSH2_FILEXFER_ATTR_SIZE)\n\t\tsize = a->size;\n\telse\n\t\tsize = 0;\n\n\tbuflen = conn->transfer_buflen;\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tattrib_clear(&junk); /* Send empty attributes */\n\n\t/* Send open request */\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_OPEN)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, remote_path)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, SSH2_FXF_READ)) != 0 ||\n\t    (r = encode_attrib(msg, &junk)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message SSH2_FXP_OPEN I:%u P:%s\", id, remote_path);\n\n\thandle = get_handle(conn, id, &handle_len,\n\t    \"remote open(\\\"%s\\\")\", remote_path);\n\tif (handle == NULL) {\n\t\tsshbuf_free(msg);\n\t\treturn(-1);\n\t}\n\n\tlocal_fd = open(local_path,\n\t    O_WRONLY | O_CREAT | (resume_flag ? 0 : O_TRUNC), mode | S_IWUSR);\n\tif (local_fd == -1) {\n\t\terror(\"Couldn't open local file \\\"%s\\\" for writing: %s\",\n\t\t    local_path, strerror(errno));\n\t\tgoto fail;\n\t}\n\toffset = highwater = 0;\n\tif (resume_flag) {\n\t\tif (fstat(local_fd, &st) == -1) {\n\t\t\terror(\"Unable to stat local file \\\"%s\\\": %s\",\n\t\t\t    local_path, strerror(errno));\n\t\t\tgoto fail;\n\t\t}\n\t\tif (st.st_size < 0) {\n\t\t\terror(\"\\\"%s\\\" has negative size\", local_path);\n\t\t\tgoto fail;\n\t\t}\n\t\tif ((u_int64_t)st.st_size > size) {\n\t\t\terror(\"Unable to resume download of \\\"%s\\\": \"\n\t\t\t    \"local file is larger than remote\", local_path);\n fail:\n\t\t\tdo_close(conn, handle, handle_len);\n\t\t\tsshbuf_free(msg);\n\t\t\tfree(handle);\n\t\t\tif (local_fd != -1)\n\t\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\t\toffset = highwater = st.st_size;\n\t}\n\n\t/* Read from remote and write to local */\n\twrite_error = read_error = write_errno = num_req = 0;\n\tmax_req = 1;\n\tprogress_counter = offset;\n\n\tif (showprogress && size != 0)\n\t\tstart_progress_meter(remote_path, size, &progress_counter);\n\n\twhile (num_req > 0 || max_req > 0) {\n\t\tu_char *data;\n\t\tsize_t len;\n\n\t\t/*\n\t\t * Simulate EOF on interrupt: stop sending new requests and\n\t\t * allow outstanding requests to drain gracefully\n\t\t */\n\t\tif (interrupted) {\n\t\t\tif (num_req == 0) /* If we haven't started yet... */\n\t\t\t\tbreak;\n\t\t\tmax_req = 0;\n\t\t}\n\n\t\t/* Send some more requests */\n\t\twhile (num_req < max_req) {\n\t\t\tdebug3(\"Request range %llu -> %llu (%d/%d)\",\n\t\t\t    (unsigned long long)offset,\n\t\t\t    (unsigned long long)offset + buflen - 1,\n\t\t\t    num_req, max_req);\n\t\t\treq = xcalloc(1, sizeof(*req));\n\t\t\treq->id = conn->msg_id++;\n\t\t\treq->len = buflen;\n\t\t\treq->offset = offset;\n\t\t\toffset += buflen;\n\t\t\tnum_req++;\n\t\t\tTAILQ_INSERT_TAIL(&requests, req, tq);\n\t\t\tsend_read_request(conn, req->id, req->offset,\n\t\t\t    req->len, handle, handle_len);\n\t\t}\n\n\t\tsshbuf_reset(msg);\n\t\tget_msg(conn, msg);\n\t\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tdebug3(\"Received reply T:%u I:%u R:%d\", type, id, max_req);\n\n\t\t/* Find the request in our queue */\n\t\tfor (req = TAILQ_FIRST(&requests);\n\t\t    req != NULL && req->id != id;\n\t\t    req = TAILQ_NEXT(req, tq))\n\t\t\t;\n\t\tif (req == NULL)\n\t\t\tfatal(\"Unexpected reply %u\", id);\n\n\t\tswitch (type) {\n\t\tcase SSH2_FXP_STATUS:\n\t\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif (status != SSH2_FX_EOF)\n\t\t\t\tread_error = 1;\n\t\t\tmax_req = 0;\n\t\t\tTAILQ_REMOVE(&requests, req, tq);\n\t\t\tfree(req);\n\t\t\tnum_req--;\n\t\t\tbreak;\n\t\tcase SSH2_FXP_DATA:\n\t\t\tif ((r = sshbuf_get_string(msg, &data, &len)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdebug3(\"Received data %llu -> %llu\",\n\t\t\t    (unsigned long long)req->offset,\n\t\t\t    (unsigned long long)req->offset + len - 1);\n\t\t\tif (len > req->len)\n\t\t\t\tfatal(\"Received more data than asked for \"\n\t\t\t\t    \"%zu > %zu\", len, req->len);\n\t\t\tif ((lseek(local_fd, req->offset, SEEK_SET) == -1 ||\n\t\t\t    atomicio(vwrite, local_fd, data, len) != len) &&\n\t\t\t    !write_error) {\n\t\t\t\twrite_errno = errno;\n\t\t\t\twrite_error = 1;\n\t\t\t\tmax_req = 0;\n\t\t\t}\n\t\t\telse if (!reordered && req->offset <= highwater)\n\t\t\t\thighwater = req->offset + len;\n\t\t\telse if (!reordered && req->offset > highwater)\n\t\t\t\treordered = 1;\n\t\t\tprogress_counter += len;\n\t\t\tfree(data);\n\n\t\t\tif (len == req->len) {\n\t\t\t\tTAILQ_REMOVE(&requests, req, tq);\n\t\t\t\tfree(req);\n\t\t\t\tnum_req--;\n\t\t\t} else {\n\t\t\t\t/* Resend the request for the missing data */\n\t\t\t\tdebug3(\"Short data block, re-requesting \"\n\t\t\t\t    \"%llu -> %llu (%2d)\",\n\t\t\t\t    (unsigned long long)req->offset + len,\n\t\t\t\t    (unsigned long long)req->offset +\n\t\t\t\t    req->len - 1, num_req);\n\t\t\t\treq->id = conn->msg_id++;\n\t\t\t\treq->len -= len;\n\t\t\t\treq->offset += len;\n\t\t\t\tsend_read_request(conn, req->id,\n\t\t\t\t    req->offset, req->len, handle, handle_len);\n\t\t\t\t/* Reduce the request size */\n\t\t\t\tif (len < buflen)\n\t\t\t\t\tbuflen = MAXIMUM(MIN_READ_SIZE, len);\n\t\t\t}\n\t\t\tif (max_req > 0) { /* max_req = 0 iff EOF received */\n\t\t\t\tif (size > 0 && offset > size) {\n\t\t\t\t\t/* Only one request at a time\n\t\t\t\t\t * after the expected EOF */\n\t\t\t\t\tdebug3(\"Finish at %llu (%2d)\",\n\t\t\t\t\t    (unsigned long long)offset,\n\t\t\t\t\t    num_req);\n\t\t\t\t\tmax_req = 1;\n\t\t\t\t} else if (max_req <= conn->num_requests) {\n\t\t\t\t\t++max_req;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Expected SSH2_FXP_DATA(%u) packet, got %u\",\n\t\t\t    SSH2_FXP_DATA, type);\n\t\t}\n\t}\n\n\tif (showprogress && size)\n\t\tstop_progress_meter();\n\n\t/* Sanity check */\n\tif (TAILQ_FIRST(&requests) != NULL)\n\t\tfatal(\"Transfer complete, but requests still in queue\");\n\t/* Truncate at highest contiguous point to avoid holes on interrupt */\n\tif (read_error || write_error || interrupted) {\n\t\tif (reordered && resume_flag) {\n\t\t\terror(\"Unable to resume download of \\\"%s\\\": \"\n\t\t\t    \"server reordered requests\", local_path);\n\t\t}\n\t\tdebug(\"truncating at %llu\", (unsigned long long)highwater);\n\t\tif (ftruncate(local_fd, highwater) == -1)\n\t\t\terror(\"ftruncate \\\"%s\\\": %s\", local_path,\n\t\t\t    strerror(errno));\n\t}\n\tif (read_error) {\n\t\terror(\"Couldn't read from remote file \\\"%s\\\" : %s\",\n\t\t    remote_path, fx2txt(status));\n\t\tstatus = -1;\n\t\tdo_close(conn, handle, handle_len);\n\t} else if (write_error) {\n\t\terror(\"Couldn't write to \\\"%s\\\": %s\", local_path,\n\t\t    strerror(write_errno));\n\t\tstatus = SSH2_FX_FAILURE;\n\t\tdo_close(conn, handle, handle_len);\n\t} else {\n\t\tif (do_close(conn, handle, handle_len) != 0 || interrupted)\n\t\t\tstatus = SSH2_FX_FAILURE;\n\t\telse\n\t\t\tstatus = SSH2_FX_OK;\n\t\t/* Override umask and utimes if asked */\n#ifdef HAVE_FCHMOD\n\t\tif (preserve_flag && fchmod(local_fd, mode) == -1)\n#else\n\t\tif (preserve_flag && chmod(local_path, mode) == -1)\n#endif /* HAVE_FCHMOD */\n\t\t\terror(\"Couldn't set mode on \\\"%s\\\": %s\", local_path,\n\t\t\t    strerror(errno));\n\t\tif (preserve_flag &&\n\t\t    (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME)) {\n\t\t\tstruct timeval tv[2];\n\t\t\ttv[0].tv_sec = a->atime;\n\t\t\ttv[1].tv_sec = a->mtime;\n\t\t\ttv[0].tv_usec = tv[1].tv_usec = 0;\n\t\t\tif (utimes(local_path, tv) == -1)\n\t\t\t\terror(\"Can't set times on \\\"%s\\\": %s\",\n\t\t\t\t    local_path, strerror(errno));\n\t\t}\n\t\tif (fsync_flag) {\n\t\t\tdebug(\"syncing \\\"%s\\\"\", local_path);\n\t\t\tif (fsync(local_fd) == -1)\n\t\t\t\terror(\"Couldn't sync file \\\"%s\\\": %s\",\n\t\t\t\t    local_path, strerror(errno));\n\t\t}\n\t}\n\tclose(local_fd);\n\tsshbuf_free(msg);\n\tfree(handle);\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define MIN_READ_SIZE\t512"
    ],
    "globals_used": [
      "extern volatile sig_atomic_t interrupted;",
      "extern int showprogress;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "handle"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "free_sftp_dirents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "681-693",
          "snippet": "void free_sftp_dirents(SFTP_DIRENT **s)\n{\n\tint i;\n\n\tif (s == NULL)\n\t\treturn;\n\tfor (i = 0; s[i]; i++) {\n\t\tfree(s[i]->filename);\n\t\tfree(s[i]->longname);\n\t\tfree(s[i]);\n\t}\n\tfree(s);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid free_sftp_dirents(SFTP_DIRENT **s)\n{\n\tint i;\n\n\tif (s == NULL)\n\t\treturn;\n\tfor (i = 0; s[i]; i++) {\n\t\tfree(s[i]->filename);\n\t\tfree(s[i]->longname);\n\t\tfree(s[i]);\n\t}\n\tfree(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "local_fd"
          ],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Couldn't sync file \\\"%s\\\": %s\"",
            "local_path",
            "strerror(errno)"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsync",
          "args": [
            "local_fd"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "process_extended_fsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1354-1370",
          "snippet": "static void\nprocess_extended_fsync(u_int32_t id)\n{\n\tint handle, fd, r, status = SSH2_FX_OP_UNSUPPORTED;\n\n\tif ((r = get_handle(iqueue, &handle)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tdebug3(\"request %u: fsync (handle %u)\", id, handle);\n\tverbose(\"fsync \\\"%s\\\"\", handle_to_name(handle));\n\tif ((fd = handle_to_fd(handle)) < 0)\n\t\tstatus = SSH2_FX_NO_SUCH_FILE;\n\telse if (handle_is_ok(handle, HANDLE_FILE)) {\n\t\tr = fsync(fd);\n\t\tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n\t}\n\tsend_status(id, status);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct sshbuf *iqueue;",
            "static void process_open(u_int32_t id);",
            "static void process_close(u_int32_t id);",
            "static void process_read(u_int32_t id);",
            "static void process_write(u_int32_t id);",
            "static void process_stat(u_int32_t id);",
            "static void process_lstat(u_int32_t id);",
            "static void process_fstat(u_int32_t id);",
            "static void process_setstat(u_int32_t id);",
            "static void process_fsetstat(u_int32_t id);",
            "static void process_opendir(u_int32_t id);",
            "static void process_readdir(u_int32_t id);",
            "static void process_remove(u_int32_t id);",
            "static void process_mkdir(u_int32_t id);",
            "static void process_rmdir(u_int32_t id);",
            "static void process_realpath(u_int32_t id);",
            "static void process_rename(u_int32_t id);",
            "static void process_readlink(u_int32_t id);",
            "static void process_symlink(u_int32_t id);",
            "static void process_extended_posix_rename(u_int32_t id);",
            "static void process_extended_statvfs(u_int32_t id);",
            "static void process_extended_fstatvfs(u_int32_t id);",
            "static void process_extended_hardlink(u_int32_t id);",
            "static void process_extended_fsync(u_int32_t id);",
            "static void process_extended(u_int32_t id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *iqueue;\nstatic void process_open(u_int32_t id);\nstatic void process_close(u_int32_t id);\nstatic void process_read(u_int32_t id);\nstatic void process_write(u_int32_t id);\nstatic void process_stat(u_int32_t id);\nstatic void process_lstat(u_int32_t id);\nstatic void process_fstat(u_int32_t id);\nstatic void process_setstat(u_int32_t id);\nstatic void process_fsetstat(u_int32_t id);\nstatic void process_opendir(u_int32_t id);\nstatic void process_readdir(u_int32_t id);\nstatic void process_remove(u_int32_t id);\nstatic void process_mkdir(u_int32_t id);\nstatic void process_rmdir(u_int32_t id);\nstatic void process_realpath(u_int32_t id);\nstatic void process_rename(u_int32_t id);\nstatic void process_readlink(u_int32_t id);\nstatic void process_symlink(u_int32_t id);\nstatic void process_extended_posix_rename(u_int32_t id);\nstatic void process_extended_statvfs(u_int32_t id);\nstatic void process_extended_fstatvfs(u_int32_t id);\nstatic void process_extended_hardlink(u_int32_t id);\nstatic void process_extended_fsync(u_int32_t id);\nstatic void process_extended(u_int32_t id);\n\nstatic void\nprocess_extended_fsync(u_int32_t id)\n{\n\tint handle, fd, r, status = SSH2_FX_OP_UNSUPPORTED;\n\n\tif ((r = get_handle(iqueue, &handle)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tdebug3(\"request %u: fsync (handle %u)\", id, handle);\n\tverbose(\"fsync \\\"%s\\\"\", handle_to_name(handle));\n\tif ((fd = handle_to_fd(handle)) < 0)\n\t\tstatus = SSH2_FX_NO_SUCH_FILE;\n\telse if (handle_is_ok(handle, HANDLE_FILE)) {\n\t\tr = fsync(fd);\n\t\tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n\t}\n\tsend_status(id, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"syncing \\\"%s\\\"\"",
            "local_path"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "utimes",
          "args": [
            "local_path",
            "tv"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "utimes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "109-117",
          "snippet": "int utimes(char *filename, struct timeval *tvp)\n{\n\tstruct utimbuf ub;\n\n\tub.actime = tvp[0].tv_sec;\n\tub.modtime = tvp[1].tv_sec;\n\n\treturn (utime(filename, &ub));\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint utimes(char *filename, struct timeval *tvp)\n{\n\tstruct utimbuf ub;\n\n\tub.actime = tvp[0].tv_sec;\n\tub.modtime = tvp[1].tv_sec;\n\n\treturn (utime(filename, &ub));\n}"
        }
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "local_path",
            "mode"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchmod",
          "args": [
            "local_fd",
            "mode"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_close",
          "args": [
            "conn",
            "handle",
            "handle_len"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "do_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "500-525",
          "snippet": "int\ndo_close(struct sftp_conn *conn, const u_char *handle, u_int handle_len)\n{\n\tu_int id, status;\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_CLOSE)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message SSH2_FXP_CLOSE I:%u\", id);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't close file: %s\", fx2txt(status));\n\n\tsshbuf_free(msg);\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_close(struct sftp_conn *conn, const u_char *handle, u_int handle_len)\n{\n\tu_int id, status;\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_CLOSE)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message SSH2_FXP_CLOSE I:%u\", id);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't close file: %s\", fx2txt(status));\n\n\tsshbuf_free(msg);\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fx2txt",
          "args": [
            "status"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "fx2txt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "182-208",
          "snippet": "const char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftruncate",
          "args": [
            "local_fd",
            "highwater"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Transfer complete, but requests still in queue\""
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&requests"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stop_progress_meter",
          "args": [],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "stop_progress_meter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/progressmeter.c",
          "lines": "270-283",
          "snippet": "void\nstop_progress_meter(void)\n{\n\talarm(0);\n\n\tif (!can_output())\n\t\treturn;\n\n\t/* Ensure we complete the progress */\n\tif (cur_pos != end_pos)\n\t\trefresh_progress_meter();\n\n\tatomicio(vwrite, STDOUT_FILENO, \"\\n\", 1);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"progressmeter.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_output(void);",
            "void refresh_progress_meter(void);",
            "static off_t end_pos;",
            "static off_t cur_pos;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"progressmeter.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int can_output(void);\nvoid refresh_progress_meter(void);\nstatic off_t end_pos;\nstatic off_t cur_pos;\n\nvoid\nstop_progress_meter(void)\n{\n\talarm(0);\n\n\tif (!can_output())\n\t\treturn;\n\n\t/* Ensure we complete the progress */\n\tif (cur_pos != end_pos)\n\t\trefresh_progress_meter();\n\n\tatomicio(vwrite, STDOUT_FILENO, \"\\n\", 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAXIMUM",
          "args": [
            "MIN_READ_SIZE",
            "len"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_read_request",
          "args": [
            "conn",
            "req->id",
            "req->offset",
            "req->len",
            "handle",
            "handle_len"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "send_read_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "1141-1159",
          "snippet": "static void\nsend_read_request(struct sftp_conn *conn, u_int id, u_int64_t offset,\n    u_int len, const u_char *handle, u_int handle_len)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tsshbuf_reset(msg);\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_READ)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0 ||\n\t    (r = sshbuf_put_u64(msg, offset)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tsshbuf_free(msg);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_read_request(struct sftp_conn *conn, u_int id, u_int64_t offset,\n    u_int len, const u_char *handle, u_int handle_len)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tsshbuf_reset(msg);\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_READ)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0 ||\n\t    (r = sshbuf_put_u64(msg, offset)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tsshbuf_free(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&requests",
            "req",
            "tq"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomicio",
          "args": [
            "vwrite",
            "local_fd",
            "data",
            "len"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "atomiciov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "165-170",
          "snippet": "size_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "local_fd",
            "req->offset",
            "SEEK_SET"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string",
          "args": [
            "msg",
            "&data",
            "&len"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&requests",
            "req",
            "tq"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "msg",
            "&status"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Unexpected reply %u\"",
            "id"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_NEXT",
          "args": [
            "req",
            "tq"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&requests"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "msg",
            "&type"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_msg",
          "args": [
            "conn",
            "msg"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "get_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "170-174",
          "snippet": "static void\nget_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tget_msg_extended(conn, m, 0);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nget_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tget_msg_extended(conn, m, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "msg"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&requests",
            "req",
            "tq"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "1",
            "sizeof(*req)"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_progress_meter",
          "args": [
            "remote_path",
            "size",
            "&progress_counter"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "start_progress_meter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/progressmeter.c",
          "lines": "249-268",
          "snippet": "void\nstart_progress_meter(const char *f, off_t filesize, off_t *ctr)\n{\n\tstart = last_update = monotime_double();\n\tfile = f;\n\tstart_pos = *ctr;\n\tend_pos = filesize;\n\tcur_pos = 0;\n\tcounter = ctr;\n\tstalled = 0;\n\tbytes_per_second = 0;\n\n\tsetscreensize();\n\tif (can_output())\n\t\trefresh_progress_meter();\n\n\tsignal(SIGALRM, update_progress_meter);\n\tsignal(SIGWINCH, sig_winch);\n\talarm(UPDATE_INTERVAL);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"progressmeter.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define UPDATE_INTERVAL 1\t/* update the progress meter every second */"
          ],
          "globals_used": [
            "static int can_output(void);",
            "static void format_size(char *, int, off_t);",
            "static void format_rate(char *, int, off_t);",
            "static void sig_winch(int);",
            "static void setscreensize(void);",
            "void refresh_progress_meter(void);",
            "static void update_progress_meter(int);",
            "static double start;",
            "static double last_update;",
            "static const char *file;",
            "static off_t start_pos;",
            "static off_t end_pos;",
            "static off_t cur_pos;",
            "static volatile off_t *counter;",
            "static long stalled;",
            "static int bytes_per_second;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"progressmeter.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define UPDATE_INTERVAL 1\t/* update the progress meter every second */\n\nstatic int can_output(void);\nstatic void format_size(char *, int, off_t);\nstatic void format_rate(char *, int, off_t);\nstatic void sig_winch(int);\nstatic void setscreensize(void);\nvoid refresh_progress_meter(void);\nstatic void update_progress_meter(int);\nstatic double start;\nstatic double last_update;\nstatic const char *file;\nstatic off_t start_pos;\nstatic off_t end_pos;\nstatic off_t cur_pos;\nstatic volatile off_t *counter;\nstatic long stalled;\nstatic int bytes_per_second;\n\nvoid\nstart_progress_meter(const char *f, off_t filesize, off_t *ctr)\n{\n\tstart = last_update = monotime_double();\n\tfile = f;\n\tstart_pos = *ctr;\n\tend_pos = filesize;\n\tcur_pos = 0;\n\tcounter = ctr;\n\tstalled = 0;\n\tbytes_per_second = 0;\n\n\tsetscreensize();\n\tif (can_output())\n\t\trefresh_progress_meter();\n\n\tsignal(SIGALRM, update_progress_meter);\n\tsignal(SIGWINCH, sig_winch);\n\talarm(UPDATE_INTERVAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "local_fd",
            "&st"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "fstatvfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-statvfs.c",
          "lines": "71-85",
          "snippet": "int fstatvfs(int fd, struct statvfs *buf)\n{\n#  ifdef HAVE_FSTATFS\n\tstruct statfs fs;\n\n\tmemset(&fs, 0, sizeof(fs));\n\tif (fstatfs(fd, &fs) == -1)\n\t\treturn -1;\n\tcopy_statfs_to_statvfs(buf, &fs);\n\treturn 0;\n#  else\n\terrno = ENOSYS;\n\treturn -1;\n#  endif\n}",
          "includes": [
            "#include <errno.h>",
            "# include <sys/mount.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n# include <sys/mount.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nint fstatvfs(int fd, struct statvfs *buf)\n{\n#  ifdef HAVE_FSTATFS\n\tstruct statfs fs;\n\n\tmemset(&fs, 0, sizeof(fs));\n\tif (fstatfs(fd, &fs) == -1)\n\t\treturn -1;\n\tcopy_statfs_to_statvfs(buf, &fs);\n\treturn 0;\n#  else\n\terrno = ENOSYS;\n\treturn -1;\n#  endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "local_path",
            "O_WRONLY | O_CREAT | (resume_flag ? 0 : O_TRUNC)",
            "mode | S_IWUSR"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "lastlog_openseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/loginrec.c",
          "lines": "1471-1514",
          "snippet": "static int\nlastlog_openseek(struct logininfo *li, int *fd, int filemode)\n{\n\toff_t offset;\n\tchar lastlog_file[1024];\n\tstruct stat st;\n\n\tif (stat(LASTLOG_FILE, &st) != 0) {\n\t\tlogit(\"%s: Couldn't stat %s: %s\", __func__,\n\t\t    LASTLOG_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (S_ISDIR(st.st_mode)) {\n\t\tsnprintf(lastlog_file, sizeof(lastlog_file), \"%s/%s\",\n\t\t    LASTLOG_FILE, li->username);\n\t} else if (S_ISREG(st.st_mode)) {\n\t\tstrlcpy(lastlog_file, LASTLOG_FILE, sizeof(lastlog_file));\n\t} else {\n\t\tlogit(\"%s: %.100s is not a file or directory!\", __func__,\n\t\t    LASTLOG_FILE);\n\t\treturn (0);\n\t}\n\n\t*fd = open(lastlog_file, filemode, 0600);\n\tif (*fd < 0) {\n\t\tdebug(\"%s: Couldn't open %s: %s\", __func__,\n\t\t    lastlog_file, strerror(errno));\n\t\treturn (0);\n\t}\n\n\tif (S_ISREG(st.st_mode)) {\n\t\t/* find this uid's offset in the lastlog file */\n\t\toffset = (off_t) ((u_long)li->uid * sizeof(struct lastlog));\n\n\t\tif (lseek(*fd, offset, SEEK_SET) != offset) {\n\t\t\tlogit(\"%s: %s->lseek(): %s\", __func__,\n\t\t\t    lastlog_file, strerror(errno));\n\t\t\tclose(*fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}",
          "includes": [
            "# include <util.h>",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"canohost.h\"",
            "#include \"packet.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"loginrec.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int utmp_write_entry(struct logininfo *li);",
            "int utmpx_write_entry(struct logininfo *li);",
            "int wtmp_write_entry(struct logininfo *li);",
            "int wtmpx_write_entry(struct logininfo *li);",
            "int lastlog_write_entry(struct logininfo *li);",
            "int syslogin_write_entry(struct logininfo *li);",
            "int getlast_entry(struct logininfo *li);",
            "int lastlog_get_entry(struct logininfo *li);",
            "int utmpx_get_entry(struct logininfo *li);",
            "int wtmp_get_entry(struct logininfo *li);",
            "int wtmpx_get_entry(struct logininfo *li);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <util.h>\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"canohost.h\"\n#include \"packet.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"loginrec.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint utmp_write_entry(struct logininfo *li);\nint utmpx_write_entry(struct logininfo *li);\nint wtmp_write_entry(struct logininfo *li);\nint wtmpx_write_entry(struct logininfo *li);\nint lastlog_write_entry(struct logininfo *li);\nint syslogin_write_entry(struct logininfo *li);\nint getlast_entry(struct logininfo *li);\nint lastlog_get_entry(struct logininfo *li);\nint utmpx_get_entry(struct logininfo *li);\nint wtmp_get_entry(struct logininfo *li);\nint wtmpx_get_entry(struct logininfo *li);\n\nstatic int\nlastlog_openseek(struct logininfo *li, int *fd, int filemode)\n{\n\toff_t offset;\n\tchar lastlog_file[1024];\n\tstruct stat st;\n\n\tif (stat(LASTLOG_FILE, &st) != 0) {\n\t\tlogit(\"%s: Couldn't stat %s: %s\", __func__,\n\t\t    LASTLOG_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (S_ISDIR(st.st_mode)) {\n\t\tsnprintf(lastlog_file, sizeof(lastlog_file), \"%s/%s\",\n\t\t    LASTLOG_FILE, li->username);\n\t} else if (S_ISREG(st.st_mode)) {\n\t\tstrlcpy(lastlog_file, LASTLOG_FILE, sizeof(lastlog_file));\n\t} else {\n\t\tlogit(\"%s: %.100s is not a file or directory!\", __func__,\n\t\t    LASTLOG_FILE);\n\t\treturn (0);\n\t}\n\n\t*fd = open(lastlog_file, filemode, 0600);\n\tif (*fd < 0) {\n\t\tdebug(\"%s: Couldn't open %s: %s\", __func__,\n\t\t    lastlog_file, strerror(errno));\n\t\treturn (0);\n\t}\n\n\tif (S_ISREG(st.st_mode)) {\n\t\t/* find this uid's offset in the lastlog file */\n\t\toffset = (off_t) ((u_long)li->uid * sizeof(struct lastlog));\n\n\t\tif (lseek(*fd, offset, SEEK_SET) != offset) {\n\t\t\tlogit(\"%s: %s->lseek(): %s\", __func__,\n\t\t\t    lastlog_file, strerror(errno));\n\t\t\tclose(*fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_handle",
          "args": [
            "conn",
            "id",
            "&handle_len",
            "\"remote open(\\\"%s\\\")\"",
            "remote_path"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "get_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "243-286",
          "snippet": "static u_char *\nget_handle(struct sftp_conn *conn, u_int expected_id, size_t *len,\n    const char *errfmt, ...)\n{\n\tstruct sshbuf *msg;\n\tu_int id, status;\n\tu_char type;\n\tu_char *handle;\n\tchar errmsg[256];\n\tva_list args;\n\tint r;\n\n\tva_start(args, errfmt);\n\tif (errfmt != NULL)\n\t\tvsnprintf(errmsg, sizeof(errmsg), errfmt, args);\n\tva_end(args);\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"%s: ID mismatch (%u != %u)\",\n\t\t    errfmt == NULL ? __func__ : errmsg, id, expected_id);\n\tif (type == SSH2_FXP_STATUS) {\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (errfmt != NULL)\n\t\t\terror(\"%s: %s\", errmsg, fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn(NULL);\n\t} else if (type != SSH2_FXP_HANDLE)\n\t\tfatal(\"%s: Expected SSH2_FXP_HANDLE(%u) packet, got %u\",\n\t\t    errfmt == NULL ? __func__ : errmsg, SSH2_FXP_HANDLE, type);\n\n\tif ((r = sshbuf_get_string(msg, &handle, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\treturn handle;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic u_char *\nget_handle(struct sftp_conn *conn, u_int expected_id, size_t *len,\n    const char *errfmt, ...)\n{\n\tstruct sshbuf *msg;\n\tu_int id, status;\n\tu_char type;\n\tu_char *handle;\n\tchar errmsg[256];\n\tva_list args;\n\tint r;\n\n\tva_start(args, errfmt);\n\tif (errfmt != NULL)\n\t\tvsnprintf(errmsg, sizeof(errmsg), errfmt, args);\n\tva_end(args);\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"%s: ID mismatch (%u != %u)\",\n\t\t    errfmt == NULL ? __func__ : errmsg, id, expected_id);\n\tif (type == SSH2_FXP_STATUS) {\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (errfmt != NULL)\n\t\t\terror(\"%s: %s\", errmsg, fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn(NULL);\n\t} else if (type != SSH2_FXP_HANDLE)\n\t\tfatal(\"%s: Expected SSH2_FXP_HANDLE(%u) packet, got %u\",\n\t\t    errfmt == NULL ? __func__ : errmsg, SSH2_FXP_HANDLE, type);\n\n\tif ((r = sshbuf_get_string(msg, &handle, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_msg",
          "args": [
            "conn",
            "msg"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "send_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "108-130",
          "snippet": "static void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_attrib",
          "args": [
            "msg",
            "&junk"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "encode_attrib",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "153-179",
          "snippet": "int\nencode_attrib(struct sshbuf *b, const Attrib *a)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(b, a->flags)) != 0)\n\t\treturn r;\n\tif (a->flags & SSH2_FILEXFER_ATTR_SIZE) {\n\t\tif ((r = sshbuf_put_u64(b, a->size)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {\n\t\tif ((r = sshbuf_put_u32(b, a->uid)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, a->gid)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {\n\t\tif ((r = sshbuf_put_u32(b, a->perm)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {\n\t\tif ((r = sshbuf_put_u32(b, a->atime)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, a->mtime)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nencode_attrib(struct sshbuf *b, const Attrib *a)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(b, a->flags)) != 0)\n\t\treturn r;\n\tif (a->flags & SSH2_FILEXFER_ATTR_SIZE) {\n\t\tif ((r = sshbuf_put_u64(b, a->size)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {\n\t\tif ((r = sshbuf_put_u32(b, a->uid)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, a->gid)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {\n\t\tif ((r = sshbuf_put_u32(b, a->perm)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {\n\t\tif ((r = sshbuf_put_u32(b, a->atime)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, a->mtime)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "msg",
            "SSH2_FXF_READ"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "msg",
            "remote_path"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "SSH2_FXP_OPEN"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "attrib_clear",
          "args": [
            "&junk"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "attrib_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "53-63",
          "snippet": "void\nattrib_clear(Attrib *a)\n{\n\ta->flags = 0;\n\ta->size = 0;\n\ta->uid = 0;\n\ta->gid = 0;\n\ta->perm = 0;\n\ta->atime = 0;\n\ta->mtime = 0;\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nattrib_clear(Attrib *a)\n{\n\ta->flags = 0;\n\ta->size = 0;\n\ta->uid = 0;\n\ta->gid = 0;\n\ta->perm = 0;\n\ta->atime = 0;\n\ta->mtime = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "a->perm"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_stat",
          "args": [
            "conn",
            "remote_path",
            "0"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "do_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "742-754",
          "snippet": "Attrib *\ndo_stat(struct sftp_conn *conn, const char *path, int quiet)\n{\n\tu_int id;\n\n\tid = conn->msg_id++;\n\n\tsend_string_request(conn, id,\n\t    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT,\n\t    path, strlen(path));\n\n\treturn(get_decode_stat(conn, id, quiet));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nAttrib *\ndo_stat(struct sftp_conn *conn, const char *path, int quiet)\n{\n\tu_int id;\n\n\tid = conn->msg_id++;\n\n\tsend_string_request(conn, id,\n\t    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT,\n\t    path, strlen(path));\n\n\treturn(get_decode_stat(conn, id, quiet));\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&requests"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_HEAD",
          "args": [
            "reqhead",
            "request"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MIN_READ_SIZE\t512\n\nextern volatile sig_atomic_t interrupted;\nextern int showprogress;\n\nint\ndo_download(struct sftp_conn *conn, const char *remote_path,\n    const char *local_path, Attrib *a, int preserve_flag, int resume_flag,\n    int fsync_flag)\n{\n\tAttrib junk;\n\tstruct sshbuf *msg;\n\tu_char *handle;\n\tint local_fd = -1, write_error;\n\tint read_error, write_errno, reordered = 0, r;\n\tu_int64_t offset = 0, size, highwater;\n\tu_int mode, id, buflen, num_req, max_req, status = SSH2_FX_OK;\n\toff_t progress_counter;\n\tsize_t handle_len;\n\tstruct stat st;\n\tstruct request {\n\t\tu_int id;\n\t\tsize_t len;\n\t\tu_int64_t offset;\n\t\tTAILQ_ENTRY(request) tq;\n\t};\n\tTAILQ_HEAD(reqhead, request) requests;\n\tstruct request *req;\n\tu_char type;\n\n\tTAILQ_INIT(&requests);\n\n\tif (a == NULL && (a = do_stat(conn, remote_path, 0)) == NULL)\n\t\treturn -1;\n\n\t/* Do not preserve set[ug]id here, as we do not preserve ownership */\n\tif (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS)\n\t\tmode = a->perm & 0777;\n\telse\n\t\tmode = 0666;\n\n\tif ((a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) &&\n\t    (!S_ISREG(a->perm))) {\n\t\terror(\"Cannot download non-regular file: %s\", remote_path);\n\t\treturn(-1);\n\t}\n\n\tif (a->flags & SSH2_FILEXFER_ATTR_SIZE)\n\t\tsize = a->size;\n\telse\n\t\tsize = 0;\n\n\tbuflen = conn->transfer_buflen;\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tattrib_clear(&junk); /* Send empty attributes */\n\n\t/* Send open request */\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_OPEN)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, remote_path)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, SSH2_FXF_READ)) != 0 ||\n\t    (r = encode_attrib(msg, &junk)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message SSH2_FXP_OPEN I:%u P:%s\", id, remote_path);\n\n\thandle = get_handle(conn, id, &handle_len,\n\t    \"remote open(\\\"%s\\\")\", remote_path);\n\tif (handle == NULL) {\n\t\tsshbuf_free(msg);\n\t\treturn(-1);\n\t}\n\n\tlocal_fd = open(local_path,\n\t    O_WRONLY | O_CREAT | (resume_flag ? 0 : O_TRUNC), mode | S_IWUSR);\n\tif (local_fd == -1) {\n\t\terror(\"Couldn't open local file \\\"%s\\\" for writing: %s\",\n\t\t    local_path, strerror(errno));\n\t\tgoto fail;\n\t}\n\toffset = highwater = 0;\n\tif (resume_flag) {\n\t\tif (fstat(local_fd, &st) == -1) {\n\t\t\terror(\"Unable to stat local file \\\"%s\\\": %s\",\n\t\t\t    local_path, strerror(errno));\n\t\t\tgoto fail;\n\t\t}\n\t\tif (st.st_size < 0) {\n\t\t\terror(\"\\\"%s\\\" has negative size\", local_path);\n\t\t\tgoto fail;\n\t\t}\n\t\tif ((u_int64_t)st.st_size > size) {\n\t\t\terror(\"Unable to resume download of \\\"%s\\\": \"\n\t\t\t    \"local file is larger than remote\", local_path);\n fail:\n\t\t\tdo_close(conn, handle, handle_len);\n\t\t\tsshbuf_free(msg);\n\t\t\tfree(handle);\n\t\t\tif (local_fd != -1)\n\t\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\t\toffset = highwater = st.st_size;\n\t}\n\n\t/* Read from remote and write to local */\n\twrite_error = read_error = write_errno = num_req = 0;\n\tmax_req = 1;\n\tprogress_counter = offset;\n\n\tif (showprogress && size != 0)\n\t\tstart_progress_meter(remote_path, size, &progress_counter);\n\n\twhile (num_req > 0 || max_req > 0) {\n\t\tu_char *data;\n\t\tsize_t len;\n\n\t\t/*\n\t\t * Simulate EOF on interrupt: stop sending new requests and\n\t\t * allow outstanding requests to drain gracefully\n\t\t */\n\t\tif (interrupted) {\n\t\t\tif (num_req == 0) /* If we haven't started yet... */\n\t\t\t\tbreak;\n\t\t\tmax_req = 0;\n\t\t}\n\n\t\t/* Send some more requests */\n\t\twhile (num_req < max_req) {\n\t\t\tdebug3(\"Request range %llu -> %llu (%d/%d)\",\n\t\t\t    (unsigned long long)offset,\n\t\t\t    (unsigned long long)offset + buflen - 1,\n\t\t\t    num_req, max_req);\n\t\t\treq = xcalloc(1, sizeof(*req));\n\t\t\treq->id = conn->msg_id++;\n\t\t\treq->len = buflen;\n\t\t\treq->offset = offset;\n\t\t\toffset += buflen;\n\t\t\tnum_req++;\n\t\t\tTAILQ_INSERT_TAIL(&requests, req, tq);\n\t\t\tsend_read_request(conn, req->id, req->offset,\n\t\t\t    req->len, handle, handle_len);\n\t\t}\n\n\t\tsshbuf_reset(msg);\n\t\tget_msg(conn, msg);\n\t\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tdebug3(\"Received reply T:%u I:%u R:%d\", type, id, max_req);\n\n\t\t/* Find the request in our queue */\n\t\tfor (req = TAILQ_FIRST(&requests);\n\t\t    req != NULL && req->id != id;\n\t\t    req = TAILQ_NEXT(req, tq))\n\t\t\t;\n\t\tif (req == NULL)\n\t\t\tfatal(\"Unexpected reply %u\", id);\n\n\t\tswitch (type) {\n\t\tcase SSH2_FXP_STATUS:\n\t\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif (status != SSH2_FX_EOF)\n\t\t\t\tread_error = 1;\n\t\t\tmax_req = 0;\n\t\t\tTAILQ_REMOVE(&requests, req, tq);\n\t\t\tfree(req);\n\t\t\tnum_req--;\n\t\t\tbreak;\n\t\tcase SSH2_FXP_DATA:\n\t\t\tif ((r = sshbuf_get_string(msg, &data, &len)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdebug3(\"Received data %llu -> %llu\",\n\t\t\t    (unsigned long long)req->offset,\n\t\t\t    (unsigned long long)req->offset + len - 1);\n\t\t\tif (len > req->len)\n\t\t\t\tfatal(\"Received more data than asked for \"\n\t\t\t\t    \"%zu > %zu\", len, req->len);\n\t\t\tif ((lseek(local_fd, req->offset, SEEK_SET) == -1 ||\n\t\t\t    atomicio(vwrite, local_fd, data, len) != len) &&\n\t\t\t    !write_error) {\n\t\t\t\twrite_errno = errno;\n\t\t\t\twrite_error = 1;\n\t\t\t\tmax_req = 0;\n\t\t\t}\n\t\t\telse if (!reordered && req->offset <= highwater)\n\t\t\t\thighwater = req->offset + len;\n\t\t\telse if (!reordered && req->offset > highwater)\n\t\t\t\treordered = 1;\n\t\t\tprogress_counter += len;\n\t\t\tfree(data);\n\n\t\t\tif (len == req->len) {\n\t\t\t\tTAILQ_REMOVE(&requests, req, tq);\n\t\t\t\tfree(req);\n\t\t\t\tnum_req--;\n\t\t\t} else {\n\t\t\t\t/* Resend the request for the missing data */\n\t\t\t\tdebug3(\"Short data block, re-requesting \"\n\t\t\t\t    \"%llu -> %llu (%2d)\",\n\t\t\t\t    (unsigned long long)req->offset + len,\n\t\t\t\t    (unsigned long long)req->offset +\n\t\t\t\t    req->len - 1, num_req);\n\t\t\t\treq->id = conn->msg_id++;\n\t\t\t\treq->len -= len;\n\t\t\t\treq->offset += len;\n\t\t\t\tsend_read_request(conn, req->id,\n\t\t\t\t    req->offset, req->len, handle, handle_len);\n\t\t\t\t/* Reduce the request size */\n\t\t\t\tif (len < buflen)\n\t\t\t\t\tbuflen = MAXIMUM(MIN_READ_SIZE, len);\n\t\t\t}\n\t\t\tif (max_req > 0) { /* max_req = 0 iff EOF received */\n\t\t\t\tif (size > 0 && offset > size) {\n\t\t\t\t\t/* Only one request at a time\n\t\t\t\t\t * after the expected EOF */\n\t\t\t\t\tdebug3(\"Finish at %llu (%2d)\",\n\t\t\t\t\t    (unsigned long long)offset,\n\t\t\t\t\t    num_req);\n\t\t\t\t\tmax_req = 1;\n\t\t\t\t} else if (max_req <= conn->num_requests) {\n\t\t\t\t\t++max_req;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Expected SSH2_FXP_DATA(%u) packet, got %u\",\n\t\t\t    SSH2_FXP_DATA, type);\n\t\t}\n\t}\n\n\tif (showprogress && size)\n\t\tstop_progress_meter();\n\n\t/* Sanity check */\n\tif (TAILQ_FIRST(&requests) != NULL)\n\t\tfatal(\"Transfer complete, but requests still in queue\");\n\t/* Truncate at highest contiguous point to avoid holes on interrupt */\n\tif (read_error || write_error || interrupted) {\n\t\tif (reordered && resume_flag) {\n\t\t\terror(\"Unable to resume download of \\\"%s\\\": \"\n\t\t\t    \"server reordered requests\", local_path);\n\t\t}\n\t\tdebug(\"truncating at %llu\", (unsigned long long)highwater);\n\t\tif (ftruncate(local_fd, highwater) == -1)\n\t\t\terror(\"ftruncate \\\"%s\\\": %s\", local_path,\n\t\t\t    strerror(errno));\n\t}\n\tif (read_error) {\n\t\terror(\"Couldn't read from remote file \\\"%s\\\" : %s\",\n\t\t    remote_path, fx2txt(status));\n\t\tstatus = -1;\n\t\tdo_close(conn, handle, handle_len);\n\t} else if (write_error) {\n\t\terror(\"Couldn't write to \\\"%s\\\": %s\", local_path,\n\t\t    strerror(write_errno));\n\t\tstatus = SSH2_FX_FAILURE;\n\t\tdo_close(conn, handle, handle_len);\n\t} else {\n\t\tif (do_close(conn, handle, handle_len) != 0 || interrupted)\n\t\t\tstatus = SSH2_FX_FAILURE;\n\t\telse\n\t\t\tstatus = SSH2_FX_OK;\n\t\t/* Override umask and utimes if asked */\n#ifdef HAVE_FCHMOD\n\t\tif (preserve_flag && fchmod(local_fd, mode) == -1)\n#else\n\t\tif (preserve_flag && chmod(local_path, mode) == -1)\n#endif /* HAVE_FCHMOD */\n\t\t\terror(\"Couldn't set mode on \\\"%s\\\": %s\", local_path,\n\t\t\t    strerror(errno));\n\t\tif (preserve_flag &&\n\t\t    (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME)) {\n\t\t\tstruct timeval tv[2];\n\t\t\ttv[0].tv_sec = a->atime;\n\t\t\ttv[1].tv_sec = a->mtime;\n\t\t\ttv[0].tv_usec = tv[1].tv_usec = 0;\n\t\t\tif (utimes(local_path, tv) == -1)\n\t\t\t\terror(\"Can't set times on \\\"%s\\\": %s\",\n\t\t\t\t    local_path, strerror(errno));\n\t\t}\n\t\tif (fsync_flag) {\n\t\t\tdebug(\"syncing \\\"%s\\\"\", local_path);\n\t\t\tif (fsync(local_fd) == -1)\n\t\t\t\terror(\"Couldn't sync file \\\"%s\\\": %s\",\n\t\t\t\t    local_path, strerror(errno));\n\t\t}\n\t}\n\tclose(local_fd);\n\tsshbuf_free(msg);\n\tfree(handle);\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
  },
  {
    "function_name": "send_read_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "1141-1159",
    "snippet": "static void\nsend_read_request(struct sftp_conn *conn, u_int id, u_int64_t offset,\n    u_int len, const u_char *handle, u_int handle_len)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tsshbuf_reset(msg);\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_READ)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0 ||\n\t    (r = sshbuf_put_u64(msg, offset)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tsshbuf_free(msg);\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_msg",
          "args": [
            "conn",
            "msg"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "send_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "108-130",
          "snippet": "static void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "msg",
            "len"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u64",
          "args": [
            "msg",
            "offset"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "299-309",
          "snippet": "int\nsshbuf_put_u64(struct sshbuf *buf, u_int64_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 8, &p)) < 0)\n\t\treturn r;\n\tPOKE_U64(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u64(struct sshbuf *buf, u_int64_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 8, &p)) < 0)\n\t\treturn r;\n\tPOKE_U64(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "msg",
            "handle",
            "handle_len"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "SSH2_FXP_READ"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "msg"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_read_request(struct sftp_conn *conn, u_int id, u_int64_t offset,\n    u_int len, const u_char *handle, u_int handle_len)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tsshbuf_reset(msg);\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_READ)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0 ||\n\t    (r = sshbuf_put_u64(msg, offset)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tsshbuf_free(msg);\n}"
  },
  {
    "function_name": "do_fstatvfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "1112-1138",
    "snippet": "int\ndo_fstatvfs(struct sftp_conn *conn, const u_char *handle, u_int handle_len,\n    struct sftp_statvfs *st, int quiet)\n{\n\tstruct sshbuf *msg;\n\tu_int id;\n\n\tif ((conn->exts & SFTP_EXT_FSTATVFS) == 0) {\n\t\terror(\"Server does not support fstatvfs@openssh.com extension\");\n\t\treturn -1;\n\t}\n\n\tid = conn->msg_id++;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tsshbuf_reset(msg);\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, \"fstatvfs@openssh.com\")) != 0 ||\n\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tsshbuf_free(msg);\n\n\treturn get_decode_statvfs(conn, st, id, quiet);\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define SFTP_EXT_FSTATVFS\t0x00000004"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_decode_statvfs",
          "args": [
            "conn",
            "st",
            "id",
            "quiet"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "get_decode_statvfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "333-390",
          "snippet": "static int\nget_decode_statvfs(struct sftp_conn *conn, struct sftp_statvfs *st,\n    u_int expected_id, int quiet)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id;\n\tu_int64_t flag;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"Received statvfs reply T:%u I:%u\", type, id);\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (quiet)\n\t\t\tdebug(\"Couldn't statvfs: %s\", fx2txt(status));\n\t\telse\n\t\t\terror(\"Couldn't statvfs: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn -1;\n\t} else if (type != SSH2_FXP_EXTENDED_REPLY) {\n\t\tfatal(\"Expected SSH2_FXP_EXTENDED_REPLY(%u) packet, got %u\",\n\t\t    SSH2_FXP_EXTENDED_REPLY, type);\n\t}\n\n\tmemset(st, 0, sizeof(*st));\n\tif ((r = sshbuf_get_u64(msg, &st->f_bsize)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_frsize)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_blocks)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_bfree)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_bavail)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_files)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_ffree)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_favail)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_fsid)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &flag)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_namemax)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tst->f_flag = (flag & SSH2_FXE_STATVFS_ST_RDONLY) ? ST_RDONLY : 0;\n\tst->f_flag |= (flag & SSH2_FXE_STATVFS_ST_NOSUID) ? ST_NOSUID : 0;\n\n\tsshbuf_free(msg);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nget_decode_statvfs(struct sftp_conn *conn, struct sftp_statvfs *st,\n    u_int expected_id, int quiet)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id;\n\tu_int64_t flag;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"Received statvfs reply T:%u I:%u\", type, id);\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (quiet)\n\t\t\tdebug(\"Couldn't statvfs: %s\", fx2txt(status));\n\t\telse\n\t\t\terror(\"Couldn't statvfs: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn -1;\n\t} else if (type != SSH2_FXP_EXTENDED_REPLY) {\n\t\tfatal(\"Expected SSH2_FXP_EXTENDED_REPLY(%u) packet, got %u\",\n\t\t    SSH2_FXP_EXTENDED_REPLY, type);\n\t}\n\n\tmemset(st, 0, sizeof(*st));\n\tif ((r = sshbuf_get_u64(msg, &st->f_bsize)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_frsize)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_blocks)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_bfree)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_bavail)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_files)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_ffree)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_favail)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_fsid)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &flag)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_namemax)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tst->f_flag = (flag & SSH2_FXE_STATVFS_ST_RDONLY) ? ST_RDONLY : 0;\n\tst->f_flag |= (flag & SSH2_FXE_STATVFS_ST_NOSUID) ? ST_NOSUID : 0;\n\n\tsshbuf_free(msg);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_msg",
          "args": [
            "conn",
            "msg"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "send_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "108-130",
          "snippet": "static void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "msg",
            "handle",
            "handle_len"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "msg",
            "\"fstatvfs@openssh.com\""
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "msg",
            "id"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "SSH2_FXP_EXTENDED"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "msg"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Server does not support fstatvfs@openssh.com extension\""
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SFTP_EXT_FSTATVFS\t0x00000004\n\nint\ndo_fstatvfs(struct sftp_conn *conn, const u_char *handle, u_int handle_len,\n    struct sftp_statvfs *st, int quiet)\n{\n\tstruct sshbuf *msg;\n\tu_int id;\n\n\tif ((conn->exts & SFTP_EXT_FSTATVFS) == 0) {\n\t\terror(\"Server does not support fstatvfs@openssh.com extension\");\n\t\treturn -1;\n\t}\n\n\tid = conn->msg_id++;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tsshbuf_reset(msg);\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, \"fstatvfs@openssh.com\")) != 0 ||\n\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tsshbuf_free(msg);\n\n\treturn get_decode_statvfs(conn, st, id, quiet);\n}"
  },
  {
    "function_name": "do_statvfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "1082-1109",
    "snippet": "int\ndo_statvfs(struct sftp_conn *conn, const char *path, struct sftp_statvfs *st,\n    int quiet)\n{\n\tstruct sshbuf *msg;\n\tu_int id;\n\tint r;\n\n\tif ((conn->exts & SFTP_EXT_STATVFS) == 0) {\n\t\terror(\"Server does not support statvfs@openssh.com extension\");\n\t\treturn -1;\n\t}\n\n\tid = conn->msg_id++;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tsshbuf_reset(msg);\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, \"statvfs@openssh.com\")) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, path)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tsshbuf_free(msg);\n\n\treturn get_decode_statvfs(conn, st, id, quiet);\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define SFTP_EXT_STATVFS\t0x00000002"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_decode_statvfs",
          "args": [
            "conn",
            "st",
            "id",
            "quiet"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "get_decode_statvfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "333-390",
          "snippet": "static int\nget_decode_statvfs(struct sftp_conn *conn, struct sftp_statvfs *st,\n    u_int expected_id, int quiet)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id;\n\tu_int64_t flag;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"Received statvfs reply T:%u I:%u\", type, id);\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (quiet)\n\t\t\tdebug(\"Couldn't statvfs: %s\", fx2txt(status));\n\t\telse\n\t\t\terror(\"Couldn't statvfs: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn -1;\n\t} else if (type != SSH2_FXP_EXTENDED_REPLY) {\n\t\tfatal(\"Expected SSH2_FXP_EXTENDED_REPLY(%u) packet, got %u\",\n\t\t    SSH2_FXP_EXTENDED_REPLY, type);\n\t}\n\n\tmemset(st, 0, sizeof(*st));\n\tif ((r = sshbuf_get_u64(msg, &st->f_bsize)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_frsize)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_blocks)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_bfree)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_bavail)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_files)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_ffree)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_favail)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_fsid)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &flag)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_namemax)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tst->f_flag = (flag & SSH2_FXE_STATVFS_ST_RDONLY) ? ST_RDONLY : 0;\n\tst->f_flag |= (flag & SSH2_FXE_STATVFS_ST_NOSUID) ? ST_NOSUID : 0;\n\n\tsshbuf_free(msg);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nget_decode_statvfs(struct sftp_conn *conn, struct sftp_statvfs *st,\n    u_int expected_id, int quiet)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id;\n\tu_int64_t flag;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"Received statvfs reply T:%u I:%u\", type, id);\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (quiet)\n\t\t\tdebug(\"Couldn't statvfs: %s\", fx2txt(status));\n\t\telse\n\t\t\terror(\"Couldn't statvfs: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn -1;\n\t} else if (type != SSH2_FXP_EXTENDED_REPLY) {\n\t\tfatal(\"Expected SSH2_FXP_EXTENDED_REPLY(%u) packet, got %u\",\n\t\t    SSH2_FXP_EXTENDED_REPLY, type);\n\t}\n\n\tmemset(st, 0, sizeof(*st));\n\tif ((r = sshbuf_get_u64(msg, &st->f_bsize)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_frsize)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_blocks)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_bfree)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_bavail)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_files)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_ffree)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_favail)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_fsid)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &flag)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_namemax)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tst->f_flag = (flag & SSH2_FXE_STATVFS_ST_RDONLY) ? ST_RDONLY : 0;\n\tst->f_flag |= (flag & SSH2_FXE_STATVFS_ST_NOSUID) ? ST_NOSUID : 0;\n\n\tsshbuf_free(msg);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_msg",
          "args": [
            "conn",
            "msg"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "send_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "108-130",
          "snippet": "static void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "msg",
            "path"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "msg",
            "id"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "SSH2_FXP_EXTENDED"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "msg"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Server does not support statvfs@openssh.com extension\""
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SFTP_EXT_STATVFS\t0x00000002\n\nint\ndo_statvfs(struct sftp_conn *conn, const char *path, struct sftp_statvfs *st,\n    int quiet)\n{\n\tstruct sshbuf *msg;\n\tu_int id;\n\tint r;\n\n\tif ((conn->exts & SFTP_EXT_STATVFS) == 0) {\n\t\terror(\"Server does not support statvfs@openssh.com extension\");\n\t\treturn -1;\n\t}\n\n\tid = conn->msg_id++;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tsshbuf_reset(msg);\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, \"statvfs@openssh.com\")) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, path)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tsshbuf_free(msg);\n\n\treturn get_decode_statvfs(conn, st, id, quiet);\n}"
  },
  {
    "function_name": "do_readlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "1026-1079",
    "snippet": "char *\ndo_readlink(struct sftp_conn *conn, const char *path)\n{\n\tstruct sshbuf *msg;\n\tu_int expected_id, count, id;\n\tchar *filename, *longname;\n\tAttrib a;\n\tu_char type;\n\tint r;\n\n\texpected_id = id = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_READLINK, path, strlen(path));\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\terror(\"Couldn't readlink: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn(NULL);\n\t} else if (type != SSH2_FXP_NAME)\n\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t    SSH2_FXP_NAME, type);\n\n\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (count != 1)\n\t\tfatal(\"Got multiple names (%d) from SSH_FXP_READLINK\", count);\n\n\tif ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||\n\t    (r = decode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"SSH_FXP_READLINK %s -> %s\", path, filename);\n\n\tfree(longname);\n\n\tsshbuf_free(msg);\n\n\treturn filename;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "longname"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "free_sftp_dirents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "681-693",
          "snippet": "void free_sftp_dirents(SFTP_DIRENT **s)\n{\n\tint i;\n\n\tif (s == NULL)\n\t\treturn;\n\tfor (i = 0; s[i]; i++) {\n\t\tfree(s[i]->filename);\n\t\tfree(s[i]->longname);\n\t\tfree(s[i]);\n\t}\n\tfree(s);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid free_sftp_dirents(SFTP_DIRENT **s)\n{\n\tint i;\n\n\tif (s == NULL)\n\t\treturn;\n\tfor (i = 0; s[i]; i++) {\n\t\tfree(s[i]->filename);\n\t\tfree(s[i]->longname);\n\t\tfree(s[i]);\n\t}\n\tfree(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"SSH_FXP_READLINK %s -> %s\"",
            "path",
            "filename"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_attrib",
          "args": [
            "msg",
            "&a"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "decode_attrib",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "104-150",
          "snippet": "int\ndecode_attrib(struct sshbuf *b, Attrib *a)\n{\n\tint r;\n\n\tattrib_clear(a);\n\tif ((r = sshbuf_get_u32(b, &a->flags)) != 0)\n\t\treturn r;\n\tif (a->flags & SSH2_FILEXFER_ATTR_SIZE) {\n\t\tif ((r = sshbuf_get_u64(b, &a->size)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {\n\t\tif ((r = sshbuf_get_u32(b, &a->uid)) != 0 ||\n\t\t    (r = sshbuf_get_u32(b, &a->gid)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {\n\t\tif ((r = sshbuf_get_u32(b, &a->perm)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {\n\t\tif ((r = sshbuf_get_u32(b, &a->atime)) != 0 ||\n\t\t    (r = sshbuf_get_u32(b, &a->mtime)) != 0)\n\t\t\treturn r;\n\t}\n\t/* vendor-specific extensions */\n\tif (a->flags & SSH2_FILEXFER_ATTR_EXTENDED) {\n\t\tchar *type;\n\t\tu_char *data;\n\t\tsize_t dlen;\n\t\tu_int i, count;\n\n\t\tif ((r = sshbuf_get_u32(b, &count)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif ((r = sshbuf_get_cstring(b, &type, NULL)) != 0 ||\n\t\t\t    (r = sshbuf_get_string(b, &data, &dlen)) != 0)\n\t\t\t\treturn r;\n\t\t\tdebug3(\"Got file attribute \\\"%.100s\\\" len %zu\",\n\t\t\t    type, dlen);\n\t\t\tfree(type);\n\t\t\tfree(data);\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndecode_attrib(struct sshbuf *b, Attrib *a)\n{\n\tint r;\n\n\tattrib_clear(a);\n\tif ((r = sshbuf_get_u32(b, &a->flags)) != 0)\n\t\treturn r;\n\tif (a->flags & SSH2_FILEXFER_ATTR_SIZE) {\n\t\tif ((r = sshbuf_get_u64(b, &a->size)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {\n\t\tif ((r = sshbuf_get_u32(b, &a->uid)) != 0 ||\n\t\t    (r = sshbuf_get_u32(b, &a->gid)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {\n\t\tif ((r = sshbuf_get_u32(b, &a->perm)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {\n\t\tif ((r = sshbuf_get_u32(b, &a->atime)) != 0 ||\n\t\t    (r = sshbuf_get_u32(b, &a->mtime)) != 0)\n\t\t\treturn r;\n\t}\n\t/* vendor-specific extensions */\n\tif (a->flags & SSH2_FILEXFER_ATTR_EXTENDED) {\n\t\tchar *type;\n\t\tu_char *data;\n\t\tsize_t dlen;\n\t\tu_int i, count;\n\n\t\tif ((r = sshbuf_get_u32(b, &count)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif ((r = sshbuf_get_cstring(b, &type, NULL)) != 0 ||\n\t\t\t    (r = sshbuf_get_string(b, &data, &dlen)) != 0)\n\t\t\t\treturn r;\n\t\t\tdebug3(\"Got file attribute \\\"%.100s\\\" len %zu\",\n\t\t\t    type, dlen);\n\t\t\tfree(type);\n\t\t\tfree(data);\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "msg",
            "&longname",
            "NULL"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Got multiple names (%d) from SSH_FXP_READLINK\"",
            "count"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "msg",
            "&count"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Couldn't readlink: %s\"",
            "fx2txt(status)"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fx2txt",
          "args": [
            "status"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "fx2txt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "182-208",
          "snippet": "const char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "msg",
            "&type"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_msg",
          "args": [
            "conn",
            "msg"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "get_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "170-174",
          "snippet": "static void\nget_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tget_msg_extended(conn, m, 0);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nget_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tget_msg_extended(conn, m, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_string_request",
          "args": [
            "conn",
            "id",
            "SSH2_FXP_READLINK",
            "path",
            "strlen(path)"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "send_string_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "176-192",
          "snippet": "static void\nsend_string_request(struct sftp_conn *conn, u_int id, u_int code, const char *s,\n    u_int len)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, code)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, s, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fd %d T:%u I:%u\", conn->fd_out, code, id);\n\tsshbuf_free(msg);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_string_request(struct sftp_conn *conn, u_int id, u_int code, const char *s,\n    u_int len)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, code)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, s, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fd %d T:%u I:%u\", conn->fd_out, code, id);\n\tsshbuf_free(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ndo_readlink(struct sftp_conn *conn, const char *path)\n{\n\tstruct sshbuf *msg;\n\tu_int expected_id, count, id;\n\tchar *filename, *longname;\n\tAttrib a;\n\tu_char type;\n\tint r;\n\n\texpected_id = id = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_READLINK, path, strlen(path));\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\terror(\"Couldn't readlink: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn(NULL);\n\t} else if (type != SSH2_FXP_NAME)\n\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t    SSH2_FXP_NAME, type);\n\n\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (count != 1)\n\t\tfatal(\"Got multiple names (%d) from SSH_FXP_READLINK\", count);\n\n\tif ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||\n\t    (r = decode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"SSH_FXP_READLINK %s -> %s\", path, filename);\n\n\tfree(longname);\n\n\tsshbuf_free(msg);\n\n\treturn filename;\n}"
  },
  {
    "function_name": "do_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "994-1023",
    "snippet": "int\ndo_fsync(struct sftp_conn *conn, u_char *handle, u_int handle_len)\n{\n\tstruct sshbuf *msg;\n\tu_int status, id;\n\tint r;\n\n\t/* Silently return if the extension is not supported */\n\tif ((conn->exts & SFTP_EXT_FSYNC) == 0)\n\t\treturn -1;\n\n\t/* Send fsync request */\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, \"fsync@openssh.com\")) != 0 ||\n\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fsync@openssh.com I:%u\", id);\n\tsshbuf_free(msg);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't sync file: %s\", fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define SFTP_EXT_FSYNC\t\t0x00000010"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Couldn't sync file: %s\"",
            "fx2txt(status)"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fx2txt",
          "args": [
            "status"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "fx2txt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "182-208",
          "snippet": "const char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_status",
          "args": [
            "conn",
            "id"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "get_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "213-241",
          "snippet": "static u_int\nget_status(struct sftp_conn *conn, u_int expected_id)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id, status;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type != SSH2_FXP_STATUS)\n\t\tfatal(\"Expected SSH2_FXP_STATUS(%u) packet, got %u\",\n\t\t    SSH2_FXP_STATUS, type);\n\n\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic u_int\nget_status(struct sftp_conn *conn, u_int expected_id)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id, status;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type != SSH2_FXP_STATUS)\n\t\tfatal(\"Expected SSH2_FXP_STATUS(%u) packet, got %u\",\n\t\t    SSH2_FXP_STATUS, type);\n\n\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Sent message fsync@openssh.com I:%u\"",
            "id"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_msg",
          "args": [
            "conn",
            "msg"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "send_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "108-130",
          "snippet": "static void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "msg",
            "handle",
            "handle_len"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "msg",
            "\"fsync@openssh.com\""
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "msg",
            "id"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "SSH2_FXP_EXTENDED"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SFTP_EXT_FSYNC\t\t0x00000010\n\nint\ndo_fsync(struct sftp_conn *conn, u_char *handle, u_int handle_len)\n{\n\tstruct sshbuf *msg;\n\tu_int status, id;\n\tint r;\n\n\t/* Silently return if the extension is not supported */\n\tif ((conn->exts & SFTP_EXT_FSYNC) == 0)\n\t\treturn -1;\n\n\t/* Send fsync request */\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, \"fsync@openssh.com\")) != 0 ||\n\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fsync@openssh.com I:%u\", id);\n\tsshbuf_free(msg);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't sync file: %s\", fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
  },
  {
    "function_name": "do_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "959-992",
    "snippet": "int\ndo_symlink(struct sftp_conn *conn, const char *oldpath, const char *newpath)\n{\n\tstruct sshbuf *msg;\n\tu_int status, id;\n\tint r;\n\n\tif (conn->version < 3) {\n\t\terror(\"This server does not support the symlink operation\");\n\t\treturn(SSH2_FX_OP_UNSUPPORTED);\n\t}\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\t/* Send symlink request */\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_SYMLINK)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, oldpath)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, newpath)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message SSH2_FXP_SYMLINK \\\"%s\\\" -> \\\"%s\\\"\", oldpath,\n\t    newpath);\n\tsshbuf_free(msg);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't symlink file \\\"%s\\\" to \\\"%s\\\": %s\", oldpath,\n\t\t    newpath, fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Couldn't symlink file \\\"%s\\\" to \\\"%s\\\": %s\"",
            "oldpath",
            "newpath",
            "fx2txt(status)"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fx2txt",
          "args": [
            "status"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "fx2txt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "182-208",
          "snippet": "const char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_status",
          "args": [
            "conn",
            "id"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "get_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "213-241",
          "snippet": "static u_int\nget_status(struct sftp_conn *conn, u_int expected_id)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id, status;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type != SSH2_FXP_STATUS)\n\t\tfatal(\"Expected SSH2_FXP_STATUS(%u) packet, got %u\",\n\t\t    SSH2_FXP_STATUS, type);\n\n\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic u_int\nget_status(struct sftp_conn *conn, u_int expected_id)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id, status;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type != SSH2_FXP_STATUS)\n\t\tfatal(\"Expected SSH2_FXP_STATUS(%u) packet, got %u\",\n\t\t    SSH2_FXP_STATUS, type);\n\n\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Sent message SSH2_FXP_SYMLINK \\\"%s\\\" -> \\\"%s\\\"\"",
            "oldpath",
            "newpath"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_msg",
          "args": [
            "conn",
            "msg"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "send_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "108-130",
          "snippet": "static void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "msg",
            "newpath"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "msg",
            "id"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "SSH2_FXP_SYMLINK"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_symlink(struct sftp_conn *conn, const char *oldpath, const char *newpath)\n{\n\tstruct sshbuf *msg;\n\tu_int status, id;\n\tint r;\n\n\tif (conn->version < 3) {\n\t\terror(\"This server does not support the symlink operation\");\n\t\treturn(SSH2_FX_OP_UNSUPPORTED);\n\t}\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\t/* Send symlink request */\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_SYMLINK)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, oldpath)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, newpath)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message SSH2_FXP_SYMLINK \\\"%s\\\" -> \\\"%s\\\"\", oldpath,\n\t    newpath);\n\tsshbuf_free(msg);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't symlink file \\\"%s\\\" to \\\"%s\\\": %s\", oldpath,\n\t\t    newpath, fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
  },
  {
    "function_name": "do_hardlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "923-957",
    "snippet": "int\ndo_hardlink(struct sftp_conn *conn, const char *oldpath, const char *newpath)\n{\n\tstruct sshbuf *msg;\n\tu_int status, id;\n\tint r;\n\n\tif ((conn->exts & SFTP_EXT_HARDLINK) == 0) {\n\t\terror(\"Server does not support hardlink@openssh.com extension\");\n\t\treturn -1;\n\t}\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\t/* Send link request */\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, \"hardlink@openssh.com\")) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, oldpath)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, newpath)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message hardlink@openssh.com \\\"%s\\\" -> \\\"%s\\\"\",\n\t       oldpath, newpath);\n\tsshbuf_free(msg);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't link file \\\"%s\\\" to \\\"%s\\\": %s\", oldpath,\n\t\t    newpath, fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define SFTP_EXT_HARDLINK\t0x00000008"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Couldn't link file \\\"%s\\\" to \\\"%s\\\": %s\"",
            "oldpath",
            "newpath",
            "fx2txt(status)"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fx2txt",
          "args": [
            "status"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "fx2txt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "182-208",
          "snippet": "const char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_status",
          "args": [
            "conn",
            "id"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "get_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "213-241",
          "snippet": "static u_int\nget_status(struct sftp_conn *conn, u_int expected_id)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id, status;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type != SSH2_FXP_STATUS)\n\t\tfatal(\"Expected SSH2_FXP_STATUS(%u) packet, got %u\",\n\t\t    SSH2_FXP_STATUS, type);\n\n\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic u_int\nget_status(struct sftp_conn *conn, u_int expected_id)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id, status;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type != SSH2_FXP_STATUS)\n\t\tfatal(\"Expected SSH2_FXP_STATUS(%u) packet, got %u\",\n\t\t    SSH2_FXP_STATUS, type);\n\n\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Sent message hardlink@openssh.com \\\"%s\\\" -> \\\"%s\\\"\"",
            "oldpath",
            "newpath"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_msg",
          "args": [
            "conn",
            "msg"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "send_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "108-130",
          "snippet": "static void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "msg",
            "newpath"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "msg",
            "id"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "SSH2_FXP_EXTENDED"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SFTP_EXT_HARDLINK\t0x00000008\n\nint\ndo_hardlink(struct sftp_conn *conn, const char *oldpath, const char *newpath)\n{\n\tstruct sshbuf *msg;\n\tu_int status, id;\n\tint r;\n\n\tif ((conn->exts & SFTP_EXT_HARDLINK) == 0) {\n\t\terror(\"Server does not support hardlink@openssh.com extension\");\n\t\treturn -1;\n\t}\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\t/* Send link request */\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, \"hardlink@openssh.com\")) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, oldpath)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, newpath)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message hardlink@openssh.com \\\"%s\\\" -> \\\"%s\\\"\",\n\t       oldpath, newpath);\n\tsshbuf_free(msg);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't link file \\\"%s\\\" to \\\"%s\\\": %s\", oldpath,\n\t\t    newpath, fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
  },
  {
    "function_name": "do_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "882-921",
    "snippet": "int\ndo_rename(struct sftp_conn *conn, const char *oldpath, const char *newpath,\n    int force_legacy)\n{\n\tstruct sshbuf *msg;\n\tu_int status, id;\n\tint r, use_ext = (conn->exts & SFTP_EXT_POSIX_RENAME) && !force_legacy;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\t/* Send rename request */\n\tid = conn->msg_id++;\n\tif (use_ext) {\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n\t\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(msg,\n\t\t    \"posix-rename@openssh.com\")) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t} else {\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_RENAME)) != 0 ||\n\t\t    (r = sshbuf_put_u32(msg, id)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\tif ((r = sshbuf_put_cstring(msg, oldpath)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, newpath)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message %s \\\"%s\\\" -> \\\"%s\\\"\",\n\t    use_ext ? \"posix-rename@openssh.com\" :\n\t    \"SSH2_FXP_RENAME\", oldpath, newpath);\n\tsshbuf_free(msg);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't rename file \\\"%s\\\" to \\\"%s\\\": %s\", oldpath,\n\t\t    newpath, fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define SFTP_EXT_POSIX_RENAME\t0x00000001"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Couldn't rename file \\\"%s\\\" to \\\"%s\\\": %s\"",
            "oldpath",
            "newpath",
            "fx2txt(status)"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fx2txt",
          "args": [
            "status"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "fx2txt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "182-208",
          "snippet": "const char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_status",
          "args": [
            "conn",
            "id"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "get_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "213-241",
          "snippet": "static u_int\nget_status(struct sftp_conn *conn, u_int expected_id)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id, status;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type != SSH2_FXP_STATUS)\n\t\tfatal(\"Expected SSH2_FXP_STATUS(%u) packet, got %u\",\n\t\t    SSH2_FXP_STATUS, type);\n\n\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic u_int\nget_status(struct sftp_conn *conn, u_int expected_id)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id, status;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type != SSH2_FXP_STATUS)\n\t\tfatal(\"Expected SSH2_FXP_STATUS(%u) packet, got %u\",\n\t\t    SSH2_FXP_STATUS, type);\n\n\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Sent message %s \\\"%s\\\" -> \\\"%s\\\"\"",
            "use_ext ? \"posix-rename@openssh.com\" :\n\t    \"SSH2_FXP_RENAME\"",
            "oldpath",
            "newpath"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_msg",
          "args": [
            "conn",
            "msg"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "send_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "108-130",
          "snippet": "static void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "msg",
            "newpath"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "msg",
            "id"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "SSH2_FXP_RENAME"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SFTP_EXT_POSIX_RENAME\t0x00000001\n\nint\ndo_rename(struct sftp_conn *conn, const char *oldpath, const char *newpath,\n    int force_legacy)\n{\n\tstruct sshbuf *msg;\n\tu_int status, id;\n\tint r, use_ext = (conn->exts & SFTP_EXT_POSIX_RENAME) && !force_legacy;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\t/* Send rename request */\n\tid = conn->msg_id++;\n\tif (use_ext) {\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n\t\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(msg,\n\t\t    \"posix-rename@openssh.com\")) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t} else {\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_RENAME)) != 0 ||\n\t\t    (r = sshbuf_put_u32(msg, id)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\tif ((r = sshbuf_put_cstring(msg, oldpath)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, newpath)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message %s \\\"%s\\\" -> \\\"%s\\\"\",\n\t    use_ext ? \"posix-rename@openssh.com\" :\n\t    \"SSH2_FXP_RENAME\", oldpath, newpath);\n\tsshbuf_free(msg);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't rename file \\\"%s\\\" to \\\"%s\\\": %s\", oldpath,\n\t\t    newpath, fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
  },
  {
    "function_name": "do_realpath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "825-880",
    "snippet": "char *\ndo_realpath(struct sftp_conn *conn, const char *path)\n{\n\tstruct sshbuf *msg;\n\tu_int expected_id, count, id;\n\tchar *filename, *longname;\n\tAttrib a;\n\tu_char type;\n\tint r;\n\n\texpected_id = id = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_REALPATH, path,\n\t    strlen(path));\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\terror(\"Couldn't canonicalize: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn NULL;\n\t} else if (type != SSH2_FXP_NAME)\n\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t    SSH2_FXP_NAME, type);\n\n\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (count != 1)\n\t\tfatal(\"Got multiple names (%d) from SSH_FXP_REALPATH\", count);\n\n\tif ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||\n\t    (r = decode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"SSH_FXP_REALPATH %s -> %s size %lu\", path, filename,\n\t    (unsigned long)a.size);\n\n\tfree(longname);\n\n\tsshbuf_free(msg);\n\n\treturn(filename);\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "longname"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "free_sftp_dirents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "681-693",
          "snippet": "void free_sftp_dirents(SFTP_DIRENT **s)\n{\n\tint i;\n\n\tif (s == NULL)\n\t\treturn;\n\tfor (i = 0; s[i]; i++) {\n\t\tfree(s[i]->filename);\n\t\tfree(s[i]->longname);\n\t\tfree(s[i]);\n\t}\n\tfree(s);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid free_sftp_dirents(SFTP_DIRENT **s)\n{\n\tint i;\n\n\tif (s == NULL)\n\t\treturn;\n\tfor (i = 0; s[i]; i++) {\n\t\tfree(s[i]->filename);\n\t\tfree(s[i]->longname);\n\t\tfree(s[i]);\n\t}\n\tfree(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"SSH_FXP_REALPATH %s -> %s size %lu\"",
            "path",
            "filename",
            "(unsigned long)a.size"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_attrib",
          "args": [
            "msg",
            "&a"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "decode_attrib",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "104-150",
          "snippet": "int\ndecode_attrib(struct sshbuf *b, Attrib *a)\n{\n\tint r;\n\n\tattrib_clear(a);\n\tif ((r = sshbuf_get_u32(b, &a->flags)) != 0)\n\t\treturn r;\n\tif (a->flags & SSH2_FILEXFER_ATTR_SIZE) {\n\t\tif ((r = sshbuf_get_u64(b, &a->size)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {\n\t\tif ((r = sshbuf_get_u32(b, &a->uid)) != 0 ||\n\t\t    (r = sshbuf_get_u32(b, &a->gid)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {\n\t\tif ((r = sshbuf_get_u32(b, &a->perm)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {\n\t\tif ((r = sshbuf_get_u32(b, &a->atime)) != 0 ||\n\t\t    (r = sshbuf_get_u32(b, &a->mtime)) != 0)\n\t\t\treturn r;\n\t}\n\t/* vendor-specific extensions */\n\tif (a->flags & SSH2_FILEXFER_ATTR_EXTENDED) {\n\t\tchar *type;\n\t\tu_char *data;\n\t\tsize_t dlen;\n\t\tu_int i, count;\n\n\t\tif ((r = sshbuf_get_u32(b, &count)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif ((r = sshbuf_get_cstring(b, &type, NULL)) != 0 ||\n\t\t\t    (r = sshbuf_get_string(b, &data, &dlen)) != 0)\n\t\t\t\treturn r;\n\t\t\tdebug3(\"Got file attribute \\\"%.100s\\\" len %zu\",\n\t\t\t    type, dlen);\n\t\t\tfree(type);\n\t\t\tfree(data);\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndecode_attrib(struct sshbuf *b, Attrib *a)\n{\n\tint r;\n\n\tattrib_clear(a);\n\tif ((r = sshbuf_get_u32(b, &a->flags)) != 0)\n\t\treturn r;\n\tif (a->flags & SSH2_FILEXFER_ATTR_SIZE) {\n\t\tif ((r = sshbuf_get_u64(b, &a->size)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {\n\t\tif ((r = sshbuf_get_u32(b, &a->uid)) != 0 ||\n\t\t    (r = sshbuf_get_u32(b, &a->gid)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {\n\t\tif ((r = sshbuf_get_u32(b, &a->perm)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {\n\t\tif ((r = sshbuf_get_u32(b, &a->atime)) != 0 ||\n\t\t    (r = sshbuf_get_u32(b, &a->mtime)) != 0)\n\t\t\treturn r;\n\t}\n\t/* vendor-specific extensions */\n\tif (a->flags & SSH2_FILEXFER_ATTR_EXTENDED) {\n\t\tchar *type;\n\t\tu_char *data;\n\t\tsize_t dlen;\n\t\tu_int i, count;\n\n\t\tif ((r = sshbuf_get_u32(b, &count)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif ((r = sshbuf_get_cstring(b, &type, NULL)) != 0 ||\n\t\t\t    (r = sshbuf_get_string(b, &data, &dlen)) != 0)\n\t\t\t\treturn r;\n\t\t\tdebug3(\"Got file attribute \\\"%.100s\\\" len %zu\",\n\t\t\t    type, dlen);\n\t\t\tfree(type);\n\t\t\tfree(data);\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "msg",
            "&longname",
            "NULL"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Got multiple names (%d) from SSH_FXP_REALPATH\"",
            "count"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "msg",
            "&count"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Couldn't canonicalize: %s\"",
            "fx2txt(status)"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fx2txt",
          "args": [
            "status"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "fx2txt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "182-208",
          "snippet": "const char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "msg",
            "&type"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_msg",
          "args": [
            "conn",
            "msg"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "get_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "170-174",
          "snippet": "static void\nget_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tget_msg_extended(conn, m, 0);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nget_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tget_msg_extended(conn, m, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_string_request",
          "args": [
            "conn",
            "id",
            "SSH2_FXP_REALPATH",
            "path",
            "strlen(path)"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "send_string_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "176-192",
          "snippet": "static void\nsend_string_request(struct sftp_conn *conn, u_int id, u_int code, const char *s,\n    u_int len)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, code)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, s, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fd %d T:%u I:%u\", conn->fd_out, code, id);\n\tsshbuf_free(msg);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_string_request(struct sftp_conn *conn, u_int id, u_int code, const char *s,\n    u_int len)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, code)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, s, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fd %d T:%u I:%u\", conn->fd_out, code, id);\n\tsshbuf_free(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ndo_realpath(struct sftp_conn *conn, const char *path)\n{\n\tstruct sshbuf *msg;\n\tu_int expected_id, count, id;\n\tchar *filename, *longname;\n\tAttrib a;\n\tu_char type;\n\tint r;\n\n\texpected_id = id = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_REALPATH, path,\n\t    strlen(path));\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\terror(\"Couldn't canonicalize: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn NULL;\n\t} else if (type != SSH2_FXP_NAME)\n\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t    SSH2_FXP_NAME, type);\n\n\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (count != 1)\n\t\tfatal(\"Got multiple names (%d) from SSH_FXP_REALPATH\", count);\n\n\tif ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||\n\t    (r = decode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"SSH_FXP_REALPATH %s -> %s size %lu\", path, filename,\n\t    (unsigned long)a.size);\n\n\tfree(longname);\n\n\tsshbuf_free(msg);\n\n\treturn(filename);\n}"
  },
  {
    "function_name": "do_fsetstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "808-823",
    "snippet": "int\ndo_fsetstat(struct sftp_conn *conn, const u_char *handle, u_int handle_len,\n    Attrib *a)\n{\n\tu_int status, id;\n\n\tid = conn->msg_id++;\n\tsend_string_attrs_request(conn, id, SSH2_FXP_FSETSTAT, handle,\n\t    handle_len, a);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't fsetstat: %s\", fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Couldn't fsetstat: %s\"",
            "fx2txt(status)"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fx2txt",
          "args": [
            "status"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "fx2txt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "182-208",
          "snippet": "const char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_status",
          "args": [
            "conn",
            "id"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "get_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "213-241",
          "snippet": "static u_int\nget_status(struct sftp_conn *conn, u_int expected_id)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id, status;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type != SSH2_FXP_STATUS)\n\t\tfatal(\"Expected SSH2_FXP_STATUS(%u) packet, got %u\",\n\t\t    SSH2_FXP_STATUS, type);\n\n\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic u_int\nget_status(struct sftp_conn *conn, u_int expected_id)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id, status;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type != SSH2_FXP_STATUS)\n\t\tfatal(\"Expected SSH2_FXP_STATUS(%u) packet, got %u\",\n\t\t    SSH2_FXP_STATUS, type);\n\n\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_string_attrs_request",
          "args": [
            "conn",
            "id",
            "SSH2_FXP_FSETSTAT",
            "handle",
            "handle_len",
            "a"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "send_string_attrs_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "194-211",
          "snippet": "static void\nsend_string_attrs_request(struct sftp_conn *conn, u_int id, u_int code,\n    const void *s, u_int len, Attrib *a)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, code)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, s, len)) != 0 ||\n\t    (r = encode_attrib(msg, a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fd %d T:%u I:%u\", conn->fd_out, code, id);\n\tsshbuf_free(msg);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_string_attrs_request(struct sftp_conn *conn, u_int id, u_int code,\n    const void *s, u_int len, Attrib *a)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, code)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, s, len)) != 0 ||\n\t    (r = encode_attrib(msg, a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fd %d T:%u I:%u\", conn->fd_out, code, id);\n\tsshbuf_free(msg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_fsetstat(struct sftp_conn *conn, const u_char *handle, u_int handle_len,\n    Attrib *a)\n{\n\tu_int status, id;\n\n\tid = conn->msg_id++;\n\tsend_string_attrs_request(conn, id, SSH2_FXP_FSETSTAT, handle,\n\t    handle_len, a);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't fsetstat: %s\", fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
  },
  {
    "function_name": "do_setstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "791-806",
    "snippet": "int\ndo_setstat(struct sftp_conn *conn, const char *path, Attrib *a)\n{\n\tu_int status, id;\n\n\tid = conn->msg_id++;\n\tsend_string_attrs_request(conn, id, SSH2_FXP_SETSTAT, path,\n\t    strlen(path), a);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't setstat on \\\"%s\\\": %s\", path,\n\t\t    fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Couldn't setstat on \\\"%s\\\": %s\"",
            "path",
            "fx2txt(status)"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fx2txt",
          "args": [
            "status"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "fx2txt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "182-208",
          "snippet": "const char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_status",
          "args": [
            "conn",
            "id"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "get_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "213-241",
          "snippet": "static u_int\nget_status(struct sftp_conn *conn, u_int expected_id)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id, status;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type != SSH2_FXP_STATUS)\n\t\tfatal(\"Expected SSH2_FXP_STATUS(%u) packet, got %u\",\n\t\t    SSH2_FXP_STATUS, type);\n\n\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic u_int\nget_status(struct sftp_conn *conn, u_int expected_id)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id, status;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type != SSH2_FXP_STATUS)\n\t\tfatal(\"Expected SSH2_FXP_STATUS(%u) packet, got %u\",\n\t\t    SSH2_FXP_STATUS, type);\n\n\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_string_attrs_request",
          "args": [
            "conn",
            "id",
            "SSH2_FXP_SETSTAT",
            "path",
            "strlen(path)",
            "a"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "send_string_attrs_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "194-211",
          "snippet": "static void\nsend_string_attrs_request(struct sftp_conn *conn, u_int id, u_int code,\n    const void *s, u_int len, Attrib *a)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, code)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, s, len)) != 0 ||\n\t    (r = encode_attrib(msg, a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fd %d T:%u I:%u\", conn->fd_out, code, id);\n\tsshbuf_free(msg);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_string_attrs_request(struct sftp_conn *conn, u_int id, u_int code,\n    const void *s, u_int len, Attrib *a)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, code)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, s, len)) != 0 ||\n\t    (r = encode_attrib(msg, a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fd %d T:%u I:%u\", conn->fd_out, code, id);\n\tsshbuf_free(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_setstat(struct sftp_conn *conn, const char *path, Attrib *a)\n{\n\tu_int status, id;\n\n\tid = conn->msg_id++;\n\tsend_string_attrs_request(conn, id, SSH2_FXP_SETSTAT, path,\n\t    strlen(path), a);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't setstat on \\\"%s\\\": %s\", path,\n\t\t    fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
  },
  {
    "function_name": "do_fstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "777-788",
    "snippet": "Attrib *\ndo_fstat(struct sftp_conn *conn, const u_char *handle, u_int handle_len,\n    int quiet)\n{\n\tu_int id;\n\n\tid = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_FSTAT, handle,\n\t    handle_len);\n\n\treturn(get_decode_stat(conn, id, quiet));\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_decode_stat",
          "args": [
            "conn",
            "id",
            "quiet"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "get_decode_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "288-331",
          "snippet": "static Attrib *\nget_decode_stat(struct sftp_conn *conn, u_int expected_id, int quiet)\n{\n\tstruct sshbuf *msg;\n\tu_int id;\n\tu_char type;\n\tint r;\n\tstatic Attrib a;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"Received stat reply T:%u I:%u\", type, id);\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (quiet)\n\t\t\tdebug(\"Couldn't stat remote file: %s\", fx2txt(status));\n\t\telse\n\t\t\terror(\"Couldn't stat remote file: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn(NULL);\n\t} else if (type != SSH2_FXP_ATTRS) {\n\t\tfatal(\"Expected SSH2_FXP_ATTRS(%u) packet, got %u\",\n\t\t    SSH2_FXP_ATTRS, type);\n\t}\n\tif ((r = decode_attrib(msg, &a)) != 0) {\n\t\terror(\"%s: couldn't decode attrib: %s\", __func__, ssh_err(r));\n\t\tsshbuf_free(msg);\n\t\treturn NULL;\n\t}\n\tsshbuf_free(msg);\n\n\treturn &a;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Attrib *\nget_decode_stat(struct sftp_conn *conn, u_int expected_id, int quiet)\n{\n\tstruct sshbuf *msg;\n\tu_int id;\n\tu_char type;\n\tint r;\n\tstatic Attrib a;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"Received stat reply T:%u I:%u\", type, id);\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (quiet)\n\t\t\tdebug(\"Couldn't stat remote file: %s\", fx2txt(status));\n\t\telse\n\t\t\terror(\"Couldn't stat remote file: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn(NULL);\n\t} else if (type != SSH2_FXP_ATTRS) {\n\t\tfatal(\"Expected SSH2_FXP_ATTRS(%u) packet, got %u\",\n\t\t    SSH2_FXP_ATTRS, type);\n\t}\n\tif ((r = decode_attrib(msg, &a)) != 0) {\n\t\terror(\"%s: couldn't decode attrib: %s\", __func__, ssh_err(r));\n\t\tsshbuf_free(msg);\n\t\treturn NULL;\n\t}\n\tsshbuf_free(msg);\n\n\treturn &a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_string_request",
          "args": [
            "conn",
            "id",
            "SSH2_FXP_FSTAT",
            "handle",
            "handle_len"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "send_string_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "176-192",
          "snippet": "static void\nsend_string_request(struct sftp_conn *conn, u_int id, u_int code, const char *s,\n    u_int len)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, code)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, s, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fd %d T:%u I:%u\", conn->fd_out, code, id);\n\tsshbuf_free(msg);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_string_request(struct sftp_conn *conn, u_int id, u_int code, const char *s,\n    u_int len)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, code)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, s, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fd %d T:%u I:%u\", conn->fd_out, code, id);\n\tsshbuf_free(msg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nAttrib *\ndo_fstat(struct sftp_conn *conn, const u_char *handle, u_int handle_len,\n    int quiet)\n{\n\tu_int id;\n\n\tid = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_FSTAT, handle,\n\t    handle_len);\n\n\treturn(get_decode_stat(conn, id, quiet));\n}"
  },
  {
    "function_name": "do_lstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "756-774",
    "snippet": "Attrib *\ndo_lstat(struct sftp_conn *conn, const char *path, int quiet)\n{\n\tu_int id;\n\n\tif (conn->version == 0) {\n\t\tif (quiet)\n\t\t\tdebug(\"Server version does not support lstat operation\");\n\t\telse\n\t\t\tlogit(\"Server version does not support lstat operation\");\n\t\treturn(do_stat(conn, path, quiet));\n\t}\n\n\tid = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_LSTAT, path,\n\t    strlen(path));\n\n\treturn(get_decode_stat(conn, id, quiet));\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_decode_stat",
          "args": [
            "conn",
            "id",
            "quiet"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "get_decode_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "288-331",
          "snippet": "static Attrib *\nget_decode_stat(struct sftp_conn *conn, u_int expected_id, int quiet)\n{\n\tstruct sshbuf *msg;\n\tu_int id;\n\tu_char type;\n\tint r;\n\tstatic Attrib a;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"Received stat reply T:%u I:%u\", type, id);\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (quiet)\n\t\t\tdebug(\"Couldn't stat remote file: %s\", fx2txt(status));\n\t\telse\n\t\t\terror(\"Couldn't stat remote file: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn(NULL);\n\t} else if (type != SSH2_FXP_ATTRS) {\n\t\tfatal(\"Expected SSH2_FXP_ATTRS(%u) packet, got %u\",\n\t\t    SSH2_FXP_ATTRS, type);\n\t}\n\tif ((r = decode_attrib(msg, &a)) != 0) {\n\t\terror(\"%s: couldn't decode attrib: %s\", __func__, ssh_err(r));\n\t\tsshbuf_free(msg);\n\t\treturn NULL;\n\t}\n\tsshbuf_free(msg);\n\n\treturn &a;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Attrib *\nget_decode_stat(struct sftp_conn *conn, u_int expected_id, int quiet)\n{\n\tstruct sshbuf *msg;\n\tu_int id;\n\tu_char type;\n\tint r;\n\tstatic Attrib a;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"Received stat reply T:%u I:%u\", type, id);\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (quiet)\n\t\t\tdebug(\"Couldn't stat remote file: %s\", fx2txt(status));\n\t\telse\n\t\t\terror(\"Couldn't stat remote file: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn(NULL);\n\t} else if (type != SSH2_FXP_ATTRS) {\n\t\tfatal(\"Expected SSH2_FXP_ATTRS(%u) packet, got %u\",\n\t\t    SSH2_FXP_ATTRS, type);\n\t}\n\tif ((r = decode_attrib(msg, &a)) != 0) {\n\t\terror(\"%s: couldn't decode attrib: %s\", __func__, ssh_err(r));\n\t\tsshbuf_free(msg);\n\t\treturn NULL;\n\t}\n\tsshbuf_free(msg);\n\n\treturn &a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_string_request",
          "args": [
            "conn",
            "id",
            "SSH2_FXP_LSTAT",
            "path",
            "strlen(path)"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "send_string_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "176-192",
          "snippet": "static void\nsend_string_request(struct sftp_conn *conn, u_int id, u_int code, const char *s,\n    u_int len)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, code)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, s, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fd %d T:%u I:%u\", conn->fd_out, code, id);\n\tsshbuf_free(msg);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_string_request(struct sftp_conn *conn, u_int id, u_int code, const char *s,\n    u_int len)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, code)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, s, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fd %d T:%u I:%u\", conn->fd_out, code, id);\n\tsshbuf_free(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_stat",
          "args": [
            "conn",
            "path",
            "quiet"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "do_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "742-754",
          "snippet": "Attrib *\ndo_stat(struct sftp_conn *conn, const char *path, int quiet)\n{\n\tu_int id;\n\n\tid = conn->msg_id++;\n\n\tsend_string_request(conn, id,\n\t    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT,\n\t    path, strlen(path));\n\n\treturn(get_decode_stat(conn, id, quiet));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nAttrib *\ndo_stat(struct sftp_conn *conn, const char *path, int quiet)\n{\n\tu_int id;\n\n\tid = conn->msg_id++;\n\n\tsend_string_request(conn, id,\n\t    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT,\n\t    path, strlen(path));\n\n\treturn(get_decode_stat(conn, id, quiet));\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Server version does not support lstat operation\""
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Server version does not support lstat operation\""
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nAttrib *\ndo_lstat(struct sftp_conn *conn, const char *path, int quiet)\n{\n\tu_int id;\n\n\tif (conn->version == 0) {\n\t\tif (quiet)\n\t\t\tdebug(\"Server version does not support lstat operation\");\n\t\telse\n\t\t\tlogit(\"Server version does not support lstat operation\");\n\t\treturn(do_stat(conn, path, quiet));\n\t}\n\n\tid = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_LSTAT, path,\n\t    strlen(path));\n\n\treturn(get_decode_stat(conn, id, quiet));\n}"
  },
  {
    "function_name": "do_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "742-754",
    "snippet": "Attrib *\ndo_stat(struct sftp_conn *conn, const char *path, int quiet)\n{\n\tu_int id;\n\n\tid = conn->msg_id++;\n\n\tsend_string_request(conn, id,\n\t    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT,\n\t    path, strlen(path));\n\n\treturn(get_decode_stat(conn, id, quiet));\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_decode_stat",
          "args": [
            "conn",
            "id",
            "quiet"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "get_decode_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "288-331",
          "snippet": "static Attrib *\nget_decode_stat(struct sftp_conn *conn, u_int expected_id, int quiet)\n{\n\tstruct sshbuf *msg;\n\tu_int id;\n\tu_char type;\n\tint r;\n\tstatic Attrib a;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"Received stat reply T:%u I:%u\", type, id);\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (quiet)\n\t\t\tdebug(\"Couldn't stat remote file: %s\", fx2txt(status));\n\t\telse\n\t\t\terror(\"Couldn't stat remote file: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn(NULL);\n\t} else if (type != SSH2_FXP_ATTRS) {\n\t\tfatal(\"Expected SSH2_FXP_ATTRS(%u) packet, got %u\",\n\t\t    SSH2_FXP_ATTRS, type);\n\t}\n\tif ((r = decode_attrib(msg, &a)) != 0) {\n\t\terror(\"%s: couldn't decode attrib: %s\", __func__, ssh_err(r));\n\t\tsshbuf_free(msg);\n\t\treturn NULL;\n\t}\n\tsshbuf_free(msg);\n\n\treturn &a;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Attrib *\nget_decode_stat(struct sftp_conn *conn, u_int expected_id, int quiet)\n{\n\tstruct sshbuf *msg;\n\tu_int id;\n\tu_char type;\n\tint r;\n\tstatic Attrib a;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"Received stat reply T:%u I:%u\", type, id);\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (quiet)\n\t\t\tdebug(\"Couldn't stat remote file: %s\", fx2txt(status));\n\t\telse\n\t\t\terror(\"Couldn't stat remote file: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn(NULL);\n\t} else if (type != SSH2_FXP_ATTRS) {\n\t\tfatal(\"Expected SSH2_FXP_ATTRS(%u) packet, got %u\",\n\t\t    SSH2_FXP_ATTRS, type);\n\t}\n\tif ((r = decode_attrib(msg, &a)) != 0) {\n\t\terror(\"%s: couldn't decode attrib: %s\", __func__, ssh_err(r));\n\t\tsshbuf_free(msg);\n\t\treturn NULL;\n\t}\n\tsshbuf_free(msg);\n\n\treturn &a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_string_request",
          "args": [
            "conn",
            "id",
            "conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT",
            "path",
            "strlen(path)"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "send_string_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "176-192",
          "snippet": "static void\nsend_string_request(struct sftp_conn *conn, u_int id, u_int code, const char *s,\n    u_int len)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, code)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, s, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fd %d T:%u I:%u\", conn->fd_out, code, id);\n\tsshbuf_free(msg);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_string_request(struct sftp_conn *conn, u_int id, u_int code, const char *s,\n    u_int len)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, code)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, s, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fd %d T:%u I:%u\", conn->fd_out, code, id);\n\tsshbuf_free(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nAttrib *\ndo_stat(struct sftp_conn *conn, const char *path, int quiet)\n{\n\tu_int id;\n\n\tid = conn->msg_id++;\n\n\tsend_string_request(conn, id,\n\t    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT,\n\t    path, strlen(path));\n\n\treturn(get_decode_stat(conn, id, quiet));\n}"
  },
  {
    "function_name": "do_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "726-740",
    "snippet": "int\ndo_rmdir(struct sftp_conn *conn, const char *path)\n{\n\tu_int status, id;\n\n\tid = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_RMDIR, path,\n\t    strlen(path));\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't remove directory: %s\", fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Couldn't remove directory: %s\"",
            "fx2txt(status)"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fx2txt",
          "args": [
            "status"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "fx2txt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "182-208",
          "snippet": "const char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_status",
          "args": [
            "conn",
            "id"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "get_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "213-241",
          "snippet": "static u_int\nget_status(struct sftp_conn *conn, u_int expected_id)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id, status;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type != SSH2_FXP_STATUS)\n\t\tfatal(\"Expected SSH2_FXP_STATUS(%u) packet, got %u\",\n\t\t    SSH2_FXP_STATUS, type);\n\n\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic u_int\nget_status(struct sftp_conn *conn, u_int expected_id)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id, status;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type != SSH2_FXP_STATUS)\n\t\tfatal(\"Expected SSH2_FXP_STATUS(%u) packet, got %u\",\n\t\t    SSH2_FXP_STATUS, type);\n\n\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_string_request",
          "args": [
            "conn",
            "id",
            "SSH2_FXP_RMDIR",
            "path",
            "strlen(path)"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "send_string_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "176-192",
          "snippet": "static void\nsend_string_request(struct sftp_conn *conn, u_int id, u_int code, const char *s,\n    u_int len)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, code)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, s, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fd %d T:%u I:%u\", conn->fd_out, code, id);\n\tsshbuf_free(msg);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_string_request(struct sftp_conn *conn, u_int id, u_int code, const char *s,\n    u_int len)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, code)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, s, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fd %d T:%u I:%u\", conn->fd_out, code, id);\n\tsshbuf_free(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_rmdir(struct sftp_conn *conn, const char *path)\n{\n\tu_int status, id;\n\n\tid = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_RMDIR, path,\n\t    strlen(path));\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't remove directory: %s\", fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
  },
  {
    "function_name": "do_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "710-724",
    "snippet": "int\ndo_mkdir(struct sftp_conn *conn, const char *path, Attrib *a, int print_flag)\n{\n\tu_int status, id;\n\n\tid = conn->msg_id++;\n\tsend_string_attrs_request(conn, id, SSH2_FXP_MKDIR, path,\n\t    strlen(path), a);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK && print_flag)\n\t\terror(\"Couldn't create directory: %s\", fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Couldn't create directory: %s\"",
            "fx2txt(status)"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fx2txt",
          "args": [
            "status"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "fx2txt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "182-208",
          "snippet": "const char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_status",
          "args": [
            "conn",
            "id"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "get_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "213-241",
          "snippet": "static u_int\nget_status(struct sftp_conn *conn, u_int expected_id)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id, status;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type != SSH2_FXP_STATUS)\n\t\tfatal(\"Expected SSH2_FXP_STATUS(%u) packet, got %u\",\n\t\t    SSH2_FXP_STATUS, type);\n\n\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic u_int\nget_status(struct sftp_conn *conn, u_int expected_id)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id, status;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type != SSH2_FXP_STATUS)\n\t\tfatal(\"Expected SSH2_FXP_STATUS(%u) packet, got %u\",\n\t\t    SSH2_FXP_STATUS, type);\n\n\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_string_attrs_request",
          "args": [
            "conn",
            "id",
            "SSH2_FXP_MKDIR",
            "path",
            "strlen(path)",
            "a"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "send_string_attrs_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "194-211",
          "snippet": "static void\nsend_string_attrs_request(struct sftp_conn *conn, u_int id, u_int code,\n    const void *s, u_int len, Attrib *a)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, code)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, s, len)) != 0 ||\n\t    (r = encode_attrib(msg, a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fd %d T:%u I:%u\", conn->fd_out, code, id);\n\tsshbuf_free(msg);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_string_attrs_request(struct sftp_conn *conn, u_int id, u_int code,\n    const void *s, u_int len, Attrib *a)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, code)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, s, len)) != 0 ||\n\t    (r = encode_attrib(msg, a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fd %d T:%u I:%u\", conn->fd_out, code, id);\n\tsshbuf_free(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_mkdir(struct sftp_conn *conn, const char *path, Attrib *a, int print_flag)\n{\n\tu_int status, id;\n\n\tid = conn->msg_id++;\n\tsend_string_attrs_request(conn, id, SSH2_FXP_MKDIR, path,\n\t    strlen(path), a);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK && print_flag)\n\t\terror(\"Couldn't create directory: %s\", fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
  },
  {
    "function_name": "do_rm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "695-708",
    "snippet": "int\ndo_rm(struct sftp_conn *conn, const char *path)\n{\n\tu_int status, id;\n\n\tdebug2(\"Sending SSH2_FXP_REMOVE \\\"%s\\\"\", path);\n\n\tid = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_REMOVE, path, strlen(path));\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't delete file: %s\", fx2txt(status));\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Couldn't delete file: %s\"",
            "fx2txt(status)"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fx2txt",
          "args": [
            "status"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "fx2txt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "182-208",
          "snippet": "const char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_status",
          "args": [
            "conn",
            "id"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "get_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "213-241",
          "snippet": "static u_int\nget_status(struct sftp_conn *conn, u_int expected_id)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id, status;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type != SSH2_FXP_STATUS)\n\t\tfatal(\"Expected SSH2_FXP_STATUS(%u) packet, got %u\",\n\t\t    SSH2_FXP_STATUS, type);\n\n\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic u_int\nget_status(struct sftp_conn *conn, u_int expected_id)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id, status;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type != SSH2_FXP_STATUS)\n\t\tfatal(\"Expected SSH2_FXP_STATUS(%u) packet, got %u\",\n\t\t    SSH2_FXP_STATUS, type);\n\n\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_string_request",
          "args": [
            "conn",
            "id",
            "SSH2_FXP_REMOVE",
            "path",
            "strlen(path)"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "send_string_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "176-192",
          "snippet": "static void\nsend_string_request(struct sftp_conn *conn, u_int id, u_int code, const char *s,\n    u_int len)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, code)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, s, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fd %d T:%u I:%u\", conn->fd_out, code, id);\n\tsshbuf_free(msg);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_string_request(struct sftp_conn *conn, u_int id, u_int code, const char *s,\n    u_int len)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, code)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, s, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fd %d T:%u I:%u\", conn->fd_out, code, id);\n\tsshbuf_free(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"Sending SSH2_FXP_REMOVE \\\"%s\\\"\"",
            "path"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_rm(struct sftp_conn *conn, const char *path)\n{\n\tu_int status, id;\n\n\tdebug2(\"Sending SSH2_FXP_REMOVE \\\"%s\\\"\", path);\n\n\tid = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_REMOVE, path, strlen(path));\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't delete file: %s\", fx2txt(status));\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
  },
  {
    "function_name": "free_sftp_dirents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "681-693",
    "snippet": "void free_sftp_dirents(SFTP_DIRENT **s)\n{\n\tint i;\n\n\tif (s == NULL)\n\t\treturn;\n\tfor (i = 0; s[i]; i++) {\n\t\tfree(s[i]->filename);\n\t\tfree(s[i]->longname);\n\t\tfree(s[i]);\n\t}\n\tfree(s);\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "free_sftp_dirents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "681-693",
          "snippet": "void free_sftp_dirents(SFTP_DIRENT **s)\n{\n\tint i;\n\n\tif (s == NULL)\n\t\treturn;\n\tfor (i = 0; s[i]; i++) {\n\t\tfree(s[i]->filename);\n\t\tfree(s[i]->longname);\n\t\tfree(s[i]);\n\t}\n\tfree(s);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid free_sftp_dirents(SFTP_DIRENT **s)\n{\n\tint i;\n\n\tif (s == NULL)\n\t\treturn;\n\tfor (i = 0; s[i]; i++) {\n\t\tfree(s[i]->filename);\n\t\tfree(s[i]->longname);\n\t\tfree(s[i]);\n\t}\n\tfree(s);\n}"
  },
  {
    "function_name": "do_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "675-679",
    "snippet": "int\ndo_readdir(struct sftp_conn *conn, const char *path, SFTP_DIRENT ***dir)\n{\n\treturn(do_lsreaddir(conn, path, 0, dir));\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_lsreaddir",
          "args": [
            "conn",
            "path",
            "0",
            "dir"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "do_lsreaddir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "528-673",
          "snippet": "static int\ndo_lsreaddir(struct sftp_conn *conn, const char *path, int print_flag,\n    SFTP_DIRENT ***dir)\n{\n\tstruct sshbuf *msg;\n\tu_int count, id, i, expected_id, ents = 0;\n\tsize_t handle_len;\n\tu_char type, *handle;\n\tint status = SSH2_FX_FAILURE;\n\tint r;\n\n\tif (dir)\n\t\t*dir = NULL;\n\n\tid = conn->msg_id++;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_OPENDIR)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, path)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\n\thandle = get_handle(conn, id, &handle_len,\n\t    \"remote readdir(\\\"%s\\\")\", path);\n\tif (handle == NULL) {\n\t\tsshbuf_free(msg);\n\t\treturn -1;\n\t}\n\n\tif (dir) {\n\t\tents = 0;\n\t\t*dir = xcalloc(1, sizeof(**dir));\n\t\t(*dir)[0] = NULL;\n\t}\n\n\tfor (; !interrupted;) {\n\t\tid = expected_id = conn->msg_id++;\n\n\t\tdebug3(\"Sending SSH2_FXP_READDIR I:%u\", id);\n\n\t\tsshbuf_reset(msg);\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_READDIR)) != 0 ||\n\t\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tsend_msg(conn, msg);\n\n\t\tsshbuf_reset(msg);\n\n\t\tget_msg(conn, msg);\n\n\t\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\t\tdebug3(\"Received reply T:%u I:%u\", type, id);\n\n\t\tif (id != expected_id)\n\t\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\t\tif (type == SSH2_FXP_STATUS) {\n\t\t\tu_int rstatus;\n\n\t\t\tif ((r = sshbuf_get_u32(msg, &rstatus)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdebug3(\"Received SSH2_FXP_STATUS %d\", rstatus);\n\t\t\tif (rstatus == SSH2_FX_EOF)\n\t\t\t\tbreak;\n\t\t\terror(\"Couldn't read directory: %s\", fx2txt(rstatus));\n\t\t\tgoto out;\n\t\t} else if (type != SSH2_FXP_NAME)\n\t\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t\t    SSH2_FXP_NAME, type);\n\n\t\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (count > SSHBUF_SIZE_MAX)\n\t\t\tfatal(\"%s: nonsensical number of entries\", __func__);\n\t\tif (count == 0)\n\t\t\tbreak;\n\t\tdebug3(\"Received %d SSH2_FXP_NAME responses\", count);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tchar *filename, *longname;\n\t\t\tAttrib a;\n\n\t\t\tif ((r = sshbuf_get_cstring(msg, &filename,\n\t\t\t    NULL)) != 0 ||\n\t\t\t    (r = sshbuf_get_cstring(msg, &longname,\n\t\t\t    NULL)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif ((r = decode_attrib(msg, &a)) != 0) {\n\t\t\t\terror(\"%s: couldn't decode attrib: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tfree(filename);\n\t\t\t\tfree(longname);\n\t\t\t\tsshbuf_free(msg);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (print_flag)\n\t\t\t\tmprintf(\"%s\\n\", longname);\n\n\t\t\t/*\n\t\t\t * Directory entries should never contain '/'\n\t\t\t * These can be used to attack recursive ops\n\t\t\t * (e.g. send '../../../../etc/passwd')\n\t\t\t */\n\t\t\tif (strpbrk(filename, SFTP_DIRECTORY_CHARS) != NULL) {\n\t\t\t\terror(\"Server sent suspect path \\\"%s\\\" \"\n\t\t\t\t    \"during readdir of \\\"%s\\\"\", filename, path);\n\t\t\t} else if (dir) {\n\t\t\t\t*dir = xreallocarray(*dir, ents + 2, sizeof(**dir));\n\t\t\t\t(*dir)[ents] = xcalloc(1, sizeof(***dir));\n\t\t\t\t(*dir)[ents]->filename = xstrdup(filename);\n\t\t\t\t(*dir)[ents]->longname = xstrdup(longname);\n\t\t\t\tmemcpy(&(*dir)[ents]->a, &a, sizeof(a));\n\t\t\t\t(*dir)[++ents] = NULL;\n\t\t\t}\n\t\t\tfree(filename);\n\t\t\tfree(longname);\n\t\t}\n\t}\n\tstatus = 0;\n\n out:\n\tsshbuf_free(msg);\n\tdo_close(conn, handle, handle_len);\n\tfree(handle);\n\n\tif (status != 0 && dir != NULL) {\n\t\t/* Don't return results on error */\n\t\tfree_sftp_dirents(*dir);\n\t\t*dir = NULL;\n\t} else if (interrupted && dir != NULL && *dir != NULL) {\n\t\t/* Don't return partial matches on interrupt */\n\t\tfree_sftp_dirents(*dir);\n\t\t*dir = xcalloc(1, sizeof(**dir));\n\t\t**dir = NULL;\n\t}\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern volatile sig_atomic_t interrupted;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern volatile sig_atomic_t interrupted;\n\nstatic int\ndo_lsreaddir(struct sftp_conn *conn, const char *path, int print_flag,\n    SFTP_DIRENT ***dir)\n{\n\tstruct sshbuf *msg;\n\tu_int count, id, i, expected_id, ents = 0;\n\tsize_t handle_len;\n\tu_char type, *handle;\n\tint status = SSH2_FX_FAILURE;\n\tint r;\n\n\tif (dir)\n\t\t*dir = NULL;\n\n\tid = conn->msg_id++;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_OPENDIR)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, path)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\n\thandle = get_handle(conn, id, &handle_len,\n\t    \"remote readdir(\\\"%s\\\")\", path);\n\tif (handle == NULL) {\n\t\tsshbuf_free(msg);\n\t\treturn -1;\n\t}\n\n\tif (dir) {\n\t\tents = 0;\n\t\t*dir = xcalloc(1, sizeof(**dir));\n\t\t(*dir)[0] = NULL;\n\t}\n\n\tfor (; !interrupted;) {\n\t\tid = expected_id = conn->msg_id++;\n\n\t\tdebug3(\"Sending SSH2_FXP_READDIR I:%u\", id);\n\n\t\tsshbuf_reset(msg);\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_READDIR)) != 0 ||\n\t\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tsend_msg(conn, msg);\n\n\t\tsshbuf_reset(msg);\n\n\t\tget_msg(conn, msg);\n\n\t\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\t\tdebug3(\"Received reply T:%u I:%u\", type, id);\n\n\t\tif (id != expected_id)\n\t\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\t\tif (type == SSH2_FXP_STATUS) {\n\t\t\tu_int rstatus;\n\n\t\t\tif ((r = sshbuf_get_u32(msg, &rstatus)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdebug3(\"Received SSH2_FXP_STATUS %d\", rstatus);\n\t\t\tif (rstatus == SSH2_FX_EOF)\n\t\t\t\tbreak;\n\t\t\terror(\"Couldn't read directory: %s\", fx2txt(rstatus));\n\t\t\tgoto out;\n\t\t} else if (type != SSH2_FXP_NAME)\n\t\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t\t    SSH2_FXP_NAME, type);\n\n\t\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (count > SSHBUF_SIZE_MAX)\n\t\t\tfatal(\"%s: nonsensical number of entries\", __func__);\n\t\tif (count == 0)\n\t\t\tbreak;\n\t\tdebug3(\"Received %d SSH2_FXP_NAME responses\", count);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tchar *filename, *longname;\n\t\t\tAttrib a;\n\n\t\t\tif ((r = sshbuf_get_cstring(msg, &filename,\n\t\t\t    NULL)) != 0 ||\n\t\t\t    (r = sshbuf_get_cstring(msg, &longname,\n\t\t\t    NULL)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif ((r = decode_attrib(msg, &a)) != 0) {\n\t\t\t\terror(\"%s: couldn't decode attrib: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tfree(filename);\n\t\t\t\tfree(longname);\n\t\t\t\tsshbuf_free(msg);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (print_flag)\n\t\t\t\tmprintf(\"%s\\n\", longname);\n\n\t\t\t/*\n\t\t\t * Directory entries should never contain '/'\n\t\t\t * These can be used to attack recursive ops\n\t\t\t * (e.g. send '../../../../etc/passwd')\n\t\t\t */\n\t\t\tif (strpbrk(filename, SFTP_DIRECTORY_CHARS) != NULL) {\n\t\t\t\terror(\"Server sent suspect path \\\"%s\\\" \"\n\t\t\t\t    \"during readdir of \\\"%s\\\"\", filename, path);\n\t\t\t} else if (dir) {\n\t\t\t\t*dir = xreallocarray(*dir, ents + 2, sizeof(**dir));\n\t\t\t\t(*dir)[ents] = xcalloc(1, sizeof(***dir));\n\t\t\t\t(*dir)[ents]->filename = xstrdup(filename);\n\t\t\t\t(*dir)[ents]->longname = xstrdup(longname);\n\t\t\t\tmemcpy(&(*dir)[ents]->a, &a, sizeof(a));\n\t\t\t\t(*dir)[++ents] = NULL;\n\t\t\t}\n\t\t\tfree(filename);\n\t\t\tfree(longname);\n\t\t}\n\t}\n\tstatus = 0;\n\n out:\n\tsshbuf_free(msg);\n\tdo_close(conn, handle, handle_len);\n\tfree(handle);\n\n\tif (status != 0 && dir != NULL) {\n\t\t/* Don't return results on error */\n\t\tfree_sftp_dirents(*dir);\n\t\t*dir = NULL;\n\t} else if (interrupted && dir != NULL && *dir != NULL) {\n\t\t/* Don't return partial matches on interrupt */\n\t\tfree_sftp_dirents(*dir);\n\t\t*dir = xcalloc(1, sizeof(**dir));\n\t\t**dir = NULL;\n\t}\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_readdir(struct sftp_conn *conn, const char *path, SFTP_DIRENT ***dir)\n{\n\treturn(do_lsreaddir(conn, path, 0, dir));\n}"
  },
  {
    "function_name": "do_lsreaddir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "528-673",
    "snippet": "static int\ndo_lsreaddir(struct sftp_conn *conn, const char *path, int print_flag,\n    SFTP_DIRENT ***dir)\n{\n\tstruct sshbuf *msg;\n\tu_int count, id, i, expected_id, ents = 0;\n\tsize_t handle_len;\n\tu_char type, *handle;\n\tint status = SSH2_FX_FAILURE;\n\tint r;\n\n\tif (dir)\n\t\t*dir = NULL;\n\n\tid = conn->msg_id++;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_OPENDIR)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, path)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\n\thandle = get_handle(conn, id, &handle_len,\n\t    \"remote readdir(\\\"%s\\\")\", path);\n\tif (handle == NULL) {\n\t\tsshbuf_free(msg);\n\t\treturn -1;\n\t}\n\n\tif (dir) {\n\t\tents = 0;\n\t\t*dir = xcalloc(1, sizeof(**dir));\n\t\t(*dir)[0] = NULL;\n\t}\n\n\tfor (; !interrupted;) {\n\t\tid = expected_id = conn->msg_id++;\n\n\t\tdebug3(\"Sending SSH2_FXP_READDIR I:%u\", id);\n\n\t\tsshbuf_reset(msg);\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_READDIR)) != 0 ||\n\t\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tsend_msg(conn, msg);\n\n\t\tsshbuf_reset(msg);\n\n\t\tget_msg(conn, msg);\n\n\t\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\t\tdebug3(\"Received reply T:%u I:%u\", type, id);\n\n\t\tif (id != expected_id)\n\t\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\t\tif (type == SSH2_FXP_STATUS) {\n\t\t\tu_int rstatus;\n\n\t\t\tif ((r = sshbuf_get_u32(msg, &rstatus)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdebug3(\"Received SSH2_FXP_STATUS %d\", rstatus);\n\t\t\tif (rstatus == SSH2_FX_EOF)\n\t\t\t\tbreak;\n\t\t\terror(\"Couldn't read directory: %s\", fx2txt(rstatus));\n\t\t\tgoto out;\n\t\t} else if (type != SSH2_FXP_NAME)\n\t\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t\t    SSH2_FXP_NAME, type);\n\n\t\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (count > SSHBUF_SIZE_MAX)\n\t\t\tfatal(\"%s: nonsensical number of entries\", __func__);\n\t\tif (count == 0)\n\t\t\tbreak;\n\t\tdebug3(\"Received %d SSH2_FXP_NAME responses\", count);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tchar *filename, *longname;\n\t\t\tAttrib a;\n\n\t\t\tif ((r = sshbuf_get_cstring(msg, &filename,\n\t\t\t    NULL)) != 0 ||\n\t\t\t    (r = sshbuf_get_cstring(msg, &longname,\n\t\t\t    NULL)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif ((r = decode_attrib(msg, &a)) != 0) {\n\t\t\t\terror(\"%s: couldn't decode attrib: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tfree(filename);\n\t\t\t\tfree(longname);\n\t\t\t\tsshbuf_free(msg);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (print_flag)\n\t\t\t\tmprintf(\"%s\\n\", longname);\n\n\t\t\t/*\n\t\t\t * Directory entries should never contain '/'\n\t\t\t * These can be used to attack recursive ops\n\t\t\t * (e.g. send '../../../../etc/passwd')\n\t\t\t */\n\t\t\tif (strpbrk(filename, SFTP_DIRECTORY_CHARS) != NULL) {\n\t\t\t\terror(\"Server sent suspect path \\\"%s\\\" \"\n\t\t\t\t    \"during readdir of \\\"%s\\\"\", filename, path);\n\t\t\t} else if (dir) {\n\t\t\t\t*dir = xreallocarray(*dir, ents + 2, sizeof(**dir));\n\t\t\t\t(*dir)[ents] = xcalloc(1, sizeof(***dir));\n\t\t\t\t(*dir)[ents]->filename = xstrdup(filename);\n\t\t\t\t(*dir)[ents]->longname = xstrdup(longname);\n\t\t\t\tmemcpy(&(*dir)[ents]->a, &a, sizeof(a));\n\t\t\t\t(*dir)[++ents] = NULL;\n\t\t\t}\n\t\t\tfree(filename);\n\t\t\tfree(longname);\n\t\t}\n\t}\n\tstatus = 0;\n\n out:\n\tsshbuf_free(msg);\n\tdo_close(conn, handle, handle_len);\n\tfree(handle);\n\n\tif (status != 0 && dir != NULL) {\n\t\t/* Don't return results on error */\n\t\tfree_sftp_dirents(*dir);\n\t\t*dir = NULL;\n\t} else if (interrupted && dir != NULL && *dir != NULL) {\n\t\t/* Don't return partial matches on interrupt */\n\t\tfree_sftp_dirents(*dir);\n\t\t*dir = xcalloc(1, sizeof(**dir));\n\t\t**dir = NULL;\n\t}\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern volatile sig_atomic_t interrupted;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "1",
            "sizeof(**dir)"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_sftp_dirents",
          "args": [
            "*dir"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "free_sftp_dirents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "681-693",
          "snippet": "void free_sftp_dirents(SFTP_DIRENT **s)\n{\n\tint i;\n\n\tif (s == NULL)\n\t\treturn;\n\tfor (i = 0; s[i]; i++) {\n\t\tfree(s[i]->filename);\n\t\tfree(s[i]->longname);\n\t\tfree(s[i]);\n\t}\n\tfree(s);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid free_sftp_dirents(SFTP_DIRENT **s)\n{\n\tint i;\n\n\tif (s == NULL)\n\t\treturn;\n\tfor (i = 0; s[i]; i++) {\n\t\tfree(s[i]->filename);\n\t\tfree(s[i]->longname);\n\t\tfree(s[i]);\n\t}\n\tfree(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_close",
          "args": [
            "conn",
            "handle",
            "handle_len"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "do_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "500-525",
          "snippet": "int\ndo_close(struct sftp_conn *conn, const u_char *handle, u_int handle_len)\n{\n\tu_int id, status;\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_CLOSE)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message SSH2_FXP_CLOSE I:%u\", id);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't close file: %s\", fx2txt(status));\n\n\tsshbuf_free(msg);\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_close(struct sftp_conn *conn, const u_char *handle, u_int handle_len)\n{\n\tu_int id, status;\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_CLOSE)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message SSH2_FXP_CLOSE I:%u\", id);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't close file: %s\", fx2txt(status));\n\n\tsshbuf_free(msg);\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&(*dir)[ents]->a",
            "&a",
            "sizeof(a)"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "longname"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xreallocarray",
          "args": [
            "*dir",
            "ents + 2",
            "sizeof(**dir)"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "xreallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "68-78",
          "snippet": "void *\nxreallocarray(void *ptr, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = reallocarray(ptr, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xreallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxreallocarray(void *ptr, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = reallocarray(ptr, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xreallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Server sent suspect path \\\"%s\\\" \"\n\t\t\t\t    \"during readdir of \\\"%s\\\"\"",
            "filename",
            "path"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "filename",
            "SFTP_DIRECTORY_CHARS"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mprintf",
          "args": [
            "\"%s\\n\"",
            "longname"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "mprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "289-299",
          "snippet": "int\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_attrib",
          "args": [
            "msg",
            "&a"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "decode_attrib",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "104-150",
          "snippet": "int\ndecode_attrib(struct sshbuf *b, Attrib *a)\n{\n\tint r;\n\n\tattrib_clear(a);\n\tif ((r = sshbuf_get_u32(b, &a->flags)) != 0)\n\t\treturn r;\n\tif (a->flags & SSH2_FILEXFER_ATTR_SIZE) {\n\t\tif ((r = sshbuf_get_u64(b, &a->size)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {\n\t\tif ((r = sshbuf_get_u32(b, &a->uid)) != 0 ||\n\t\t    (r = sshbuf_get_u32(b, &a->gid)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {\n\t\tif ((r = sshbuf_get_u32(b, &a->perm)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {\n\t\tif ((r = sshbuf_get_u32(b, &a->atime)) != 0 ||\n\t\t    (r = sshbuf_get_u32(b, &a->mtime)) != 0)\n\t\t\treturn r;\n\t}\n\t/* vendor-specific extensions */\n\tif (a->flags & SSH2_FILEXFER_ATTR_EXTENDED) {\n\t\tchar *type;\n\t\tu_char *data;\n\t\tsize_t dlen;\n\t\tu_int i, count;\n\n\t\tif ((r = sshbuf_get_u32(b, &count)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif ((r = sshbuf_get_cstring(b, &type, NULL)) != 0 ||\n\t\t\t    (r = sshbuf_get_string(b, &data, &dlen)) != 0)\n\t\t\t\treturn r;\n\t\t\tdebug3(\"Got file attribute \\\"%.100s\\\" len %zu\",\n\t\t\t    type, dlen);\n\t\t\tfree(type);\n\t\t\tfree(data);\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndecode_attrib(struct sshbuf *b, Attrib *a)\n{\n\tint r;\n\n\tattrib_clear(a);\n\tif ((r = sshbuf_get_u32(b, &a->flags)) != 0)\n\t\treturn r;\n\tif (a->flags & SSH2_FILEXFER_ATTR_SIZE) {\n\t\tif ((r = sshbuf_get_u64(b, &a->size)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {\n\t\tif ((r = sshbuf_get_u32(b, &a->uid)) != 0 ||\n\t\t    (r = sshbuf_get_u32(b, &a->gid)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {\n\t\tif ((r = sshbuf_get_u32(b, &a->perm)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {\n\t\tif ((r = sshbuf_get_u32(b, &a->atime)) != 0 ||\n\t\t    (r = sshbuf_get_u32(b, &a->mtime)) != 0)\n\t\t\treturn r;\n\t}\n\t/* vendor-specific extensions */\n\tif (a->flags & SSH2_FILEXFER_ATTR_EXTENDED) {\n\t\tchar *type;\n\t\tu_char *data;\n\t\tsize_t dlen;\n\t\tu_int i, count;\n\n\t\tif ((r = sshbuf_get_u32(b, &count)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif ((r = sshbuf_get_cstring(b, &type, NULL)) != 0 ||\n\t\t\t    (r = sshbuf_get_string(b, &data, &dlen)) != 0)\n\t\t\t\treturn r;\n\t\t\tdebug3(\"Got file attribute \\\"%.100s\\\" len %zu\",\n\t\t\t    type, dlen);\n\t\t\tfree(type);\n\t\t\tfree(data);\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "msg",
            "&longname",
            "NULL"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Received %d SSH2_FXP_NAME responses\"",
            "count"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: nonsensical number of entries\"",
            "__func__"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "msg",
            "&count"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fx2txt",
          "args": [
            "rstatus"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "fx2txt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "182-208",
          "snippet": "const char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "msg",
            "&type"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_msg",
          "args": [
            "conn",
            "msg"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "get_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "170-174",
          "snippet": "static void\nget_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tget_msg_extended(conn, m, 0);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nget_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tget_msg_extended(conn, m, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "msg"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_msg",
          "args": [
            "conn",
            "msg"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "send_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "108-130",
          "snippet": "static void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "msg",
            "handle",
            "handle_len"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "msg",
            "id"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "SSH2_FXP_READDIR"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_handle",
          "args": [
            "conn",
            "id",
            "&handle_len",
            "\"remote readdir(\\\"%s\\\")\"",
            "path"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "get_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "243-286",
          "snippet": "static u_char *\nget_handle(struct sftp_conn *conn, u_int expected_id, size_t *len,\n    const char *errfmt, ...)\n{\n\tstruct sshbuf *msg;\n\tu_int id, status;\n\tu_char type;\n\tu_char *handle;\n\tchar errmsg[256];\n\tva_list args;\n\tint r;\n\n\tva_start(args, errfmt);\n\tif (errfmt != NULL)\n\t\tvsnprintf(errmsg, sizeof(errmsg), errfmt, args);\n\tva_end(args);\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"%s: ID mismatch (%u != %u)\",\n\t\t    errfmt == NULL ? __func__ : errmsg, id, expected_id);\n\tif (type == SSH2_FXP_STATUS) {\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (errfmt != NULL)\n\t\t\terror(\"%s: %s\", errmsg, fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn(NULL);\n\t} else if (type != SSH2_FXP_HANDLE)\n\t\tfatal(\"%s: Expected SSH2_FXP_HANDLE(%u) packet, got %u\",\n\t\t    errfmt == NULL ? __func__ : errmsg, SSH2_FXP_HANDLE, type);\n\n\tif ((r = sshbuf_get_string(msg, &handle, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\treturn handle;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic u_char *\nget_handle(struct sftp_conn *conn, u_int expected_id, size_t *len,\n    const char *errfmt, ...)\n{\n\tstruct sshbuf *msg;\n\tu_int id, status;\n\tu_char type;\n\tu_char *handle;\n\tchar errmsg[256];\n\tva_list args;\n\tint r;\n\n\tva_start(args, errfmt);\n\tif (errfmt != NULL)\n\t\tvsnprintf(errmsg, sizeof(errmsg), errfmt, args);\n\tva_end(args);\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"%s: ID mismatch (%u != %u)\",\n\t\t    errfmt == NULL ? __func__ : errmsg, id, expected_id);\n\tif (type == SSH2_FXP_STATUS) {\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (errfmt != NULL)\n\t\t\terror(\"%s: %s\", errmsg, fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn(NULL);\n\t} else if (type != SSH2_FXP_HANDLE)\n\t\tfatal(\"%s: Expected SSH2_FXP_HANDLE(%u) packet, got %u\",\n\t\t    errfmt == NULL ? __func__ : errmsg, SSH2_FXP_HANDLE, type);\n\n\tif ((r = sshbuf_get_string(msg, &handle, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "msg",
            "path"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern volatile sig_atomic_t interrupted;\n\nstatic int\ndo_lsreaddir(struct sftp_conn *conn, const char *path, int print_flag,\n    SFTP_DIRENT ***dir)\n{\n\tstruct sshbuf *msg;\n\tu_int count, id, i, expected_id, ents = 0;\n\tsize_t handle_len;\n\tu_char type, *handle;\n\tint status = SSH2_FX_FAILURE;\n\tint r;\n\n\tif (dir)\n\t\t*dir = NULL;\n\n\tid = conn->msg_id++;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_OPENDIR)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, path)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\n\thandle = get_handle(conn, id, &handle_len,\n\t    \"remote readdir(\\\"%s\\\")\", path);\n\tif (handle == NULL) {\n\t\tsshbuf_free(msg);\n\t\treturn -1;\n\t}\n\n\tif (dir) {\n\t\tents = 0;\n\t\t*dir = xcalloc(1, sizeof(**dir));\n\t\t(*dir)[0] = NULL;\n\t}\n\n\tfor (; !interrupted;) {\n\t\tid = expected_id = conn->msg_id++;\n\n\t\tdebug3(\"Sending SSH2_FXP_READDIR I:%u\", id);\n\n\t\tsshbuf_reset(msg);\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_READDIR)) != 0 ||\n\t\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tsend_msg(conn, msg);\n\n\t\tsshbuf_reset(msg);\n\n\t\tget_msg(conn, msg);\n\n\t\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\t\tdebug3(\"Received reply T:%u I:%u\", type, id);\n\n\t\tif (id != expected_id)\n\t\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\t\tif (type == SSH2_FXP_STATUS) {\n\t\t\tu_int rstatus;\n\n\t\t\tif ((r = sshbuf_get_u32(msg, &rstatus)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdebug3(\"Received SSH2_FXP_STATUS %d\", rstatus);\n\t\t\tif (rstatus == SSH2_FX_EOF)\n\t\t\t\tbreak;\n\t\t\terror(\"Couldn't read directory: %s\", fx2txt(rstatus));\n\t\t\tgoto out;\n\t\t} else if (type != SSH2_FXP_NAME)\n\t\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t\t    SSH2_FXP_NAME, type);\n\n\t\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (count > SSHBUF_SIZE_MAX)\n\t\t\tfatal(\"%s: nonsensical number of entries\", __func__);\n\t\tif (count == 0)\n\t\t\tbreak;\n\t\tdebug3(\"Received %d SSH2_FXP_NAME responses\", count);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tchar *filename, *longname;\n\t\t\tAttrib a;\n\n\t\t\tif ((r = sshbuf_get_cstring(msg, &filename,\n\t\t\t    NULL)) != 0 ||\n\t\t\t    (r = sshbuf_get_cstring(msg, &longname,\n\t\t\t    NULL)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif ((r = decode_attrib(msg, &a)) != 0) {\n\t\t\t\terror(\"%s: couldn't decode attrib: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tfree(filename);\n\t\t\t\tfree(longname);\n\t\t\t\tsshbuf_free(msg);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (print_flag)\n\t\t\t\tmprintf(\"%s\\n\", longname);\n\n\t\t\t/*\n\t\t\t * Directory entries should never contain '/'\n\t\t\t * These can be used to attack recursive ops\n\t\t\t * (e.g. send '../../../../etc/passwd')\n\t\t\t */\n\t\t\tif (strpbrk(filename, SFTP_DIRECTORY_CHARS) != NULL) {\n\t\t\t\terror(\"Server sent suspect path \\\"%s\\\" \"\n\t\t\t\t    \"during readdir of \\\"%s\\\"\", filename, path);\n\t\t\t} else if (dir) {\n\t\t\t\t*dir = xreallocarray(*dir, ents + 2, sizeof(**dir));\n\t\t\t\t(*dir)[ents] = xcalloc(1, sizeof(***dir));\n\t\t\t\t(*dir)[ents]->filename = xstrdup(filename);\n\t\t\t\t(*dir)[ents]->longname = xstrdup(longname);\n\t\t\t\tmemcpy(&(*dir)[ents]->a, &a, sizeof(a));\n\t\t\t\t(*dir)[++ents] = NULL;\n\t\t\t}\n\t\t\tfree(filename);\n\t\t\tfree(longname);\n\t\t}\n\t}\n\tstatus = 0;\n\n out:\n\tsshbuf_free(msg);\n\tdo_close(conn, handle, handle_len);\n\tfree(handle);\n\n\tif (status != 0 && dir != NULL) {\n\t\t/* Don't return results on error */\n\t\tfree_sftp_dirents(*dir);\n\t\t*dir = NULL;\n\t} else if (interrupted && dir != NULL && *dir != NULL) {\n\t\t/* Don't return partial matches on interrupt */\n\t\tfree_sftp_dirents(*dir);\n\t\t*dir = xcalloc(1, sizeof(**dir));\n\t\t**dir = NULL;\n\t}\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
  },
  {
    "function_name": "do_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "500-525",
    "snippet": "int\ndo_close(struct sftp_conn *conn, const u_char *handle, u_int handle_len)\n{\n\tu_int id, status;\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_CLOSE)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message SSH2_FXP_CLOSE I:%u\", id);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't close file: %s\", fx2txt(status));\n\n\tsshbuf_free(msg);\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Couldn't close file: %s\"",
            "fx2txt(status)"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fx2txt",
          "args": [
            "status"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "fx2txt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "182-208",
          "snippet": "const char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_status",
          "args": [
            "conn",
            "id"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "get_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "213-241",
          "snippet": "static u_int\nget_status(struct sftp_conn *conn, u_int expected_id)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id, status;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type != SSH2_FXP_STATUS)\n\t\tfatal(\"Expected SSH2_FXP_STATUS(%u) packet, got %u\",\n\t\t    SSH2_FXP_STATUS, type);\n\n\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic u_int\nget_status(struct sftp_conn *conn, u_int expected_id)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id, status;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type != SSH2_FXP_STATUS)\n\t\tfatal(\"Expected SSH2_FXP_STATUS(%u) packet, got %u\",\n\t\t    SSH2_FXP_STATUS, type);\n\n\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Sent message SSH2_FXP_CLOSE I:%u\"",
            "id"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_msg",
          "args": [
            "conn",
            "msg"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "send_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "108-130",
          "snippet": "static void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "msg",
            "handle",
            "handle_len"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "msg",
            "id"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "SSH2_FXP_CLOSE"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_close(struct sftp_conn *conn, const u_char *handle, u_int handle_len)\n{\n\tu_int id, status;\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_CLOSE)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message SSH2_FXP_CLOSE I:%u\", id);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't close file: %s\", fx2txt(status));\n\n\tsshbuf_free(msg);\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}"
  },
  {
    "function_name": "sftp_proto_version",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "494-498",
    "snippet": "u_int\nsftp_proto_version(struct sftp_conn *conn)\n{\n\treturn conn->version;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\nsftp_proto_version(struct sftp_conn *conn)\n{\n\treturn conn->version;\n}"
  },
  {
    "function_name": "do_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "392-492",
    "snippet": "struct sftp_conn *\ndo_init(int fd_in, int fd_out, u_int transfer_buflen, u_int num_requests,\n    u_int64_t limit_kbps)\n{\n\tu_char type;\n\tstruct sshbuf *msg;\n\tstruct sftp_conn *ret;\n\tint r;\n\n\tret = xcalloc(1, sizeof(*ret));\n\tret->msg_id = 1;\n\tret->fd_in = fd_in;\n\tret->fd_out = fd_out;\n\tret->transfer_buflen = transfer_buflen;\n\tret->num_requests = num_requests;\n\tret->exts = 0;\n\tret->limit_kbps = 0;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_INIT)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, SSH2_FILEXFER_VERSION)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(ret, msg);\n\n\tsshbuf_reset(msg);\n\n\tget_msg_extended(ret, msg, 1);\n\n\t/* Expecting a VERSION reply */\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (type != SSH2_FXP_VERSION) {\n\t\terror(\"Invalid packet back from SSH2_FXP_INIT (type %u)\",\n\t\t    type);\n\t\tsshbuf_free(msg);\n\t\tfree(ret);\n\t\treturn(NULL);\n\t}\n\tif ((r = sshbuf_get_u32(msg, &ret->version)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug2(\"Remote version: %u\", ret->version);\n\n\t/* Check for extensions */\n\twhile (sshbuf_len(msg) > 0) {\n\t\tchar *name;\n\t\tu_char *value;\n\t\tsize_t vlen;\n\t\tint known = 0;\n\n\t\tif ((r = sshbuf_get_cstring(msg, &name, NULL)) != 0 ||\n\t\t    (r = sshbuf_get_string(msg, &value, &vlen)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (strcmp(name, \"posix-rename@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"1\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_POSIX_RENAME;\n\t\t\tknown = 1;\n\t\t} else if (strcmp(name, \"statvfs@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"2\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_STATVFS;\n\t\t\tknown = 1;\n\t\t} else if (strcmp(name, \"fstatvfs@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"2\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_FSTATVFS;\n\t\t\tknown = 1;\n\t\t} else if (strcmp(name, \"hardlink@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"1\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_HARDLINK;\n\t\t\tknown = 1;\n\t\t} else if (strcmp(name, \"fsync@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"1\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_FSYNC;\n\t\t\tknown = 1;\n\t\t}\n\t\tif (known) {\n\t\t\tdebug2(\"Server supports extension \\\"%s\\\" revision %s\",\n\t\t\t    name, value);\n\t\t} else {\n\t\t\tdebug2(\"Unrecognised server extension \\\"%s\\\"\", name);\n\t\t}\n\t\tfree(name);\n\t\tfree(value);\n\t}\n\n\tsshbuf_free(msg);\n\n\t/* Some filexfer v.0 servers don't support large packets */\n\tif (ret->version == 0)\n\t\tret->transfer_buflen = MINIMUM(ret->transfer_buflen, 20480);\n\n\tret->limit_kbps = limit_kbps;\n\tif (ret->limit_kbps > 0) {\n\t\tbandwidth_limit_init(&ret->bwlimit_in, ret->limit_kbps,\n\t\t    ret->transfer_buflen);\n\t\tbandwidth_limit_init(&ret->bwlimit_out, ret->limit_kbps,\n\t\t    ret->transfer_buflen);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define SFTP_EXT_FSYNC\t\t0x00000010",
      "#define SFTP_EXT_HARDLINK\t0x00000008",
      "#define SFTP_EXT_FSTATVFS\t0x00000004",
      "#define SFTP_EXT_STATVFS\t0x00000002",
      "#define SFTP_EXT_POSIX_RENAME\t0x00000001"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bandwidth_limit_init",
          "args": [
            "&ret->bwlimit_out",
            "ret->limit_kbps",
            "ret->transfer_buflen"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "bandwidth_limit_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1333-1342",
          "snippet": "void\nbandwidth_limit_init(struct bwlimit *bw, u_int64_t kbps, size_t buflen)\n{\n\tbw->buflen = buflen;\n\tbw->rate = kbps;\n\tbw->thresh = bw->rate;\n\tbw->lamt = 0;\n\ttimerclear(&bw->bwstart);\n\ttimerclear(&bw->bwend);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nbandwidth_limit_init(struct bwlimit *bw, u_int64_t kbps, size_t buflen)\n{\n\tbw->buflen = buflen;\n\tbw->rate = kbps;\n\tbw->thresh = bw->rate;\n\tbw->lamt = 0;\n\ttimerclear(&bw->bwstart);\n\ttimerclear(&bw->bwend);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MINIMUM",
          "args": [
            "ret->transfer_buflen",
            "20480"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "value"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "free_sftp_dirents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "681-693",
          "snippet": "void free_sftp_dirents(SFTP_DIRENT **s)\n{\n\tint i;\n\n\tif (s == NULL)\n\t\treturn;\n\tfor (i = 0; s[i]; i++) {\n\t\tfree(s[i]->filename);\n\t\tfree(s[i]->longname);\n\t\tfree(s[i]);\n\t}\n\tfree(s);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid free_sftp_dirents(SFTP_DIRENT **s)\n{\n\tint i;\n\n\tif (s == NULL)\n\t\treturn;\n\tfor (i = 0; s[i]; i++) {\n\t\tfree(s[i]->filename);\n\t\tfree(s[i]->longname);\n\t\tfree(s[i]);\n\t}\n\tfree(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"Unrecognised server extension \\\"%s\\\"\"",
            "name"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "(char *)value",
            "\"1\""
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string",
          "args": [
            "msg",
            "&value",
            "&vlen"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "msg",
            "&name",
            "NULL"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "msg"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "msg",
            "&ret->version"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Invalid packet back from SSH2_FXP_INIT (type %u)\"",
            "type"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "msg",
            "&type"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_msg_extended",
          "args": [
            "ret",
            "msg",
            "1"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "get_msg_extended",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "132-168",
          "snippet": "static void\nget_msg_extended(struct sftp_conn *conn, struct sshbuf *m, int initial)\n{\n\tu_int msg_len;\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(m, 4, &p)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (atomicio6(read, conn->fd_in, p, 4,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_in) != 4) {\n\t\tif (errno == EPIPE || errno == ECONNRESET)\n\t\t\tfatal(\"Connection closed\");\n\t\telse\n\t\t\tfatal(\"Couldn't read packet: %s\", strerror(errno));\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &msg_len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (msg_len > SFTP_MAX_MSG_LENGTH) {\n\t\tdo_log2(initial ? SYSLOG_LEVEL_ERROR : SYSLOG_LEVEL_FATAL,\n\t\t    \"Received message too long %u\", msg_len);\n\t\tfatal(\"Ensure the remote shell produces no output \"\n\t\t    \"for non-interactive sessions.\");\n\t}\n\n\tif ((r = sshbuf_reserve(m, msg_len, &p)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (atomicio6(read, conn->fd_in, p, msg_len,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_in)\n\t    != msg_len) {\n\t\tif (errno == EPIPE)\n\t\t\tfatal(\"Connection closed\");\n\t\telse\n\t\t\tfatal(\"Read packet: %s\", strerror(errno));\n\t}\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nget_msg_extended(struct sftp_conn *conn, struct sshbuf *m, int initial)\n{\n\tu_int msg_len;\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(m, 4, &p)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (atomicio6(read, conn->fd_in, p, 4,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_in) != 4) {\n\t\tif (errno == EPIPE || errno == ECONNRESET)\n\t\t\tfatal(\"Connection closed\");\n\t\telse\n\t\t\tfatal(\"Couldn't read packet: %s\", strerror(errno));\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &msg_len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (msg_len > SFTP_MAX_MSG_LENGTH) {\n\t\tdo_log2(initial ? SYSLOG_LEVEL_ERROR : SYSLOG_LEVEL_FATAL,\n\t\t    \"Received message too long %u\", msg_len);\n\t\tfatal(\"Ensure the remote shell produces no output \"\n\t\t    \"for non-interactive sessions.\");\n\t}\n\n\tif ((r = sshbuf_reserve(m, msg_len, &p)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (atomicio6(read, conn->fd_in, p, msg_len,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_in)\n\t    != msg_len) {\n\t\tif (errno == EPIPE)\n\t\t\tfatal(\"Connection closed\");\n\t\telse\n\t\t\tfatal(\"Read packet: %s\", strerror(errno));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "msg"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_msg",
          "args": [
            "ret",
            "msg"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "send_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "108-130",
          "snippet": "static void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "msg",
            "SSH2_FILEXFER_VERSION"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "SSH2_FXP_INIT"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "1",
            "sizeof(*ret)"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SFTP_EXT_FSYNC\t\t0x00000010\n#define SFTP_EXT_HARDLINK\t0x00000008\n#define SFTP_EXT_FSTATVFS\t0x00000004\n#define SFTP_EXT_STATVFS\t0x00000002\n#define SFTP_EXT_POSIX_RENAME\t0x00000001\n\nstruct sftp_conn *\ndo_init(int fd_in, int fd_out, u_int transfer_buflen, u_int num_requests,\n    u_int64_t limit_kbps)\n{\n\tu_char type;\n\tstruct sshbuf *msg;\n\tstruct sftp_conn *ret;\n\tint r;\n\n\tret = xcalloc(1, sizeof(*ret));\n\tret->msg_id = 1;\n\tret->fd_in = fd_in;\n\tret->fd_out = fd_out;\n\tret->transfer_buflen = transfer_buflen;\n\tret->num_requests = num_requests;\n\tret->exts = 0;\n\tret->limit_kbps = 0;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_INIT)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, SSH2_FILEXFER_VERSION)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(ret, msg);\n\n\tsshbuf_reset(msg);\n\n\tget_msg_extended(ret, msg, 1);\n\n\t/* Expecting a VERSION reply */\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (type != SSH2_FXP_VERSION) {\n\t\terror(\"Invalid packet back from SSH2_FXP_INIT (type %u)\",\n\t\t    type);\n\t\tsshbuf_free(msg);\n\t\tfree(ret);\n\t\treturn(NULL);\n\t}\n\tif ((r = sshbuf_get_u32(msg, &ret->version)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug2(\"Remote version: %u\", ret->version);\n\n\t/* Check for extensions */\n\twhile (sshbuf_len(msg) > 0) {\n\t\tchar *name;\n\t\tu_char *value;\n\t\tsize_t vlen;\n\t\tint known = 0;\n\n\t\tif ((r = sshbuf_get_cstring(msg, &name, NULL)) != 0 ||\n\t\t    (r = sshbuf_get_string(msg, &value, &vlen)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (strcmp(name, \"posix-rename@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"1\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_POSIX_RENAME;\n\t\t\tknown = 1;\n\t\t} else if (strcmp(name, \"statvfs@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"2\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_STATVFS;\n\t\t\tknown = 1;\n\t\t} else if (strcmp(name, \"fstatvfs@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"2\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_FSTATVFS;\n\t\t\tknown = 1;\n\t\t} else if (strcmp(name, \"hardlink@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"1\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_HARDLINK;\n\t\t\tknown = 1;\n\t\t} else if (strcmp(name, \"fsync@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"1\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_FSYNC;\n\t\t\tknown = 1;\n\t\t}\n\t\tif (known) {\n\t\t\tdebug2(\"Server supports extension \\\"%s\\\" revision %s\",\n\t\t\t    name, value);\n\t\t} else {\n\t\t\tdebug2(\"Unrecognised server extension \\\"%s\\\"\", name);\n\t\t}\n\t\tfree(name);\n\t\tfree(value);\n\t}\n\n\tsshbuf_free(msg);\n\n\t/* Some filexfer v.0 servers don't support large packets */\n\tif (ret->version == 0)\n\t\tret->transfer_buflen = MINIMUM(ret->transfer_buflen, 20480);\n\n\tret->limit_kbps = limit_kbps;\n\tif (ret->limit_kbps > 0) {\n\t\tbandwidth_limit_init(&ret->bwlimit_in, ret->limit_kbps,\n\t\t    ret->transfer_buflen);\n\t\tbandwidth_limit_init(&ret->bwlimit_out, ret->limit_kbps,\n\t\t    ret->transfer_buflen);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "get_decode_statvfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "333-390",
    "snippet": "static int\nget_decode_statvfs(struct sftp_conn *conn, struct sftp_statvfs *st,\n    u_int expected_id, int quiet)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id;\n\tu_int64_t flag;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"Received statvfs reply T:%u I:%u\", type, id);\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (quiet)\n\t\t\tdebug(\"Couldn't statvfs: %s\", fx2txt(status));\n\t\telse\n\t\t\terror(\"Couldn't statvfs: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn -1;\n\t} else if (type != SSH2_FXP_EXTENDED_REPLY) {\n\t\tfatal(\"Expected SSH2_FXP_EXTENDED_REPLY(%u) packet, got %u\",\n\t\t    SSH2_FXP_EXTENDED_REPLY, type);\n\t}\n\n\tmemset(st, 0, sizeof(*st));\n\tif ((r = sshbuf_get_u64(msg, &st->f_bsize)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_frsize)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_blocks)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_bfree)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_bavail)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_files)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_ffree)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_favail)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_fsid)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &flag)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_namemax)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tst->f_flag = (flag & SSH2_FXE_STATVFS_ST_RDONLY) ? ST_RDONLY : 0;\n\tst->f_flag |= (flag & SSH2_FXE_STATVFS_ST_NOSUID) ? ST_NOSUID : 0;\n\n\tsshbuf_free(msg);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u64",
          "args": [
            "msg",
            "&st->f_namemax"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "44-55",
          "snippet": "int\nsshbuf_get_u64(struct sshbuf *buf, u_int64_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 8)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U64(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u64(struct sshbuf *buf, u_int64_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 8)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U64(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "st",
            "0",
            "sizeof(*st)"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Couldn't statvfs: %s\"",
            "fx2txt(status)"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fx2txt",
          "args": [
            "status"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "fx2txt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "182-208",
          "snippet": "const char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Couldn't statvfs: %s\"",
            "fx2txt(status)"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "msg",
            "&status"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "msg",
            "&type"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_msg",
          "args": [
            "conn",
            "msg"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "get_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "170-174",
          "snippet": "static void\nget_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tget_msg_extended(conn, m, 0);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nget_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tget_msg_extended(conn, m, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nget_decode_statvfs(struct sftp_conn *conn, struct sftp_statvfs *st,\n    u_int expected_id, int quiet)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id;\n\tu_int64_t flag;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"Received statvfs reply T:%u I:%u\", type, id);\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (quiet)\n\t\t\tdebug(\"Couldn't statvfs: %s\", fx2txt(status));\n\t\telse\n\t\t\terror(\"Couldn't statvfs: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn -1;\n\t} else if (type != SSH2_FXP_EXTENDED_REPLY) {\n\t\tfatal(\"Expected SSH2_FXP_EXTENDED_REPLY(%u) packet, got %u\",\n\t\t    SSH2_FXP_EXTENDED_REPLY, type);\n\t}\n\n\tmemset(st, 0, sizeof(*st));\n\tif ((r = sshbuf_get_u64(msg, &st->f_bsize)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_frsize)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_blocks)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_bfree)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_bavail)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_files)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_ffree)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_favail)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_fsid)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &flag)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_namemax)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tst->f_flag = (flag & SSH2_FXE_STATVFS_ST_RDONLY) ? ST_RDONLY : 0;\n\tst->f_flag |= (flag & SSH2_FXE_STATVFS_ST_NOSUID) ? ST_NOSUID : 0;\n\n\tsshbuf_free(msg);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_decode_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "288-331",
    "snippet": "static Attrib *\nget_decode_stat(struct sftp_conn *conn, u_int expected_id, int quiet)\n{\n\tstruct sshbuf *msg;\n\tu_int id;\n\tu_char type;\n\tint r;\n\tstatic Attrib a;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"Received stat reply T:%u I:%u\", type, id);\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (quiet)\n\t\t\tdebug(\"Couldn't stat remote file: %s\", fx2txt(status));\n\t\telse\n\t\t\terror(\"Couldn't stat remote file: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn(NULL);\n\t} else if (type != SSH2_FXP_ATTRS) {\n\t\tfatal(\"Expected SSH2_FXP_ATTRS(%u) packet, got %u\",\n\t\t    SSH2_FXP_ATTRS, type);\n\t}\n\tif ((r = decode_attrib(msg, &a)) != 0) {\n\t\terror(\"%s: couldn't decode attrib: %s\", __func__, ssh_err(r));\n\t\tsshbuf_free(msg);\n\t\treturn NULL;\n\t}\n\tsshbuf_free(msg);\n\n\treturn &a;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: couldn't decode attrib: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_attrib",
          "args": [
            "msg",
            "&a"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "decode_attrib",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "104-150",
          "snippet": "int\ndecode_attrib(struct sshbuf *b, Attrib *a)\n{\n\tint r;\n\n\tattrib_clear(a);\n\tif ((r = sshbuf_get_u32(b, &a->flags)) != 0)\n\t\treturn r;\n\tif (a->flags & SSH2_FILEXFER_ATTR_SIZE) {\n\t\tif ((r = sshbuf_get_u64(b, &a->size)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {\n\t\tif ((r = sshbuf_get_u32(b, &a->uid)) != 0 ||\n\t\t    (r = sshbuf_get_u32(b, &a->gid)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {\n\t\tif ((r = sshbuf_get_u32(b, &a->perm)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {\n\t\tif ((r = sshbuf_get_u32(b, &a->atime)) != 0 ||\n\t\t    (r = sshbuf_get_u32(b, &a->mtime)) != 0)\n\t\t\treturn r;\n\t}\n\t/* vendor-specific extensions */\n\tif (a->flags & SSH2_FILEXFER_ATTR_EXTENDED) {\n\t\tchar *type;\n\t\tu_char *data;\n\t\tsize_t dlen;\n\t\tu_int i, count;\n\n\t\tif ((r = sshbuf_get_u32(b, &count)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif ((r = sshbuf_get_cstring(b, &type, NULL)) != 0 ||\n\t\t\t    (r = sshbuf_get_string(b, &data, &dlen)) != 0)\n\t\t\t\treturn r;\n\t\t\tdebug3(\"Got file attribute \\\"%.100s\\\" len %zu\",\n\t\t\t    type, dlen);\n\t\t\tfree(type);\n\t\t\tfree(data);\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndecode_attrib(struct sshbuf *b, Attrib *a)\n{\n\tint r;\n\n\tattrib_clear(a);\n\tif ((r = sshbuf_get_u32(b, &a->flags)) != 0)\n\t\treturn r;\n\tif (a->flags & SSH2_FILEXFER_ATTR_SIZE) {\n\t\tif ((r = sshbuf_get_u64(b, &a->size)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {\n\t\tif ((r = sshbuf_get_u32(b, &a->uid)) != 0 ||\n\t\t    (r = sshbuf_get_u32(b, &a->gid)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {\n\t\tif ((r = sshbuf_get_u32(b, &a->perm)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {\n\t\tif ((r = sshbuf_get_u32(b, &a->atime)) != 0 ||\n\t\t    (r = sshbuf_get_u32(b, &a->mtime)) != 0)\n\t\t\treturn r;\n\t}\n\t/* vendor-specific extensions */\n\tif (a->flags & SSH2_FILEXFER_ATTR_EXTENDED) {\n\t\tchar *type;\n\t\tu_char *data;\n\t\tsize_t dlen;\n\t\tu_int i, count;\n\n\t\tif ((r = sshbuf_get_u32(b, &count)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif ((r = sshbuf_get_cstring(b, &type, NULL)) != 0 ||\n\t\t\t    (r = sshbuf_get_string(b, &data, &dlen)) != 0)\n\t\t\t\treturn r;\n\t\t\tdebug3(\"Got file attribute \\\"%.100s\\\" len %zu\",\n\t\t\t    type, dlen);\n\t\t\tfree(type);\n\t\t\tfree(data);\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Expected SSH2_FXP_ATTRS(%u) packet, got %u\"",
            "SSH2_FXP_ATTRS",
            "type"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fx2txt",
          "args": [
            "status"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "fx2txt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "182-208",
          "snippet": "const char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Couldn't stat remote file: %s\"",
            "fx2txt(status)"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "msg",
            "&status"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "msg",
            "&type"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_msg",
          "args": [
            "conn",
            "msg"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "get_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "170-174",
          "snippet": "static void\nget_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tget_msg_extended(conn, m, 0);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nget_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tget_msg_extended(conn, m, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Attrib *\nget_decode_stat(struct sftp_conn *conn, u_int expected_id, int quiet)\n{\n\tstruct sshbuf *msg;\n\tu_int id;\n\tu_char type;\n\tint r;\n\tstatic Attrib a;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"Received stat reply T:%u I:%u\", type, id);\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (quiet)\n\t\t\tdebug(\"Couldn't stat remote file: %s\", fx2txt(status));\n\t\telse\n\t\t\terror(\"Couldn't stat remote file: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn(NULL);\n\t} else if (type != SSH2_FXP_ATTRS) {\n\t\tfatal(\"Expected SSH2_FXP_ATTRS(%u) packet, got %u\",\n\t\t    SSH2_FXP_ATTRS, type);\n\t}\n\tif ((r = decode_attrib(msg, &a)) != 0) {\n\t\terror(\"%s: couldn't decode attrib: %s\", __func__, ssh_err(r));\n\t\tsshbuf_free(msg);\n\t\treturn NULL;\n\t}\n\tsshbuf_free(msg);\n\n\treturn &a;\n}"
  },
  {
    "function_name": "get_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "243-286",
    "snippet": "static u_char *\nget_handle(struct sftp_conn *conn, u_int expected_id, size_t *len,\n    const char *errfmt, ...)\n{\n\tstruct sshbuf *msg;\n\tu_int id, status;\n\tu_char type;\n\tu_char *handle;\n\tchar errmsg[256];\n\tva_list args;\n\tint r;\n\n\tva_start(args, errfmt);\n\tif (errfmt != NULL)\n\t\tvsnprintf(errmsg, sizeof(errmsg), errfmt, args);\n\tva_end(args);\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"%s: ID mismatch (%u != %u)\",\n\t\t    errfmt == NULL ? __func__ : errmsg, id, expected_id);\n\tif (type == SSH2_FXP_STATUS) {\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (errfmt != NULL)\n\t\t\terror(\"%s: %s\", errmsg, fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn(NULL);\n\t} else if (type != SSH2_FXP_HANDLE)\n\t\tfatal(\"%s: Expected SSH2_FXP_HANDLE(%u) packet, got %u\",\n\t\t    errfmt == NULL ? __func__ : errmsg, SSH2_FXP_HANDLE, type);\n\n\tif ((r = sshbuf_get_string(msg, &handle, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\treturn handle;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string",
          "args": [
            "msg",
            "&handle",
            "len"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: %s\"",
            "errmsg",
            "fx2txt(status)"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fx2txt",
          "args": [
            "status"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "fx2txt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "182-208",
          "snippet": "const char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nfx2txt(int status)\n{\n\tswitch (status) {\n\tcase SSH2_FX_OK:\n\t\treturn(\"No error\");\n\tcase SSH2_FX_EOF:\n\t\treturn(\"End of file\");\n\tcase SSH2_FX_NO_SUCH_FILE:\n\t\treturn(\"No such file or directory\");\n\tcase SSH2_FX_PERMISSION_DENIED:\n\t\treturn(\"Permission denied\");\n\tcase SSH2_FX_FAILURE:\n\t\treturn(\"Failure\");\n\tcase SSH2_FX_BAD_MESSAGE:\n\t\treturn(\"Bad message\");\n\tcase SSH2_FX_NO_CONNECTION:\n\t\treturn(\"No connection\");\n\tcase SSH2_FX_CONNECTION_LOST:\n\t\treturn(\"Connection lost\");\n\tcase SSH2_FX_OP_UNSUPPORTED:\n\t\treturn(\"Operation unsupported\");\n\tdefault:\n\t\treturn(\"Unknown status\");\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "msg",
            "&status"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "msg",
            "&type"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_msg",
          "args": [
            "conn",
            "msg"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "get_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "170-174",
          "snippet": "static void\nget_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tget_msg_extended(conn, m, 0);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nget_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tget_msg_extended(conn, m, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "errmsg",
            "sizeof(errmsg)",
            "errfmt",
            "args"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "vsnprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "861-865",
          "snippet": "int\nvsnprintf (char *str, size_t count, const char *fmt, va_list args)\n{\n\treturn dopr(str, count, fmt, args);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nvsnprintf (char *str, size_t count, const char *fmt, va_list args)\n{\n\treturn dopr(str, count, fmt, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "errfmt"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic u_char *\nget_handle(struct sftp_conn *conn, u_int expected_id, size_t *len,\n    const char *errfmt, ...)\n{\n\tstruct sshbuf *msg;\n\tu_int id, status;\n\tu_char type;\n\tu_char *handle;\n\tchar errmsg[256];\n\tva_list args;\n\tint r;\n\n\tva_start(args, errfmt);\n\tif (errfmt != NULL)\n\t\tvsnprintf(errmsg, sizeof(errmsg), errfmt, args);\n\tva_end(args);\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"%s: ID mismatch (%u != %u)\",\n\t\t    errfmt == NULL ? __func__ : errmsg, id, expected_id);\n\tif (type == SSH2_FXP_STATUS) {\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (errfmt != NULL)\n\t\t\terror(\"%s: %s\", errmsg, fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn(NULL);\n\t} else if (type != SSH2_FXP_HANDLE)\n\t\tfatal(\"%s: Expected SSH2_FXP_HANDLE(%u) packet, got %u\",\n\t\t    errfmt == NULL ? __func__ : errmsg, SSH2_FXP_HANDLE, type);\n\n\tif ((r = sshbuf_get_string(msg, &handle, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\treturn handle;\n}"
  },
  {
    "function_name": "get_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "213-241",
    "snippet": "static u_int\nget_status(struct sftp_conn *conn, u_int expected_id)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id, status;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type != SSH2_FXP_STATUS)\n\t\tfatal(\"Expected SSH2_FXP_STATUS(%u) packet, got %u\",\n\t\t    SSH2_FXP_STATUS, type);\n\n\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\treturn status;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"SSH2_FXP_STATUS %u\"",
            "status"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "msg",
            "&status"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "msg",
            "&type"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_msg",
          "args": [
            "conn",
            "msg"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "get_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "170-174",
          "snippet": "static void\nget_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tget_msg_extended(conn, m, 0);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nget_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tget_msg_extended(conn, m, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic u_int\nget_status(struct sftp_conn *conn, u_int expected_id)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id, status;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type != SSH2_FXP_STATUS)\n\t\tfatal(\"Expected SSH2_FXP_STATUS(%u) packet, got %u\",\n\t\t    SSH2_FXP_STATUS, type);\n\n\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n\n\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\treturn status;\n}"
  },
  {
    "function_name": "send_string_attrs_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "194-211",
    "snippet": "static void\nsend_string_attrs_request(struct sftp_conn *conn, u_int id, u_int code,\n    const void *s, u_int len, Attrib *a)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, code)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, s, len)) != 0 ||\n\t    (r = encode_attrib(msg, a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fd %d T:%u I:%u\", conn->fd_out, code, id);\n\tsshbuf_free(msg);\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Sent message fd %d T:%u I:%u\"",
            "conn->fd_out",
            "code",
            "id"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_msg",
          "args": [
            "conn",
            "msg"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "send_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "108-130",
          "snippet": "static void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_attrib",
          "args": [
            "msg",
            "a"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "encode_attrib",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-common.c",
          "lines": "153-179",
          "snippet": "int\nencode_attrib(struct sshbuf *b, const Attrib *a)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(b, a->flags)) != 0)\n\t\treturn r;\n\tif (a->flags & SSH2_FILEXFER_ATTR_SIZE) {\n\t\tif ((r = sshbuf_put_u64(b, a->size)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {\n\t\tif ((r = sshbuf_put_u32(b, a->uid)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, a->gid)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {\n\t\tif ((r = sshbuf_put_u32(b, a->perm)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {\n\t\tif ((r = sshbuf_put_u32(b, a->atime)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, a->mtime)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <util.h>",
            "#include <stdarg.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <util.h>\n#include <stdarg.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nencode_attrib(struct sshbuf *b, const Attrib *a)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(b, a->flags)) != 0)\n\t\treturn r;\n\tif (a->flags & SSH2_FILEXFER_ATTR_SIZE) {\n\t\tif ((r = sshbuf_put_u64(b, a->size)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {\n\t\tif ((r = sshbuf_put_u32(b, a->uid)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, a->gid)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {\n\t\tif ((r = sshbuf_put_u32(b, a->perm)) != 0)\n\t\t\treturn r;\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {\n\t\tif ((r = sshbuf_put_u32(b, a->atime)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, a->mtime)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "msg",
            "s",
            "len"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "msg",
            "id"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "code"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_string_attrs_request(struct sftp_conn *conn, u_int id, u_int code,\n    const void *s, u_int len, Attrib *a)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, code)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, s, len)) != 0 ||\n\t    (r = encode_attrib(msg, a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fd %d T:%u I:%u\", conn->fd_out, code, id);\n\tsshbuf_free(msg);\n}"
  },
  {
    "function_name": "send_string_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "176-192",
    "snippet": "static void\nsend_string_request(struct sftp_conn *conn, u_int id, u_int code, const char *s,\n    u_int len)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, code)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, s, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fd %d T:%u I:%u\", conn->fd_out, code, id);\n\tsshbuf_free(msg);\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Sent message fd %d T:%u I:%u\"",
            "conn->fd_out",
            "code",
            "id"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_msg",
          "args": [
            "conn",
            "msg"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "send_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "108-130",
          "snippet": "static void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "msg",
            "s",
            "len"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "msg",
            "id"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "code"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_string_request(struct sftp_conn *conn, u_int id, u_int code, const char *s,\n    u_int len)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, code)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, s, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fd %d T:%u I:%u\", conn->fd_out, code, id);\n\tsshbuf_free(msg);\n}"
  },
  {
    "function_name": "get_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "170-174",
    "snippet": "static void\nget_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tget_msg_extended(conn, m, 0);\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_msg_extended",
          "args": [
            "conn",
            "m",
            "0"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "get_msg_extended",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "132-168",
          "snippet": "static void\nget_msg_extended(struct sftp_conn *conn, struct sshbuf *m, int initial)\n{\n\tu_int msg_len;\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(m, 4, &p)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (atomicio6(read, conn->fd_in, p, 4,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_in) != 4) {\n\t\tif (errno == EPIPE || errno == ECONNRESET)\n\t\t\tfatal(\"Connection closed\");\n\t\telse\n\t\t\tfatal(\"Couldn't read packet: %s\", strerror(errno));\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &msg_len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (msg_len > SFTP_MAX_MSG_LENGTH) {\n\t\tdo_log2(initial ? SYSLOG_LEVEL_ERROR : SYSLOG_LEVEL_FATAL,\n\t\t    \"Received message too long %u\", msg_len);\n\t\tfatal(\"Ensure the remote shell produces no output \"\n\t\t    \"for non-interactive sessions.\");\n\t}\n\n\tif ((r = sshbuf_reserve(m, msg_len, &p)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (atomicio6(read, conn->fd_in, p, msg_len,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_in)\n\t    != msg_len) {\n\t\tif (errno == EPIPE)\n\t\t\tfatal(\"Connection closed\");\n\t\telse\n\t\t\tfatal(\"Read packet: %s\", strerror(errno));\n\t}\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nget_msg_extended(struct sftp_conn *conn, struct sshbuf *m, int initial)\n{\n\tu_int msg_len;\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(m, 4, &p)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (atomicio6(read, conn->fd_in, p, 4,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_in) != 4) {\n\t\tif (errno == EPIPE || errno == ECONNRESET)\n\t\t\tfatal(\"Connection closed\");\n\t\telse\n\t\t\tfatal(\"Couldn't read packet: %s\", strerror(errno));\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &msg_len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (msg_len > SFTP_MAX_MSG_LENGTH) {\n\t\tdo_log2(initial ? SYSLOG_LEVEL_ERROR : SYSLOG_LEVEL_FATAL,\n\t\t    \"Received message too long %u\", msg_len);\n\t\tfatal(\"Ensure the remote shell produces no output \"\n\t\t    \"for non-interactive sessions.\");\n\t}\n\n\tif ((r = sshbuf_reserve(m, msg_len, &p)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (atomicio6(read, conn->fd_in, p, msg_len,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_in)\n\t    != msg_len) {\n\t\tif (errno == EPIPE)\n\t\t\tfatal(\"Connection closed\");\n\t\telse\n\t\t\tfatal(\"Read packet: %s\", strerror(errno));\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nget_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tget_msg_extended(conn, m, 0);\n}"
  },
  {
    "function_name": "get_msg_extended",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "132-168",
    "snippet": "static void\nget_msg_extended(struct sftp_conn *conn, struct sshbuf *m, int initial)\n{\n\tu_int msg_len;\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(m, 4, &p)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (atomicio6(read, conn->fd_in, p, 4,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_in) != 4) {\n\t\tif (errno == EPIPE || errno == ECONNRESET)\n\t\t\tfatal(\"Connection closed\");\n\t\telse\n\t\t\tfatal(\"Couldn't read packet: %s\", strerror(errno));\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &msg_len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (msg_len > SFTP_MAX_MSG_LENGTH) {\n\t\tdo_log2(initial ? SYSLOG_LEVEL_ERROR : SYSLOG_LEVEL_FATAL,\n\t\t    \"Received message too long %u\", msg_len);\n\t\tfatal(\"Ensure the remote shell produces no output \"\n\t\t    \"for non-interactive sessions.\");\n\t}\n\n\tif ((r = sshbuf_reserve(m, msg_len, &p)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (atomicio6(read, conn->fd_in, p, msg_len,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_in)\n\t    != msg_len) {\n\t\tif (errno == EPIPE)\n\t\t\tfatal(\"Connection closed\");\n\t\telse\n\t\t\tfatal(\"Read packet: %s\", strerror(errno));\n\t}\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Read packet: %s\"",
            "strerror(errno)"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Connection closed\""
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomicio6",
          "args": [
            "read",
            "conn->fd_in",
            "p",
            "msg_len",
            "conn->limit_kbps > 0 ? sftpio : NULL",
            "&conn->bwlimit_in"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "atomicio6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "51-89",
          "snippet": "size_t\natomicio6(ssize_t (*f) (int, void *, size_t), int fd, void *_s, size_t n,\n    int (*cb)(void *, size_t), void *cb_arg)\n{\n\tchar *s = _s;\n\tsize_t pos = 0;\n\tssize_t res;\n\tstruct pollfd pfd;\n\n#ifndef BROKEN_READ_COMPARISON\n\tpfd.fd = fd;\n\tpfd.events = f == read ? POLLIN : POLLOUT;\n#endif\n\twhile (n > pos) {\n\t\tres = (f) (fd, s + pos, n - pos);\n\t\tswitch (res) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tif (errno == EAGAIN || errno == EWOULDBLOCK) {\n#ifndef BROKEN_READ_COMPARISON\n\t\t\t\t(void)poll(&pfd, 1, -1);\n#endif\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase 0:\n\t\t\terrno = EPIPE;\n\t\t\treturn pos;\n\t\tdefault:\n\t\t\tpos += (size_t)res;\n\t\t\tif (cb != NULL && cb(cb_arg, (size_t)res) == -1) {\n\t\t\t\terrno = EINTR;\n\t\t\t\treturn pos;\n\t\t\t}\n\t\t}\n\t}\n\treturn pos;\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomicio6(ssize_t (*f) (int, void *, size_t), int fd, void *_s, size_t n,\n    int (*cb)(void *, size_t), void *cb_arg)\n{\n\tchar *s = _s;\n\tsize_t pos = 0;\n\tssize_t res;\n\tstruct pollfd pfd;\n\n#ifndef BROKEN_READ_COMPARISON\n\tpfd.fd = fd;\n\tpfd.events = f == read ? POLLIN : POLLOUT;\n#endif\n\twhile (n > pos) {\n\t\tres = (f) (fd, s + pos, n - pos);\n\t\tswitch (res) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tif (errno == EAGAIN || errno == EWOULDBLOCK) {\n#ifndef BROKEN_READ_COMPARISON\n\t\t\t\t(void)poll(&pfd, 1, -1);\n#endif\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase 0:\n\t\t\terrno = EPIPE;\n\t\t\treturn pos;\n\t\tdefault:\n\t\t\tpos += (size_t)res;\n\t\t\tif (cb != NULL && cb(cb_arg, (size_t)res) == -1) {\n\t\t\t\terrno = EINTR;\n\t\t\t\treturn pos;\n\t\t\t}\n\t\t}\n\t}\n\treturn pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reserve",
          "args": [
            "m",
            "msg_len",
            "&p"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "343-361",
          "snippet": "int\nsshbuf_reserve(struct sshbuf *buf, size_t len, u_char **dpp)\n{\n\tu_char *dp;\n\tint r;\n\n\tif (dpp != NULL)\n\t\t*dpp = NULL;\n\n\tSSHBUF_DBG((\"reserve buf = %p len = %zu\", buf, len));\n\tif ((r = sshbuf_allocate(buf, len)) != 0)\n\t\treturn r;\n\n\tdp = buf->d + buf->size;\n\tbuf->size += len;\n\tif (dpp != NULL)\n\t\t*dpp = dp;\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_reserve(struct sshbuf *buf, size_t len, u_char **dpp)\n{\n\tu_char *dp;\n\tint r;\n\n\tif (dpp != NULL)\n\t\t*dpp = NULL;\n\n\tSSHBUF_DBG((\"reserve buf = %p len = %zu\", buf, len));\n\tif ((r = sshbuf_allocate(buf, len)) != 0)\n\t\treturn r;\n\n\tdp = buf->d + buf->size;\n\tbuf->size += len;\n\tif (dpp != NULL)\n\t\t*dpp = dp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_log2",
          "args": [
            "initial ? SYSLOG_LEVEL_ERROR : SYSLOG_LEVEL_FATAL",
            "\"Received message too long %u\"",
            "msg_len"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "do_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "390-398",
          "snippet": "void\ndo_log2(LogLevel level, const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(level, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndo_log2(LogLevel level, const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(level, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "m",
            "&msg_len"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nget_msg_extended(struct sftp_conn *conn, struct sshbuf *m, int initial)\n{\n\tu_int msg_len;\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(m, 4, &p)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (atomicio6(read, conn->fd_in, p, 4,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_in) != 4) {\n\t\tif (errno == EPIPE || errno == ECONNRESET)\n\t\t\tfatal(\"Connection closed\");\n\t\telse\n\t\t\tfatal(\"Couldn't read packet: %s\", strerror(errno));\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &msg_len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (msg_len > SFTP_MAX_MSG_LENGTH) {\n\t\tdo_log2(initial ? SYSLOG_LEVEL_ERROR : SYSLOG_LEVEL_FATAL,\n\t\t    \"Received message too long %u\", msg_len);\n\t\tfatal(\"Ensure the remote shell produces no output \"\n\t\t    \"for non-interactive sessions.\");\n\t}\n\n\tif ((r = sshbuf_reserve(m, msg_len, &p)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (atomicio6(read, conn->fd_in, p, msg_len,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_in)\n\t    != msg_len) {\n\t\tif (errno == EPIPE)\n\t\t\tfatal(\"Connection closed\");\n\t\telse\n\t\t\tfatal(\"Read packet: %s\", strerror(errno));\n\t}\n}"
  },
  {
    "function_name": "send_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "108-130",
    "snippet": "static void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Couldn't send packet: %s\"",
            "strerror(errno)"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "m"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomiciov6",
          "args": [
            "writev",
            "conn->fd_out",
            "iov",
            "2",
            "conn->limit_kbps > 0 ? sftpio : NULL",
            "&conn->bwlimit_out"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "atomiciov6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "100-163",
          "snippet": "size_t\natomiciov6(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt,\n    int (*cb)(void *, size_t), void *cb_arg)\n{\n\tsize_t pos = 0, rem;\n\tssize_t res;\n\tstruct iovec iov_array[IOV_MAX], *iov = iov_array;\n\tstruct pollfd pfd;\n\n\tif (iovcnt < 0 || iovcnt > IOV_MAX) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\t/* Make a copy of the iov array because we may modify it below */\n\tmemcpy(iov, _iov, (size_t)iovcnt * sizeof(*_iov));\n\n#ifndef BROKEN_READV_COMPARISON\n\tpfd.fd = fd;\n\tpfd.events = f == readv ? POLLIN : POLLOUT;\n#endif\n\tfor (; iovcnt > 0 && iov[0].iov_len > 0;) {\n\t\tres = (f) (fd, iov, iovcnt);\n\t\tswitch (res) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tif (errno == EAGAIN || errno == EWOULDBLOCK) {\n#ifndef BROKEN_READV_COMPARISON\n\t\t\t\t(void)poll(&pfd, 1, -1);\n#endif\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase 0:\n\t\t\terrno = EPIPE;\n\t\t\treturn pos;\n\t\tdefault:\n\t\t\trem = (size_t)res;\n\t\t\tpos += rem;\n\t\t\t/* skip completed iov entries */\n\t\t\twhile (iovcnt > 0 && rem >= iov[0].iov_len) {\n\t\t\t\trem -= iov[0].iov_len;\n\t\t\t\tiov++;\n\t\t\t\tiovcnt--;\n\t\t\t}\n\t\t\t/* This shouldn't happen... */\n\t\t\tif (rem > 0 && (iovcnt <= 0 || rem > iov[0].iov_len)) {\n\t\t\t\terrno = EFAULT;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (iovcnt == 0)\n\t\t\t\tbreak;\n\t\t\t/* update pointer in partially complete iov */\n\t\t\tiov[0].iov_base = ((char *)iov[0].iov_base) + rem;\n\t\t\tiov[0].iov_len -= rem;\n\t\t}\n\t\tif (cb != NULL && cb(cb_arg, (size_t)res) == -1) {\n\t\t\terrno = EINTR;\n\t\t\treturn pos;\n\t\t}\n\t}\n\treturn pos;\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomiciov6(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt,\n    int (*cb)(void *, size_t), void *cb_arg)\n{\n\tsize_t pos = 0, rem;\n\tssize_t res;\n\tstruct iovec iov_array[IOV_MAX], *iov = iov_array;\n\tstruct pollfd pfd;\n\n\tif (iovcnt < 0 || iovcnt > IOV_MAX) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\t/* Make a copy of the iov array because we may modify it below */\n\tmemcpy(iov, _iov, (size_t)iovcnt * sizeof(*_iov));\n\n#ifndef BROKEN_READV_COMPARISON\n\tpfd.fd = fd;\n\tpfd.events = f == readv ? POLLIN : POLLOUT;\n#endif\n\tfor (; iovcnt > 0 && iov[0].iov_len > 0;) {\n\t\tres = (f) (fd, iov, iovcnt);\n\t\tswitch (res) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tif (errno == EAGAIN || errno == EWOULDBLOCK) {\n#ifndef BROKEN_READV_COMPARISON\n\t\t\t\t(void)poll(&pfd, 1, -1);\n#endif\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase 0:\n\t\t\terrno = EPIPE;\n\t\t\treturn pos;\n\t\tdefault:\n\t\t\trem = (size_t)res;\n\t\t\tpos += rem;\n\t\t\t/* skip completed iov entries */\n\t\t\twhile (iovcnt > 0 && rem >= iov[0].iov_len) {\n\t\t\t\trem -= iov[0].iov_len;\n\t\t\t\tiov++;\n\t\t\t\tiovcnt--;\n\t\t\t}\n\t\t\t/* This shouldn't happen... */\n\t\t\tif (rem > 0 && (iovcnt <= 0 || rem > iov[0].iov_len)) {\n\t\t\t\terrno = EFAULT;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (iovcnt == 0)\n\t\t\t\tbreak;\n\t\t\t/* update pointer in partially complete iov */\n\t\t\tiov[0].iov_base = ((char *)iov[0].iov_base) + rem;\n\t\t\tiov[0].iov_len -= rem;\n\t\t}\n\t\tif (cb != NULL && cb(cb_arg, (size_t)res) == -1) {\n\t\t\terrno = EINTR;\n\t\t\treturn pos;\n\t\t}\n\t}\n\treturn pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "m"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_u32",
          "args": [
            "mlen",
            "sshbuf_len(m)"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "put_u32_le",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1235-1244",
          "snippet": "void\nput_u32_le(void *vp, u_int32_t v)\n{\n\tu_char *p = (u_char *)vp;\n\n\tp[0] = (u_char)v & 0xff;\n\tp[1] = (u_char)(v >> 8) & 0xff;\n\tp[2] = (u_char)(v >> 16) & 0xff;\n\tp[3] = (u_char)(v >> 24) & 0xff;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nput_u32_le(void *vp, u_int32_t v)\n{\n\tu_char *p = (u_char *)vp;\n\n\tp[0] = (u_char)v & 0xff;\n\tp[1] = (u_char)(v >> 8) & 0xff;\n\tp[2] = (u_char)(v >> 16) & 0xff;\n\tp[3] = (u_char)(v >> 24) & 0xff;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t/* Send length first */\n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2,\n\t    conn->limit_kbps > 0 ? sftpio : NULL, &conn->bwlimit_out) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}"
  },
  {
    "function_name": "sftpio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
    "lines": "99-106",
    "snippet": "static int\nsftpio(void *_bwlimit, size_t amount)\n{\n\tstruct bwlimit *bwlimit = (struct bwlimit *)_bwlimit;\n\n\tbandwidth_limit(bwlimit, amount);\n\treturn 0;\n}",
    "includes": [
      "#include \"sftp-client.h\"",
      "#include \"sftp-common.h\"",
      "#include \"sftp.h\"",
      "#include \"utf8.h\"",
      "#include \"misc.h\"",
      "#include \"progressmeter.h\"",
      "#include \"atomicio.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/uio.h>",
      "# include <sys/time.h>",
      "# include <sys/stat.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <sys/statvfs.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bandwidth_limit",
          "args": [
            "bwlimit",
            "amount"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "bandwidth_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1345-1395",
          "snippet": "void\nbandwidth_limit(struct bwlimit *bw, size_t read_len)\n{\n\tu_int64_t waitlen;\n\tstruct timespec ts, rm;\n\n\tif (!timerisset(&bw->bwstart)) {\n\t\tmonotime_tv(&bw->bwstart);\n\t\treturn;\n\t}\n\n\tbw->lamt += read_len;\n\tif (bw->lamt < bw->thresh)\n\t\treturn;\n\n\tmonotime_tv(&bw->bwend);\n\ttimersub(&bw->bwend, &bw->bwstart, &bw->bwend);\n\tif (!timerisset(&bw->bwend))\n\t\treturn;\n\n\tbw->lamt *= 8;\n\twaitlen = (double)1000000L * bw->lamt / bw->rate;\n\n\tbw->bwstart.tv_sec = waitlen / 1000000L;\n\tbw->bwstart.tv_usec = waitlen % 1000000L;\n\n\tif (timercmp(&bw->bwstart, &bw->bwend, >)) {\n\t\ttimersub(&bw->bwstart, &bw->bwend, &bw->bwend);\n\n\t\t/* Adjust the wait time */\n\t\tif (bw->bwend.tv_sec) {\n\t\t\tbw->thresh /= 2;\n\t\t\tif (bw->thresh < bw->buflen / 4)\n\t\t\t\tbw->thresh = bw->buflen / 4;\n\t\t} else if (bw->bwend.tv_usec < 10000) {\n\t\t\tbw->thresh *= 2;\n\t\t\tif (bw->thresh > bw->buflen * 8)\n\t\t\t\tbw->thresh = bw->buflen * 8;\n\t\t}\n\n\t\tTIMEVAL_TO_TIMESPEC(&bw->bwend, &ts);\n\t\twhile (nanosleep(&ts, &rm) == -1) {\n\t\t\tif (errno != EINTR)\n\t\t\t\tbreak;\n\t\t\tts = rm;\n\t\t}\n\t}\n\n\tbw->lamt = 0;\n\tmonotime_tv(&bw->bwstart);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nbandwidth_limit(struct bwlimit *bw, size_t read_len)\n{\n\tu_int64_t waitlen;\n\tstruct timespec ts, rm;\n\n\tif (!timerisset(&bw->bwstart)) {\n\t\tmonotime_tv(&bw->bwstart);\n\t\treturn;\n\t}\n\n\tbw->lamt += read_len;\n\tif (bw->lamt < bw->thresh)\n\t\treturn;\n\n\tmonotime_tv(&bw->bwend);\n\ttimersub(&bw->bwend, &bw->bwstart, &bw->bwend);\n\tif (!timerisset(&bw->bwend))\n\t\treturn;\n\n\tbw->lamt *= 8;\n\twaitlen = (double)1000000L * bw->lamt / bw->rate;\n\n\tbw->bwstart.tv_sec = waitlen / 1000000L;\n\tbw->bwstart.tv_usec = waitlen % 1000000L;\n\n\tif (timercmp(&bw->bwstart, &bw->bwend, >)) {\n\t\ttimersub(&bw->bwstart, &bw->bwend, &bw->bwend);\n\n\t\t/* Adjust the wait time */\n\t\tif (bw->bwend.tv_sec) {\n\t\t\tbw->thresh /= 2;\n\t\t\tif (bw->thresh < bw->buflen / 4)\n\t\t\t\tbw->thresh = bw->buflen / 4;\n\t\t} else if (bw->bwend.tv_usec < 10000) {\n\t\t\tbw->thresh *= 2;\n\t\t\tif (bw->thresh > bw->buflen * 8)\n\t\t\t\tbw->thresh = bw->buflen * 8;\n\t\t}\n\n\t\tTIMEVAL_TO_TIMESPEC(&bw->bwend, &ts);\n\t\twhile (nanosleep(&ts, &rm) == -1) {\n\t\t\tif (errno != EINTR)\n\t\t\t\tbreak;\n\t\t\tts = rm;\n\t\t}\n\t}\n\n\tbw->lamt = 0;\n\tmonotime_tv(&bw->bwstart);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nsftpio(void *_bwlimit, size_t amount)\n{\n\tstruct bwlimit *bwlimit = (struct bwlimit *)_bwlimit;\n\n\tbandwidth_limit(bwlimit, amount);\n\treturn 0;\n}"
  }
]