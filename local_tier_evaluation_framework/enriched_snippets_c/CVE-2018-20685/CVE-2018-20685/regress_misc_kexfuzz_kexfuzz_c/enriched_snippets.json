[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/misc/kexfuzz/kexfuzz.c",
    "lines": "342-459",
    "snippet": "int\nmain(int argc, char **argv)\n{\n\tint ch, fd, r;\n\tint count_flag = 0, dump_flag = 0, replace_flag = 0;\n\tint packet_index = -1, direction = -1;\n\tint s2c = 0, c2s = 0; /* packet counts */\n\tconst char *kex = NULL, *kpath = NULL, *data_path = NULL;\n\tstruct sshkey *key = NULL;\n\tstruct sshbuf *replace_data = NULL;\n\n\tsetvbuf(stdout, NULL, _IONBF, 0);\n\twhile ((ch = getopt(argc, argv, \"hcdrvD:f:K:k:i:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'h':\n\t\t\tusage();\n\t\t\treturn 0;\n\t\tcase 'c':\n\t\t\tcount_flag = 1;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdump_flag = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\treplace_flag = 1;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tdo_debug = 1;\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tif (strcasecmp(optarg, \"s2c\") == 0)\n\t\t\t\tdirection = S2C;\n\t\t\telse if (strcasecmp(optarg, \"c2s\") == 0)\n\t\t\t\tdirection = C2S;\n\t\t\telse\n\t\t\t\tbadusage(\"Invalid direction (-D)\");\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tdata_path = optarg;\n\t\t\tbreak;\n\t\tcase 'K':\n\t\t\tkex = optarg;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tkpath = optarg;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tpacket_index = atoi(optarg);\n\t\t\tif (packet_index < 0)\n\t\t\t\tbadusage(\"Invalid packet index\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbadusage(\"unsupported flag\");\n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\n\tlog_init(argv[0], do_debug ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO,\n\t    SYSLOG_FACILITY_USER, 1);\n\n\t/* Must select a single mode */\n\tif ((count_flag + dump_flag + replace_flag) != 1)\n\t\tbadusage(\"Must select one mode: -c, -d or -r\");\n\t/* KEX type is mandatory */\n\tif (kex == NULL || !kex_names_valid(kex) || strchr(kex, ',') != NULL)\n\t\tbadusage(\"Missing or invalid kex type (-K flag)\");\n\t/* Valid key is mandatory */\n\tif (kpath == NULL)\n\t\tbadusage(\"Missing private key (-k flag)\");\n\tif ((fd = open(kpath, O_RDONLY)) == -1)\n\t\terr(1, \"open %s\", kpath);\n\tif ((r = sshkey_load_private_type_fd(fd, KEY_UNSPEC, NULL,\n\t    &key, NULL)) != 0)\n\t\terrx(1, \"Unable to load key %s: %s\", kpath, ssh_err(r));\n\tclose(fd);\n\t/* XXX check that it is a private key */\n\t/* XXX support certificates */\n\tif (key == NULL || key->type == KEY_UNSPEC)\n\t\tbadusage(\"Invalid key file (-k flag)\");\n\n\t/* Replace (fuzz) mode */\n\tif (replace_flag) {\n\t\tif (packet_index == -1 || direction == -1 || data_path == NULL)\n\t\t\tbadusage(\"Replace (-r) mode must specify direction \"\n\t\t\t    \"(-D) packet index (-i) and data path (-f)\");\n\t\tif ((fd = open(data_path, O_RDONLY)) == -1)\n\t\t\terr(1, \"open %s\", data_path);\n\t\treplace_data = sshbuf_new();\n\t\tif ((r = sshkey_load_file(fd, replace_data)) != 0)\n\t\t\terrx(1, \"read %s: %s\", data_path, ssh_err(r));\n\t\tclose(fd);\n\t}\n\n\t/* Dump mode */\n\tif (dump_flag) {\n\t\tif (packet_index == -1 || direction == -1 || data_path == NULL)\n\t\t\tbadusage(\"Dump (-d) mode must specify direction \"\n\t\t\t    \"(-D), packet index (-i) and data path (-f)\");\n\t}\n\n\t/* Count mode needs no further flags */\n\n\tdo_kex_with_key(kex, key, &c2s, &s2c,\n\t    direction, packet_index,\n\t    dump_flag ? data_path : NULL,\n\t    replace_flag ? replace_data : NULL);\n\tsshkey_free(key);\n\tsshbuf_free(replace_data);\n\n\tif (count_flag) {\n\t\tprintf(\"S2C: %d\\n\", s2c);\n\t\tprintf(\"C2S: %d\\n\", c2s);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssherr.h\"",
      "# include <err.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "# include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int do_debug = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"C2S: %d\\n\"",
            "c2s"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "replace_data"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "key"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_kex_with_key",
          "args": [
            "kex",
            "key",
            "&c2s",
            "&s2c",
            "direction",
            "packet_index",
            "dump_flag ? data_path : NULL",
            "replace_flag ? replace_data : NULL"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "do_kex_with_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/misc/kexfuzz/kexfuzz.c",
          "lines": "198-309",
          "snippet": "static void\ndo_kex_with_key(const char *kex, struct sshkey *prvkey, int *c2s, int *s2c,\n    int direction, int packet_index,\n    const char *dump_path, struct sshbuf *replace_data)\n{\n\tstruct ssh *client = NULL, *server = NULL, *server2 = NULL;\n\tstruct sshkey *pubkey = NULL;\n\tstruct sshbuf *state;\n\tstruct kex_params kex_params;\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tchar *keyname = NULL;\n\tstruct hook_ctx hook_ctx;\n\n\tTEST_START(\"sshkey_from_private\");\n\tASSERT_INT_EQ(sshkey_from_private(prvkey, &pubkey), 0);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_init\");\n\tmemcpy(kex_params.proposal, myproposal, sizeof(myproposal));\n\tif (kex != NULL)\n\t\tkex_params.proposal[PROPOSAL_KEX_ALGS] = strdup(kex);\n\tkeyname = strdup(sshkey_ssh_name(prvkey));\n\tASSERT_PTR_NE(keyname, NULL);\n\tkex_params.proposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = keyname;\n\tASSERT_INT_EQ(ssh_init(&client, 0, &kex_params), 0);\n\tASSERT_INT_EQ(ssh_init(&server, 1, &kex_params), 0);\n\tASSERT_INT_EQ(ssh_init(&server2, 1, NULL), 0);\n\tASSERT_PTR_NE(client, NULL);\n\tASSERT_PTR_NE(server, NULL);\n\tASSERT_PTR_NE(server2, NULL);\n\tTEST_DONE();\n\n\thook_ctx.c2s = c2s;\n\thook_ctx.s2c = s2c;\n\thook_ctx.trigger_direction = direction;\n\thook_ctx.packet_index = packet_index;\n\thook_ctx.dump_path = dump_path;\n\thook_ctx.replace_data = replace_data;\n\thook_ctx.client = client;\n\thook_ctx.server = server;\n\thook_ctx.server2 = server2;\n\tssh_packet_set_input_hook(client, packet_hook, &hook_ctx);\n\tssh_packet_set_input_hook(server, packet_hook, &hook_ctx);\n\tssh_packet_set_input_hook(server2, packet_hook, &hook_ctx);\n\n\tTEST_START(\"ssh_add_hostkey\");\n\tASSERT_INT_EQ(ssh_add_hostkey(server, prvkey), 0);\n\tASSERT_INT_EQ(ssh_add_hostkey(client, pubkey), 0);\n\tTEST_DONE();\n\n\tTEST_START(\"kex\");\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying client\");\n\tASSERT_INT_EQ(kex_send_kexinit(client), 0);\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying server\");\n\tASSERT_INT_EQ(kex_send_kexinit(server), 0);\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_packet_get_state\");\n\tstate = sshbuf_new();\n\tASSERT_PTR_NE(state, NULL);\n\tASSERT_INT_EQ(ssh_packet_get_state(server, state), 0);\n\tASSERT_INT_GE(sshbuf_len(state), 1);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_packet_set_state\");\n\tASSERT_INT_EQ(ssh_add_hostkey(server2, prvkey), 0);\n\tkex_free(server2->kex);\t/* XXX or should ssh_packet_set_state()? */\n\tASSERT_INT_EQ(ssh_packet_set_state(server2, state), 0);\n\tASSERT_INT_EQ(sshbuf_len(state), 0);\n\tsshbuf_free(state);\n\tASSERT_PTR_NE(server2->kex, NULL);\n\t/* XXX we need to set the callbacks */\n#ifdef WITH_OPENSSL\n\tserver2->kex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GRP14_SHA256] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GRP16_SHA512] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GRP18_SHA512] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\tserver2->kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n# ifdef OPENSSL_HAS_ECC\n\tserver2->kex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n# endif\n#endif\n\tserver2->kex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\tserver2->kex->load_host_public_key = server->kex->load_host_public_key;\n\tserver2->kex->load_host_private_key = server->kex->load_host_private_key;\n\tserver2->kex->sign = server->kex->sign;\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying server2\");\n\tASSERT_INT_EQ(kex_send_kexinit(server2), 0);\n\trun_kex(client, server2);\n\tASSERT_INT_EQ(kex_send_kexinit(client), 0);\n\trun_kex(client, server2);\n\tTEST_DONE();\n\n\tTEST_START(\"cleanup\");\n\tsshkey_free(pubkey);\n\tssh_free(client);\n\tssh_free(server);\n\tssh_free(server2);\n\tfree(keyname);\n\tTEST_DONE();\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssherr.h\"",
            "# include <err.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n# include <err.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndo_kex_with_key(const char *kex, struct sshkey *prvkey, int *c2s, int *s2c,\n    int direction, int packet_index,\n    const char *dump_path, struct sshbuf *replace_data)\n{\n\tstruct ssh *client = NULL, *server = NULL, *server2 = NULL;\n\tstruct sshkey *pubkey = NULL;\n\tstruct sshbuf *state;\n\tstruct kex_params kex_params;\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tchar *keyname = NULL;\n\tstruct hook_ctx hook_ctx;\n\n\tTEST_START(\"sshkey_from_private\");\n\tASSERT_INT_EQ(sshkey_from_private(prvkey, &pubkey), 0);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_init\");\n\tmemcpy(kex_params.proposal, myproposal, sizeof(myproposal));\n\tif (kex != NULL)\n\t\tkex_params.proposal[PROPOSAL_KEX_ALGS] = strdup(kex);\n\tkeyname = strdup(sshkey_ssh_name(prvkey));\n\tASSERT_PTR_NE(keyname, NULL);\n\tkex_params.proposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = keyname;\n\tASSERT_INT_EQ(ssh_init(&client, 0, &kex_params), 0);\n\tASSERT_INT_EQ(ssh_init(&server, 1, &kex_params), 0);\n\tASSERT_INT_EQ(ssh_init(&server2, 1, NULL), 0);\n\tASSERT_PTR_NE(client, NULL);\n\tASSERT_PTR_NE(server, NULL);\n\tASSERT_PTR_NE(server2, NULL);\n\tTEST_DONE();\n\n\thook_ctx.c2s = c2s;\n\thook_ctx.s2c = s2c;\n\thook_ctx.trigger_direction = direction;\n\thook_ctx.packet_index = packet_index;\n\thook_ctx.dump_path = dump_path;\n\thook_ctx.replace_data = replace_data;\n\thook_ctx.client = client;\n\thook_ctx.server = server;\n\thook_ctx.server2 = server2;\n\tssh_packet_set_input_hook(client, packet_hook, &hook_ctx);\n\tssh_packet_set_input_hook(server, packet_hook, &hook_ctx);\n\tssh_packet_set_input_hook(server2, packet_hook, &hook_ctx);\n\n\tTEST_START(\"ssh_add_hostkey\");\n\tASSERT_INT_EQ(ssh_add_hostkey(server, prvkey), 0);\n\tASSERT_INT_EQ(ssh_add_hostkey(client, pubkey), 0);\n\tTEST_DONE();\n\n\tTEST_START(\"kex\");\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying client\");\n\tASSERT_INT_EQ(kex_send_kexinit(client), 0);\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying server\");\n\tASSERT_INT_EQ(kex_send_kexinit(server), 0);\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_packet_get_state\");\n\tstate = sshbuf_new();\n\tASSERT_PTR_NE(state, NULL);\n\tASSERT_INT_EQ(ssh_packet_get_state(server, state), 0);\n\tASSERT_INT_GE(sshbuf_len(state), 1);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_packet_set_state\");\n\tASSERT_INT_EQ(ssh_add_hostkey(server2, prvkey), 0);\n\tkex_free(server2->kex);\t/* XXX or should ssh_packet_set_state()? */\n\tASSERT_INT_EQ(ssh_packet_set_state(server2, state), 0);\n\tASSERT_INT_EQ(sshbuf_len(state), 0);\n\tsshbuf_free(state);\n\tASSERT_PTR_NE(server2->kex, NULL);\n\t/* XXX we need to set the callbacks */\n#ifdef WITH_OPENSSL\n\tserver2->kex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GRP14_SHA256] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GRP16_SHA512] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GRP18_SHA512] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\tserver2->kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n# ifdef OPENSSL_HAS_ECC\n\tserver2->kex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n# endif\n#endif\n\tserver2->kex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\tserver2->kex->load_host_public_key = server->kex->load_host_public_key;\n\tserver2->kex->load_host_private_key = server->kex->load_host_private_key;\n\tserver2->kex->sign = server->kex->sign;\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying server2\");\n\tASSERT_INT_EQ(kex_send_kexinit(server2), 0);\n\trun_kex(client, server2);\n\tASSERT_INT_EQ(kex_send_kexinit(client), 0);\n\trun_kex(client, server2);\n\tTEST_DONE();\n\n\tTEST_START(\"cleanup\");\n\tsshkey_free(pubkey);\n\tssh_free(client);\n\tssh_free(server);\n\tssh_free(server2);\n\tfree(keyname);\n\tTEST_DONE();\n}"
        }
      },
      {
        "call_info": {
          "callee": "badusage",
          "args": [
            "\"Dump (-d) mode must specify direction \"\n\t\t\t    \"(-D), packet index (-i) and data path (-f)\""
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "badusage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/misc/kexfuzz/kexfuzz.c",
          "lines": "333-340",
          "snippet": "static void\nbadusage(const char *bad)\n{\n\tfprintf(stderr, \"Invalid options\\n\");\n\tfprintf(stderr, \"%s\\n\", bad);\n\tusage();\n\texit(1);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssherr.h\"",
            "# include <err.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n# include <err.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nbadusage(const char *bad)\n{\n\tfprintf(stderr, \"Invalid options\\n\");\n\tfprintf(stderr, \"%s\\n\", bad);\n\tusage();\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"read %s: %s\"",
            "data_path",
            "ssh_err(r)"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "errx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-err.c",
          "lines": "52-62",
          "snippet": "void\nerrx(int r, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(r);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\nvoid\nerrx(int r, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_load_file",
          "args": [
            "fd",
            "replace_data"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_load_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "96-135",
          "snippet": "int\nsshkey_load_file(int fd, struct sshbuf *blob)\n{\n\tu_char buf[1024];\n\tsize_t len;\n\tstruct stat st;\n\tint r;\n\n\tif (fstat(fd, &st) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size > MAX_KEY_FILE_SIZE)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tfor (;;) {\n\t\tif ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tbreak;\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put(blob, buf, len)) != 0)\n\t\t\tgoto out;\n\t\tif (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size != (off_t)sshbuf_len(blob)) {\n\t\tr = SSH_ERR_FILE_CHANGED;\n\t\tgoto out;\n\t}\n\tr = 0;\n\n out:\n\texplicit_bzero(buf, sizeof(buf));\n\tif (r != 0)\n\t\tsshbuf_reset(blob);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MAX_KEY_FILE_SIZE\t(1024 * 1024)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MAX_KEY_FILE_SIZE\t(1024 * 1024)\n\nint\nsshkey_load_file(int fd, struct sshbuf *blob)\n{\n\tu_char buf[1024];\n\tsize_t len;\n\tstruct stat st;\n\tint r;\n\n\tif (fstat(fd, &st) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size > MAX_KEY_FILE_SIZE)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tfor (;;) {\n\t\tif ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tbreak;\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put(blob, buf, len)) != 0)\n\t\t\tgoto out;\n\t\tif (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size != (off_t)sshbuf_len(blob)) {\n\t\tr = SSH_ERR_FILE_CHANGED;\n\t\tgoto out;\n\t}\n\tr = 0;\n\n out:\n\texplicit_bzero(buf, sizeof(buf));\n\tif (r != 0)\n\t\tsshbuf_reset(blob);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"open %s\"",
            "data_path"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "run_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1323-1346",
          "snippet": "void\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void run_err(const char *,...);",
            "int errs, remin, remout;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid run_err(const char *,...);\nint errs, remin, remout;\n\nvoid\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "data_path",
            "O_RDONLY"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "process_permitopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "901-909",
          "snippet": "void\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_load_private_type_fd",
          "args": [
            "fd",
            "KEY_UNSPEC",
            "NULL",
            "&key",
            "NULL"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_load_private_type_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "201-224",
          "snippet": "int\nsshkey_load_private_type_fd(int fd, int type, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tstruct sshbuf *buffer = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif ((buffer = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_load_file(fd, buffer)) != 0 ||\n\t    (r = sshkey_parse_private_fileblob_type(buffer, type,\n\t    passphrase, keyp, commentp)) != 0)\n\t\tgoto out;\n\n\t/* success */\n\tr = 0;\n out:\n\tsshbuf_free(buffer);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_load_private_type_fd(int fd, int type, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tstruct sshbuf *buffer = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif ((buffer = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_load_file(fd, buffer)) != 0 ||\n\t    (r = sshkey_parse_private_fileblob_type(buffer, type,\n\t    passphrase, keyp, commentp)) != 0)\n\t\tgoto out;\n\n\t/* success */\n\tr = 0;\n out:\n\tsshbuf_free(buffer);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "kex",
            "','"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kex_names_valid",
          "args": [
            "kex"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "kex_names_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/kex.c",
          "lines": "144-164",
          "snippet": "int\nkex_names_valid(const char *names)\n{\n\tchar *s, *cp, *p;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((s = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, \",\")); p && *p != '\\0';\n\t    (p = strsep(&cp, \",\"))) {\n\t\tif (kex_alg_by_name(p) == NULL) {\n\t\t\terror(\"Unsupported KEX algorithm \\\"%.100s\\\"\", p);\n\t\t\tfree(s);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tdebug3(\"kex names ok: [%s]\", names);\n\tfree(s);\n\treturn 1;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor.h\"",
            "#include \"dispatch.h\"",
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"log.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include <openssl/dh.h>",
            "#include <openssl/crypto.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"monitor.h\"\n#include \"dispatch.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include <openssl/dh.h>\n#include <openssl/crypto.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include \"includes.h\"\n\nint\nkex_names_valid(const char *names)\n{\n\tchar *s, *cp, *p;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((s = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, \",\")); p && *p != '\\0';\n\t    (p = strsep(&cp, \",\"))) {\n\t\tif (kex_alg_by_name(p) == NULL) {\n\t\t\terror(\"Unsupported KEX algorithm \\\"%.100s\\\"\", p);\n\t\t\tfree(s);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tdebug3(\"kex names ok: [%s]\", names);\n\tfree(s);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_init",
          "args": [
            "argv[0]",
            "do_debug ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO",
            "SYSLOG_FACILITY_USER",
            "1"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "log_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "256-336",
          "snippet": "void\nlog_init(char *av0, LogLevel level, SyslogFacility facility, int on_stderr)\n{\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\tstruct syslog_data sdata = SYSLOG_DATA_INIT;\n#endif\n\n\targv0 = av0;\n\n\tif (log_change_level(level) != 0) {\n\t\tfprintf(stderr, \"Unrecognized internal syslog level code %d\\n\",\n\t\t    (int) level);\n\t\texit(1);\n\t}\n\n\tlog_handler = NULL;\n\tlog_handler_ctx = NULL;\n\n\tlog_on_stderr = on_stderr;\n\tif (on_stderr)\n\t\treturn;\n\n\tswitch (facility) {\n\tcase SYSLOG_FACILITY_DAEMON:\n\t\tlog_facility = LOG_DAEMON;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_USER:\n\t\tlog_facility = LOG_USER;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_AUTH:\n\t\tlog_facility = LOG_AUTH;\n\t\tbreak;\n#ifdef LOG_AUTHPRIV\n\tcase SYSLOG_FACILITY_AUTHPRIV:\n\t\tlog_facility = LOG_AUTHPRIV;\n\t\tbreak;\n#endif\n\tcase SYSLOG_FACILITY_LOCAL0:\n\t\tlog_facility = LOG_LOCAL0;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL1:\n\t\tlog_facility = LOG_LOCAL1;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL2:\n\t\tlog_facility = LOG_LOCAL2;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL3:\n\t\tlog_facility = LOG_LOCAL3;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL4:\n\t\tlog_facility = LOG_LOCAL4;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL5:\n\t\tlog_facility = LOG_LOCAL5;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL6:\n\t\tlog_facility = LOG_LOCAL6;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL7:\n\t\tlog_facility = LOG_LOCAL7;\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr,\n\t\t    \"Unrecognized internal syslog facility code %d\\n\",\n\t\t    (int) facility);\n\t\texit(1);\n\t}\n\n\t/*\n\t * If an external library (eg libwrap) attempts to use syslog\n\t * immediately after reexec, syslog may be pointing to the wrong\n\t * facility, so we force an open/close of syslog here.\n\t */\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\topenlog_r(argv0 ? argv0 : __progname, LOG_PID, log_facility, &sdata);\n\tcloselog_r(&sdata);\n#else\n\topenlog(argv0 ? argv0 : __progname, LOG_PID, log_facility);\n\tcloselog();\n#endif\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int log_on_stderr = 1;",
            "static int log_facility = LOG_AUTH;",
            "static char *argv0;",
            "static log_handler_fn *log_handler;",
            "static void *log_handler_ctx;",
            "extern char *__progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int log_on_stderr = 1;\nstatic int log_facility = LOG_AUTH;\nstatic char *argv0;\nstatic log_handler_fn *log_handler;\nstatic void *log_handler_ctx;\nextern char *__progname;\n\nvoid\nlog_init(char *av0, LogLevel level, SyslogFacility facility, int on_stderr)\n{\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\tstruct syslog_data sdata = SYSLOG_DATA_INIT;\n#endif\n\n\targv0 = av0;\n\n\tif (log_change_level(level) != 0) {\n\t\tfprintf(stderr, \"Unrecognized internal syslog level code %d\\n\",\n\t\t    (int) level);\n\t\texit(1);\n\t}\n\n\tlog_handler = NULL;\n\tlog_handler_ctx = NULL;\n\n\tlog_on_stderr = on_stderr;\n\tif (on_stderr)\n\t\treturn;\n\n\tswitch (facility) {\n\tcase SYSLOG_FACILITY_DAEMON:\n\t\tlog_facility = LOG_DAEMON;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_USER:\n\t\tlog_facility = LOG_USER;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_AUTH:\n\t\tlog_facility = LOG_AUTH;\n\t\tbreak;\n#ifdef LOG_AUTHPRIV\n\tcase SYSLOG_FACILITY_AUTHPRIV:\n\t\tlog_facility = LOG_AUTHPRIV;\n\t\tbreak;\n#endif\n\tcase SYSLOG_FACILITY_LOCAL0:\n\t\tlog_facility = LOG_LOCAL0;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL1:\n\t\tlog_facility = LOG_LOCAL1;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL2:\n\t\tlog_facility = LOG_LOCAL2;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL3:\n\t\tlog_facility = LOG_LOCAL3;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL4:\n\t\tlog_facility = LOG_LOCAL4;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL5:\n\t\tlog_facility = LOG_LOCAL5;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL6:\n\t\tlog_facility = LOG_LOCAL6;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL7:\n\t\tlog_facility = LOG_LOCAL7;\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr,\n\t\t    \"Unrecognized internal syslog facility code %d\\n\",\n\t\t    (int) facility);\n\t\texit(1);\n\t}\n\n\t/*\n\t * If an external library (eg libwrap) attempts to use syslog\n\t * immediately after reexec, syslog may be pointing to the wrong\n\t * facility, so we force an open/close of syslog here.\n\t */\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\topenlog_r(argv0 ? argv0 : __progname, LOG_PID, log_facility, &sdata);\n\tcloselog_r(&sdata);\n#else\n\topenlog(argv0 ? argv0 : __progname, LOG_PID, log_facility);\n\tcloselog();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "optarg"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "optarg",
            "\"c2s\""
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "optarg",
            "\"s2c\""
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/misc/kexfuzz/kexfuzz.c",
          "lines": "311-331",
          "snippet": "static void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"Usage: kexfuzz [-hcdrv] [-D direction] [-f data_file]\\n\"\n\t    \"               [-K kex_alg] [-k private_key] [-i packet_index]\\n\"\n\t    \"\\n\"\n\t    \"Options:\\n\"\n\t    \"    -h               Display this help\\n\"\n\t    \"    -c               Count packets sent during KEX\\n\"\n\t    \"    -d               Dump mode: record KEX packet to data file\\n\"\n\t    \"    -r               Replace mode: replace packet with data file\\n\"\n\t    \"    -v               Turn on verbose logging\\n\"\n\t    \"    -D S2C|C2S       Packet direction for replacement or dump\\n\"\n\t    \"    -f data_file     Path to data file for replacement or dump\\n\"\n\t    \"    -K kex_alg       Name of KEX algorithm to test (see below)\\n\"\n\t    \"    -k private_key   Path to private key file\\n\"\n\t    \"    -i packet_index  Index of packet to replace or dump (from 0)\\n\"\n\t    \"\\n\"\n\t    \"Available KEX algorithms: %s\\n\", kex_alg_list(' '));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssherr.h\"",
            "# include <err.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n# include <err.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"Usage: kexfuzz [-hcdrv] [-D direction] [-f data_file]\\n\"\n\t    \"               [-K kex_alg] [-k private_key] [-i packet_index]\\n\"\n\t    \"\\n\"\n\t    \"Options:\\n\"\n\t    \"    -h               Display this help\\n\"\n\t    \"    -c               Count packets sent during KEX\\n\"\n\t    \"    -d               Dump mode: record KEX packet to data file\\n\"\n\t    \"    -r               Replace mode: replace packet with data file\\n\"\n\t    \"    -v               Turn on verbose logging\\n\"\n\t    \"    -D S2C|C2S       Packet direction for replacement or dump\\n\"\n\t    \"    -f data_file     Path to data file for replacement or dump\\n\"\n\t    \"    -K kex_alg       Name of KEX algorithm to test (see below)\\n\"\n\t    \"    -k private_key   Path to private key file\\n\"\n\t    \"    -i packet_index  Index of packet to replace or dump (from 0)\\n\"\n\t    \"\\n\"\n\t    \"Available KEX algorithms: %s\\n\", kex_alg_list(' '));\n}"
        }
      },
      {
        "call_info": {
          "callee": "getopt",
          "args": [
            "argc",
            "argv",
            "\"hcdrvD:f:K:k:i:\""
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "getopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
          "lines": "489-502",
          "snippet": "int\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <getopt.h>",
            "#include <err.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\n#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */\n\nint\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "setvbuf",
          "args": [
            "stdout",
            "NULL",
            "_IONBF",
            "0"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n# include <err.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int do_debug = 0;\n\nint\nmain(int argc, char **argv)\n{\n\tint ch, fd, r;\n\tint count_flag = 0, dump_flag = 0, replace_flag = 0;\n\tint packet_index = -1, direction = -1;\n\tint s2c = 0, c2s = 0; /* packet counts */\n\tconst char *kex = NULL, *kpath = NULL, *data_path = NULL;\n\tstruct sshkey *key = NULL;\n\tstruct sshbuf *replace_data = NULL;\n\n\tsetvbuf(stdout, NULL, _IONBF, 0);\n\twhile ((ch = getopt(argc, argv, \"hcdrvD:f:K:k:i:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'h':\n\t\t\tusage();\n\t\t\treturn 0;\n\t\tcase 'c':\n\t\t\tcount_flag = 1;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdump_flag = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\treplace_flag = 1;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tdo_debug = 1;\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tif (strcasecmp(optarg, \"s2c\") == 0)\n\t\t\t\tdirection = S2C;\n\t\t\telse if (strcasecmp(optarg, \"c2s\") == 0)\n\t\t\t\tdirection = C2S;\n\t\t\telse\n\t\t\t\tbadusage(\"Invalid direction (-D)\");\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tdata_path = optarg;\n\t\t\tbreak;\n\t\tcase 'K':\n\t\t\tkex = optarg;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tkpath = optarg;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tpacket_index = atoi(optarg);\n\t\t\tif (packet_index < 0)\n\t\t\t\tbadusage(\"Invalid packet index\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbadusage(\"unsupported flag\");\n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\n\tlog_init(argv[0], do_debug ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO,\n\t    SYSLOG_FACILITY_USER, 1);\n\n\t/* Must select a single mode */\n\tif ((count_flag + dump_flag + replace_flag) != 1)\n\t\tbadusage(\"Must select one mode: -c, -d or -r\");\n\t/* KEX type is mandatory */\n\tif (kex == NULL || !kex_names_valid(kex) || strchr(kex, ',') != NULL)\n\t\tbadusage(\"Missing or invalid kex type (-K flag)\");\n\t/* Valid key is mandatory */\n\tif (kpath == NULL)\n\t\tbadusage(\"Missing private key (-k flag)\");\n\tif ((fd = open(kpath, O_RDONLY)) == -1)\n\t\terr(1, \"open %s\", kpath);\n\tif ((r = sshkey_load_private_type_fd(fd, KEY_UNSPEC, NULL,\n\t    &key, NULL)) != 0)\n\t\terrx(1, \"Unable to load key %s: %s\", kpath, ssh_err(r));\n\tclose(fd);\n\t/* XXX check that it is a private key */\n\t/* XXX support certificates */\n\tif (key == NULL || key->type == KEY_UNSPEC)\n\t\tbadusage(\"Invalid key file (-k flag)\");\n\n\t/* Replace (fuzz) mode */\n\tif (replace_flag) {\n\t\tif (packet_index == -1 || direction == -1 || data_path == NULL)\n\t\t\tbadusage(\"Replace (-r) mode must specify direction \"\n\t\t\t    \"(-D) packet index (-i) and data path (-f)\");\n\t\tif ((fd = open(data_path, O_RDONLY)) == -1)\n\t\t\terr(1, \"open %s\", data_path);\n\t\treplace_data = sshbuf_new();\n\t\tif ((r = sshkey_load_file(fd, replace_data)) != 0)\n\t\t\terrx(1, \"read %s: %s\", data_path, ssh_err(r));\n\t\tclose(fd);\n\t}\n\n\t/* Dump mode */\n\tif (dump_flag) {\n\t\tif (packet_index == -1 || direction == -1 || data_path == NULL)\n\t\t\tbadusage(\"Dump (-d) mode must specify direction \"\n\t\t\t    \"(-D), packet index (-i) and data path (-f)\");\n\t}\n\n\t/* Count mode needs no further flags */\n\n\tdo_kex_with_key(kex, key, &c2s, &s2c,\n\t    direction, packet_index,\n\t    dump_flag ? data_path : NULL,\n\t    replace_flag ? replace_data : NULL);\n\tsshkey_free(key);\n\tsshbuf_free(replace_data);\n\n\tif (count_flag) {\n\t\tprintf(\"S2C: %d\\n\", s2c);\n\t\tprintf(\"C2S: %d\\n\", c2s);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "badusage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/misc/kexfuzz/kexfuzz.c",
    "lines": "333-340",
    "snippet": "static void\nbadusage(const char *bad)\n{\n\tfprintf(stderr, \"Invalid options\\n\");\n\tfprintf(stderr, \"%s\\n\", bad);\n\tusage();\n\texit(1);\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssherr.h\"",
      "# include <err.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "# include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/misc/kexfuzz/kexfuzz.c",
          "lines": "311-331",
          "snippet": "static void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"Usage: kexfuzz [-hcdrv] [-D direction] [-f data_file]\\n\"\n\t    \"               [-K kex_alg] [-k private_key] [-i packet_index]\\n\"\n\t    \"\\n\"\n\t    \"Options:\\n\"\n\t    \"    -h               Display this help\\n\"\n\t    \"    -c               Count packets sent during KEX\\n\"\n\t    \"    -d               Dump mode: record KEX packet to data file\\n\"\n\t    \"    -r               Replace mode: replace packet with data file\\n\"\n\t    \"    -v               Turn on verbose logging\\n\"\n\t    \"    -D S2C|C2S       Packet direction for replacement or dump\\n\"\n\t    \"    -f data_file     Path to data file for replacement or dump\\n\"\n\t    \"    -K kex_alg       Name of KEX algorithm to test (see below)\\n\"\n\t    \"    -k private_key   Path to private key file\\n\"\n\t    \"    -i packet_index  Index of packet to replace or dump (from 0)\\n\"\n\t    \"\\n\"\n\t    \"Available KEX algorithms: %s\\n\", kex_alg_list(' '));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssherr.h\"",
            "# include <err.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n# include <err.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"Usage: kexfuzz [-hcdrv] [-D direction] [-f data_file]\\n\"\n\t    \"               [-K kex_alg] [-k private_key] [-i packet_index]\\n\"\n\t    \"\\n\"\n\t    \"Options:\\n\"\n\t    \"    -h               Display this help\\n\"\n\t    \"    -c               Count packets sent during KEX\\n\"\n\t    \"    -d               Dump mode: record KEX packet to data file\\n\"\n\t    \"    -r               Replace mode: replace packet with data file\\n\"\n\t    \"    -v               Turn on verbose logging\\n\"\n\t    \"    -D S2C|C2S       Packet direction for replacement or dump\\n\"\n\t    \"    -f data_file     Path to data file for replacement or dump\\n\"\n\t    \"    -K kex_alg       Name of KEX algorithm to test (see below)\\n\"\n\t    \"    -k private_key   Path to private key file\\n\"\n\t    \"    -i packet_index  Index of packet to replace or dump (from 0)\\n\"\n\t    \"\\n\"\n\t    \"Available KEX algorithms: %s\\n\", kex_alg_list(' '));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\\n\"",
            "bad"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Invalid options\\n\""
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n# include <err.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nbadusage(const char *bad)\n{\n\tfprintf(stderr, \"Invalid options\\n\");\n\tfprintf(stderr, \"%s\\n\", bad);\n\tusage();\n\texit(1);\n}"
  },
  {
    "function_name": "usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/misc/kexfuzz/kexfuzz.c",
    "lines": "311-331",
    "snippet": "static void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"Usage: kexfuzz [-hcdrv] [-D direction] [-f data_file]\\n\"\n\t    \"               [-K kex_alg] [-k private_key] [-i packet_index]\\n\"\n\t    \"\\n\"\n\t    \"Options:\\n\"\n\t    \"    -h               Display this help\\n\"\n\t    \"    -c               Count packets sent during KEX\\n\"\n\t    \"    -d               Dump mode: record KEX packet to data file\\n\"\n\t    \"    -r               Replace mode: replace packet with data file\\n\"\n\t    \"    -v               Turn on verbose logging\\n\"\n\t    \"    -D S2C|C2S       Packet direction for replacement or dump\\n\"\n\t    \"    -f data_file     Path to data file for replacement or dump\\n\"\n\t    \"    -K kex_alg       Name of KEX algorithm to test (see below)\\n\"\n\t    \"    -k private_key   Path to private key file\\n\"\n\t    \"    -i packet_index  Index of packet to replace or dump (from 0)\\n\"\n\t    \"\\n\"\n\t    \"Available KEX algorithms: %s\\n\", kex_alg_list(' '));\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssherr.h\"",
      "# include <err.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "# include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Usage: kexfuzz [-hcdrv] [-D direction] [-f data_file]\\n\"\n\t    \"               [-K kex_alg] [-k private_key] [-i packet_index]\\n\"\n\t    \"\\n\"\n\t    \"Options:\\n\"\n\t    \"    -h               Display this help\\n\"\n\t    \"    -c               Count packets sent during KEX\\n\"\n\t    \"    -d               Dump mode: record KEX packet to data file\\n\"\n\t    \"    -r               Replace mode: replace packet with data file\\n\"\n\t    \"    -v               Turn on verbose logging\\n\"\n\t    \"    -D S2C|C2S       Packet direction for replacement or dump\\n\"\n\t    \"    -f data_file     Path to data file for replacement or dump\\n\"\n\t    \"    -K kex_alg       Name of KEX algorithm to test (see below)\\n\"\n\t    \"    -k private_key   Path to private key file\\n\"\n\t    \"    -i packet_index  Index of packet to replace or dump (from 0)\\n\"\n\t    \"\\n\"\n\t    \"Available KEX algorithms: %s\\n\"",
            "kex_alg_list(' ')"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kex_alg_list",
          "args": [
            "' '"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "kex_alg_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/kex.c",
          "lines": "109-129",
          "snippet": "char *\nkex_alg_list(char sep)\n{\n\tchar *ret = NULL, *tmp;\n\tsize_t nlen, rlen = 0;\n\tconst struct kexalg *k;\n\n\tfor (k = kexalgs; k->name != NULL; k++) {\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(k->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, k->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor.h\"",
            "#include \"dispatch.h\"",
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"log.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include <openssl/dh.h>",
            "#include <openssl/crypto.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct kexalg kexalgs[] = {\n#ifdef WITH_OPENSSL\n\t{ KEX_DH1, KEX_DH_GRP1_SHA1, 0, SSH_DIGEST_SHA1 },\n\t{ KEX_DH14_SHA1, KEX_DH_GRP14_SHA1, 0, SSH_DIGEST_SHA1 },\n\t{ KEX_DH14_SHA256, KEX_DH_GRP14_SHA256, 0, SSH_DIGEST_SHA256 },\n\t{ KEX_DH16_SHA512, KEX_DH_GRP16_SHA512, 0, SSH_DIGEST_SHA512 },\n\t{ KEX_DH18_SHA512, KEX_DH_GRP18_SHA512, 0, SSH_DIGEST_SHA512 },\n\t{ KEX_DHGEX_SHA1, KEX_DH_GEX_SHA1, 0, SSH_DIGEST_SHA1 },\n#ifdef HAVE_EVP_SHA256\n\t{ KEX_DHGEX_SHA256, KEX_DH_GEX_SHA256, 0, SSH_DIGEST_SHA256 },\n#endif /* HAVE_EVP_SHA256 */\n#ifdef OPENSSL_HAS_ECC\n\t{ KEX_ECDH_SHA2_NISTP256, KEX_ECDH_SHA2,\n\t    NID_X9_62_prime256v1, SSH_DIGEST_SHA256 },\n\t{ KEX_ECDH_SHA2_NISTP384, KEX_ECDH_SHA2, NID_secp384r1,\n\t    SSH_DIGEST_SHA384 },\n# ifdef OPENSSL_HAS_NISTP521\n\t{ KEX_ECDH_SHA2_NISTP521, KEX_ECDH_SHA2, NID_secp521r1,\n\t    SSH_DIGEST_SHA512 },\n# endif /* OPENSSL_HAS_NISTP521 */\n#endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n#if defined(HAVE_EVP_SHA256) || !defined(WITH_OPENSSL)\n\t{ KEX_CURVE25519_SHA256, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },\n\t{ KEX_CURVE25519_SHA256_OLD, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },\n#endif /* HAVE_EVP_SHA256 || !WITH_OPENSSL */\n\t{ NULL, -1, -1, -1},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"monitor.h\"\n#include \"dispatch.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include <openssl/dh.h>\n#include <openssl/crypto.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include \"includes.h\"\n\nstatic const struct kexalg kexalgs[] = {\n#ifdef WITH_OPENSSL\n\t{ KEX_DH1, KEX_DH_GRP1_SHA1, 0, SSH_DIGEST_SHA1 },\n\t{ KEX_DH14_SHA1, KEX_DH_GRP14_SHA1, 0, SSH_DIGEST_SHA1 },\n\t{ KEX_DH14_SHA256, KEX_DH_GRP14_SHA256, 0, SSH_DIGEST_SHA256 },\n\t{ KEX_DH16_SHA512, KEX_DH_GRP16_SHA512, 0, SSH_DIGEST_SHA512 },\n\t{ KEX_DH18_SHA512, KEX_DH_GRP18_SHA512, 0, SSH_DIGEST_SHA512 },\n\t{ KEX_DHGEX_SHA1, KEX_DH_GEX_SHA1, 0, SSH_DIGEST_SHA1 },\n#ifdef HAVE_EVP_SHA256\n\t{ KEX_DHGEX_SHA256, KEX_DH_GEX_SHA256, 0, SSH_DIGEST_SHA256 },\n#endif /* HAVE_EVP_SHA256 */\n#ifdef OPENSSL_HAS_ECC\n\t{ KEX_ECDH_SHA2_NISTP256, KEX_ECDH_SHA2,\n\t    NID_X9_62_prime256v1, SSH_DIGEST_SHA256 },\n\t{ KEX_ECDH_SHA2_NISTP384, KEX_ECDH_SHA2, NID_secp384r1,\n\t    SSH_DIGEST_SHA384 },\n# ifdef OPENSSL_HAS_NISTP521\n\t{ KEX_ECDH_SHA2_NISTP521, KEX_ECDH_SHA2, NID_secp521r1,\n\t    SSH_DIGEST_SHA512 },\n# endif /* OPENSSL_HAS_NISTP521 */\n#endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n#if defined(HAVE_EVP_SHA256) || !defined(WITH_OPENSSL)\n\t{ KEX_CURVE25519_SHA256, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },\n\t{ KEX_CURVE25519_SHA256_OLD, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },\n#endif /* HAVE_EVP_SHA256 || !WITH_OPENSSL */\n\t{ NULL, -1, -1, -1},\n};\n\nchar *\nkex_alg_list(char sep)\n{\n\tchar *ret = NULL, *tmp;\n\tsize_t nlen, rlen = 0;\n\tconst struct kexalg *k;\n\n\tfor (k = kexalgs; k->name != NULL; k++) {\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(k->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, k->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n# include <err.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"Usage: kexfuzz [-hcdrv] [-D direction] [-f data_file]\\n\"\n\t    \"               [-K kex_alg] [-k private_key] [-i packet_index]\\n\"\n\t    \"\\n\"\n\t    \"Options:\\n\"\n\t    \"    -h               Display this help\\n\"\n\t    \"    -c               Count packets sent during KEX\\n\"\n\t    \"    -d               Dump mode: record KEX packet to data file\\n\"\n\t    \"    -r               Replace mode: replace packet with data file\\n\"\n\t    \"    -v               Turn on verbose logging\\n\"\n\t    \"    -D S2C|C2S       Packet direction for replacement or dump\\n\"\n\t    \"    -f data_file     Path to data file for replacement or dump\\n\"\n\t    \"    -K kex_alg       Name of KEX algorithm to test (see below)\\n\"\n\t    \"    -k private_key   Path to private key file\\n\"\n\t    \"    -i packet_index  Index of packet to replace or dump (from 0)\\n\"\n\t    \"\\n\"\n\t    \"Available KEX algorithms: %s\\n\", kex_alg_list(' '));\n}"
  },
  {
    "function_name": "do_kex_with_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/misc/kexfuzz/kexfuzz.c",
    "lines": "198-309",
    "snippet": "static void\ndo_kex_with_key(const char *kex, struct sshkey *prvkey, int *c2s, int *s2c,\n    int direction, int packet_index,\n    const char *dump_path, struct sshbuf *replace_data)\n{\n\tstruct ssh *client = NULL, *server = NULL, *server2 = NULL;\n\tstruct sshkey *pubkey = NULL;\n\tstruct sshbuf *state;\n\tstruct kex_params kex_params;\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tchar *keyname = NULL;\n\tstruct hook_ctx hook_ctx;\n\n\tTEST_START(\"sshkey_from_private\");\n\tASSERT_INT_EQ(sshkey_from_private(prvkey, &pubkey), 0);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_init\");\n\tmemcpy(kex_params.proposal, myproposal, sizeof(myproposal));\n\tif (kex != NULL)\n\t\tkex_params.proposal[PROPOSAL_KEX_ALGS] = strdup(kex);\n\tkeyname = strdup(sshkey_ssh_name(prvkey));\n\tASSERT_PTR_NE(keyname, NULL);\n\tkex_params.proposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = keyname;\n\tASSERT_INT_EQ(ssh_init(&client, 0, &kex_params), 0);\n\tASSERT_INT_EQ(ssh_init(&server, 1, &kex_params), 0);\n\tASSERT_INT_EQ(ssh_init(&server2, 1, NULL), 0);\n\tASSERT_PTR_NE(client, NULL);\n\tASSERT_PTR_NE(server, NULL);\n\tASSERT_PTR_NE(server2, NULL);\n\tTEST_DONE();\n\n\thook_ctx.c2s = c2s;\n\thook_ctx.s2c = s2c;\n\thook_ctx.trigger_direction = direction;\n\thook_ctx.packet_index = packet_index;\n\thook_ctx.dump_path = dump_path;\n\thook_ctx.replace_data = replace_data;\n\thook_ctx.client = client;\n\thook_ctx.server = server;\n\thook_ctx.server2 = server2;\n\tssh_packet_set_input_hook(client, packet_hook, &hook_ctx);\n\tssh_packet_set_input_hook(server, packet_hook, &hook_ctx);\n\tssh_packet_set_input_hook(server2, packet_hook, &hook_ctx);\n\n\tTEST_START(\"ssh_add_hostkey\");\n\tASSERT_INT_EQ(ssh_add_hostkey(server, prvkey), 0);\n\tASSERT_INT_EQ(ssh_add_hostkey(client, pubkey), 0);\n\tTEST_DONE();\n\n\tTEST_START(\"kex\");\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying client\");\n\tASSERT_INT_EQ(kex_send_kexinit(client), 0);\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying server\");\n\tASSERT_INT_EQ(kex_send_kexinit(server), 0);\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_packet_get_state\");\n\tstate = sshbuf_new();\n\tASSERT_PTR_NE(state, NULL);\n\tASSERT_INT_EQ(ssh_packet_get_state(server, state), 0);\n\tASSERT_INT_GE(sshbuf_len(state), 1);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_packet_set_state\");\n\tASSERT_INT_EQ(ssh_add_hostkey(server2, prvkey), 0);\n\tkex_free(server2->kex);\t/* XXX or should ssh_packet_set_state()? */\n\tASSERT_INT_EQ(ssh_packet_set_state(server2, state), 0);\n\tASSERT_INT_EQ(sshbuf_len(state), 0);\n\tsshbuf_free(state);\n\tASSERT_PTR_NE(server2->kex, NULL);\n\t/* XXX we need to set the callbacks */\n#ifdef WITH_OPENSSL\n\tserver2->kex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GRP14_SHA256] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GRP16_SHA512] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GRP18_SHA512] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\tserver2->kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n# ifdef OPENSSL_HAS_ECC\n\tserver2->kex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n# endif\n#endif\n\tserver2->kex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\tserver2->kex->load_host_public_key = server->kex->load_host_public_key;\n\tserver2->kex->load_host_private_key = server->kex->load_host_private_key;\n\tserver2->kex->sign = server->kex->sign;\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying server2\");\n\tASSERT_INT_EQ(kex_send_kexinit(server2), 0);\n\trun_kex(client, server2);\n\tASSERT_INT_EQ(kex_send_kexinit(client), 0);\n\trun_kex(client, server2);\n\tTEST_DONE();\n\n\tTEST_START(\"cleanup\");\n\tsshkey_free(pubkey);\n\tssh_free(client);\n\tssh_free(server);\n\tssh_free(server2);\n\tfree(keyname);\n\tTEST_DONE();\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssherr.h\"",
      "# include <err.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "# include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "keyname"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_free",
          "args": [
            "server2"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_free_identitylist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "302-316",
          "snippet": "void\nssh_free_identitylist(struct ssh_identitylist *idl)\n{\n\tsize_t i;\n\n\tif (idl == NULL)\n\t\treturn;\n\tfor (i = 0; i < idl->nkeys; i++) {\n\t\tif (idl->keys != NULL)\n\t\t\tsshkey_free(idl->keys[i]);\n\t\tif (idl->comments != NULL)\n\t\t\tfree(idl->comments[i]);\n\t}\n\tfree(idl);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_free_identitylist(struct ssh_identitylist *idl)\n{\n\tsize_t i;\n\n\tif (idl == NULL)\n\t\treturn;\n\tfor (i = 0; i < idl->nkeys; i++) {\n\t\tif (idl->keys != NULL)\n\t\t\tsshkey_free(idl->keys[i]);\n\t\tif (idl->comments != NULL)\n\t\t\tfree(idl->comments[i]);\n\t}\n\tfree(idl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "pubkey"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"cleanup\""
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_kex",
          "args": [
            "client",
            "server2"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "run_kex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/misc/kexfuzz/kexfuzz.c",
          "lines": "176-196",
          "snippet": "static void\nrun_kex(struct ssh *client, struct ssh *server)\n{\n\tint r = 0;\n\n\twhile (!server->kex->done || !client->kex->done) {\n\t\tif ((r = do_send_and_receive(server, client)) != 0) {\n\t\t\tdebug(\"do_send_and_receive S2C: %s\", ssh_err(r));\n\t\t\tbreak;\n\t\t}\n\t\tif ((r = do_send_and_receive(client, server)) != 0) {\n\t\t\tdebug(\"do_send_and_receive C2S: %s\", ssh_err(r));\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (do_debug)\n\t\tprintf(\"done: %s\\n\", ssh_err(r));\n\tASSERT_INT_EQ(r, 0);\n\tASSERT_INT_EQ(server->kex->done, 1);\n\tASSERT_INT_EQ(client->kex->done, 1);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssherr.h\"",
            "# include <err.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int do_debug = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n# include <err.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int do_debug = 0;\n\nstatic void\nrun_kex(struct ssh *client, struct ssh *server)\n{\n\tint r = 0;\n\n\twhile (!server->kex->done || !client->kex->done) {\n\t\tif ((r = do_send_and_receive(server, client)) != 0) {\n\t\t\tdebug(\"do_send_and_receive S2C: %s\", ssh_err(r));\n\t\t\tbreak;\n\t\t}\n\t\tif ((r = do_send_and_receive(client, server)) != 0) {\n\t\t\tdebug(\"do_send_and_receive C2S: %s\", ssh_err(r));\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (do_debug)\n\t\tprintf(\"done: %s\\n\", ssh_err(r));\n\tASSERT_INT_EQ(r, 0);\n\tASSERT_INT_EQ(server->kex->done, 1);\n\tASSERT_INT_EQ(client->kex->done, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "kex_send_kexinit(client)",
            "0"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kex_send_kexinit",
          "args": [
            "client"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "kex_send_kexinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/kex.c",
          "lines": "498-525",
          "snippet": "int\nkex_send_kexinit(struct ssh *ssh)\n{\n\tu_char *cookie;\n\tstruct kex *kex = ssh->kex;\n\tint r;\n\n\tif (kex == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif (kex->flags & KEX_INIT_SENT)\n\t\treturn 0;\n\tkex->done = 0;\n\n\t/* generate a random cookie */\n\tif (sshbuf_len(kex->my) < KEX_COOKIE_LEN)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif ((cookie = sshbuf_mutable_ptr(kex->my)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tarc4random_buf(cookie, KEX_COOKIE_LEN);\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_KEXINIT)) != 0 ||\n\t    (r = sshpkt_putb(ssh, kex->my)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\treturn r;\n\tdebug(\"SSH2_MSG_KEXINIT sent\");\n\tkex->flags |= KEX_INIT_SENT;\n\treturn 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor.h\"",
            "#include \"dispatch.h\"",
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"log.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include <openssl/dh.h>",
            "#include <openssl/crypto.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int kex_choose_conf(struct ssh *);",
            "static int kex_input_newkeys(int, u_int32_t, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"monitor.h\"\n#include \"dispatch.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include <openssl/dh.h>\n#include <openssl/crypto.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include \"includes.h\"\n\nstatic int kex_choose_conf(struct ssh *);\nstatic int kex_input_newkeys(int, u_int32_t, struct ssh *);\n\nint\nkex_send_kexinit(struct ssh *ssh)\n{\n\tu_char *cookie;\n\tstruct kex *kex = ssh->kex;\n\tint r;\n\n\tif (kex == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif (kex->flags & KEX_INIT_SENT)\n\t\treturn 0;\n\tkex->done = 0;\n\n\t/* generate a random cookie */\n\tif (sshbuf_len(kex->my) < KEX_COOKIE_LEN)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif ((cookie = sshbuf_mutable_ptr(kex->my)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tarc4random_buf(cookie, KEX_COOKIE_LEN);\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_KEXINIT)) != 0 ||\n\t    (r = sshpkt_putb(ssh, kex->my)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\treturn r;\n\tdebug(\"SSH2_MSG_KEXINIT sent\");\n\tkex->flags |= KEX_INIT_SENT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "kex_send_kexinit(server2)",
            "0"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"rekeying server2\""
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "server2->kex",
            "NULL"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "state"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshbuf_len(state)",
            "0"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "state"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "ssh_packet_set_state(server2, state)",
            "0"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_packet_set_state",
          "args": [
            "server2",
            "state"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_set_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2370-2417",
          "snippet": "int\nssh_packet_set_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tconst u_char *input, *output;\n\tsize_t ilen, olen;\n\tint r;\n\n\tif ((r = kex_from_blob(m, &ssh->kex)) != 0 ||\n\t    (r = newkeys_from_blob(m, ssh, MODE_OUT)) != 0 ||\n\t    (r = newkeys_from_blob(m, ssh, MODE_IN)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->rekey_limit)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->rekey_interval)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_send.seqnr)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_send.blocks)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_send.packets)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_send.bytes)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_read.seqnr)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_read.blocks)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_read.packets)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_read.bytes)) != 0)\n\t\treturn r;\n\t/*\n\t * We set the time here so that in post-auth privsep slave we\n\t * count from the completion of the authentication.\n\t */\n\tstate->rekey_time = monotime();\n\t/* XXX ssh_set_newkeys overrides p_read.packets? XXX */\n\tif ((r = ssh_set_newkeys(ssh, MODE_IN)) != 0 ||\n\t    (r = ssh_set_newkeys(ssh, MODE_OUT)) != 0)\n\t\treturn r;\n\n\tif ((r = ssh_packet_set_postauth(ssh)) != 0)\n\t\treturn r;\n\n\tsshbuf_reset(state->input);\n\tsshbuf_reset(state->output);\n\tif ((r = sshbuf_get_string_direct(m, &input, &ilen)) != 0 ||\n\t    (r = sshbuf_get_string_direct(m, &output, &olen)) != 0 ||\n\t    (r = sshbuf_put(state->input, input, ilen)) != 0 ||\n\t    (r = sshbuf_put(state->output, output, olen)) != 0)\n\t\treturn r;\n\n\tif (sshbuf_len(m))\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tdebug3(\"%s: done\", __func__);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_packet_set_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tconst u_char *input, *output;\n\tsize_t ilen, olen;\n\tint r;\n\n\tif ((r = kex_from_blob(m, &ssh->kex)) != 0 ||\n\t    (r = newkeys_from_blob(m, ssh, MODE_OUT)) != 0 ||\n\t    (r = newkeys_from_blob(m, ssh, MODE_IN)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->rekey_limit)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->rekey_interval)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_send.seqnr)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_send.blocks)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_send.packets)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_send.bytes)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_read.seqnr)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_read.blocks)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_read.packets)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_read.bytes)) != 0)\n\t\treturn r;\n\t/*\n\t * We set the time here so that in post-auth privsep slave we\n\t * count from the completion of the authentication.\n\t */\n\tstate->rekey_time = monotime();\n\t/* XXX ssh_set_newkeys overrides p_read.packets? XXX */\n\tif ((r = ssh_set_newkeys(ssh, MODE_IN)) != 0 ||\n\t    (r = ssh_set_newkeys(ssh, MODE_OUT)) != 0)\n\t\treturn r;\n\n\tif ((r = ssh_packet_set_postauth(ssh)) != 0)\n\t\treturn r;\n\n\tsshbuf_reset(state->input);\n\tsshbuf_reset(state->output);\n\tif ((r = sshbuf_get_string_direct(m, &input, &ilen)) != 0 ||\n\t    (r = sshbuf_get_string_direct(m, &output, &olen)) != 0 ||\n\t    (r = sshbuf_put(state->input, input, ilen)) != 0 ||\n\t    (r = sshbuf_put(state->output, output, olen)) != 0)\n\t\treturn r;\n\n\tif (sshbuf_len(m))\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tdebug3(\"%s: done\", __func__);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kex_free",
          "args": [
            "server2->kex"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "kex_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/kex.c",
          "lines": "638-662",
          "snippet": "void\nkex_free(struct kex *kex)\n{\n\tu_int mode;\n\n#ifdef WITH_OPENSSL\n\tDH_free(kex->dh);\n#ifdef OPENSSL_HAS_ECC\n\tEC_KEY_free(kex->ec_client_key);\n#endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tkex_free_newkeys(kex->newkeys[mode]);\n\t\tkex->newkeys[mode] = NULL;\n\t}\n\tsshbuf_free(kex->peer);\n\tsshbuf_free(kex->my);\n\tfree(kex->session_id);\n\tfree(kex->client_version_string);\n\tfree(kex->server_version_string);\n\tfree(kex->failed_choice);\n\tfree(kex->hostkey_alg);\n\tfree(kex->name);\n\tfree(kex);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor.h\"",
            "#include \"dispatch.h\"",
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"log.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include <openssl/dh.h>",
            "#include <openssl/crypto.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"monitor.h\"\n#include \"dispatch.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include <openssl/dh.h>\n#include <openssl/crypto.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include \"includes.h\"\n\nvoid\nkex_free(struct kex *kex)\n{\n\tu_int mode;\n\n#ifdef WITH_OPENSSL\n\tDH_free(kex->dh);\n#ifdef OPENSSL_HAS_ECC\n\tEC_KEY_free(kex->ec_client_key);\n#endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tkex_free_newkeys(kex->newkeys[mode]);\n\t\tkex->newkeys[mode] = NULL;\n\t}\n\tsshbuf_free(kex->peer);\n\tsshbuf_free(kex->my);\n\tfree(kex->session_id);\n\tfree(kex->client_version_string);\n\tfree(kex->server_version_string);\n\tfree(kex->failed_choice);\n\tfree(kex->hostkey_alg);\n\tfree(kex->name);\n\tfree(kex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "ssh_add_hostkey(server2, prvkey)",
            "0"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_add_hostkey",
          "args": [
            "server2",
            "prvkey"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_add_hostkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
          "lines": "177-209",
          "snippet": "int\nssh_add_hostkey(struct ssh *ssh, struct sshkey *key)\n{\n\tstruct sshkey *pubkey = NULL;\n\tstruct key_entry *k = NULL, *k_prv = NULL;\n\tint r;\n\n\tif (ssh->kex->server) {\n\t\tif ((r = sshkey_from_private(key, &pubkey)) != 0)\n\t\t\treturn r;\n\t\tif ((k = malloc(sizeof(*k))) == NULL ||\n\t\t    (k_prv = malloc(sizeof(*k_prv))) == NULL) {\n\t\t\tfree(k);\n\t\t\tsshkey_free(pubkey);\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tk_prv->key = key;\n\t\tTAILQ_INSERT_TAIL(&ssh->private_keys, k_prv, next);\n\n\t\t/* add the public key, too */\n\t\tk->key = pubkey;\n\t\tTAILQ_INSERT_TAIL(&ssh->public_keys, k, next);\n\t\tr = 0;\n\t} else {\n\t\tif ((k = malloc(sizeof(*k))) == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\tk->key = key;\n\t\tTAILQ_INSERT_TAIL(&ssh->public_keys, k, next);\n\t\tr = 0;\n\t}\n\n\treturn r;\n}",
          "includes": [
            "#include <string.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"myproposal.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"ssh_api.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t_ssh_exchange_banner(struct ssh *);",
            "int\t_ssh_send_banner(struct ssh *, char **);",
            "int\t_ssh_read_banner(struct ssh *, char **);",
            "int\t_ssh_order_hostkeyalgs(struct ssh *);",
            "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
            "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
            "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\nssh_add_hostkey(struct ssh *ssh, struct sshkey *key)\n{\n\tstruct sshkey *pubkey = NULL;\n\tstruct key_entry *k = NULL, *k_prv = NULL;\n\tint r;\n\n\tif (ssh->kex->server) {\n\t\tif ((r = sshkey_from_private(key, &pubkey)) != 0)\n\t\t\treturn r;\n\t\tif ((k = malloc(sizeof(*k))) == NULL ||\n\t\t    (k_prv = malloc(sizeof(*k_prv))) == NULL) {\n\t\t\tfree(k);\n\t\t\tsshkey_free(pubkey);\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tk_prv->key = key;\n\t\tTAILQ_INSERT_TAIL(&ssh->private_keys, k_prv, next);\n\n\t\t/* add the public key, too */\n\t\tk->key = pubkey;\n\t\tTAILQ_INSERT_TAIL(&ssh->public_keys, k, next);\n\t\tr = 0;\n\t} else {\n\t\tif ((k = malloc(sizeof(*k))) == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\tk->key = key;\n\t\tTAILQ_INSERT_TAIL(&ssh->public_keys, k, next);\n\t\tr = 0;\n\t}\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"ssh_packet_set_state\""
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_GE",
          "args": [
            "sshbuf_len(state)",
            "1"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "ssh_packet_get_state(server, state)",
            "0"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_packet_get_state",
          "args": [
            "server",
            "state"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_get_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2230-2254",
          "snippet": "int\nssh_packet_get_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tint r;\n\n\tif ((r = kex_to_blob(m, ssh->kex)) != 0 ||\n\t    (r = newkeys_to_blob(m, ssh, MODE_OUT)) != 0 ||\n\t    (r = newkeys_to_blob(m, ssh, MODE_IN)) != 0 ||\n\t    (r = sshbuf_put_u64(m, state->rekey_limit)) != 0 ||\n\t    (r = sshbuf_put_u32(m, state->rekey_interval)) != 0 ||\n\t    (r = sshbuf_put_u32(m, state->p_send.seqnr)) != 0 ||\n\t    (r = sshbuf_put_u64(m, state->p_send.blocks)) != 0 ||\n\t    (r = sshbuf_put_u32(m, state->p_send.packets)) != 0 ||\n\t    (r = sshbuf_put_u64(m, state->p_send.bytes)) != 0 ||\n\t    (r = sshbuf_put_u32(m, state->p_read.seqnr)) != 0 ||\n\t    (r = sshbuf_put_u64(m, state->p_read.blocks)) != 0 ||\n\t    (r = sshbuf_put_u32(m, state->p_read.packets)) != 0 ||\n\t    (r = sshbuf_put_u64(m, state->p_read.bytes)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, state->input)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, state->output)) != 0)\n\t\treturn r;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_packet_get_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tint r;\n\n\tif ((r = kex_to_blob(m, ssh->kex)) != 0 ||\n\t    (r = newkeys_to_blob(m, ssh, MODE_OUT)) != 0 ||\n\t    (r = newkeys_to_blob(m, ssh, MODE_IN)) != 0 ||\n\t    (r = sshbuf_put_u64(m, state->rekey_limit)) != 0 ||\n\t    (r = sshbuf_put_u32(m, state->rekey_interval)) != 0 ||\n\t    (r = sshbuf_put_u32(m, state->p_send.seqnr)) != 0 ||\n\t    (r = sshbuf_put_u64(m, state->p_send.blocks)) != 0 ||\n\t    (r = sshbuf_put_u32(m, state->p_send.packets)) != 0 ||\n\t    (r = sshbuf_put_u64(m, state->p_send.bytes)) != 0 ||\n\t    (r = sshbuf_put_u32(m, state->p_read.seqnr)) != 0 ||\n\t    (r = sshbuf_put_u64(m, state->p_read.blocks)) != 0 ||\n\t    (r = sshbuf_put_u32(m, state->p_read.packets)) != 0 ||\n\t    (r = sshbuf_put_u64(m, state->p_read.bytes)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, state->input)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, state->output)) != 0)\n\t\treturn r;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "state",
            "NULL"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"ssh_packet_get_state\""
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "kex_send_kexinit(server)",
            "0"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"rekeying server\""
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "kex_send_kexinit(client)",
            "0"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"rekeying client\""
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"kex\""
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "ssh_add_hostkey(client, pubkey)",
            "0"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "ssh_add_hostkey(server, prvkey)",
            "0"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"ssh_add_hostkey\""
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_packet_set_input_hook",
          "args": [
            "server2",
            "packet_hook",
            "&hook_ctx"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_set_input_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "264-269",
          "snippet": "void\nssh_packet_set_input_hook(struct ssh *ssh, ssh_packet_hook_fn *hook, void *ctx)\n{\n\tssh->state->hook_in = hook;\n\tssh->state->hook_in_ctx = ctx;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_packet_set_input_hook(struct ssh *ssh, ssh_packet_hook_fn *hook, void *ctx)\n{\n\tssh->state->hook_in = hook;\n\tssh->state->hook_in_ctx = ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "server2",
            "NULL"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "server",
            "NULL"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "client",
            "NULL"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "ssh_init(&server2, 1, NULL)",
            "0"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_init",
          "args": [
            "&server2",
            "1",
            "NULL"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
          "lines": "74-137",
          "snippet": "int\nssh_init(struct ssh **sshp, int is_server, struct kex_params *kex_params)\n{\n        char *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tstruct ssh *ssh;\n\tchar **proposal;\n\tstatic int called;\n\tint r;\n\n\tif (!called) {\n#ifdef WITH_OPENSSL\n\t\tOpenSSL_add_all_algorithms();\n#endif /* WITH_OPENSSL */\n\t\tcalled = 1;\n\t}\n\n\tif ((ssh = ssh_packet_set_connection(NULL, -1, -1)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (is_server)\n\t\tssh_packet_set_server(ssh);\n\n\t/* Initialize key exchange */\n\tproposal = kex_params ? kex_params->proposal : myproposal;\n\tif ((r = kex_new(ssh, proposal, &ssh->kex)) != 0) {\n\t\tssh_free(ssh);\n\t\treturn r;\n\t}\n\tssh->kex->server = is_server;\n\tif (is_server) {\n#ifdef WITH_OPENSSL\n\t\tssh->kex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA256] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GRP16_SHA512] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GRP18_SHA512] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n# ifdef OPENSSL_HAS_ECC\n\t\tssh->kex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n# endif\n#endif /* WITH_OPENSSL */\n\t\tssh->kex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\t\tssh->kex->load_host_public_key=&_ssh_host_public_key;\n\t\tssh->kex->load_host_private_key=&_ssh_host_private_key;\n\t\tssh->kex->sign=&_ssh_host_key_sign;\n\t} else {\n#ifdef WITH_OPENSSL\n\t\tssh->kex->kex[KEX_DH_GRP1_SHA1] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA1] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA256] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GRP16_SHA512] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GRP18_SHA512] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA1] = kexgex_client;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA256] = kexgex_client;\n# ifdef OPENSSL_HAS_ECC\n\t\tssh->kex->kex[KEX_ECDH_SHA2] = kexecdh_client;\n# endif\n#endif /* WITH_OPENSSL */\n\t\tssh->kex->kex[KEX_C25519_SHA256] = kexc25519_client;\n\t\tssh->kex->verify_host_key =&_ssh_verify_host_key;\n\t}\n\t*sshp = ssh;\n\treturn 0;\n}",
          "includes": [
            "#include <string.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"myproposal.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"ssh_api.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t_ssh_exchange_banner(struct ssh *);",
            "int\t_ssh_send_banner(struct ssh *, char **);",
            "int\t_ssh_read_banner(struct ssh *, char **);",
            "int\t_ssh_order_hostkeyalgs(struct ssh *);",
            "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
            "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
            "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\nssh_init(struct ssh **sshp, int is_server, struct kex_params *kex_params)\n{\n        char *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tstruct ssh *ssh;\n\tchar **proposal;\n\tstatic int called;\n\tint r;\n\n\tif (!called) {\n#ifdef WITH_OPENSSL\n\t\tOpenSSL_add_all_algorithms();\n#endif /* WITH_OPENSSL */\n\t\tcalled = 1;\n\t}\n\n\tif ((ssh = ssh_packet_set_connection(NULL, -1, -1)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (is_server)\n\t\tssh_packet_set_server(ssh);\n\n\t/* Initialize key exchange */\n\tproposal = kex_params ? kex_params->proposal : myproposal;\n\tif ((r = kex_new(ssh, proposal, &ssh->kex)) != 0) {\n\t\tssh_free(ssh);\n\t\treturn r;\n\t}\n\tssh->kex->server = is_server;\n\tif (is_server) {\n#ifdef WITH_OPENSSL\n\t\tssh->kex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA256] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GRP16_SHA512] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GRP18_SHA512] = kexdh_server;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n# ifdef OPENSSL_HAS_ECC\n\t\tssh->kex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n# endif\n#endif /* WITH_OPENSSL */\n\t\tssh->kex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\t\tssh->kex->load_host_public_key=&_ssh_host_public_key;\n\t\tssh->kex->load_host_private_key=&_ssh_host_private_key;\n\t\tssh->kex->sign=&_ssh_host_key_sign;\n\t} else {\n#ifdef WITH_OPENSSL\n\t\tssh->kex->kex[KEX_DH_GRP1_SHA1] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA1] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA256] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GRP16_SHA512] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GRP18_SHA512] = kexdh_client;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA1] = kexgex_client;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA256] = kexgex_client;\n# ifdef OPENSSL_HAS_ECC\n\t\tssh->kex->kex[KEX_ECDH_SHA2] = kexecdh_client;\n# endif\n#endif /* WITH_OPENSSL */\n\t\tssh->kex->kex[KEX_C25519_SHA256] = kexc25519_client;\n\t\tssh->kex->verify_host_key =&_ssh_verify_host_key;\n\t}\n\t*sshp = ssh;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "ssh_init(&server, 1, &kex_params)",
            "0"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "ssh_init(&client, 0, &kex_params)",
            "0"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "keyname",
            "NULL"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "sshkey_ssh_name(prvkey)"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ssh_name",
          "args": [
            "prvkey"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "183-188",
          "snippet": "const char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kex_params.proposal",
            "myproposal",
            "sizeof(myproposal)"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"ssh_init\""
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_from_private(prvkey, &pubkey)",
            "0"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_from_private",
          "args": [
            "prvkey",
            "&pubkey"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1726-1868",
          "snippet": "int\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"sshkey_from_private\""
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n# include <err.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ndo_kex_with_key(const char *kex, struct sshkey *prvkey, int *c2s, int *s2c,\n    int direction, int packet_index,\n    const char *dump_path, struct sshbuf *replace_data)\n{\n\tstruct ssh *client = NULL, *server = NULL, *server2 = NULL;\n\tstruct sshkey *pubkey = NULL;\n\tstruct sshbuf *state;\n\tstruct kex_params kex_params;\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tchar *keyname = NULL;\n\tstruct hook_ctx hook_ctx;\n\n\tTEST_START(\"sshkey_from_private\");\n\tASSERT_INT_EQ(sshkey_from_private(prvkey, &pubkey), 0);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_init\");\n\tmemcpy(kex_params.proposal, myproposal, sizeof(myproposal));\n\tif (kex != NULL)\n\t\tkex_params.proposal[PROPOSAL_KEX_ALGS] = strdup(kex);\n\tkeyname = strdup(sshkey_ssh_name(prvkey));\n\tASSERT_PTR_NE(keyname, NULL);\n\tkex_params.proposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = keyname;\n\tASSERT_INT_EQ(ssh_init(&client, 0, &kex_params), 0);\n\tASSERT_INT_EQ(ssh_init(&server, 1, &kex_params), 0);\n\tASSERT_INT_EQ(ssh_init(&server2, 1, NULL), 0);\n\tASSERT_PTR_NE(client, NULL);\n\tASSERT_PTR_NE(server, NULL);\n\tASSERT_PTR_NE(server2, NULL);\n\tTEST_DONE();\n\n\thook_ctx.c2s = c2s;\n\thook_ctx.s2c = s2c;\n\thook_ctx.trigger_direction = direction;\n\thook_ctx.packet_index = packet_index;\n\thook_ctx.dump_path = dump_path;\n\thook_ctx.replace_data = replace_data;\n\thook_ctx.client = client;\n\thook_ctx.server = server;\n\thook_ctx.server2 = server2;\n\tssh_packet_set_input_hook(client, packet_hook, &hook_ctx);\n\tssh_packet_set_input_hook(server, packet_hook, &hook_ctx);\n\tssh_packet_set_input_hook(server2, packet_hook, &hook_ctx);\n\n\tTEST_START(\"ssh_add_hostkey\");\n\tASSERT_INT_EQ(ssh_add_hostkey(server, prvkey), 0);\n\tASSERT_INT_EQ(ssh_add_hostkey(client, pubkey), 0);\n\tTEST_DONE();\n\n\tTEST_START(\"kex\");\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying client\");\n\tASSERT_INT_EQ(kex_send_kexinit(client), 0);\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying server\");\n\tASSERT_INT_EQ(kex_send_kexinit(server), 0);\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_packet_get_state\");\n\tstate = sshbuf_new();\n\tASSERT_PTR_NE(state, NULL);\n\tASSERT_INT_EQ(ssh_packet_get_state(server, state), 0);\n\tASSERT_INT_GE(sshbuf_len(state), 1);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_packet_set_state\");\n\tASSERT_INT_EQ(ssh_add_hostkey(server2, prvkey), 0);\n\tkex_free(server2->kex);\t/* XXX or should ssh_packet_set_state()? */\n\tASSERT_INT_EQ(ssh_packet_set_state(server2, state), 0);\n\tASSERT_INT_EQ(sshbuf_len(state), 0);\n\tsshbuf_free(state);\n\tASSERT_PTR_NE(server2->kex, NULL);\n\t/* XXX we need to set the callbacks */\n#ifdef WITH_OPENSSL\n\tserver2->kex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GRP14_SHA256] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GRP16_SHA512] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GRP18_SHA512] = kexdh_server;\n\tserver2->kex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\tserver2->kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n# ifdef OPENSSL_HAS_ECC\n\tserver2->kex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n# endif\n#endif\n\tserver2->kex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\tserver2->kex->load_host_public_key = server->kex->load_host_public_key;\n\tserver2->kex->load_host_private_key = server->kex->load_host_private_key;\n\tserver2->kex->sign = server->kex->sign;\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying server2\");\n\tASSERT_INT_EQ(kex_send_kexinit(server2), 0);\n\trun_kex(client, server2);\n\tASSERT_INT_EQ(kex_send_kexinit(client), 0);\n\trun_kex(client, server2);\n\tTEST_DONE();\n\n\tTEST_START(\"cleanup\");\n\tsshkey_free(pubkey);\n\tssh_free(client);\n\tssh_free(server);\n\tssh_free(server2);\n\tfree(keyname);\n\tTEST_DONE();\n}"
  },
  {
    "function_name": "run_kex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/misc/kexfuzz/kexfuzz.c",
    "lines": "176-196",
    "snippet": "static void\nrun_kex(struct ssh *client, struct ssh *server)\n{\n\tint r = 0;\n\n\twhile (!server->kex->done || !client->kex->done) {\n\t\tif ((r = do_send_and_receive(server, client)) != 0) {\n\t\t\tdebug(\"do_send_and_receive S2C: %s\", ssh_err(r));\n\t\t\tbreak;\n\t\t}\n\t\tif ((r = do_send_and_receive(client, server)) != 0) {\n\t\t\tdebug(\"do_send_and_receive C2S: %s\", ssh_err(r));\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (do_debug)\n\t\tprintf(\"done: %s\\n\", ssh_err(r));\n\tASSERT_INT_EQ(r, 0);\n\tASSERT_INT_EQ(server->kex->done, 1);\n\tASSERT_INT_EQ(client->kex->done, 1);\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssherr.h\"",
      "# include <err.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "# include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int do_debug = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "client->kex->done",
            "1"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "server->kex->done",
            "1"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "r",
            "0"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"done: %s\\n\"",
            "ssh_err(r)"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"do_send_and_receive C2S: %s\"",
            "ssh_err(r)"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_send_and_receive",
          "args": [
            "client",
            "server"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "do_send_and_receive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/misc/kexfuzz/kexfuzz.c",
          "lines": "99-127",
          "snippet": "static int\ndo_send_and_receive(struct ssh *from, struct ssh *to)\n{\n\tu_char type;\n\tsize_t len;\n\tconst u_char *buf;\n\tint r;\n\n\tfor (;;) {\n\t\tif ((r = ssh_packet_next(from, &type)) != 0) {\n\t\t\tfprintf(stderr, \"ssh_packet_next: %s\\n\", ssh_err(r));\n\t\t\treturn r;\n\t\t}\n\n\t\tif (type != 0)\n\t\t\treturn 0;\n\t\tbuf = ssh_output_ptr(from, &len);\n\t\tif (len == 0)\n\t\t\treturn 0;\n\t\tif ((r = ssh_input_append(to, buf, len)) != 0) {\n\t\t\tdebug(\"ssh_input_append: %s\", ssh_err(r));\n\t\t\treturn r;\n\t\t}\n\t\tif ((r = ssh_output_consume(from, len)) != 0) {\n\t\t\tdebug(\"ssh_output_consume: %s\", ssh_err(r));\n\t\t\treturn r;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"authfile.h\"",
            "#include \"myproposal.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssherr.h\"",
            "# include <err.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n# include <err.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndo_send_and_receive(struct ssh *from, struct ssh *to)\n{\n\tu_char type;\n\tsize_t len;\n\tconst u_char *buf;\n\tint r;\n\n\tfor (;;) {\n\t\tif ((r = ssh_packet_next(from, &type)) != 0) {\n\t\t\tfprintf(stderr, \"ssh_packet_next: %s\\n\", ssh_err(r));\n\t\t\treturn r;\n\t\t}\n\n\t\tif (type != 0)\n\t\t\treturn 0;\n\t\tbuf = ssh_output_ptr(from, &len);\n\t\tif (len == 0)\n\t\t\treturn 0;\n\t\tif ((r = ssh_input_append(to, buf, len)) != 0) {\n\t\t\tdebug(\"ssh_input_append: %s\", ssh_err(r));\n\t\t\treturn r;\n\t\t}\n\t\tif ((r = ssh_output_consume(from, len)) != 0) {\n\t\t\tdebug(\"ssh_output_consume: %s\", ssh_err(r));\n\t\t\treturn r;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n# include <err.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int do_debug = 0;\n\nstatic void\nrun_kex(struct ssh *client, struct ssh *server)\n{\n\tint r = 0;\n\n\twhile (!server->kex->done || !client->kex->done) {\n\t\tif ((r = do_send_and_receive(server, client)) != 0) {\n\t\t\tdebug(\"do_send_and_receive S2C: %s\", ssh_err(r));\n\t\t\tbreak;\n\t\t}\n\t\tif ((r = do_send_and_receive(client, server)) != 0) {\n\t\t\tdebug(\"do_send_and_receive C2S: %s\", ssh_err(r));\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (do_debug)\n\t\tprintf(\"done: %s\\n\", ssh_err(r));\n\tASSERT_INT_EQ(r, 0);\n\tASSERT_INT_EQ(server->kex->done, 1);\n\tASSERT_INT_EQ(client->kex->done, 1);\n}"
  },
  {
    "function_name": "do_send_and_receive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/misc/kexfuzz/kexfuzz.c",
    "lines": "99-127",
    "snippet": "static int\ndo_send_and_receive(struct ssh *from, struct ssh *to)\n{\n\tu_char type;\n\tsize_t len;\n\tconst u_char *buf;\n\tint r;\n\n\tfor (;;) {\n\t\tif ((r = ssh_packet_next(from, &type)) != 0) {\n\t\t\tfprintf(stderr, \"ssh_packet_next: %s\\n\", ssh_err(r));\n\t\t\treturn r;\n\t\t}\n\n\t\tif (type != 0)\n\t\t\treturn 0;\n\t\tbuf = ssh_output_ptr(from, &len);\n\t\tif (len == 0)\n\t\t\treturn 0;\n\t\tif ((r = ssh_input_append(to, buf, len)) != 0) {\n\t\t\tdebug(\"ssh_input_append: %s\", ssh_err(r));\n\t\t\treturn r;\n\t\t}\n\t\tif ((r = ssh_output_consume(from, len)) != 0) {\n\t\t\tdebug(\"ssh_output_consume: %s\", ssh_err(r));\n\t\t\treturn r;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssherr.h\"",
      "# include <err.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "# include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"ssh_output_consume: %s\"",
            "ssh_err(r)"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_output_consume",
          "args": [
            "from",
            "len"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_output_consume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
          "lines": "297-301",
          "snippet": "int\nssh_output_consume(struct ssh *ssh, size_t len)\n{\n\treturn sshbuf_consume(ssh_packet_get_output(ssh), len);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"myproposal.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"ssh_api.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t_ssh_exchange_banner(struct ssh *);",
            "int\t_ssh_send_banner(struct ssh *, char **);",
            "int\t_ssh_read_banner(struct ssh *, char **);",
            "int\t_ssh_order_hostkeyalgs(struct ssh *);",
            "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
            "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
            "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\nssh_output_consume(struct ssh *ssh, size_t len)\n{\n\treturn sshbuf_consume(ssh_packet_get_output(ssh), len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_input_append",
          "args": [
            "to",
            "buf",
            "len"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_input_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
          "lines": "223-227",
          "snippet": "int\nssh_input_append(struct ssh *ssh, const u_char *data, size_t len)\n{\n\treturn sshbuf_put(ssh_packet_get_input(ssh), data, len);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"myproposal.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"ssh_api.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t_ssh_exchange_banner(struct ssh *);",
            "int\t_ssh_send_banner(struct ssh *, char **);",
            "int\t_ssh_read_banner(struct ssh *, char **);",
            "int\t_ssh_order_hostkeyalgs(struct ssh *);",
            "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
            "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
            "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\nssh_input_append(struct ssh *ssh, const u_char *data, size_t len)\n{\n\treturn sshbuf_put(ssh_packet_get_input(ssh), data, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_output_ptr",
          "args": [
            "from",
            "&len"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_output_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
          "lines": "288-295",
          "snippet": "const u_char *\nssh_output_ptr(struct ssh *ssh, size_t *len)\n{\n\tstruct sshbuf *output = ssh_packet_get_output(ssh);\n\n\t*len = sshbuf_len(output);\n\treturn sshbuf_ptr(output);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"myproposal.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"ssh_api.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t_ssh_exchange_banner(struct ssh *);",
            "int\t_ssh_send_banner(struct ssh *, char **);",
            "int\t_ssh_read_banner(struct ssh *, char **);",
            "int\t_ssh_order_hostkeyalgs(struct ssh *);",
            "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
            "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
            "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nconst u_char *\nssh_output_ptr(struct ssh *ssh, size_t *len)\n{\n\tstruct sshbuf *output = ssh_packet_get_output(ssh);\n\n\t*len = sshbuf_len(output);\n\treturn sshbuf_ptr(output);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ssh_packet_next: %s\\n\"",
            "ssh_err(r)"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_packet_next",
          "args": [
            "from",
            "&type"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh_api.c",
          "lines": "229-268",
          "snippet": "int\nssh_packet_next(struct ssh *ssh, u_char *typep)\n{\n\tint r;\n\tu_int32_t seqnr;\n\tu_char type;\n\n\t/*\n\t * Try to read a packet. Return SSH_MSG_NONE if no packet or not\n\t * enough data.\n\t */\n\t*typep = SSH_MSG_NONE;\n\tif (ssh->kex->client_version_string == NULL ||\n\t    ssh->kex->server_version_string == NULL)\n\t\treturn _ssh_exchange_banner(ssh);\n\t/*\n\t * If we enough data and a dispatch function then\n\t * call the function and get the next packet.\n\t * Otherwise return the packet type to the caller so it\n\t * can decide how to go on.\n\t *\n\t * We will only call the dispatch function for:\n\t *     20-29    Algorithm negotiation\n\t *     30-49    Key exchange method specific (numbers can be reused for\n\t *              different authentication methods)\n\t */\n\tfor (;;) {\n\t\tif ((r = ssh_packet_read_poll2(ssh, &type, &seqnr)) != 0)\n\t\t\treturn r;\n\t\tif (type > 0 && type < DISPATCH_MAX &&\n\t\t    type >= SSH2_MSG_KEXINIT && type <= SSH2_MSG_TRANSPORT_MAX &&\n\t\t    ssh->dispatch[type] != NULL) {\n\t\t\tif ((r = (*ssh->dispatch[type])(type, seqnr, ssh)) != 0)\n\t\t\t\treturn r;\n\t\t} else {\n\t\t\t*typep = type;\n\t\t\treturn 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"myproposal.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"misc.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"ssh_api.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t_ssh_exchange_banner(struct ssh *);",
            "int\t_ssh_send_banner(struct ssh *, char **);",
            "int\t_ssh_read_banner(struct ssh *, char **);",
            "int\t_ssh_order_hostkeyalgs(struct ssh *);",
            "int\t_ssh_verify_host_key(struct sshkey *, struct ssh *);",
            "struct sshkey *_ssh_host_public_key(int, int, struct ssh *);",
            "struct sshkey *_ssh_host_private_key(int, int, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"ssh_api.h\"\n#include \"includes.h\"\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, char **);\nint\t_ssh_read_banner(struct ssh *, char **);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\n\nint\nssh_packet_next(struct ssh *ssh, u_char *typep)\n{\n\tint r;\n\tu_int32_t seqnr;\n\tu_char type;\n\n\t/*\n\t * Try to read a packet. Return SSH_MSG_NONE if no packet or not\n\t * enough data.\n\t */\n\t*typep = SSH_MSG_NONE;\n\tif (ssh->kex->client_version_string == NULL ||\n\t    ssh->kex->server_version_string == NULL)\n\t\treturn _ssh_exchange_banner(ssh);\n\t/*\n\t * If we enough data and a dispatch function then\n\t * call the function and get the next packet.\n\t * Otherwise return the packet type to the caller so it\n\t * can decide how to go on.\n\t *\n\t * We will only call the dispatch function for:\n\t *     20-29    Algorithm negotiation\n\t *     30-49    Key exchange method specific (numbers can be reused for\n\t *              different authentication methods)\n\t */\n\tfor (;;) {\n\t\tif ((r = ssh_packet_read_poll2(ssh, &type, &seqnr)) != 0)\n\t\t\treturn r;\n\t\tif (type > 0 && type < DISPATCH_MAX &&\n\t\t    type >= SSH2_MSG_KEXINIT && type <= SSH2_MSG_TRANSPORT_MAX &&\n\t\t    ssh->dispatch[type] != NULL) {\n\t\t\tif ((r = (*ssh->dispatch[type])(type, seqnr, ssh)) != 0)\n\t\t\t\treturn r;\n\t\t} else {\n\t\t\t*typep = type;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n# include <err.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndo_send_and_receive(struct ssh *from, struct ssh *to)\n{\n\tu_char type;\n\tsize_t len;\n\tconst u_char *buf;\n\tint r;\n\n\tfor (;;) {\n\t\tif ((r = ssh_packet_next(from, &type)) != 0) {\n\t\t\tfprintf(stderr, \"ssh_packet_next: %s\\n\", ssh_err(r));\n\t\t\treturn r;\n\t\t}\n\n\t\tif (type != 0)\n\t\t\treturn 0;\n\t\tbuf = ssh_output_ptr(from, &len);\n\t\tif (len == 0)\n\t\t\treturn 0;\n\t\tif ((r = ssh_input_append(to, buf, len)) != 0) {\n\t\t\tdebug(\"ssh_input_append: %s\", ssh_err(r));\n\t\t\treturn r;\n\t\t}\n\t\tif ((r = ssh_output_consume(from, len)) != 0) {\n\t\t\tdebug(\"ssh_output_consume: %s\", ssh_err(r));\n\t\t\treturn r;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "packet_hook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/misc/kexfuzz/kexfuzz.c",
    "lines": "47-97",
    "snippet": "static int\npacket_hook(struct ssh *ssh, struct sshbuf *packet, u_char *typep, void *_ctx)\n{\n\tstruct hook_ctx *ctx = (struct hook_ctx *)_ctx;\n\tint mydirection = ssh == ctx->client ? S2C : C2S;\n\tint *packet_count = mydirection == S2C ? ctx->s2c : ctx->c2s;\n\tFILE *dumpfile;\n\tint r;\n\n\tif (do_debug) {\n\t\tprintf(\"%s packet %d type %u:\\n\",\n\t\t    mydirection == S2C ? \"s2c\" : \"c2s\",\n\t\t    *packet_count, *typep);\n\t\tsshbuf_dump(packet, stdout);\n\t}\n\tif (mydirection == ctx->trigger_direction &&\n\t    ctx->packet_index == *packet_count) {\n\t\tif (ctx->replace_data != NULL) {\n\t\t\tsshbuf_reset(packet);\n\t\t\t/* Type is first byte of packet */\n\t\t\tif ((r = sshbuf_get_u8(ctx->replace_data,\n\t\t\t    typep)) != 0 ||\n\t\t\t    (r = sshbuf_putb(packet, ctx->replace_data)) != 0)\n\t\t\t\treturn r;\n\t\t\tif (do_debug) {\n\t\t\t\tprintf(\"***** replaced packet type %u\\n\",\n\t\t\t\t    *typep);\n\t\t\t\tsshbuf_dump(packet, stdout);\n\t\t\t}\n\t\t} else if (ctx->dump_path != NULL) {\n\t\t\tif ((dumpfile = fopen(ctx->dump_path, \"w+\")) == NULL)\n\t\t\t\terr(1, \"fopen %s\", ctx->dump_path);\n\t\t\t/* Write { type, packet } */\n\t\t\tif (fwrite(typep, 1, 1, dumpfile) != 1)\n\t\t\t\terr(1, \"fwrite type %s\", ctx->dump_path);\n\t\t\tif (sshbuf_len(packet) != 0 &&\n\t\t\t    fwrite(sshbuf_ptr(packet), sshbuf_len(packet),\n\t\t\t    1, dumpfile) != 1)\n\t\t\t\terr(1, \"fwrite body %s\", ctx->dump_path);\n\t\t\tif (do_debug) {\n\t\t\t\tprintf(\"***** dumped packet type %u len %zu\\n\",\n\t\t\t\t    *typep, sshbuf_len(packet));\n\t\t\t}\n\t\t\tfclose(dumpfile);\n\t\t\t/* No point in continuing */\n\t\t\texit(0);\n\t\t}\n\t}\n\t(*packet_count)++;\n\treturn 0;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"authfile.h\"",
      "#include \"myproposal.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh_api.h\"",
      "#include \"ssherr.h\"",
      "# include <err.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "# include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int do_debug = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "dumpfile"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"***** dumped packet type %u len %zu\\n\"",
            "*typep",
            "sshbuf_len(packet)"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "packet"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"fwrite body %s\"",
            "ctx->dump_path"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "run_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1323-1346",
          "snippet": "void\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void run_err(const char *,...);",
            "int errs, remin, remout;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid run_err(const char *,...);\nint errs, remin, remout;\n\nvoid\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fwrite",
          "args": [
            "sshbuf_ptr(packet)",
            "sshbuf_len(packet)",
            "1",
            "dumpfile"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "packet"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fwrite",
          "args": [
            "typep",
            "1",
            "1",
            "dumpfile"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "ctx->dump_path",
            "\"w+\""
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_dump",
          "args": [
            "packet",
            "stdout"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-misc.c",
          "lines": "65-70",
          "snippet": "void\nsshbuf_dump(struct sshbuf *buf, FILE *f)\n{\n\tfprintf(f, \"buffer %p len = %zu\\n\", buf, sshbuf_len(buf));\n\tsshbuf_dump_data(sshbuf_ptr(buf), sshbuf_len(buf), f);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <ctype.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <ctype.h>\n#include <resolv.h>\n#include <string.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_dump(struct sshbuf *buf, FILE *f)\n{\n\tfprintf(f, \"buffer %p len = %zu\\n\", buf, sshbuf_len(buf));\n\tsshbuf_dump_data(sshbuf_ptr(buf), sshbuf_len(buf), f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_putb",
          "args": [
            "packet",
            "ctx->replace_data"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "248-252",
          "snippet": "int\nsshbuf_putb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "ctx->replace_data",
            "typep"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "packet"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"authfile.h\"\n#include \"myproposal.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n# include <err.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int do_debug = 0;\n\nstatic int\npacket_hook(struct ssh *ssh, struct sshbuf *packet, u_char *typep, void *_ctx)\n{\n\tstruct hook_ctx *ctx = (struct hook_ctx *)_ctx;\n\tint mydirection = ssh == ctx->client ? S2C : C2S;\n\tint *packet_count = mydirection == S2C ? ctx->s2c : ctx->c2s;\n\tFILE *dumpfile;\n\tint r;\n\n\tif (do_debug) {\n\t\tprintf(\"%s packet %d type %u:\\n\",\n\t\t    mydirection == S2C ? \"s2c\" : \"c2s\",\n\t\t    *packet_count, *typep);\n\t\tsshbuf_dump(packet, stdout);\n\t}\n\tif (mydirection == ctx->trigger_direction &&\n\t    ctx->packet_index == *packet_count) {\n\t\tif (ctx->replace_data != NULL) {\n\t\t\tsshbuf_reset(packet);\n\t\t\t/* Type is first byte of packet */\n\t\t\tif ((r = sshbuf_get_u8(ctx->replace_data,\n\t\t\t    typep)) != 0 ||\n\t\t\t    (r = sshbuf_putb(packet, ctx->replace_data)) != 0)\n\t\t\t\treturn r;\n\t\t\tif (do_debug) {\n\t\t\t\tprintf(\"***** replaced packet type %u\\n\",\n\t\t\t\t    *typep);\n\t\t\t\tsshbuf_dump(packet, stdout);\n\t\t\t}\n\t\t} else if (ctx->dump_path != NULL) {\n\t\t\tif ((dumpfile = fopen(ctx->dump_path, \"w+\")) == NULL)\n\t\t\t\terr(1, \"fopen %s\", ctx->dump_path);\n\t\t\t/* Write { type, packet } */\n\t\t\tif (fwrite(typep, 1, 1, dumpfile) != 1)\n\t\t\t\terr(1, \"fwrite type %s\", ctx->dump_path);\n\t\t\tif (sshbuf_len(packet) != 0 &&\n\t\t\t    fwrite(sshbuf_ptr(packet), sshbuf_len(packet),\n\t\t\t    1, dumpfile) != 1)\n\t\t\t\terr(1, \"fwrite body %s\", ctx->dump_path);\n\t\t\tif (do_debug) {\n\t\t\t\tprintf(\"***** dumped packet type %u len %zu\\n\",\n\t\t\t\t    *typep, sshbuf_len(packet));\n\t\t\t}\n\t\t\tfclose(dumpfile);\n\t\t\t/* No point in continuing */\n\t\t\texit(0);\n\t\t}\n\t}\n\t(*packet_count)++;\n\treturn 0;\n}"
  }
]