[
  {
    "function_name": "freerrset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname-ldns.c",
    "lines": "252-281",
    "snippet": "void\nfreerrset(struct rrsetinfo *rrset)\n{\n\tu_int16_t i;\n\n\tif (rrset == NULL)\n\t\treturn;\n\n\tif (rrset->rri_rdatas) {\n\t\tfor (i = 0; i < rrset->rri_nrdatas; i++) {\n\t\t\tif (rrset->rri_rdatas[i].rdi_data == NULL)\n\t\t\t\tbreak;\n\t\t\tfree(rrset->rri_rdatas[i].rdi_data);\n\t\t}\n\t\tfree(rrset->rri_rdatas);\n\t}\n\n\tif (rrset->rri_sigs) {\n\t\tfor (i = 0; i < rrset->rri_nsigs; i++) {\n\t\t\tif (rrset->rri_sigs[i].rdi_data == NULL)\n\t\t\t\tbreak;\n\t\t\tfree(rrset->rri_sigs[i].rdi_data);\n\t\t}\n\t\tfree(rrset->rri_sigs);\n\t}\n\n\tif (rrset->rri_name)\n\t\tfree(rrset->rri_name);\n\tfree(rrset);\n}",
    "includes": [
      "#include \"xmalloc.h\"",
      "#include \"log.h\"",
      "#include \"getrrsetbyname.h\"",
      "#include <ldns/ldns.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "rrset"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "freerrset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname-ldns.c",
          "lines": "252-281",
          "snippet": "void\nfreerrset(struct rrsetinfo *rrset)\n{\n\tu_int16_t i;\n\n\tif (rrset == NULL)\n\t\treturn;\n\n\tif (rrset->rri_rdatas) {\n\t\tfor (i = 0; i < rrset->rri_nrdatas; i++) {\n\t\t\tif (rrset->rri_rdatas[i].rdi_data == NULL)\n\t\t\t\tbreak;\n\t\t\tfree(rrset->rri_rdatas[i].rdi_data);\n\t\t}\n\t\tfree(rrset->rri_rdatas);\n\t}\n\n\tif (rrset->rri_sigs) {\n\t\tfor (i = 0; i < rrset->rri_nsigs; i++) {\n\t\t\tif (rrset->rri_sigs[i].rdi_data == NULL)\n\t\t\t\tbreak;\n\t\t\tfree(rrset->rri_sigs[i].rdi_data);\n\t\t}\n\t\tfree(rrset->rri_sigs);\n\t}\n\n\tif (rrset->rri_name)\n\t\tfree(rrset->rri_name);\n\tfree(rrset);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"xmalloc.h\"\n#include \"log.h\"\n#include \"getrrsetbyname.h\"\n#include <ldns/ldns.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreerrset(struct rrsetinfo *rrset)\n{\n\tu_int16_t i;\n\n\tif (rrset == NULL)\n\t\treturn;\n\n\tif (rrset->rri_rdatas) {\n\t\tfor (i = 0; i < rrset->rri_nrdatas; i++) {\n\t\t\tif (rrset->rri_rdatas[i].rdi_data == NULL)\n\t\t\t\tbreak;\n\t\t\tfree(rrset->rri_rdatas[i].rdi_data);\n\t\t}\n\t\tfree(rrset->rri_rdatas);\n\t}\n\n\tif (rrset->rri_sigs) {\n\t\tfor (i = 0; i < rrset->rri_nsigs; i++) {\n\t\t\tif (rrset->rri_sigs[i].rdi_data == NULL)\n\t\t\t\tbreak;\n\t\t\tfree(rrset->rri_sigs[i].rdi_data);\n\t\t}\n\t\tfree(rrset->rri_sigs);\n\t}\n\n\tif (rrset->rri_name)\n\t\tfree(rrset->rri_name);\n\tfree(rrset);\n}"
  },
  {
    "function_name": "getrrsetbyname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname-ldns.c",
    "lines": "62-249",
    "snippet": "int\ngetrrsetbyname(const char *hostname, unsigned int rdclass,\n\t       unsigned int rdtype, unsigned int flags,\n\t       struct rrsetinfo **res)\n{\n\tint result;\n\tunsigned int i, j, index_ans, index_sig;\n\tstruct rrsetinfo *rrset = NULL;\n\tstruct rdatainfo *rdata;\n\tsize_t len;\n\tldns_resolver *ldns_res = NULL;\n\tldns_rdf *domain = NULL;\n\tldns_pkt *pkt = NULL;\n\tldns_rr_list *rrsigs = NULL, *rrdata = NULL;\n\tldns_status err;\n\tldns_rr *rr;\n\n\t/* check for invalid class and type */\n\tif (rdclass > 0xffff || rdtype > 0xffff) {\n\t\tresult = ERRSET_INVAL;\n\t\tgoto fail;\n\t}\n\n\t/* don't allow queries of class or type ANY */\n\tif (rdclass == 0xff || rdtype == 0xff) {\n\t\tresult = ERRSET_INVAL;\n\t\tgoto fail;\n\t}\n\n\t/* don't allow flags yet, unimplemented */\n\tif (flags) {\n\t\tresult = ERRSET_INVAL;\n\t\tgoto fail;\n\t}\n\n\t/* Initialize resolver from resolv.conf */\n\tdomain = ldns_dname_new_frm_str(hostname);\n\tif ((err = ldns_resolver_new_frm_file(&ldns_res, NULL)) != \\\n\t    LDNS_STATUS_OK) {\n\t\tresult = ERRSET_FAIL;\n\t\tgoto fail;\n\t}\n\n#ifdef LDNS_DEBUG\n\tldns_resolver_set_debug(ldns_res, true);\n#endif /* LDNS_DEBUG */\n\n\tldns_resolver_set_dnssec(ldns_res, true); /* Use DNSSEC */\n\n\t/* make query */\n\tpkt = ldns_resolver_query(ldns_res, domain, rdtype, rdclass, LDNS_RD);\n\n\t/*** TODO: finer errcodes -- see original **/\n\tif (!pkt || ldns_pkt_ancount(pkt) < 1) {\n\t\tresult = ERRSET_FAIL;\n\t\tgoto fail;\n\t}\n\n\t/* initialize rrset */\n\trrset = calloc(1, sizeof(struct rrsetinfo));\n\tif (rrset == NULL) {\n\t\tresult = ERRSET_NOMEMORY;\n\t\tgoto fail;\n\t}\n\n\trrdata = ldns_pkt_rr_list_by_type(pkt, rdtype, LDNS_SECTION_ANSWER);\n\trrset->rri_nrdatas = ldns_rr_list_rr_count(rrdata);\n\tif (!rrset->rri_nrdatas) {\n\t\tresult = ERRSET_NODATA;\n\t\tgoto fail;\n\t}\n\n\t/* copy name from answer section */\n\tlen = ldns_rdf_size(ldns_rr_owner(ldns_rr_list_rr(rrdata, 0)));\n\tif ((rrset->rri_name = malloc(len)) == NULL) {\n\t\tresult = ERRSET_NOMEMORY;\n\t\tgoto fail;\n\t}\n\tmemcpy(rrset->rri_name,\n\t    ldns_rdf_data(ldns_rr_owner(ldns_rr_list_rr(rrdata, 0))), len);\n\n\trrset->rri_rdclass = ldns_rr_get_class(ldns_rr_list_rr(rrdata, 0));\n\trrset->rri_rdtype = ldns_rr_get_type(ldns_rr_list_rr(rrdata, 0));\n\trrset->rri_ttl = ldns_rr_ttl(ldns_rr_list_rr(rrdata, 0));\n\n\tdebug2(\"ldns: got %u answers from DNS\", rrset->rri_nrdatas);\n\n\t/* Check for authenticated data */\n\tif (ldns_pkt_ad(pkt)) {\n\t\trrset->rri_flags |= RRSET_VALIDATED;\n\t} else { /* AD is not set, try autonomous validation */\n\t\tldns_rr_list * trusted_keys = ldns_rr_list_new();\n\n\t\tdebug2(\"ldns: trying to validate RRset\");\n\t\t/* Get eventual sigs */\n\t\trrsigs = ldns_pkt_rr_list_by_type(pkt, LDNS_RR_TYPE_RRSIG,\n\t\t    LDNS_SECTION_ANSWER);\n\n\t\trrset->rri_nsigs = ldns_rr_list_rr_count(rrsigs);\n\t\tdebug2(\"ldns: got %u signature(s) (RRTYPE %u) from DNS\",\n\t\t       rrset->rri_nsigs, LDNS_RR_TYPE_RRSIG);\n\n\t\tif ((err = ldns_verify_trusted(ldns_res, rrdata, rrsigs,\n\t\t     trusted_keys)) == LDNS_STATUS_OK) {\n\t\t\trrset->rri_flags |= RRSET_VALIDATED;\n\t\t\tdebug2(\"ldns: RRset is signed with a valid key\");\n\t\t} else {\n\t\t\tdebug2(\"ldns: RRset validation failed: %s\",\n\t\t\t    ldns_get_errorstr_by_id(err));\n\t\t}\n\n\t\tldns_rr_list_deep_free(trusted_keys);\n\t}\n\n\t/* allocate memory for answers */\n\trrset->rri_rdatas = calloc(rrset->rri_nrdatas,\n\t   sizeof(struct rdatainfo));\n\n\tif (rrset->rri_rdatas == NULL) {\n\t\tresult = ERRSET_NOMEMORY;\n\t\tgoto fail;\n\t}\n\n\t/* allocate memory for signatures */\n\tif (rrset->rri_nsigs > 0) {\n\t\trrset->rri_sigs = calloc(rrset->rri_nsigs,\n\t\t    sizeof(struct rdatainfo));\n\n\t\tif (rrset->rri_sigs == NULL) {\n\t\t\tresult = ERRSET_NOMEMORY;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* copy answers & signatures */\n\tfor (i=0, index_ans=0, index_sig=0; i< pkt->_header->_ancount; i++) {\n\t\trdata = NULL;\n\t\trr = ldns_rr_list_rr(ldns_pkt_answer(pkt), i);\n\n\t\tif (ldns_rr_get_class(rr) == rrset->rri_rdclass &&\n\t\t    ldns_rr_get_type(rr) == rrset->rri_rdtype) {\n\t\t\trdata = &rrset->rri_rdatas[index_ans++];\n\t\t}\n\n\t\tif (rr->_rr_class == rrset->rri_rdclass &&\n\t\t    rr->_rr_type == LDNS_RR_TYPE_RRSIG &&\n\t\t    rrset->rri_sigs) {\n\t\t\trdata = &rrset->rri_sigs[index_sig++];\n\t\t}\n\n\t\tif (rdata) {\n\t\t\tsize_t rdata_offset = 0;\n\n\t\t\trdata->rdi_length = 0;\n\t\t\tfor (j=0; j< rr->_rd_count; j++) {\n\t\t\t\trdata->rdi_length +=\n\t\t\t\t    ldns_rdf_size(ldns_rr_rdf(rr, j));\n\t\t\t}\n\n\t\t\trdata->rdi_data = malloc(rdata->rdi_length);\n\t\t\tif (rdata->rdi_data == NULL) {\n\t\t\t\tresult = ERRSET_NOMEMORY;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\t/* Re-create the raw DNS RDATA */\n\t\t\tfor (j=0; j< rr->_rd_count; j++) {\n\t\t\t\tlen = ldns_rdf_size(ldns_rr_rdf(rr, j));\n\t\t\t\tmemcpy(rdata->rdi_data + rdata_offset,\n\t\t\t\t       ldns_rdf_data(ldns_rr_rdf(rr, j)), len);\n\t\t\t\trdata_offset += len;\n\t\t\t}\n\t\t}\n\t}\n\n\t*res = rrset;\n\tresult = ERRSET_SUCCESS;\n\nfail:\n\t/* freerrset(rrset); */\n\tldns_rdf_deep_free(domain);\n\tldns_pkt_free(pkt);\n\tldns_rr_list_deep_free(rrsigs);\n\tldns_rr_list_deep_free(rrdata);\n\tldns_resolver_deep_free(ldns_res);\n\n\treturn result;\n}",
    "includes": [
      "#include \"xmalloc.h\"",
      "#include \"log.h\"",
      "#include \"getrrsetbyname.h\"",
      "#include <ldns/ldns.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ldns_resolver_deep_free",
          "args": [
            "ldns_res"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_rr_list_deep_free",
          "args": [
            "rrdata"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_rr_list_deep_free",
          "args": [
            "rrsigs"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_pkt_free",
          "args": [
            "pkt"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_rdf_deep_free",
          "args": [
            "domain"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "rdata->rdi_data + rdata_offset",
            "ldns_rdf_data(ldns_rr_rdf(rr, j))",
            "len"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_rdf_data",
          "args": [
            "ldns_rr_rdf(rr, j)"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_rr_rdf",
          "args": [
            "rr",
            "j"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_rdf_size",
          "args": [
            "ldns_rr_rdf(rr, j)"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_rr_rdf",
          "args": [
            "rr",
            "j"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "rdata->rdi_length"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "rpl_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-malloc.c",
          "lines": "26-32",
          "snippet": "void *\nrpl_malloc(size_t size)\n{\n\tif (size == 0)\n\t\tsize = 1;\n\treturn malloc(size);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nvoid *\nrpl_malloc(size_t size)\n{\n\tif (size == 0)\n\t\tsize = 1;\n\treturn malloc(size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ldns_rdf_size",
          "args": [
            "ldns_rr_rdf(rr, j)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_rr_rdf",
          "args": [
            "rr",
            "j"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_rr_get_type",
          "args": [
            "rr"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_rr_get_class",
          "args": [
            "rr"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_rr_list_rr",
          "args": [
            "ldns_pkt_answer(pkt)",
            "i"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_pkt_answer",
          "args": [
            "pkt"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "rrset->rri_nsigs",
            "sizeof(struct rdatainfo)"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "rpl_calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-malloc.c",
          "lines": "36-44",
          "snippet": "void *\nrpl_calloc(size_t nmemb, size_t size)\n{\n\tif (nmemb == 0)\n\t\tnmemb = 1;\n\tif (size == 0)\n\t\tsize = 1;\n\treturn calloc(nmemb, size);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nvoid *\nrpl_calloc(size_t nmemb, size_t size)\n{\n\tif (nmemb == 0)\n\t\tnmemb = 1;\n\tif (size == 0)\n\t\tsize = 1;\n\treturn calloc(nmemb, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ldns_rr_list_deep_free",
          "args": [
            "trusted_keys"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"ldns: RRset validation failed: %s\"",
            "ldns_get_errorstr_by_id(err)"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ldns_get_errorstr_by_id",
          "args": [
            "err"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_verify_trusted",
          "args": [
            "ldns_res",
            "rrdata",
            "rrsigs",
            "trusted_keys"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_rr_list_rr_count",
          "args": [
            "rrsigs"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_pkt_rr_list_by_type",
          "args": [
            "pkt",
            "LDNS_RR_TYPE_RRSIG",
            "LDNS_SECTION_ANSWER"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_rr_list_new",
          "args": [],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_pkt_ad",
          "args": [
            "pkt"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_rr_ttl",
          "args": [
            "ldns_rr_list_rr(rrdata, 0)"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_rr_list_rr",
          "args": [
            "rrdata",
            "0"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_rr_get_type",
          "args": [
            "ldns_rr_list_rr(rrdata, 0)"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_rr_list_rr",
          "args": [
            "rrdata",
            "0"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_rr_get_class",
          "args": [
            "ldns_rr_list_rr(rrdata, 0)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_rr_list_rr",
          "args": [
            "rrdata",
            "0"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "rrset->rri_name",
            "ldns_rdf_data(ldns_rr_owner(ldns_rr_list_rr(rrdata, 0)))",
            "len"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_rdf_data",
          "args": [
            "ldns_rr_owner(ldns_rr_list_rr(rrdata, 0))"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_rr_owner",
          "args": [
            "ldns_rr_list_rr(rrdata, 0)"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_rr_list_rr",
          "args": [
            "rrdata",
            "0"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_rdf_size",
          "args": [
            "ldns_rr_owner(ldns_rr_list_rr(rrdata, 0))"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_rr_owner",
          "args": [
            "ldns_rr_list_rr(rrdata, 0)"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_rr_list_rr",
          "args": [
            "rrdata",
            "0"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_rr_list_rr_count",
          "args": [
            "rrdata"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_pkt_rr_list_by_type",
          "args": [
            "pkt",
            "rdtype",
            "LDNS_SECTION_ANSWER"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_pkt_ancount",
          "args": [
            "pkt"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_resolver_query",
          "args": [
            "ldns_res",
            "domain",
            "rdtype",
            "rdclass",
            "LDNS_RD"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_resolver_set_dnssec",
          "args": [
            "ldns_res",
            "true"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_resolver_set_debug",
          "args": [
            "ldns_res",
            "true"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_resolver_new_frm_file",
          "args": [
            "&ldns_res",
            "NULL"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldns_dname_new_frm_str",
          "args": [
            "hostname"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xmalloc.h\"\n#include \"log.h\"\n#include \"getrrsetbyname.h\"\n#include <ldns/ldns.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint\ngetrrsetbyname(const char *hostname, unsigned int rdclass,\n\t       unsigned int rdtype, unsigned int flags,\n\t       struct rrsetinfo **res)\n{\n\tint result;\n\tunsigned int i, j, index_ans, index_sig;\n\tstruct rrsetinfo *rrset = NULL;\n\tstruct rdatainfo *rdata;\n\tsize_t len;\n\tldns_resolver *ldns_res = NULL;\n\tldns_rdf *domain = NULL;\n\tldns_pkt *pkt = NULL;\n\tldns_rr_list *rrsigs = NULL, *rrdata = NULL;\n\tldns_status err;\n\tldns_rr *rr;\n\n\t/* check for invalid class and type */\n\tif (rdclass > 0xffff || rdtype > 0xffff) {\n\t\tresult = ERRSET_INVAL;\n\t\tgoto fail;\n\t}\n\n\t/* don't allow queries of class or type ANY */\n\tif (rdclass == 0xff || rdtype == 0xff) {\n\t\tresult = ERRSET_INVAL;\n\t\tgoto fail;\n\t}\n\n\t/* don't allow flags yet, unimplemented */\n\tif (flags) {\n\t\tresult = ERRSET_INVAL;\n\t\tgoto fail;\n\t}\n\n\t/* Initialize resolver from resolv.conf */\n\tdomain = ldns_dname_new_frm_str(hostname);\n\tif ((err = ldns_resolver_new_frm_file(&ldns_res, NULL)) != \\\n\t    LDNS_STATUS_OK) {\n\t\tresult = ERRSET_FAIL;\n\t\tgoto fail;\n\t}\n\n#ifdef LDNS_DEBUG\n\tldns_resolver_set_debug(ldns_res, true);\n#endif /* LDNS_DEBUG */\n\n\tldns_resolver_set_dnssec(ldns_res, true); /* Use DNSSEC */\n\n\t/* make query */\n\tpkt = ldns_resolver_query(ldns_res, domain, rdtype, rdclass, LDNS_RD);\n\n\t/*** TODO: finer errcodes -- see original **/\n\tif (!pkt || ldns_pkt_ancount(pkt) < 1) {\n\t\tresult = ERRSET_FAIL;\n\t\tgoto fail;\n\t}\n\n\t/* initialize rrset */\n\trrset = calloc(1, sizeof(struct rrsetinfo));\n\tif (rrset == NULL) {\n\t\tresult = ERRSET_NOMEMORY;\n\t\tgoto fail;\n\t}\n\n\trrdata = ldns_pkt_rr_list_by_type(pkt, rdtype, LDNS_SECTION_ANSWER);\n\trrset->rri_nrdatas = ldns_rr_list_rr_count(rrdata);\n\tif (!rrset->rri_nrdatas) {\n\t\tresult = ERRSET_NODATA;\n\t\tgoto fail;\n\t}\n\n\t/* copy name from answer section */\n\tlen = ldns_rdf_size(ldns_rr_owner(ldns_rr_list_rr(rrdata, 0)));\n\tif ((rrset->rri_name = malloc(len)) == NULL) {\n\t\tresult = ERRSET_NOMEMORY;\n\t\tgoto fail;\n\t}\n\tmemcpy(rrset->rri_name,\n\t    ldns_rdf_data(ldns_rr_owner(ldns_rr_list_rr(rrdata, 0))), len);\n\n\trrset->rri_rdclass = ldns_rr_get_class(ldns_rr_list_rr(rrdata, 0));\n\trrset->rri_rdtype = ldns_rr_get_type(ldns_rr_list_rr(rrdata, 0));\n\trrset->rri_ttl = ldns_rr_ttl(ldns_rr_list_rr(rrdata, 0));\n\n\tdebug2(\"ldns: got %u answers from DNS\", rrset->rri_nrdatas);\n\n\t/* Check for authenticated data */\n\tif (ldns_pkt_ad(pkt)) {\n\t\trrset->rri_flags |= RRSET_VALIDATED;\n\t} else { /* AD is not set, try autonomous validation */\n\t\tldns_rr_list * trusted_keys = ldns_rr_list_new();\n\n\t\tdebug2(\"ldns: trying to validate RRset\");\n\t\t/* Get eventual sigs */\n\t\trrsigs = ldns_pkt_rr_list_by_type(pkt, LDNS_RR_TYPE_RRSIG,\n\t\t    LDNS_SECTION_ANSWER);\n\n\t\trrset->rri_nsigs = ldns_rr_list_rr_count(rrsigs);\n\t\tdebug2(\"ldns: got %u signature(s) (RRTYPE %u) from DNS\",\n\t\t       rrset->rri_nsigs, LDNS_RR_TYPE_RRSIG);\n\n\t\tif ((err = ldns_verify_trusted(ldns_res, rrdata, rrsigs,\n\t\t     trusted_keys)) == LDNS_STATUS_OK) {\n\t\t\trrset->rri_flags |= RRSET_VALIDATED;\n\t\t\tdebug2(\"ldns: RRset is signed with a valid key\");\n\t\t} else {\n\t\t\tdebug2(\"ldns: RRset validation failed: %s\",\n\t\t\t    ldns_get_errorstr_by_id(err));\n\t\t}\n\n\t\tldns_rr_list_deep_free(trusted_keys);\n\t}\n\n\t/* allocate memory for answers */\n\trrset->rri_rdatas = calloc(rrset->rri_nrdatas,\n\t   sizeof(struct rdatainfo));\n\n\tif (rrset->rri_rdatas == NULL) {\n\t\tresult = ERRSET_NOMEMORY;\n\t\tgoto fail;\n\t}\n\n\t/* allocate memory for signatures */\n\tif (rrset->rri_nsigs > 0) {\n\t\trrset->rri_sigs = calloc(rrset->rri_nsigs,\n\t\t    sizeof(struct rdatainfo));\n\n\t\tif (rrset->rri_sigs == NULL) {\n\t\t\tresult = ERRSET_NOMEMORY;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* copy answers & signatures */\n\tfor (i=0, index_ans=0, index_sig=0; i< pkt->_header->_ancount; i++) {\n\t\trdata = NULL;\n\t\trr = ldns_rr_list_rr(ldns_pkt_answer(pkt), i);\n\n\t\tif (ldns_rr_get_class(rr) == rrset->rri_rdclass &&\n\t\t    ldns_rr_get_type(rr) == rrset->rri_rdtype) {\n\t\t\trdata = &rrset->rri_rdatas[index_ans++];\n\t\t}\n\n\t\tif (rr->_rr_class == rrset->rri_rdclass &&\n\t\t    rr->_rr_type == LDNS_RR_TYPE_RRSIG &&\n\t\t    rrset->rri_sigs) {\n\t\t\trdata = &rrset->rri_sigs[index_sig++];\n\t\t}\n\n\t\tif (rdata) {\n\t\t\tsize_t rdata_offset = 0;\n\n\t\t\trdata->rdi_length = 0;\n\t\t\tfor (j=0; j< rr->_rd_count; j++) {\n\t\t\t\trdata->rdi_length +=\n\t\t\t\t    ldns_rdf_size(ldns_rr_rdf(rr, j));\n\t\t\t}\n\n\t\t\trdata->rdi_data = malloc(rdata->rdi_length);\n\t\t\tif (rdata->rdi_data == NULL) {\n\t\t\t\tresult = ERRSET_NOMEMORY;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\t/* Re-create the raw DNS RDATA */\n\t\t\tfor (j=0; j< rr->_rd_count; j++) {\n\t\t\t\tlen = ldns_rdf_size(ldns_rr_rdf(rr, j));\n\t\t\t\tmemcpy(rdata->rdi_data + rdata_offset,\n\t\t\t\t       ldns_rdf_data(ldns_rr_rdf(rr, j)), len);\n\t\t\t\trdata_offset += len;\n\t\t\t}\n\t\t}\n\t}\n\n\t*res = rrset;\n\tresult = ERRSET_SUCCESS;\n\nfail:\n\t/* freerrset(rrset); */\n\tldns_rdf_deep_free(domain);\n\tldns_pkt_free(pkt);\n\tldns_rr_list_deep_free(rrsigs);\n\tldns_rr_list_deep_free(rrdata);\n\tldns_resolver_deep_free(ldns_res);\n\n\treturn result;\n}"
  }
]