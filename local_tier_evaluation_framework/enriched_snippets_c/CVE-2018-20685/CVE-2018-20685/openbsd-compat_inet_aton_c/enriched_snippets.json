[
  {
    "function_name": "inet_aton",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/inet_aton.c",
    "lines": "87-177",
    "snippet": "int\ninet_aton(const char *cp, struct in_addr *addr)\n{\n\tu_int32_t val;\n\tint base, n;\n\tchar c;\n\tu_int parts[4];\n\tu_int *pp = parts;\n\n\tc = *cp;\n\tfor (;;) {\n\t\t/*\n\t\t * Collect number up to ``.''.\n\t\t * Values are specified as for C:\n\t\t * 0x=hex, 0=octal, isdigit=decimal.\n\t\t */\n\t\tif (!isdigit(c))\n\t\t\treturn (0);\n\t\tval = 0; base = 10;\n\t\tif (c == '0') {\n\t\t\tc = *++cp;\n\t\t\tif (c == 'x' || c == 'X')\n\t\t\t\tbase = 16, c = *++cp;\n\t\t\telse\n\t\t\t\tbase = 8;\n\t\t}\n\t\tfor (;;) {\n\t\t\tif (isascii(c) && isdigit(c)) {\n\t\t\t\tval = (val * base) + (c - '0');\n\t\t\t\tc = *++cp;\n\t\t\t} else if (base == 16 && isascii(c) && isxdigit(c)) {\n\t\t\t\tval = (val << 4) |\n\t\t\t\t\t(c + 10 - (islower(c) ? 'a' : 'A'));\n\t\t\t\tc = *++cp;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\tif (c == '.') {\n\t\t\t/*\n\t\t\t * Internet format:\n\t\t\t *\ta.b.c.d\n\t\t\t *\ta.b.c\t(with c treated as 16 bits)\n\t\t\t *\ta.b\t(with b treated as 24 bits)\n\t\t\t */\n\t\t\tif (pp >= parts + 3)\n\t\t\t\treturn (0);\n\t\t\t*pp++ = val;\n\t\t\tc = *++cp;\n\t\t} else\n\t\t\tbreak;\n\t}\n\t/*\n\t * Check for trailing characters.\n\t */\n\tif (c != '\\0' && (!isascii(c) || !isspace(c)))\n\t\treturn (0);\n\t/*\n\t * Concoct the address according to\n\t * the number of parts specified.\n\t */\n\tn = pp - parts + 1;\n\tswitch (n) {\n\n\tcase 0:\n\t\treturn (0);\t\t/* initial nondigit */\n\n\tcase 1:\t\t\t\t/* a -- 32 bits */\n\t\tbreak;\n\n\tcase 2:\t\t\t\t/* a.b -- 8.24 bits */\n\t\tif ((val > 0xffffff) || (parts[0] > 0xff))\n\t\t\treturn (0);\n\t\tval |= parts[0] << 24;\n\t\tbreak;\n\n\tcase 3:\t\t\t\t/* a.b.c -- 8.8.16 bits */\n\t\tif ((val > 0xffff) || (parts[0] > 0xff) || (parts[1] > 0xff))\n\t\t\treturn (0);\n\t\tval |= (parts[0] << 24) | (parts[1] << 16);\n\t\tbreak;\n\n\tcase 4:\t\t\t\t/* a.b.c.d -- 8.8.8.8 bits */\n\t\tif ((val > 0xff) || (parts[0] > 0xff) || (parts[1] > 0xff) || (parts[2] > 0xff))\n\t\t\treturn (0);\n\t\tval |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);\n\t\tbreak;\n\t}\n\tif (addr)\n\t\taddr->s_addr = htonl(val);\n\treturn (1);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "val"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "c"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isascii",
          "args": [
            "c"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "islower",
          "args": [
            "c"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isxdigit",
          "args": [
            "c"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isascii",
          "args": [
            "c"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "c"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isascii",
          "args": [
            "c"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "c"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ninet_aton(const char *cp, struct in_addr *addr)\n{\n\tu_int32_t val;\n\tint base, n;\n\tchar c;\n\tu_int parts[4];\n\tu_int *pp = parts;\n\n\tc = *cp;\n\tfor (;;) {\n\t\t/*\n\t\t * Collect number up to ``.''.\n\t\t * Values are specified as for C:\n\t\t * 0x=hex, 0=octal, isdigit=decimal.\n\t\t */\n\t\tif (!isdigit(c))\n\t\t\treturn (0);\n\t\tval = 0; base = 10;\n\t\tif (c == '0') {\n\t\t\tc = *++cp;\n\t\t\tif (c == 'x' || c == 'X')\n\t\t\t\tbase = 16, c = *++cp;\n\t\t\telse\n\t\t\t\tbase = 8;\n\t\t}\n\t\tfor (;;) {\n\t\t\tif (isascii(c) && isdigit(c)) {\n\t\t\t\tval = (val * base) + (c - '0');\n\t\t\t\tc = *++cp;\n\t\t\t} else if (base == 16 && isascii(c) && isxdigit(c)) {\n\t\t\t\tval = (val << 4) |\n\t\t\t\t\t(c + 10 - (islower(c) ? 'a' : 'A'));\n\t\t\t\tc = *++cp;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\tif (c == '.') {\n\t\t\t/*\n\t\t\t * Internet format:\n\t\t\t *\ta.b.c.d\n\t\t\t *\ta.b.c\t(with c treated as 16 bits)\n\t\t\t *\ta.b\t(with b treated as 24 bits)\n\t\t\t */\n\t\t\tif (pp >= parts + 3)\n\t\t\t\treturn (0);\n\t\t\t*pp++ = val;\n\t\t\tc = *++cp;\n\t\t} else\n\t\t\tbreak;\n\t}\n\t/*\n\t * Check for trailing characters.\n\t */\n\tif (c != '\\0' && (!isascii(c) || !isspace(c)))\n\t\treturn (0);\n\t/*\n\t * Concoct the address according to\n\t * the number of parts specified.\n\t */\n\tn = pp - parts + 1;\n\tswitch (n) {\n\n\tcase 0:\n\t\treturn (0);\t\t/* initial nondigit */\n\n\tcase 1:\t\t\t\t/* a -- 32 bits */\n\t\tbreak;\n\n\tcase 2:\t\t\t\t/* a.b -- 8.24 bits */\n\t\tif ((val > 0xffffff) || (parts[0] > 0xff))\n\t\t\treturn (0);\n\t\tval |= parts[0] << 24;\n\t\tbreak;\n\n\tcase 3:\t\t\t\t/* a.b.c -- 8.8.16 bits */\n\t\tif ((val > 0xffff) || (parts[0] > 0xff) || (parts[1] > 0xff))\n\t\t\treturn (0);\n\t\tval |= (parts[0] << 24) | (parts[1] << 16);\n\t\tbreak;\n\n\tcase 4:\t\t\t\t/* a.b.c.d -- 8.8.8.8 bits */\n\t\tif ((val > 0xff) || (parts[0] > 0xff) || (parts[1] > 0xff) || (parts[2] > 0xff))\n\t\t\treturn (0);\n\t\tval |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);\n\t\tbreak;\n\t}\n\tif (addr)\n\t\taddr->s_addr = htonl(val);\n\treturn (1);\n}"
  },
  {
    "function_name": "inet_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/inet_aton.c",
    "lines": "69-77",
    "snippet": "in_addr_t\ninet_addr(const char *cp)\n{\n\tstruct in_addr val;\n\n\tif (inet_aton(cp, &val))\n\t\treturn (val.s_addr);\n\treturn (INADDR_NONE);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inet_aton",
          "args": [
            "cp",
            "&val"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "inet_aton",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/inet_aton.c",
          "lines": "87-177",
          "snippet": "int\ninet_aton(const char *cp, struct in_addr *addr)\n{\n\tu_int32_t val;\n\tint base, n;\n\tchar c;\n\tu_int parts[4];\n\tu_int *pp = parts;\n\n\tc = *cp;\n\tfor (;;) {\n\t\t/*\n\t\t * Collect number up to ``.''.\n\t\t * Values are specified as for C:\n\t\t * 0x=hex, 0=octal, isdigit=decimal.\n\t\t */\n\t\tif (!isdigit(c))\n\t\t\treturn (0);\n\t\tval = 0; base = 10;\n\t\tif (c == '0') {\n\t\t\tc = *++cp;\n\t\t\tif (c == 'x' || c == 'X')\n\t\t\t\tbase = 16, c = *++cp;\n\t\t\telse\n\t\t\t\tbase = 8;\n\t\t}\n\t\tfor (;;) {\n\t\t\tif (isascii(c) && isdigit(c)) {\n\t\t\t\tval = (val * base) + (c - '0');\n\t\t\t\tc = *++cp;\n\t\t\t} else if (base == 16 && isascii(c) && isxdigit(c)) {\n\t\t\t\tval = (val << 4) |\n\t\t\t\t\t(c + 10 - (islower(c) ? 'a' : 'A'));\n\t\t\t\tc = *++cp;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\tif (c == '.') {\n\t\t\t/*\n\t\t\t * Internet format:\n\t\t\t *\ta.b.c.d\n\t\t\t *\ta.b.c\t(with c treated as 16 bits)\n\t\t\t *\ta.b\t(with b treated as 24 bits)\n\t\t\t */\n\t\t\tif (pp >= parts + 3)\n\t\t\t\treturn (0);\n\t\t\t*pp++ = val;\n\t\t\tc = *++cp;\n\t\t} else\n\t\t\tbreak;\n\t}\n\t/*\n\t * Check for trailing characters.\n\t */\n\tif (c != '\\0' && (!isascii(c) || !isspace(c)))\n\t\treturn (0);\n\t/*\n\t * Concoct the address according to\n\t * the number of parts specified.\n\t */\n\tn = pp - parts + 1;\n\tswitch (n) {\n\n\tcase 0:\n\t\treturn (0);\t\t/* initial nondigit */\n\n\tcase 1:\t\t\t\t/* a -- 32 bits */\n\t\tbreak;\n\n\tcase 2:\t\t\t\t/* a.b -- 8.24 bits */\n\t\tif ((val > 0xffffff) || (parts[0] > 0xff))\n\t\t\treturn (0);\n\t\tval |= parts[0] << 24;\n\t\tbreak;\n\n\tcase 3:\t\t\t\t/* a.b.c -- 8.8.16 bits */\n\t\tif ((val > 0xffff) || (parts[0] > 0xff) || (parts[1] > 0xff))\n\t\t\treturn (0);\n\t\tval |= (parts[0] << 24) | (parts[1] << 16);\n\t\tbreak;\n\n\tcase 4:\t\t\t\t/* a.b.c.d -- 8.8.8.8 bits */\n\t\tif ((val > 0xff) || (parts[0] > 0xff) || (parts[1] > 0xff) || (parts[2] > 0xff))\n\t\t\treturn (0);\n\t\tval |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);\n\t\tbreak;\n\t}\n\tif (addr)\n\t\taddr->s_addr = htonl(val);\n\treturn (1);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ninet_aton(const char *cp, struct in_addr *addr)\n{\n\tu_int32_t val;\n\tint base, n;\n\tchar c;\n\tu_int parts[4];\n\tu_int *pp = parts;\n\n\tc = *cp;\n\tfor (;;) {\n\t\t/*\n\t\t * Collect number up to ``.''.\n\t\t * Values are specified as for C:\n\t\t * 0x=hex, 0=octal, isdigit=decimal.\n\t\t */\n\t\tif (!isdigit(c))\n\t\t\treturn (0);\n\t\tval = 0; base = 10;\n\t\tif (c == '0') {\n\t\t\tc = *++cp;\n\t\t\tif (c == 'x' || c == 'X')\n\t\t\t\tbase = 16, c = *++cp;\n\t\t\telse\n\t\t\t\tbase = 8;\n\t\t}\n\t\tfor (;;) {\n\t\t\tif (isascii(c) && isdigit(c)) {\n\t\t\t\tval = (val * base) + (c - '0');\n\t\t\t\tc = *++cp;\n\t\t\t} else if (base == 16 && isascii(c) && isxdigit(c)) {\n\t\t\t\tval = (val << 4) |\n\t\t\t\t\t(c + 10 - (islower(c) ? 'a' : 'A'));\n\t\t\t\tc = *++cp;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\tif (c == '.') {\n\t\t\t/*\n\t\t\t * Internet format:\n\t\t\t *\ta.b.c.d\n\t\t\t *\ta.b.c\t(with c treated as 16 bits)\n\t\t\t *\ta.b\t(with b treated as 24 bits)\n\t\t\t */\n\t\t\tif (pp >= parts + 3)\n\t\t\t\treturn (0);\n\t\t\t*pp++ = val;\n\t\t\tc = *++cp;\n\t\t} else\n\t\t\tbreak;\n\t}\n\t/*\n\t * Check for trailing characters.\n\t */\n\tif (c != '\\0' && (!isascii(c) || !isspace(c)))\n\t\treturn (0);\n\t/*\n\t * Concoct the address according to\n\t * the number of parts specified.\n\t */\n\tn = pp - parts + 1;\n\tswitch (n) {\n\n\tcase 0:\n\t\treturn (0);\t\t/* initial nondigit */\n\n\tcase 1:\t\t\t\t/* a -- 32 bits */\n\t\tbreak;\n\n\tcase 2:\t\t\t\t/* a.b -- 8.24 bits */\n\t\tif ((val > 0xffffff) || (parts[0] > 0xff))\n\t\t\treturn (0);\n\t\tval |= parts[0] << 24;\n\t\tbreak;\n\n\tcase 3:\t\t\t\t/* a.b.c -- 8.8.16 bits */\n\t\tif ((val > 0xffff) || (parts[0] > 0xff) || (parts[1] > 0xff))\n\t\t\treturn (0);\n\t\tval |= (parts[0] << 24) | (parts[1] << 16);\n\t\tbreak;\n\n\tcase 4:\t\t\t\t/* a.b.c.d -- 8.8.8.8 bits */\n\t\tif ((val > 0xff) || (parts[0] > 0xff) || (parts[1] > 0xff) || (parts[2] > 0xff))\n\t\t\treturn (0);\n\t\tval |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);\n\t\tbreak;\n\t}\n\tif (addr)\n\t\taddr->s_addr = htonl(val);\n\treturn (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nin_addr_t\ninet_addr(const char *cp)\n{\n\tstruct in_addr val;\n\n\tif (inet_aton(cp, &val))\n\t\treturn (val.s_addr);\n\treturn (INADDR_NONE);\n}"
  }
]