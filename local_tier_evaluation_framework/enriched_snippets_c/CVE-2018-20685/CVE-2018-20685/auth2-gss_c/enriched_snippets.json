[
  {
    "function_name": "input_gssapi_mic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-gss.c",
    "lines": "278-327",
    "snippet": "static int\ninput_gssapi_mic(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt;\n\tint r, authenticated = 0;\n\tstruct sshbuf *b;\n\tgss_buffer_desc mic, gssbuf;\n\tconst char *displayname;\n\tu_char *p;\n\tsize_t len;\n\n\tif (authctxt == NULL || (authctxt->methoddata == NULL && !use_privsep))\n\t\tfatal(\"No authentication or GSSAPI context\");\n\n\tgssctxt = authctxt->methoddata;\n\n\tif ((r = sshpkt_get_string(ssh, &p, &len)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tmic.value = p;\n\tmic.length = len;\n\tssh_gssapi_buildmic(b, authctxt->user, authctxt->service,\n\t    \"gssapi-with-mic\");\n\n\tif ((gssbuf.value = sshbuf_mutable_ptr(b)) == NULL)\n\t\tfatal(\"%s: sshbuf_mutable_ptr failed\", __func__);\n\tgssbuf.length = sshbuf_len(b);\n\n\tif (!GSS_ERROR(PRIVSEP(ssh_gssapi_checkmic(gssctxt, &gssbuf, &mic))))\n\t\tauthenticated = PRIVSEP(ssh_gssapi_userok(authctxt->user));\n\telse\n\t\tlogit(\"GSSAPI MIC check failed\");\n\n\tsshbuf_free(b);\n\tfree(mic.value);\n\n\tif ((!use_privsep || mm_is_monitor()) &&\n\t    (displayname = ssh_gssapi_displayname()) != NULL)\n\t\tauth2_record_info(authctxt, \"%s\", displayname);\n\n\tauthctxt->postponed = 0;\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_MIC, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE, NULL);\n\tuserauth_finish(ssh, authenticated, \"gssapi-with-mic\", NULL);\n\treturn 0;\n}",
    "includes": [
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"packet.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"dispatch.h\"",
      "#include \"log.h\"",
      "#include \"ssh2.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <stdarg.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "userauth_finish",
          "args": [
            "ssh",
            "authenticated",
            "\"gssapi-with-mic\"",
            "NULL"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "userauth_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2.c",
          "lines": "340-429",
          "snippet": "void\nuserauth_finish(struct ssh *ssh, int authenticated, const char *method,\n    const char *submethod)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tchar *methods;\n\tint partial = 0;\n\n\tif (!authctxt->valid && authenticated)\n\t\tfatal(\"INTERNAL ERROR: authenticated invalid user %s\",\n\t\t    authctxt->user);\n\tif (authenticated && authctxt->postponed)\n\t\tfatal(\"INTERNAL ERROR: authenticated and postponed\");\n\n\t/* Special handling for root */\n\tif (authenticated && authctxt->pw->pw_uid == 0 &&\n\t    !auth_root_allowed(ssh, method)) {\n\t\tauthenticated = 0;\n#ifdef SSH_AUDIT_EVENTS\n\t\tPRIVSEP(audit_event(SSH_LOGIN_ROOT_DENIED));\n#endif\n\t}\n\n\tif (authenticated && options.num_auth_methods != 0) {\n\t\tif (!auth2_update_methods_lists(authctxt, method, submethod)) {\n\t\t\tauthenticated = 0;\n\t\t\tpartial = 1;\n\t\t}\n\t}\n\n\t/* Log before sending the reply */\n\tauth_log(authctxt, authenticated, partial, method, submethod);\n\n\t/* Update information exposed to session */\n\tif (authenticated || partial)\n\t\tauth2_update_session_info(authctxt, method, submethod);\n\n\tif (authctxt->postponed)\n\t\treturn;\n\n#ifdef USE_PAM\n\tif (options.use_pam && authenticated) {\n\t\tint r;\n\n\t\tif (!PRIVSEP(do_pam_account())) {\n\t\t\t/* if PAM returned a message, send it to the user */\n\t\t\tif (sshbuf_len(loginmsg) > 0) {\n\t\t\t\tif ((r = sshbuf_put(loginmsg, \"\\0\", 1)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tuserauth_send_banner(sshbuf_ptr(loginmsg));\n\t\t\t\tpacket_write_wait();\n\t\t\t}\n\t\t\tfatal(\"Access denied for user %s by PAM account \"\n\t\t\t    \"configuration\", authctxt->user);\n\t\t}\n\t}\n#endif\n\n\tif (authenticated == 1) {\n\t\t/* turn off userauth */\n\t\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_REQUEST, &dispatch_protocol_ignore);\n\t\tpacket_start(SSH2_MSG_USERAUTH_SUCCESS);\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\t\t/* now we can break out */\n\t\tauthctxt->success = 1;\n\t\tssh_packet_set_log_preamble(ssh, \"user %s\", authctxt->user);\n\t} else {\n\t\t/* Allow initial try of \"none\" auth without failure penalty */\n\t\tif (!partial && !authctxt->server_caused_failure &&\n\t\t    (authctxt->attempt > 1 || strcmp(method, \"none\") != 0))\n\t\t\tauthctxt->failures++;\n\t\tif (authctxt->failures >= options.max_authtries) {\n#ifdef SSH_AUDIT_EVENTS\n\t\t\tPRIVSEP(audit_event(SSH_LOGIN_EXCEED_MAXTRIES));\n#endif\n\t\t\tauth_maxtries_exceeded(authctxt);\n\t\t}\n\t\tmethods = authmethods_get(authctxt);\n\t\tdebug3(\"%s: failure partial=%d next methods=\\\"%s\\\"\", __func__,\n\t\t    partial, methods);\n\t\tpacket_start(SSH2_MSG_USERAUTH_FAILURE);\n\t\tpacket_put_cstring(methods);\n\t\tpacket_put_char(partial);\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\t\tfree(methods);\n\t}\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"pathnames.h\"",
            "#include \"dispatch.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "extern struct sshbuf *loginmsg;",
            "static int input_service_request(int, u_int32_t, struct ssh *);",
            "static int input_userauth_request(int, u_int32_t, struct ssh *);",
            "static Authmethod *authmethod_lookup(Authctxt *, const char *);",
            "static char *authmethods_get(Authctxt *authctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"pathnames.h\"\n#include \"dispatch.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern struct sshbuf *loginmsg;\nstatic int input_service_request(int, u_int32_t, struct ssh *);\nstatic int input_userauth_request(int, u_int32_t, struct ssh *);\nstatic Authmethod *authmethod_lookup(Authctxt *, const char *);\nstatic char *authmethods_get(Authctxt *authctxt);\n\nvoid\nuserauth_finish(struct ssh *ssh, int authenticated, const char *method,\n    const char *submethod)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tchar *methods;\n\tint partial = 0;\n\n\tif (!authctxt->valid && authenticated)\n\t\tfatal(\"INTERNAL ERROR: authenticated invalid user %s\",\n\t\t    authctxt->user);\n\tif (authenticated && authctxt->postponed)\n\t\tfatal(\"INTERNAL ERROR: authenticated and postponed\");\n\n\t/* Special handling for root */\n\tif (authenticated && authctxt->pw->pw_uid == 0 &&\n\t    !auth_root_allowed(ssh, method)) {\n\t\tauthenticated = 0;\n#ifdef SSH_AUDIT_EVENTS\n\t\tPRIVSEP(audit_event(SSH_LOGIN_ROOT_DENIED));\n#endif\n\t}\n\n\tif (authenticated && options.num_auth_methods != 0) {\n\t\tif (!auth2_update_methods_lists(authctxt, method, submethod)) {\n\t\t\tauthenticated = 0;\n\t\t\tpartial = 1;\n\t\t}\n\t}\n\n\t/* Log before sending the reply */\n\tauth_log(authctxt, authenticated, partial, method, submethod);\n\n\t/* Update information exposed to session */\n\tif (authenticated || partial)\n\t\tauth2_update_session_info(authctxt, method, submethod);\n\n\tif (authctxt->postponed)\n\t\treturn;\n\n#ifdef USE_PAM\n\tif (options.use_pam && authenticated) {\n\t\tint r;\n\n\t\tif (!PRIVSEP(do_pam_account())) {\n\t\t\t/* if PAM returned a message, send it to the user */\n\t\t\tif (sshbuf_len(loginmsg) > 0) {\n\t\t\t\tif ((r = sshbuf_put(loginmsg, \"\\0\", 1)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tuserauth_send_banner(sshbuf_ptr(loginmsg));\n\t\t\t\tpacket_write_wait();\n\t\t\t}\n\t\t\tfatal(\"Access denied for user %s by PAM account \"\n\t\t\t    \"configuration\", authctxt->user);\n\t\t}\n\t}\n#endif\n\n\tif (authenticated == 1) {\n\t\t/* turn off userauth */\n\t\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_REQUEST, &dispatch_protocol_ignore);\n\t\tpacket_start(SSH2_MSG_USERAUTH_SUCCESS);\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\t\t/* now we can break out */\n\t\tauthctxt->success = 1;\n\t\tssh_packet_set_log_preamble(ssh, \"user %s\", authctxt->user);\n\t} else {\n\t\t/* Allow initial try of \"none\" auth without failure penalty */\n\t\tif (!partial && !authctxt->server_caused_failure &&\n\t\t    (authctxt->attempt > 1 || strcmp(method, \"none\") != 0))\n\t\t\tauthctxt->failures++;\n\t\tif (authctxt->failures >= options.max_authtries) {\n#ifdef SSH_AUDIT_EVENTS\n\t\t\tPRIVSEP(audit_event(SSH_LOGIN_EXCEED_MAXTRIES));\n#endif\n\t\t\tauth_maxtries_exceeded(authctxt);\n\t\t}\n\t\tmethods = authmethods_get(authctxt);\n\t\tdebug3(\"%s: failure partial=%d next methods=\\\"%s\\\"\", __func__,\n\t\t    partial, methods);\n\t\tpacket_start(SSH2_MSG_USERAUTH_FAILURE);\n\t\tpacket_put_cstring(methods);\n\t\tpacket_put_char(partial);\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\t\tfree(methods);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_dispatch_set",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE",
            "NULL"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_dispatch_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dispatch.c",
          "lines": "81-85",
          "snippet": "void\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"dispatch.h\"",
            "#include \"log.h\"",
            "#include \"ssh2.h\"",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include <stdarg.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth2_record_info",
          "args": [
            "authctxt",
            "\"%s\"",
            "displayname"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "auth2_record_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2.c",
          "lines": "680-695",
          "snippet": "void\nauth2_record_info(Authctxt *authctxt, const char *fmt, ...)\n{\n\tva_list ap;\n        int i;\n\n\tfree(authctxt->auth_method_info);\n\tauthctxt->auth_method_info = NULL;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(&authctxt->auth_method_info, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || authctxt->auth_method_info == NULL)\n\t\tfatal(\"%s: vasprintf failed\", __func__);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"pathnames.h\"",
            "#include \"dispatch.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Authmethod *authmethod_lookup(Authctxt *, const char *);",
            "static char *authmethods_get(Authctxt *authctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"pathnames.h\"\n#include \"dispatch.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Authmethod *authmethod_lookup(Authctxt *, const char *);\nstatic char *authmethods_get(Authctxt *authctxt);\n\nvoid\nauth2_record_info(Authctxt *authctxt, const char *fmt, ...)\n{\n\tva_list ap;\n        int i;\n\n\tfree(authctxt->auth_method_info);\n\tauthctxt->auth_method_info = NULL;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(&authctxt->auth_method_info, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || authctxt->auth_method_info == NULL)\n\t\tfatal(\"%s: vasprintf failed\", __func__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_displayname",
          "args": [],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_displayname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-serv.c",
          "lines": "396-402",
          "snippet": "const char *ssh_gssapi_displayname(void)\n{\n\tif (gssapi_client.displayname.length == 0 ||\n\t    gssapi_client.displayname.value == NULL)\n\t\treturn NULL;\n\treturn (char *)gssapi_client.displayname.value;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"log.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"log.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *ssh_gssapi_displayname(void)\n{\n\tif (gssapi_client.displayname.length == 0 ||\n\t    gssapi_client.displayname.value == NULL)\n\t\treturn NULL;\n\treturn (char *)gssapi_client.displayname.value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_is_monitor",
          "args": [],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "mm_is_monitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "111-119",
          "snippet": "int\nmm_is_monitor(void)\n{\n\t/*\n\t * m_pid is only set in the privileged part, and\n\t * points to the unprivileged child.\n\t */\n\treturn (pmonitor && pmonitor->m_pid > 0);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct monitor *pmonitor;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern struct monitor *pmonitor;\n\nint\nmm_is_monitor(void)\n{\n\t/*\n\t * m_pid is only set in the privileged part, and\n\t * points to the unprivileged child.\n\t */\n\treturn (pmonitor && pmonitor->m_pid > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "mic.value"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"GSSAPI MIC check failed\""
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRIVSEP",
          "args": [
            "ssh_gssapi_userok(authctxt->user)"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_userok",
          "args": [
            "authctxt->user"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_userok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-serv.c",
          "lines": "358-383",
          "snippet": "int\nssh_gssapi_userok(char *user)\n{\n\tOM_uint32 lmin;\n\n\tif (gssapi_client.exportedname.length == 0 ||\n\t    gssapi_client.exportedname.value == NULL) {\n\t\tdebug(\"No suitable client data\");\n\t\treturn 0;\n\t}\n\tif (gssapi_client.mech && gssapi_client.mech->userok)\n\t\tif ((*gssapi_client.mech->userok)(&gssapi_client, user))\n\t\t\treturn 1;\n\t\telse {\n\t\t\t/* Destroy delegated credentials if userok fails */\n\t\t\tgss_release_buffer(&lmin, &gssapi_client.displayname);\n\t\t\tgss_release_buffer(&lmin, &gssapi_client.exportedname);\n\t\t\tgss_release_cred(&lmin, &gssapi_client.creds);\n\t\t\texplicit_bzero(&gssapi_client,\n\t\t\t    sizeof(ssh_gssapi_client));\n\t\t\treturn 0;\n\t\t}\n\telse\n\t\tdebug(\"ssh_gssapi_userok: Unknown GSSAPI mechanism\");\n\treturn (0);\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"log.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"log.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_gssapi_userok(char *user)\n{\n\tOM_uint32 lmin;\n\n\tif (gssapi_client.exportedname.length == 0 ||\n\t    gssapi_client.exportedname.value == NULL) {\n\t\tdebug(\"No suitable client data\");\n\t\treturn 0;\n\t}\n\tif (gssapi_client.mech && gssapi_client.mech->userok)\n\t\tif ((*gssapi_client.mech->userok)(&gssapi_client, user))\n\t\t\treturn 1;\n\t\telse {\n\t\t\t/* Destroy delegated credentials if userok fails */\n\t\t\tgss_release_buffer(&lmin, &gssapi_client.displayname);\n\t\t\tgss_release_buffer(&lmin, &gssapi_client.exportedname);\n\t\t\tgss_release_cred(&lmin, &gssapi_client.creds);\n\t\t\texplicit_bzero(&gssapi_client,\n\t\t\t    sizeof(ssh_gssapi_client));\n\t\t\treturn 0;\n\t\t}\n\telse\n\t\tdebug(\"ssh_gssapi_userok: Unknown GSSAPI mechanism\");\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GSS_ERROR",
          "args": [
            "PRIVSEP(ssh_gssapi_checkmic(gssctxt, &gssbuf, &mic))"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRIVSEP",
          "args": [
            "ssh_gssapi_checkmic(gssctxt, &gssbuf, &mic)"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_checkmic",
          "args": [
            "gssctxt",
            "&gssbuf",
            "&mic"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_checkmic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-serv.c",
          "lines": "386-393",
          "snippet": "OM_uint32\nssh_gssapi_checkmic(Gssctxt *ctx, gss_buffer_t gssbuf, gss_buffer_t gssmic)\n{\n\tctx->major = gss_verify_mic(&ctx->minor, ctx->context,\n\t    gssbuf, gssmic, NULL);\n\n\treturn (ctx->major);\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"log.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"log.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOM_uint32\nssh_gssapi_checkmic(Gssctxt *ctx, gss_buffer_t gssbuf, gss_buffer_t gssmic)\n{\n\tctx->major = gss_verify_mic(&ctx->minor, ctx->context,\n\t    gssbuf, gssmic, NULL);\n\n\treturn (ctx->major);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "b"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_mutable_ptr failed\"",
            "__func__"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_mutable_ptr",
          "args": [
            "b"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_mutable_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "276-282",
          "snippet": "u_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_buildmic",
          "args": [
            "b",
            "authctxt->user",
            "authctxt->service",
            "\"gssapi-with-mic\""
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_buildmic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-genr.c",
          "lines": "260-273",
          "snippet": "void\nssh_gssapi_buildmic(struct sshbuf *b, const char *user, const char *service,\n    const char *context)\n{\n\tint r;\n\n\tsshbuf_reset(b);\n\tif ((r = sshbuf_put_string(b, session_id2, session_id2_len)) != 0 ||\n\t    (r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, user)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, service)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, context)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"ssh2.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"ssh2.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_gssapi_buildmic(struct sshbuf *b, const char *user, const char *service,\n    const char *context)\n{\n\tint r;\n\n\tsshbuf_reset(b);\n\tif ((r = sshbuf_put_string(b, session_id2, session_id2_len)) != 0 ||\n\t    (r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, user)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, service)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, context)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_string",
          "args": [
            "ssh",
            "&p",
            "&len"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2520-2524",
          "snippet": "int\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"packet.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ninput_gssapi_mic(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt;\n\tint r, authenticated = 0;\n\tstruct sshbuf *b;\n\tgss_buffer_desc mic, gssbuf;\n\tconst char *displayname;\n\tu_char *p;\n\tsize_t len;\n\n\tif (authctxt == NULL || (authctxt->methoddata == NULL && !use_privsep))\n\t\tfatal(\"No authentication or GSSAPI context\");\n\n\tgssctxt = authctxt->methoddata;\n\n\tif ((r = sshpkt_get_string(ssh, &p, &len)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tmic.value = p;\n\tmic.length = len;\n\tssh_gssapi_buildmic(b, authctxt->user, authctxt->service,\n\t    \"gssapi-with-mic\");\n\n\tif ((gssbuf.value = sshbuf_mutable_ptr(b)) == NULL)\n\t\tfatal(\"%s: sshbuf_mutable_ptr failed\", __func__);\n\tgssbuf.length = sshbuf_len(b);\n\n\tif (!GSS_ERROR(PRIVSEP(ssh_gssapi_checkmic(gssctxt, &gssbuf, &mic))))\n\t\tauthenticated = PRIVSEP(ssh_gssapi_userok(authctxt->user));\n\telse\n\t\tlogit(\"GSSAPI MIC check failed\");\n\n\tsshbuf_free(b);\n\tfree(mic.value);\n\n\tif ((!use_privsep || mm_is_monitor()) &&\n\t    (displayname = ssh_gssapi_displayname()) != NULL)\n\t\tauth2_record_info(authctxt, \"%s\", displayname);\n\n\tauthctxt->postponed = 0;\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_MIC, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE, NULL);\n\tuserauth_finish(ssh, authenticated, \"gssapi-with-mic\", NULL);\n\treturn 0;\n}"
  },
  {
    "function_name": "input_gssapi_exchange_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-gss.c",
    "lines": "245-276",
    "snippet": "static int\ninput_gssapi_exchange_complete(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tint r, authenticated;\n\tconst char *displayname;\n\n\tif (authctxt == NULL || (authctxt->methoddata == NULL && !use_privsep))\n\t\tfatal(\"No authentication or GSSAPI context\");\n\n\t/*\n\t * We don't need to check the status, because we're only enabled in\n\t * the dispatcher once the exchange is complete\n\t */\n\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tauthenticated = PRIVSEP(ssh_gssapi_userok(authctxt->user));\n\n\tif ((!use_privsep || mm_is_monitor()) &&\n\t    (displayname = ssh_gssapi_displayname()) != NULL)\n\t\tauth2_record_info(authctxt, \"%s\", displayname);\n\n\tauthctxt->postponed = 0;\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_MIC, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE, NULL);\n\tuserauth_finish(ssh, authenticated, \"gssapi-with-mic\", NULL);\n\treturn 0;\n}",
    "includes": [
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"packet.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"dispatch.h\"",
      "#include \"log.h\"",
      "#include \"ssh2.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <stdarg.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "userauth_finish",
          "args": [
            "ssh",
            "authenticated",
            "\"gssapi-with-mic\"",
            "NULL"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "userauth_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2.c",
          "lines": "340-429",
          "snippet": "void\nuserauth_finish(struct ssh *ssh, int authenticated, const char *method,\n    const char *submethod)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tchar *methods;\n\tint partial = 0;\n\n\tif (!authctxt->valid && authenticated)\n\t\tfatal(\"INTERNAL ERROR: authenticated invalid user %s\",\n\t\t    authctxt->user);\n\tif (authenticated && authctxt->postponed)\n\t\tfatal(\"INTERNAL ERROR: authenticated and postponed\");\n\n\t/* Special handling for root */\n\tif (authenticated && authctxt->pw->pw_uid == 0 &&\n\t    !auth_root_allowed(ssh, method)) {\n\t\tauthenticated = 0;\n#ifdef SSH_AUDIT_EVENTS\n\t\tPRIVSEP(audit_event(SSH_LOGIN_ROOT_DENIED));\n#endif\n\t}\n\n\tif (authenticated && options.num_auth_methods != 0) {\n\t\tif (!auth2_update_methods_lists(authctxt, method, submethod)) {\n\t\t\tauthenticated = 0;\n\t\t\tpartial = 1;\n\t\t}\n\t}\n\n\t/* Log before sending the reply */\n\tauth_log(authctxt, authenticated, partial, method, submethod);\n\n\t/* Update information exposed to session */\n\tif (authenticated || partial)\n\t\tauth2_update_session_info(authctxt, method, submethod);\n\n\tif (authctxt->postponed)\n\t\treturn;\n\n#ifdef USE_PAM\n\tif (options.use_pam && authenticated) {\n\t\tint r;\n\n\t\tif (!PRIVSEP(do_pam_account())) {\n\t\t\t/* if PAM returned a message, send it to the user */\n\t\t\tif (sshbuf_len(loginmsg) > 0) {\n\t\t\t\tif ((r = sshbuf_put(loginmsg, \"\\0\", 1)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tuserauth_send_banner(sshbuf_ptr(loginmsg));\n\t\t\t\tpacket_write_wait();\n\t\t\t}\n\t\t\tfatal(\"Access denied for user %s by PAM account \"\n\t\t\t    \"configuration\", authctxt->user);\n\t\t}\n\t}\n#endif\n\n\tif (authenticated == 1) {\n\t\t/* turn off userauth */\n\t\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_REQUEST, &dispatch_protocol_ignore);\n\t\tpacket_start(SSH2_MSG_USERAUTH_SUCCESS);\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\t\t/* now we can break out */\n\t\tauthctxt->success = 1;\n\t\tssh_packet_set_log_preamble(ssh, \"user %s\", authctxt->user);\n\t} else {\n\t\t/* Allow initial try of \"none\" auth without failure penalty */\n\t\tif (!partial && !authctxt->server_caused_failure &&\n\t\t    (authctxt->attempt > 1 || strcmp(method, \"none\") != 0))\n\t\t\tauthctxt->failures++;\n\t\tif (authctxt->failures >= options.max_authtries) {\n#ifdef SSH_AUDIT_EVENTS\n\t\t\tPRIVSEP(audit_event(SSH_LOGIN_EXCEED_MAXTRIES));\n#endif\n\t\t\tauth_maxtries_exceeded(authctxt);\n\t\t}\n\t\tmethods = authmethods_get(authctxt);\n\t\tdebug3(\"%s: failure partial=%d next methods=\\\"%s\\\"\", __func__,\n\t\t    partial, methods);\n\t\tpacket_start(SSH2_MSG_USERAUTH_FAILURE);\n\t\tpacket_put_cstring(methods);\n\t\tpacket_put_char(partial);\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\t\tfree(methods);\n\t}\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"pathnames.h\"",
            "#include \"dispatch.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "extern struct sshbuf *loginmsg;",
            "static int input_service_request(int, u_int32_t, struct ssh *);",
            "static int input_userauth_request(int, u_int32_t, struct ssh *);",
            "static Authmethod *authmethod_lookup(Authctxt *, const char *);",
            "static char *authmethods_get(Authctxt *authctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"pathnames.h\"\n#include \"dispatch.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern struct sshbuf *loginmsg;\nstatic int input_service_request(int, u_int32_t, struct ssh *);\nstatic int input_userauth_request(int, u_int32_t, struct ssh *);\nstatic Authmethod *authmethod_lookup(Authctxt *, const char *);\nstatic char *authmethods_get(Authctxt *authctxt);\n\nvoid\nuserauth_finish(struct ssh *ssh, int authenticated, const char *method,\n    const char *submethod)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tchar *methods;\n\tint partial = 0;\n\n\tif (!authctxt->valid && authenticated)\n\t\tfatal(\"INTERNAL ERROR: authenticated invalid user %s\",\n\t\t    authctxt->user);\n\tif (authenticated && authctxt->postponed)\n\t\tfatal(\"INTERNAL ERROR: authenticated and postponed\");\n\n\t/* Special handling for root */\n\tif (authenticated && authctxt->pw->pw_uid == 0 &&\n\t    !auth_root_allowed(ssh, method)) {\n\t\tauthenticated = 0;\n#ifdef SSH_AUDIT_EVENTS\n\t\tPRIVSEP(audit_event(SSH_LOGIN_ROOT_DENIED));\n#endif\n\t}\n\n\tif (authenticated && options.num_auth_methods != 0) {\n\t\tif (!auth2_update_methods_lists(authctxt, method, submethod)) {\n\t\t\tauthenticated = 0;\n\t\t\tpartial = 1;\n\t\t}\n\t}\n\n\t/* Log before sending the reply */\n\tauth_log(authctxt, authenticated, partial, method, submethod);\n\n\t/* Update information exposed to session */\n\tif (authenticated || partial)\n\t\tauth2_update_session_info(authctxt, method, submethod);\n\n\tif (authctxt->postponed)\n\t\treturn;\n\n#ifdef USE_PAM\n\tif (options.use_pam && authenticated) {\n\t\tint r;\n\n\t\tif (!PRIVSEP(do_pam_account())) {\n\t\t\t/* if PAM returned a message, send it to the user */\n\t\t\tif (sshbuf_len(loginmsg) > 0) {\n\t\t\t\tif ((r = sshbuf_put(loginmsg, \"\\0\", 1)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tuserauth_send_banner(sshbuf_ptr(loginmsg));\n\t\t\t\tpacket_write_wait();\n\t\t\t}\n\t\t\tfatal(\"Access denied for user %s by PAM account \"\n\t\t\t    \"configuration\", authctxt->user);\n\t\t}\n\t}\n#endif\n\n\tif (authenticated == 1) {\n\t\t/* turn off userauth */\n\t\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_REQUEST, &dispatch_protocol_ignore);\n\t\tpacket_start(SSH2_MSG_USERAUTH_SUCCESS);\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\t\t/* now we can break out */\n\t\tauthctxt->success = 1;\n\t\tssh_packet_set_log_preamble(ssh, \"user %s\", authctxt->user);\n\t} else {\n\t\t/* Allow initial try of \"none\" auth without failure penalty */\n\t\tif (!partial && !authctxt->server_caused_failure &&\n\t\t    (authctxt->attempt > 1 || strcmp(method, \"none\") != 0))\n\t\t\tauthctxt->failures++;\n\t\tif (authctxt->failures >= options.max_authtries) {\n#ifdef SSH_AUDIT_EVENTS\n\t\t\tPRIVSEP(audit_event(SSH_LOGIN_EXCEED_MAXTRIES));\n#endif\n\t\t\tauth_maxtries_exceeded(authctxt);\n\t\t}\n\t\tmethods = authmethods_get(authctxt);\n\t\tdebug3(\"%s: failure partial=%d next methods=\\\"%s\\\"\", __func__,\n\t\t    partial, methods);\n\t\tpacket_start(SSH2_MSG_USERAUTH_FAILURE);\n\t\tpacket_put_cstring(methods);\n\t\tpacket_put_char(partial);\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\t\tfree(methods);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_dispatch_set",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE",
            "NULL"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_dispatch_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dispatch.c",
          "lines": "81-85",
          "snippet": "void\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"dispatch.h\"",
            "#include \"log.h\"",
            "#include \"ssh2.h\"",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include <stdarg.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth2_record_info",
          "args": [
            "authctxt",
            "\"%s\"",
            "displayname"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "auth2_record_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2.c",
          "lines": "680-695",
          "snippet": "void\nauth2_record_info(Authctxt *authctxt, const char *fmt, ...)\n{\n\tva_list ap;\n        int i;\n\n\tfree(authctxt->auth_method_info);\n\tauthctxt->auth_method_info = NULL;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(&authctxt->auth_method_info, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || authctxt->auth_method_info == NULL)\n\t\tfatal(\"%s: vasprintf failed\", __func__);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"pathnames.h\"",
            "#include \"dispatch.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Authmethod *authmethod_lookup(Authctxt *, const char *);",
            "static char *authmethods_get(Authctxt *authctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"pathnames.h\"\n#include \"dispatch.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Authmethod *authmethod_lookup(Authctxt *, const char *);\nstatic char *authmethods_get(Authctxt *authctxt);\n\nvoid\nauth2_record_info(Authctxt *authctxt, const char *fmt, ...)\n{\n\tva_list ap;\n        int i;\n\n\tfree(authctxt->auth_method_info);\n\tauthctxt->auth_method_info = NULL;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(&authctxt->auth_method_info, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || authctxt->auth_method_info == NULL)\n\t\tfatal(\"%s: vasprintf failed\", __func__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_displayname",
          "args": [],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_displayname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-serv.c",
          "lines": "396-402",
          "snippet": "const char *ssh_gssapi_displayname(void)\n{\n\tif (gssapi_client.displayname.length == 0 ||\n\t    gssapi_client.displayname.value == NULL)\n\t\treturn NULL;\n\treturn (char *)gssapi_client.displayname.value;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"log.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"log.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *ssh_gssapi_displayname(void)\n{\n\tif (gssapi_client.displayname.length == 0 ||\n\t    gssapi_client.displayname.value == NULL)\n\t\treturn NULL;\n\treturn (char *)gssapi_client.displayname.value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_is_monitor",
          "args": [],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "mm_is_monitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "111-119",
          "snippet": "int\nmm_is_monitor(void)\n{\n\t/*\n\t * m_pid is only set in the privileged part, and\n\t * points to the unprivileged child.\n\t */\n\treturn (pmonitor && pmonitor->m_pid > 0);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct monitor *pmonitor;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern struct monitor *pmonitor;\n\nint\nmm_is_monitor(void)\n{\n\t/*\n\t * m_pid is only set in the privileged part, and\n\t * points to the unprivileged child.\n\t */\n\treturn (pmonitor && pmonitor->m_pid > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRIVSEP",
          "args": [
            "ssh_gssapi_userok(authctxt->user)"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_userok",
          "args": [
            "authctxt->user"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_userok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-serv.c",
          "lines": "358-383",
          "snippet": "int\nssh_gssapi_userok(char *user)\n{\n\tOM_uint32 lmin;\n\n\tif (gssapi_client.exportedname.length == 0 ||\n\t    gssapi_client.exportedname.value == NULL) {\n\t\tdebug(\"No suitable client data\");\n\t\treturn 0;\n\t}\n\tif (gssapi_client.mech && gssapi_client.mech->userok)\n\t\tif ((*gssapi_client.mech->userok)(&gssapi_client, user))\n\t\t\treturn 1;\n\t\telse {\n\t\t\t/* Destroy delegated credentials if userok fails */\n\t\t\tgss_release_buffer(&lmin, &gssapi_client.displayname);\n\t\t\tgss_release_buffer(&lmin, &gssapi_client.exportedname);\n\t\t\tgss_release_cred(&lmin, &gssapi_client.creds);\n\t\t\texplicit_bzero(&gssapi_client,\n\t\t\t    sizeof(ssh_gssapi_client));\n\t\t\treturn 0;\n\t\t}\n\telse\n\t\tdebug(\"ssh_gssapi_userok: Unknown GSSAPI mechanism\");\n\treturn (0);\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"log.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"log.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_gssapi_userok(char *user)\n{\n\tOM_uint32 lmin;\n\n\tif (gssapi_client.exportedname.length == 0 ||\n\t    gssapi_client.exportedname.value == NULL) {\n\t\tdebug(\"No suitable client data\");\n\t\treturn 0;\n\t}\n\tif (gssapi_client.mech && gssapi_client.mech->userok)\n\t\tif ((*gssapi_client.mech->userok)(&gssapi_client, user))\n\t\t\treturn 1;\n\t\telse {\n\t\t\t/* Destroy delegated credentials if userok fails */\n\t\t\tgss_release_buffer(&lmin, &gssapi_client.displayname);\n\t\t\tgss_release_buffer(&lmin, &gssapi_client.exportedname);\n\t\t\tgss_release_cred(&lmin, &gssapi_client.creds);\n\t\t\texplicit_bzero(&gssapi_client,\n\t\t\t    sizeof(ssh_gssapi_client));\n\t\t\treturn 0;\n\t\t}\n\telse\n\t\tdebug(\"ssh_gssapi_userok: Unknown GSSAPI mechanism\");\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_end",
          "args": [
            "ssh"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2555-2561",
          "snippet": "int\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"packet.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ninput_gssapi_exchange_complete(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tint r, authenticated;\n\tconst char *displayname;\n\n\tif (authctxt == NULL || (authctxt->methoddata == NULL && !use_privsep))\n\t\tfatal(\"No authentication or GSSAPI context\");\n\n\t/*\n\t * We don't need to check the status, because we're only enabled in\n\t * the dispatcher once the exchange is complete\n\t */\n\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tauthenticated = PRIVSEP(ssh_gssapi_userok(authctxt->user));\n\n\tif ((!use_privsep || mm_is_monitor()) &&\n\t    (displayname = ssh_gssapi_displayname()) != NULL)\n\t\tauth2_record_info(authctxt, \"%s\", displayname);\n\n\tauthctxt->postponed = 0;\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_MIC, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE, NULL);\n\tuserauth_finish(ssh, authenticated, \"gssapi-with-mic\", NULL);\n\treturn 0;\n}"
  },
  {
    "function_name": "input_gssapi_errtok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-gss.c",
    "lines": "201-237",
    "snippet": "static int\ninput_gssapi_errtok(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt;\n\tgss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc recv_tok;\n\tOM_uint32 maj_status;\n\tint r;\n\tu_char *p;\n\tsize_t len;\n\n\tif (authctxt == NULL || (authctxt->methoddata == NULL && !use_privsep))\n\t\tfatal(\"No authentication or GSSAPI context\");\n\n\tgssctxt = authctxt->methoddata;\n\tif ((r = sshpkt_get_string(ssh, &p, &len)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\trecv_tok.value = p;\n\trecv_tok.length = len;\n\n\t/* Push the error token into GSSAPI to see what it says */\n\tmaj_status = PRIVSEP(ssh_gssapi_accept_ctx(gssctxt, &recv_tok,\n\t    &send_tok, NULL));\n\n\tfree(recv_tok.value);\n\n\t/* We can't return anything to the client, even if we wanted to */\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, NULL);\n\n\t/* The client will have already moved on to the next auth */\n\n\tgss_release_buffer(&maj_status, &send_tok);\n\treturn 0;\n}",
    "includes": [
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"packet.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"dispatch.h\"",
      "#include \"log.h\"",
      "#include \"ssh2.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <stdarg.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gss_release_buffer",
          "args": [
            "&maj_status",
            "&send_tok"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_dispatch_set",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_GSSAPI_ERRTOK",
            "NULL"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_dispatch_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dispatch.c",
          "lines": "81-85",
          "snippet": "void\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"dispatch.h\"",
            "#include \"log.h\"",
            "#include \"ssh2.h\"",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include <stdarg.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "recv_tok.value"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRIVSEP",
          "args": [
            "ssh_gssapi_accept_ctx(gssctxt, &recv_tok,\n\t    &send_tok, NULL)"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_accept_ctx",
          "args": [
            "gssctxt",
            "&recv_tok",
            "&send_tok",
            "NULL"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_accept_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-serv.c",
          "lines": "175-208",
          "snippet": "OM_uint32\nssh_gssapi_accept_ctx(Gssctxt *ctx, gss_buffer_desc *recv_tok,\n    gss_buffer_desc *send_tok, OM_uint32 *flags)\n{\n\tOM_uint32 status;\n\tgss_OID mech;\n\n\tctx->major = gss_accept_sec_context(&ctx->minor,\n\t    &ctx->context, ctx->creds, recv_tok,\n\t    GSS_C_NO_CHANNEL_BINDINGS, &ctx->client, &mech,\n\t    send_tok, flags, NULL, &ctx->client_creds);\n\n\tif (GSS_ERROR(ctx->major))\n\t\tssh_gssapi_error(ctx);\n\n\tif (ctx->client_creds)\n\t\tdebug(\"Received some client credentials\");\n\telse\n\t\tdebug(\"Got no client credentials\");\n\n\tstatus = ctx->major;\n\n\t/* Now, if we're complete and we have the right flags, then\n\t * we flag the user as also having been authenticated\n\t */\n\n\tif (((flags == NULL) || ((*flags & GSS_C_MUTUAL_FLAG) &&\n\t    (*flags & GSS_C_INTEG_FLAG))) && (ctx->major == GSS_S_COMPLETE)) {\n\t\tif (ssh_gssapi_getclient(ctx, &gssapi_client))\n\t\t\tfatal(\"Couldn't convert client name\");\n\t}\n\n\treturn (status);\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"log.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"log.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOM_uint32\nssh_gssapi_accept_ctx(Gssctxt *ctx, gss_buffer_desc *recv_tok,\n    gss_buffer_desc *send_tok, OM_uint32 *flags)\n{\n\tOM_uint32 status;\n\tgss_OID mech;\n\n\tctx->major = gss_accept_sec_context(&ctx->minor,\n\t    &ctx->context, ctx->creds, recv_tok,\n\t    GSS_C_NO_CHANNEL_BINDINGS, &ctx->client, &mech,\n\t    send_tok, flags, NULL, &ctx->client_creds);\n\n\tif (GSS_ERROR(ctx->major))\n\t\tssh_gssapi_error(ctx);\n\n\tif (ctx->client_creds)\n\t\tdebug(\"Received some client credentials\");\n\telse\n\t\tdebug(\"Got no client credentials\");\n\n\tstatus = ctx->major;\n\n\t/* Now, if we're complete and we have the right flags, then\n\t * we flag the user as also having been authenticated\n\t */\n\n\tif (((flags == NULL) || ((*flags & GSS_C_MUTUAL_FLAG) &&\n\t    (*flags & GSS_C_INTEG_FLAG))) && (ctx->major == GSS_S_COMPLETE)) {\n\t\tif (ssh_gssapi_getclient(ctx, &gssapi_client))\n\t\t\tfatal(\"Couldn't convert client name\");\n\t}\n\n\treturn (status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_end",
          "args": [
            "ssh"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2555-2561",
          "snippet": "int\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_string",
          "args": [
            "ssh",
            "&p",
            "&len"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2520-2524",
          "snippet": "int\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"packet.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ninput_gssapi_errtok(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt;\n\tgss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc recv_tok;\n\tOM_uint32 maj_status;\n\tint r;\n\tu_char *p;\n\tsize_t len;\n\n\tif (authctxt == NULL || (authctxt->methoddata == NULL && !use_privsep))\n\t\tfatal(\"No authentication or GSSAPI context\");\n\n\tgssctxt = authctxt->methoddata;\n\tif ((r = sshpkt_get_string(ssh, &p, &len)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\trecv_tok.value = p;\n\trecv_tok.length = len;\n\n\t/* Push the error token into GSSAPI to see what it says */\n\tmaj_status = PRIVSEP(ssh_gssapi_accept_ctx(gssctxt, &recv_tok,\n\t    &send_tok, NULL));\n\n\tfree(recv_tok.value);\n\n\t/* We can't return anything to the client, even if we wanted to */\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, NULL);\n\n\t/* The client will have already moved on to the next auth */\n\n\tgss_release_buffer(&maj_status, &send_tok);\n\treturn 0;\n}"
  },
  {
    "function_name": "input_gssapi_token",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-gss.c",
    "lines": "137-199",
    "snippet": "static int\ninput_gssapi_token(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt;\n\tgss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc recv_tok;\n\tOM_uint32 maj_status, min_status, flags;\n\tu_char *p;\n\tsize_t len;\n\tint r;\n\n\tif (authctxt == NULL || (authctxt->methoddata == NULL && !use_privsep))\n\t\tfatal(\"No authentication or GSSAPI context\");\n\n\tgssctxt = authctxt->methoddata;\n\tif ((r = sshpkt_get_string(ssh, &p, &len)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\trecv_tok.value = p;\n\trecv_tok.length = len;\n\tmaj_status = PRIVSEP(ssh_gssapi_accept_ctx(gssctxt, &recv_tok,\n\t    &send_tok, &flags));\n\n\tfree(p);\n\n\tif (GSS_ERROR(maj_status)) {\n\t\tif (send_tok.length != 0) {\n\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_ERRTOK)) != 0 ||\n\t\t\t    (r = sshpkt_put_string(ssh, send_tok.value,\n\t\t\t    send_tok.length)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\t}\n\t\tauthctxt->postponed = 0;\n\t\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);\n\t\tuserauth_finish(ssh, 0, \"gssapi-with-mic\", NULL);\n\t} else {\n\t\tif (send_tok.length != 0) {\n\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_TOKEN)) != 0 ||\n\t\t\t    (r = sshpkt_put_string(ssh, send_tok.value,\n\t\t\t    send_tok.length)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\t}\n\t\tif (maj_status == GSS_S_COMPLETE) {\n\t\t\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);\n\t\t\tif (flags & GSS_C_INTEG_FLAG)\n\t\t\t\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_MIC,\n\t\t\t\t    &input_gssapi_mic);\n\t\t\telse\n\t\t\t\tssh_dispatch_set(ssh,\n\t\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE,\n\t\t\t\t    &input_gssapi_exchange_complete);\n\t\t}\n\t}\n\n\tgss_release_buffer(&min_status, &send_tok);\n\treturn 0;\n}",
    "includes": [
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"packet.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"dispatch.h\"",
      "#include \"log.h\"",
      "#include \"ssh2.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <stdarg.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gss_release_buffer",
          "args": [
            "&min_status",
            "&send_tok"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_dispatch_set",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE",
            "&input_gssapi_exchange_complete"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_dispatch_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dispatch.c",
          "lines": "81-85",
          "snippet": "void\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"dispatch.h\"",
            "#include \"log.h\"",
            "#include \"ssh2.h\"",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include <stdarg.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_string",
          "args": [
            "ssh",
            "send_tok.value",
            "send_tok.length"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2453-2457",
          "snippet": "int\nsshpkt_put_string(struct ssh *ssh, const void *v, size_t len)\n{\n\treturn sshbuf_put_string(ssh->state->outgoing_packet, v, len);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_string(struct ssh *ssh, const void *v, size_t len)\n{\n\treturn sshbuf_put_string(ssh->state->outgoing_packet, v, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_GSSAPI_TOKEN"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "userauth_finish",
          "args": [
            "ssh",
            "0",
            "\"gssapi-with-mic\"",
            "NULL"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "userauth_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2.c",
          "lines": "340-429",
          "snippet": "void\nuserauth_finish(struct ssh *ssh, int authenticated, const char *method,\n    const char *submethod)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tchar *methods;\n\tint partial = 0;\n\n\tif (!authctxt->valid && authenticated)\n\t\tfatal(\"INTERNAL ERROR: authenticated invalid user %s\",\n\t\t    authctxt->user);\n\tif (authenticated && authctxt->postponed)\n\t\tfatal(\"INTERNAL ERROR: authenticated and postponed\");\n\n\t/* Special handling for root */\n\tif (authenticated && authctxt->pw->pw_uid == 0 &&\n\t    !auth_root_allowed(ssh, method)) {\n\t\tauthenticated = 0;\n#ifdef SSH_AUDIT_EVENTS\n\t\tPRIVSEP(audit_event(SSH_LOGIN_ROOT_DENIED));\n#endif\n\t}\n\n\tif (authenticated && options.num_auth_methods != 0) {\n\t\tif (!auth2_update_methods_lists(authctxt, method, submethod)) {\n\t\t\tauthenticated = 0;\n\t\t\tpartial = 1;\n\t\t}\n\t}\n\n\t/* Log before sending the reply */\n\tauth_log(authctxt, authenticated, partial, method, submethod);\n\n\t/* Update information exposed to session */\n\tif (authenticated || partial)\n\t\tauth2_update_session_info(authctxt, method, submethod);\n\n\tif (authctxt->postponed)\n\t\treturn;\n\n#ifdef USE_PAM\n\tif (options.use_pam && authenticated) {\n\t\tint r;\n\n\t\tif (!PRIVSEP(do_pam_account())) {\n\t\t\t/* if PAM returned a message, send it to the user */\n\t\t\tif (sshbuf_len(loginmsg) > 0) {\n\t\t\t\tif ((r = sshbuf_put(loginmsg, \"\\0\", 1)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tuserauth_send_banner(sshbuf_ptr(loginmsg));\n\t\t\t\tpacket_write_wait();\n\t\t\t}\n\t\t\tfatal(\"Access denied for user %s by PAM account \"\n\t\t\t    \"configuration\", authctxt->user);\n\t\t}\n\t}\n#endif\n\n\tif (authenticated == 1) {\n\t\t/* turn off userauth */\n\t\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_REQUEST, &dispatch_protocol_ignore);\n\t\tpacket_start(SSH2_MSG_USERAUTH_SUCCESS);\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\t\t/* now we can break out */\n\t\tauthctxt->success = 1;\n\t\tssh_packet_set_log_preamble(ssh, \"user %s\", authctxt->user);\n\t} else {\n\t\t/* Allow initial try of \"none\" auth without failure penalty */\n\t\tif (!partial && !authctxt->server_caused_failure &&\n\t\t    (authctxt->attempt > 1 || strcmp(method, \"none\") != 0))\n\t\t\tauthctxt->failures++;\n\t\tif (authctxt->failures >= options.max_authtries) {\n#ifdef SSH_AUDIT_EVENTS\n\t\t\tPRIVSEP(audit_event(SSH_LOGIN_EXCEED_MAXTRIES));\n#endif\n\t\t\tauth_maxtries_exceeded(authctxt);\n\t\t}\n\t\tmethods = authmethods_get(authctxt);\n\t\tdebug3(\"%s: failure partial=%d next methods=\\\"%s\\\"\", __func__,\n\t\t    partial, methods);\n\t\tpacket_start(SSH2_MSG_USERAUTH_FAILURE);\n\t\tpacket_put_cstring(methods);\n\t\tpacket_put_char(partial);\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\t\tfree(methods);\n\t}\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"pathnames.h\"",
            "#include \"dispatch.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "extern struct sshbuf *loginmsg;",
            "static int input_service_request(int, u_int32_t, struct ssh *);",
            "static int input_userauth_request(int, u_int32_t, struct ssh *);",
            "static Authmethod *authmethod_lookup(Authctxt *, const char *);",
            "static char *authmethods_get(Authctxt *authctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"pathnames.h\"\n#include \"dispatch.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern struct sshbuf *loginmsg;\nstatic int input_service_request(int, u_int32_t, struct ssh *);\nstatic int input_userauth_request(int, u_int32_t, struct ssh *);\nstatic Authmethod *authmethod_lookup(Authctxt *, const char *);\nstatic char *authmethods_get(Authctxt *authctxt);\n\nvoid\nuserauth_finish(struct ssh *ssh, int authenticated, const char *method,\n    const char *submethod)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tchar *methods;\n\tint partial = 0;\n\n\tif (!authctxt->valid && authenticated)\n\t\tfatal(\"INTERNAL ERROR: authenticated invalid user %s\",\n\t\t    authctxt->user);\n\tif (authenticated && authctxt->postponed)\n\t\tfatal(\"INTERNAL ERROR: authenticated and postponed\");\n\n\t/* Special handling for root */\n\tif (authenticated && authctxt->pw->pw_uid == 0 &&\n\t    !auth_root_allowed(ssh, method)) {\n\t\tauthenticated = 0;\n#ifdef SSH_AUDIT_EVENTS\n\t\tPRIVSEP(audit_event(SSH_LOGIN_ROOT_DENIED));\n#endif\n\t}\n\n\tif (authenticated && options.num_auth_methods != 0) {\n\t\tif (!auth2_update_methods_lists(authctxt, method, submethod)) {\n\t\t\tauthenticated = 0;\n\t\t\tpartial = 1;\n\t\t}\n\t}\n\n\t/* Log before sending the reply */\n\tauth_log(authctxt, authenticated, partial, method, submethod);\n\n\t/* Update information exposed to session */\n\tif (authenticated || partial)\n\t\tauth2_update_session_info(authctxt, method, submethod);\n\n\tif (authctxt->postponed)\n\t\treturn;\n\n#ifdef USE_PAM\n\tif (options.use_pam && authenticated) {\n\t\tint r;\n\n\t\tif (!PRIVSEP(do_pam_account())) {\n\t\t\t/* if PAM returned a message, send it to the user */\n\t\t\tif (sshbuf_len(loginmsg) > 0) {\n\t\t\t\tif ((r = sshbuf_put(loginmsg, \"\\0\", 1)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tuserauth_send_banner(sshbuf_ptr(loginmsg));\n\t\t\t\tpacket_write_wait();\n\t\t\t}\n\t\t\tfatal(\"Access denied for user %s by PAM account \"\n\t\t\t    \"configuration\", authctxt->user);\n\t\t}\n\t}\n#endif\n\n\tif (authenticated == 1) {\n\t\t/* turn off userauth */\n\t\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_REQUEST, &dispatch_protocol_ignore);\n\t\tpacket_start(SSH2_MSG_USERAUTH_SUCCESS);\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\t\t/* now we can break out */\n\t\tauthctxt->success = 1;\n\t\tssh_packet_set_log_preamble(ssh, \"user %s\", authctxt->user);\n\t} else {\n\t\t/* Allow initial try of \"none\" auth without failure penalty */\n\t\tif (!partial && !authctxt->server_caused_failure &&\n\t\t    (authctxt->attempt > 1 || strcmp(method, \"none\") != 0))\n\t\t\tauthctxt->failures++;\n\t\tif (authctxt->failures >= options.max_authtries) {\n#ifdef SSH_AUDIT_EVENTS\n\t\t\tPRIVSEP(audit_event(SSH_LOGIN_EXCEED_MAXTRIES));\n#endif\n\t\t\tauth_maxtries_exceeded(authctxt);\n\t\t}\n\t\tmethods = authmethods_get(authctxt);\n\t\tdebug3(\"%s: failure partial=%d next methods=\\\"%s\\\"\", __func__,\n\t\t    partial, methods);\n\t\tpacket_start(SSH2_MSG_USERAUTH_FAILURE);\n\t\tpacket_put_cstring(methods);\n\t\tpacket_put_char(partial);\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\t\tfree(methods);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GSS_ERROR",
          "args": [
            "maj_status"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "p"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRIVSEP",
          "args": [
            "ssh_gssapi_accept_ctx(gssctxt, &recv_tok,\n\t    &send_tok, &flags)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_accept_ctx",
          "args": [
            "gssctxt",
            "&recv_tok",
            "&send_tok",
            "&flags"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_accept_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-serv.c",
          "lines": "175-208",
          "snippet": "OM_uint32\nssh_gssapi_accept_ctx(Gssctxt *ctx, gss_buffer_desc *recv_tok,\n    gss_buffer_desc *send_tok, OM_uint32 *flags)\n{\n\tOM_uint32 status;\n\tgss_OID mech;\n\n\tctx->major = gss_accept_sec_context(&ctx->minor,\n\t    &ctx->context, ctx->creds, recv_tok,\n\t    GSS_C_NO_CHANNEL_BINDINGS, &ctx->client, &mech,\n\t    send_tok, flags, NULL, &ctx->client_creds);\n\n\tif (GSS_ERROR(ctx->major))\n\t\tssh_gssapi_error(ctx);\n\n\tif (ctx->client_creds)\n\t\tdebug(\"Received some client credentials\");\n\telse\n\t\tdebug(\"Got no client credentials\");\n\n\tstatus = ctx->major;\n\n\t/* Now, if we're complete and we have the right flags, then\n\t * we flag the user as also having been authenticated\n\t */\n\n\tif (((flags == NULL) || ((*flags & GSS_C_MUTUAL_FLAG) &&\n\t    (*flags & GSS_C_INTEG_FLAG))) && (ctx->major == GSS_S_COMPLETE)) {\n\t\tif (ssh_gssapi_getclient(ctx, &gssapi_client))\n\t\t\tfatal(\"Couldn't convert client name\");\n\t}\n\n\treturn (status);\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"log.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"log.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOM_uint32\nssh_gssapi_accept_ctx(Gssctxt *ctx, gss_buffer_desc *recv_tok,\n    gss_buffer_desc *send_tok, OM_uint32 *flags)\n{\n\tOM_uint32 status;\n\tgss_OID mech;\n\n\tctx->major = gss_accept_sec_context(&ctx->minor,\n\t    &ctx->context, ctx->creds, recv_tok,\n\t    GSS_C_NO_CHANNEL_BINDINGS, &ctx->client, &mech,\n\t    send_tok, flags, NULL, &ctx->client_creds);\n\n\tif (GSS_ERROR(ctx->major))\n\t\tssh_gssapi_error(ctx);\n\n\tif (ctx->client_creds)\n\t\tdebug(\"Received some client credentials\");\n\telse\n\t\tdebug(\"Got no client credentials\");\n\n\tstatus = ctx->major;\n\n\t/* Now, if we're complete and we have the right flags, then\n\t * we flag the user as also having been authenticated\n\t */\n\n\tif (((flags == NULL) || ((*flags & GSS_C_MUTUAL_FLAG) &&\n\t    (*flags & GSS_C_INTEG_FLAG))) && (ctx->major == GSS_S_COMPLETE)) {\n\t\tif (ssh_gssapi_getclient(ctx, &gssapi_client))\n\t\t\tfatal(\"Couldn't convert client name\");\n\t}\n\n\treturn (status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_end",
          "args": [
            "ssh"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2555-2561",
          "snippet": "int\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_string",
          "args": [
            "ssh",
            "&p",
            "&len"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2520-2524",
          "snippet": "int\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"packet.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ninput_gssapi_token(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt;\n\tgss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc recv_tok;\n\tOM_uint32 maj_status, min_status, flags;\n\tu_char *p;\n\tsize_t len;\n\tint r;\n\n\tif (authctxt == NULL || (authctxt->methoddata == NULL && !use_privsep))\n\t\tfatal(\"No authentication or GSSAPI context\");\n\n\tgssctxt = authctxt->methoddata;\n\tif ((r = sshpkt_get_string(ssh, &p, &len)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\trecv_tok.value = p;\n\trecv_tok.length = len;\n\tmaj_status = PRIVSEP(ssh_gssapi_accept_ctx(gssctxt, &recv_tok,\n\t    &send_tok, &flags));\n\n\tfree(p);\n\n\tif (GSS_ERROR(maj_status)) {\n\t\tif (send_tok.length != 0) {\n\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_ERRTOK)) != 0 ||\n\t\t\t    (r = sshpkt_put_string(ssh, send_tok.value,\n\t\t\t    send_tok.length)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\t}\n\t\tauthctxt->postponed = 0;\n\t\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);\n\t\tuserauth_finish(ssh, 0, \"gssapi-with-mic\", NULL);\n\t} else {\n\t\tif (send_tok.length != 0) {\n\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_TOKEN)) != 0 ||\n\t\t\t    (r = sshpkt_put_string(ssh, send_tok.value,\n\t\t\t    send_tok.length)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\t}\n\t\tif (maj_status == GSS_S_COMPLETE) {\n\t\t\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);\n\t\t\tif (flags & GSS_C_INTEG_FLAG)\n\t\t\t\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_MIC,\n\t\t\t\t    &input_gssapi_mic);\n\t\t\telse\n\t\t\t\tssh_dispatch_set(ssh,\n\t\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE,\n\t\t\t\t    &input_gssapi_exchange_complete);\n\t\t}\n\t}\n\n\tgss_release_buffer(&min_status, &send_tok);\n\treturn 0;\n}"
  },
  {
    "function_name": "userauth_gssapi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-gss.c",
    "lines": "61-135",
    "snippet": "static int\nuserauth_gssapi(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tgss_OID_desc goid = {0, NULL};\n\tGssctxt *ctxt = NULL;\n\tint r, present;\n\tu_int mechs;\n\tOM_uint32 ms;\n\tsize_t len;\n\tu_char *doid = NULL;\n\n\tif ((r = sshpkt_get_u32(ssh, &mechs)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tif (mechs == 0) {\n\t\tdebug(\"Mechanism negotiation is not supported\");\n\t\treturn (0);\n\t}\n\n\tdo {\n\t\tmechs--;\n\n\t\tfree(doid);\n\n\t\tpresent = 0;\n\t\tif ((r = sshpkt_get_string(ssh, &doid, &len)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\t\tif (len > 2 && doid[0] == SSH_GSS_OIDTYPE &&\n\t\t    doid[1] == len - 2) {\n\t\t\tgoid.elements = doid + 2;\n\t\t\tgoid.length   = len - 2;\n\t\t\tssh_gssapi_test_oid_supported(&ms, &goid, &present);\n\t\t} else {\n\t\t\tlogit(\"Badly formed OID received\");\n\t\t}\n\t} while (mechs > 0 && !present);\n\n\tif (!present) {\n\t\tfree(doid);\n\t\tauthctxt->server_caused_failure = 1;\n\t\treturn (0);\n\t}\n\n\tif (!authctxt->valid || authctxt->user == NULL) {\n\t\tdebug2(\"%s: disabled because of invalid user\", __func__);\n\t\tfree(doid);\n\t\treturn (0);\n\t}\n\n\tif (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {\n\t\tif (ctxt != NULL)\n\t\t\tssh_gssapi_delete_ctx(&ctxt);\n\t\tfree(doid);\n\t\tauthctxt->server_caused_failure = 1;\n\t\treturn (0);\n\t}\n\n\tauthctxt->methoddata = (void *)ctxt;\n\n\t/* Return the OID that we received */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_GSSAPI_RESPONSE)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, doid, len)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tfree(doid);\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);\n\tauthctxt->postponed = 1;\n\n\treturn (0);\n}",
    "includes": [
      "#include \"monitor_wrap.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"packet.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"dispatch.h\"",
      "#include \"log.h\"",
      "#include \"ssh2.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <stdarg.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_dispatch_set",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_GSSAPI_ERRTOK",
            "&input_gssapi_errtok"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_dispatch_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dispatch.c",
          "lines": "81-85",
          "snippet": "void\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"dispatch.h\"",
            "#include \"log.h\"",
            "#include \"ssh2.h\"",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include <stdarg.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "doid"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_string",
          "args": [
            "ssh",
            "doid",
            "len"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2453-2457",
          "snippet": "int\nsshpkt_put_string(struct ssh *ssh, const void *v, size_t len)\n{\n\treturn sshbuf_put_string(ssh->state->outgoing_packet, v, len);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_string(struct ssh *ssh, const void *v, size_t len)\n{\n\treturn sshbuf_put_string(ssh->state->outgoing_packet, v, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_GSSAPI_RESPONSE"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_delete_ctx",
          "args": [
            "&ctxt"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_delete_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-genr.c",
          "lines": "176-201",
          "snippet": "void\nssh_gssapi_delete_ctx(Gssctxt **ctx)\n{\n\tOM_uint32 ms;\n\n\tif ((*ctx) == NULL)\n\t\treturn;\n\tif ((*ctx)->context != GSS_C_NO_CONTEXT)\n\t\tgss_delete_sec_context(&ms, &(*ctx)->context, GSS_C_NO_BUFFER);\n\tif ((*ctx)->name != GSS_C_NO_NAME)\n\t\tgss_release_name(&ms, &(*ctx)->name);\n\tif ((*ctx)->oid != GSS_C_NO_OID) {\n\t\tfree((*ctx)->oid->elements);\n\t\tfree((*ctx)->oid);\n\t\t(*ctx)->oid = GSS_C_NO_OID;\n\t}\n\tif ((*ctx)->creds != GSS_C_NO_CREDENTIAL)\n\t\tgss_release_cred(&ms, &(*ctx)->creds);\n\tif ((*ctx)->client != GSS_C_NO_NAME)\n\t\tgss_release_name(&ms, &(*ctx)->client);\n\tif ((*ctx)->client_creds != GSS_C_NO_CREDENTIAL)\n\t\tgss_release_cred(&ms, &(*ctx)->client_creds);\n\n\tfree(*ctx);\n\t*ctx = NULL;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"ssh2.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"ssh2.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_gssapi_delete_ctx(Gssctxt **ctx)\n{\n\tOM_uint32 ms;\n\n\tif ((*ctx) == NULL)\n\t\treturn;\n\tif ((*ctx)->context != GSS_C_NO_CONTEXT)\n\t\tgss_delete_sec_context(&ms, &(*ctx)->context, GSS_C_NO_BUFFER);\n\tif ((*ctx)->name != GSS_C_NO_NAME)\n\t\tgss_release_name(&ms, &(*ctx)->name);\n\tif ((*ctx)->oid != GSS_C_NO_OID) {\n\t\tfree((*ctx)->oid->elements);\n\t\tfree((*ctx)->oid);\n\t\t(*ctx)->oid = GSS_C_NO_OID;\n\t}\n\tif ((*ctx)->creds != GSS_C_NO_CREDENTIAL)\n\t\tgss_release_cred(&ms, &(*ctx)->creds);\n\tif ((*ctx)->client != GSS_C_NO_NAME)\n\t\tgss_release_name(&ms, &(*ctx)->client);\n\tif ((*ctx)->client_creds != GSS_C_NO_CREDENTIAL)\n\t\tgss_release_cred(&ms, &(*ctx)->client_creds);\n\n\tfree(*ctx);\n\t*ctx = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GSS_ERROR",
          "args": [
            "PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid))"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRIVSEP",
          "args": [
            "ssh_gssapi_server_ctx(&ctxt, &goid)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_server_ctx",
          "args": [
            "&ctxt",
            "&goid"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_server_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-serv.c",
          "lines": "133-141",
          "snippet": "OM_uint32\nssh_gssapi_server_ctx(Gssctxt **ctx, gss_OID oid)\n{\n\tif (*ctx)\n\t\tssh_gssapi_delete_ctx(ctx);\n\tssh_gssapi_build_ctx(ctx);\n\tssh_gssapi_set_oid(*ctx, oid);\n\treturn (ssh_gssapi_acquire_cred(*ctx));\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"log.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"log.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOM_uint32\nssh_gssapi_server_ctx(Gssctxt **ctx, gss_OID oid)\n{\n\tif (*ctx)\n\t\tssh_gssapi_delete_ctx(ctx);\n\tssh_gssapi_build_ctx(ctx);\n\tssh_gssapi_set_oid(*ctx, oid);\n\treturn (ssh_gssapi_acquire_cred(*ctx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: disabled because of invalid user\"",
            "__func__"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Badly formed OID received\""
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_test_oid_supported",
          "args": [
            "&ms",
            "&goid",
            "&present"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_test_oid_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-serv.c",
          "lines": "82-88",
          "snippet": "OM_uint32\nssh_gssapi_test_oid_supported(OM_uint32 *ms, gss_OID member, int *present)\n{\n\tif (supported_oids == NULL)\n\t\tssh_gssapi_prepare_supported_oids();\n\treturn gss_test_oid_set_member(ms, member, supported_oids, present);\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"log.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"log.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOM_uint32\nssh_gssapi_test_oid_supported(OM_uint32 *ms, gss_OID member, int *present)\n{\n\tif (supported_oids == NULL)\n\t\tssh_gssapi_prepare_supported_oids();\n\treturn gss_test_oid_set_member(ms, member, supported_oids, present);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_string",
          "args": [
            "ssh",
            "&doid",
            "&len"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2520-2524",
          "snippet": "int\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Mechanism negotiation is not supported\""
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_u32",
          "args": [
            "ssh",
            "&mechs"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2502-2506",
          "snippet": "int\nsshpkt_get_u32(struct ssh *ssh, u_int32_t *valp)\n{\n\treturn sshbuf_get_u32(ssh->state->incoming_packet, valp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_u32(struct ssh *ssh, u_int32_t *valp)\n{\n\treturn sshbuf_get_u32(ssh->state->incoming_packet, valp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"packet.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nuserauth_gssapi(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tgss_OID_desc goid = {0, NULL};\n\tGssctxt *ctxt = NULL;\n\tint r, present;\n\tu_int mechs;\n\tOM_uint32 ms;\n\tsize_t len;\n\tu_char *doid = NULL;\n\n\tif ((r = sshpkt_get_u32(ssh, &mechs)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tif (mechs == 0) {\n\t\tdebug(\"Mechanism negotiation is not supported\");\n\t\treturn (0);\n\t}\n\n\tdo {\n\t\tmechs--;\n\n\t\tfree(doid);\n\n\t\tpresent = 0;\n\t\tif ((r = sshpkt_get_string(ssh, &doid, &len)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\t\tif (len > 2 && doid[0] == SSH_GSS_OIDTYPE &&\n\t\t    doid[1] == len - 2) {\n\t\t\tgoid.elements = doid + 2;\n\t\t\tgoid.length   = len - 2;\n\t\t\tssh_gssapi_test_oid_supported(&ms, &goid, &present);\n\t\t} else {\n\t\t\tlogit(\"Badly formed OID received\");\n\t\t}\n\t} while (mechs > 0 && !present);\n\n\tif (!present) {\n\t\tfree(doid);\n\t\tauthctxt->server_caused_failure = 1;\n\t\treturn (0);\n\t}\n\n\tif (!authctxt->valid || authctxt->user == NULL) {\n\t\tdebug2(\"%s: disabled because of invalid user\", __func__);\n\t\tfree(doid);\n\t\treturn (0);\n\t}\n\n\tif (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {\n\t\tif (ctxt != NULL)\n\t\t\tssh_gssapi_delete_ctx(&ctxt);\n\t\tfree(doid);\n\t\tauthctxt->server_caused_failure = 1;\n\t\treturn (0);\n\t}\n\n\tauthctxt->methoddata = (void *)ctxt;\n\n\t/* Return the OID that we received */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_GSSAPI_RESPONSE)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, doid, len)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tfree(doid);\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);\n\tauthctxt->postponed = 1;\n\n\treturn (0);\n}"
  }
]