[
  {
    "function_name": "lostconn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
    "lines": "1416-1425",
    "snippet": "void\nlostconn(int signo)\n{\n\tif (!iamremote)\n\t\t(void)write(STDERR_FILENO, \"lost connection\\n\", 16);\n\tif (signo)\n\t\t_exit(1);\n\telse\n\t\texit(1);\n}",
    "includes": [
      "#include \"utf8.h\"",
      "#include \"progressmeter.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include <sys/uio.h>",
      "#include <sys/wait.h>",
      "# include <sys/time.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void lostconn(int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "STDERR_FILENO",
            "\"lost connection\\n\"",
            "16"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid lostconn(int);\n\nvoid\nlostconn(int signo)\n{\n\tif (!iamremote)\n\t\t(void)write(STDERR_FILENO, \"lost connection\\n\", 16);\n\tif (signo)\n\t\t_exit(1);\n\telse\n\t\texit(1);\n}"
  },
  {
    "function_name": "allocbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
    "lines": "1392-1414",
    "snippet": "BUF *\nallocbuf(BUF *bp, int fd, int blksize)\n{\n\tsize_t size;\n#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE\n\tstruct stat stb;\n\n\tif (fstat(fd, &stb) < 0) {\n\t\trun_err(\"fstat: %s\", strerror(errno));\n\t\treturn (0);\n\t}\n\tsize = ROUNDUP(stb.st_blksize, blksize);\n\tif (size == 0)\n\t\tsize = blksize;\n#else /* HAVE_STRUCT_STAT_ST_BLKSIZE */\n\tsize = blksize;\n#endif /* HAVE_STRUCT_STAT_ST_BLKSIZE */\n\tif (bp->cnt >= size)\n\t\treturn (bp);\n\tbp->buf = xrecallocarray(bp->buf, bp->cnt, size, 1);\n\tbp->cnt = size;\n\treturn (bp);\n}",
    "includes": [
      "#include \"utf8.h\"",
      "#include \"progressmeter.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include <sys/uio.h>",
      "#include <sys/wait.h>",
      "# include <sys/time.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "BUF *allocbuf(BUF *, int, int);",
      "void run_err(const char *,...);",
      "void rsource(char *, struct stat *);",
      "struct stat stb;",
      "BUF *bp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xrecallocarray",
          "args": [
            "bp->buf",
            "bp->cnt",
            "size",
            "1"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "xrecallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "80-90",
          "snippet": "void *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ROUNDUP",
          "args": [
            "stb.st_blksize",
            "blksize"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_err",
          "args": [
            "\"fstat: %s\"",
            "strerror(errno)"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "run_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1323-1346",
          "snippet": "void\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void run_err(const char *,...);",
            "int errs, remin, remout;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid run_err(const char *,...);\nint errs, remin, remout;\n\nvoid\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&stb"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "fstatvfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-statvfs.c",
          "lines": "71-85",
          "snippet": "int fstatvfs(int fd, struct statvfs *buf)\n{\n#  ifdef HAVE_FSTATFS\n\tstruct statfs fs;\n\n\tmemset(&fs, 0, sizeof(fs));\n\tif (fstatfs(fd, &fs) == -1)\n\t\treturn -1;\n\tcopy_statfs_to_statvfs(buf, &fs);\n\treturn 0;\n#  else\n\terrno = ENOSYS;\n\treturn -1;\n#  endif\n}",
          "includes": [
            "#include <errno.h>",
            "# include <sys/mount.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n# include <sys/mount.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nint fstatvfs(int fd, struct statvfs *buf)\n{\n#  ifdef HAVE_FSTATFS\n\tstruct statfs fs;\n\n\tmemset(&fs, 0, sizeof(fs));\n\tif (fstatfs(fd, &fs) == -1)\n\t\treturn -1;\n\tcopy_statfs_to_statvfs(buf, &fs);\n\treturn 0;\n#  else\n\terrno = ENOSYS;\n\treturn -1;\n#  endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nBUF *allocbuf(BUF *, int, int);\nvoid run_err(const char *,...);\nvoid rsource(char *, struct stat *);\nstruct stat stb;\nBUF *bp;\n\nBUF *\nallocbuf(BUF *bp, int fd, int blksize)\n{\n\tsize_t size;\n#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE\n\tstruct stat stb;\n\n\tif (fstat(fd, &stb) < 0) {\n\t\trun_err(\"fstat: %s\", strerror(errno));\n\t\treturn (0);\n\t}\n\tsize = ROUNDUP(stb.st_blksize, blksize);\n\tif (size == 0)\n\t\tsize = blksize;\n#else /* HAVE_STRUCT_STAT_ST_BLKSIZE */\n\tsize = blksize;\n#endif /* HAVE_STRUCT_STAT_ST_BLKSIZE */\n\tif (bp->cnt >= size)\n\t\treturn (bp);\n\tbp->buf = xrecallocarray(bp->buf, bp->cnt, size, 1);\n\tbp->cnt = size;\n\treturn (bp);\n}"
  },
  {
    "function_name": "okname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
    "lines": "1362-1390",
    "snippet": "int\nokname(char *cp0)\n{\n\tint c;\n\tchar *cp;\n\n\tcp = cp0;\n\tdo {\n\t\tc = (int)*cp;\n\t\tif (c & 0200)\n\t\t\tgoto bad;\n\t\tif (!isalpha(c) && !isdigit((unsigned char)c)) {\n\t\t\tswitch (c) {\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\tcase '`':\n\t\t\tcase ' ':\n\t\t\tcase '#':\n\t\t\t\tgoto bad;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (*++cp);\n\treturn (1);\n\nbad:\tfmprintf(stderr, \"%s: invalid user name\\n\", cp0);\n\treturn (0);\n}",
    "includes": [
      "#include \"utf8.h\"",
      "#include \"progressmeter.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include <sys/uio.h>",
      "#include <sys/wait.h>",
      "# include <sys/time.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int okname(char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fmprintf",
          "args": [
            "stderr",
            "\"%s: invalid user name\\n\"",
            "cp0"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "fmprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "277-287",
          "snippet": "int\nfmprintf(FILE *stream, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stream, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nfmprintf(FILE *stream, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stream, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char)c"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalpha",
          "args": [
            "c"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint okname(char *);\n\nint\nokname(char *cp0)\n{\n\tint c;\n\tchar *cp;\n\n\tcp = cp0;\n\tdo {\n\t\tc = (int)*cp;\n\t\tif (c & 0200)\n\t\t\tgoto bad;\n\t\tif (!isalpha(c) && !isdigit((unsigned char)c)) {\n\t\t\tswitch (c) {\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\tcase '`':\n\t\t\tcase ' ':\n\t\t\tcase '#':\n\t\t\t\tgoto bad;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (*++cp);\n\treturn (1);\n\nbad:\tfmprintf(stderr, \"%s: invalid user name\\n\", cp0);\n\treturn (0);\n}"
  },
  {
    "function_name": "verifydir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
    "lines": "1348-1360",
    "snippet": "void\nverifydir(char *cp)\n{\n\tstruct stat stb;\n\n\tif (!stat(cp, &stb)) {\n\t\tif (S_ISDIR(stb.st_mode))\n\t\t\treturn;\n\t\terrno = ENOTDIR;\n\t}\n\trun_err(\"%s: %s\", cp, strerror(errno));\n\tkillchild(0);\n}",
    "includes": [
      "#include \"utf8.h\"",
      "#include \"progressmeter.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include <sys/uio.h>",
      "#include <sys/wait.h>",
      "# include <sys/time.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void run_err(const char *,...);",
      "void verifydir(char *);",
      "void rsource(char *, struct stat *);",
      "struct stat stb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "killchild",
          "args": [
            "0"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "killchild",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "162-173",
          "snippet": "static void\nkillchild(int signo)\n{\n\tif (do_cmd_pid > 1) {\n\t\tkill(do_cmd_pid, signo ? signo : SIGTERM);\n\t\twaitpid(do_cmd_pid, NULL, 0);\n\t}\n\n\tif (signo)\n\t\t_exit(1);\n\texit(1);\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "pid_t do_cmd_pid = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\npid_t do_cmd_pid = -1;\n\nstatic void\nkillchild(int signo)\n{\n\tif (do_cmd_pid > 1) {\n\t\tkill(do_cmd_pid, signo ? signo : SIGTERM);\n\t\twaitpid(do_cmd_pid, NULL, 0);\n\t}\n\n\tif (signo)\n\t\t_exit(1);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "run_err",
          "args": [
            "\"%s: %s\"",
            "cp",
            "strerror(errno)"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "run_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1323-1346",
          "snippet": "void\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void run_err(const char *,...);",
            "int errs, remin, remout;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid run_err(const char *,...);\nint errs, remin, remout;\n\nvoid\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "stb.st_mode"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "cp",
            "&stb"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid run_err(const char *,...);\nvoid verifydir(char *);\nvoid rsource(char *, struct stat *);\nstruct stat stb;\n\nvoid\nverifydir(char *cp)\n{\n\tstruct stat stb;\n\n\tif (!stat(cp, &stb)) {\n\t\tif (S_ISDIR(stb.st_mode))\n\t\t\treturn;\n\t\terrno = ENOTDIR;\n\t}\n\trun_err(\"%s: %s\", cp, strerror(errno));\n\tkillchild(0);\n}"
  },
  {
    "function_name": "run_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
    "lines": "1323-1346",
    "snippet": "void\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}",
    "includes": [
      "#include \"utf8.h\"",
      "#include \"progressmeter.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include <sys/uio.h>",
      "#include <sys/wait.h>",
      "# include <sys/time.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void run_err(const char *,...);",
      "int errs, remin, remout;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfmprintf",
          "args": [
            "stderr",
            "fmt",
            "ap"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "vfmprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "263-275",
          "snippet": "int\nvfmprintf(FILE *stream, const char *fmt, va_list ap)\n{\n\tchar\t*str;\n\tint\t ret;\n\n\tif ((ret = vasnmprintf(&str, INT_MAX, NULL, fmt, ap)) < 0)\n\t\treturn -1;\n\tif (fputs(str, stream) == EOF)\n\t\tret = -1;\n\tfree(str);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nvfmprintf(FILE *stream, const char *fmt, va_list ap)\n{\n\tchar\t*str;\n\tint\t ret;\n\n\tif ((ret = vasnmprintf(&str, INT_MAX, NULL, fmt, ap)) < 0)\n\t\treturn -1;\n\tif (fputs(str, stream) == EOF)\n\t\tret = -1;\n\tfree(str);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "fmt"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "fp"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "_ssh_compat_fflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "314-326",
          "snippet": "int _ssh_compat_fflush(FILE *f)\n{\n\tint r1, r2;\n\n\tif (f == NULL) {\n\t\tr1 = fflush(stdout);\n\t\tr2 = fflush(stderr);\n\t\tif (r1 == -1 || r2 == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\treturn fflush(f);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint _ssh_compat_fflush(FILE *f)\n{\n\tint r1, r2;\n\n\tif (f == NULL) {\n\t\tr1 = fflush(stdout);\n\t\tr2 = fflush(stderr);\n\t\tif (r1 == -1 || r2 == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\treturn fflush(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"\\n\""
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfprintf",
          "args": [
            "fp",
            "fmt",
            "ap"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "fmt"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"scp: \""
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"%c\"",
            "0x01"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "remout",
            "\"w\""
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid run_err(const char *,...);\nint errs, remin, remout;\n\nvoid\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}"
  },
  {
    "function_name": "usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
    "lines": "1314-1321",
    "snippet": "void\nusage(void)\n{\n\t(void) fprintf(stderr,\n\t    \"usage: scp [-346BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]\\n\"\n\t    \"           [-l limit] [-o ssh_option] [-P port] [-S program] source ... target\\n\");\n\texit(1);\n}",
    "includes": [
      "#include \"utf8.h\"",
      "#include \"progressmeter.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include <sys/uio.h>",
      "#include <sys/wait.h>",
      "# include <sys/time.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void source(int, char *[]);",
      "void usage(void);",
      "off_t i;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"usage: scp [-346BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]\\n\"\n\t    \"           [-l limit] [-o ssh_option] [-P port] [-S program] source ... target\\n\""
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid source(int, char *[]);\nvoid usage(void);\noff_t i;\n\nvoid\nusage(void)\n{\n\t(void) fprintf(stderr,\n\t    \"usage: scp [-346BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]\\n\"\n\t    \"           [-l limit] [-o ssh_option] [-P port] [-S program] source ... target\\n\");\n\texit(1);\n}"
  },
  {
    "function_name": "response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
    "lines": "1276-1312",
    "snippet": "int\nresponse(void)\n{\n\tchar ch, *cp, resp, rbuf[2048], visbuf[2048];\n\n\tif (atomicio(read, remin, &resp, sizeof(resp)) != sizeof(resp))\n\t\tlostconn(0);\n\n\tcp = rbuf;\n\tswitch (resp) {\n\tcase 0:\t\t/* ok */\n\t\treturn (0);\n\tdefault:\n\t\t*cp++ = resp;\n\t\t/* FALLTHROUGH */\n\tcase 1:\t\t/* error, followed by error msg */\n\tcase 2:\t\t/* fatal error, \"\" */\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tlostconn(0);\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &rbuf[sizeof(rbuf) - 1] && ch != '\\n');\n\n\t\tif (!iamremote) {\n\t\t\tcp[-1] = '\\0';\n\t\t\t(void) snmprintf(visbuf, sizeof(visbuf),\n\t\t\t    NULL, \"%s\\n\", rbuf);\n\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t    visbuf, strlen(visbuf));\n\t\t}\n\t\t++errs;\n\t\tif (resp == 1)\n\t\t\treturn (-1);\n\t\texit(1);\n\t}\n\t/* NOTREACHED */\n}",
    "includes": [
      "#include \"utf8.h\"",
      "#include \"progressmeter.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include <sys/uio.h>",
      "#include <sys/wait.h>",
      "# include <sys/time.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void lostconn(int);",
      "int response(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomicio",
          "args": [
            "vwrite",
            "STDERR_FILENO",
            "visbuf",
            "strlen(visbuf)"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "atomiciov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "165-170",
          "snippet": "size_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "visbuf"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snmprintf",
          "args": [
            "visbuf",
            "sizeof(visbuf)",
            "NULL",
            "\"%s\\n\"",
            "rbuf"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "snmprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "240-256",
          "snippet": "int\nsnmprintf(char *str, size_t sz, int *wp, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tchar\t*cp;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vasnmprintf(&cp, sz, wp, fmt, ap);\n\tva_end(ap);\n\tif (cp != NULL) {\n\t\t(void)strlcpy(str, cp, sz);\n\t\tfree(cp);\n\t} else\n\t\t*str = '\\0';\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t grow_dst(char **, size_t *, size_t, char **, size_t);",
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t grow_dst(char **, size_t *, size_t, char **, size_t);\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nsnmprintf(char *str, size_t sz, int *wp, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tchar\t*cp;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vasnmprintf(&cp, sz, wp, fmt, ap);\n\tva_end(ap);\n\tif (cp != NULL) {\n\t\t(void)strlcpy(str, cp, sz);\n\t\tfree(cp);\n\t} else\n\t\t*str = '\\0';\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lostconn",
          "args": [
            "0"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "lostconn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1416-1425",
          "snippet": "void\nlostconn(int signo)\n{\n\tif (!iamremote)\n\t\t(void)write(STDERR_FILENO, \"lost connection\\n\", 16);\n\tif (signo)\n\t\t_exit(1);\n\telse\n\t\texit(1);\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void lostconn(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid lostconn(int);\n\nvoid\nlostconn(int signo)\n{\n\tif (!iamremote)\n\t\t(void)write(STDERR_FILENO, \"lost connection\\n\", 16);\n\tif (signo)\n\t\t_exit(1);\n\telse\n\t\texit(1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid lostconn(int);\nint response(void);\n\nint\nresponse(void)\n{\n\tchar ch, *cp, resp, rbuf[2048], visbuf[2048];\n\n\tif (atomicio(read, remin, &resp, sizeof(resp)) != sizeof(resp))\n\t\tlostconn(0);\n\n\tcp = rbuf;\n\tswitch (resp) {\n\tcase 0:\t\t/* ok */\n\t\treturn (0);\n\tdefault:\n\t\t*cp++ = resp;\n\t\t/* FALLTHROUGH */\n\tcase 1:\t\t/* error, followed by error msg */\n\tcase 2:\t\t/* fatal error, \"\" */\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tlostconn(0);\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &rbuf[sizeof(rbuf) - 1] && ch != '\\n');\n\n\t\tif (!iamremote) {\n\t\t\tcp[-1] = '\\0';\n\t\t\t(void) snmprintf(visbuf, sizeof(visbuf),\n\t\t\t    NULL, \"%s\\n\", rbuf);\n\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t    visbuf, strlen(visbuf));\n\t\t}\n\t\t++errs;\n\t\tif (resp == 1)\n\t\t\treturn (-1);\n\t\texit(1);\n\t}\n\t/* NOTREACHED */\n}"
  },
  {
    "function_name": "rsource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
    "lines": "915-962",
    "snippet": "void\nrsource(char *name, struct stat *statp)\n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *last, *vect[1], path[PATH_MAX];\n\n\tif (!(dirp = opendir(name))) {\n\t\trun_err(\"%s: %s\", name, strerror(errno));\n\t\treturn;\n\t}\n\tlast = strrchr(name, '/');\n\tif (last == NULL)\n\t\tlast = name;\n\telse\n\t\tlast++;\n\tif (pflag) {\n\t\tif (do_times(remout, verbose_mode, statp) < 0) {\n\t\t\tclosedir(dirp);\n\t\t\treturn;\n\t\t}\n\t}\n\t(void) snprintf(path, sizeof path, \"D%04o %d %.1024s\\n\",\n\t    (u_int) (statp->st_mode & FILEMODEMASK), 0, last);\n\tif (verbose_mode)\n\t\tfmprintf(stderr, \"Entering directory: %s\", path);\n\t(void) atomicio(vwrite, remout, path, strlen(path));\n\tif (response() < 0) {\n\t\tclosedir(dirp);\n\t\treturn;\n\t}\n\twhile ((dp = readdir(dirp)) != NULL) {\n\t\tif (dp->d_ino == 0)\n\t\t\tcontinue;\n\t\tif (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tif (strlen(name) + 1 + strlen(dp->d_name) >= sizeof(path) - 1) {\n\t\t\trun_err(\"%s/%s: name too long\", name, dp->d_name);\n\t\t\tcontinue;\n\t\t}\n\t\t(void) snprintf(path, sizeof path, \"%s/%s\", name, dp->d_name);\n\t\tvect[0] = path;\n\t\tsource(1, vect);\n\t}\n\t(void) closedir(dirp);\n\t(void) atomicio(vwrite, remout, \"E\\n\", 2);\n\t(void) response();\n}",
    "includes": [
      "#include \"utf8.h\"",
      "#include \"progressmeter.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include <sys/uio.h>",
      "#include <sys/wait.h>",
      "# include <sys/time.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define\tFILEMODEMASK\t(S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO)"
    ],
    "globals_used": [
      "int verbose_mode = 0;",
      "void run_err(const char *,...);",
      "int errs, remin, remout;",
      "int response(void);",
      "void rsource(char *, struct stat *);",
      "void source(int, char *[]);",
      "char ch, *cp, *np, *targ, *why, *vect[1], buf[2048], visbuf[2048];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "response",
          "args": [],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1276-1312",
          "snippet": "int\nresponse(void)\n{\n\tchar ch, *cp, resp, rbuf[2048], visbuf[2048];\n\n\tif (atomicio(read, remin, &resp, sizeof(resp)) != sizeof(resp))\n\t\tlostconn(0);\n\n\tcp = rbuf;\n\tswitch (resp) {\n\tcase 0:\t\t/* ok */\n\t\treturn (0);\n\tdefault:\n\t\t*cp++ = resp;\n\t\t/* FALLTHROUGH */\n\tcase 1:\t\t/* error, followed by error msg */\n\tcase 2:\t\t/* fatal error, \"\" */\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tlostconn(0);\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &rbuf[sizeof(rbuf) - 1] && ch != '\\n');\n\n\t\tif (!iamremote) {\n\t\t\tcp[-1] = '\\0';\n\t\t\t(void) snmprintf(visbuf, sizeof(visbuf),\n\t\t\t    NULL, \"%s\\n\", rbuf);\n\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t    visbuf, strlen(visbuf));\n\t\t}\n\t\t++errs;\n\t\tif (resp == 1)\n\t\t\treturn (-1);\n\t\texit(1);\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void lostconn(int);",
            "int response(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid lostconn(int);\nint response(void);\n\nint\nresponse(void)\n{\n\tchar ch, *cp, resp, rbuf[2048], visbuf[2048];\n\n\tif (atomicio(read, remin, &resp, sizeof(resp)) != sizeof(resp))\n\t\tlostconn(0);\n\n\tcp = rbuf;\n\tswitch (resp) {\n\tcase 0:\t\t/* ok */\n\t\treturn (0);\n\tdefault:\n\t\t*cp++ = resp;\n\t\t/* FALLTHROUGH */\n\tcase 1:\t\t/* error, followed by error msg */\n\tcase 2:\t\t/* fatal error, \"\" */\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tlostconn(0);\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &rbuf[sizeof(rbuf) - 1] && ch != '\\n');\n\n\t\tif (!iamremote) {\n\t\t\tcp[-1] = '\\0';\n\t\t\t(void) snmprintf(visbuf, sizeof(visbuf),\n\t\t\t    NULL, \"%s\\n\", rbuf);\n\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t    visbuf, strlen(visbuf));\n\t\t}\n\t\t++errs;\n\t\tif (resp == 1)\n\t\t\treturn (-1);\n\t\texit(1);\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomicio",
          "args": [
            "vwrite",
            "remout",
            "\"E\\n\"",
            "2"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "atomiciov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "165-170",
          "snippet": "size_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dirp"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "fudge_closedir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-glob.c",
          "lines": "103-108",
          "snippet": "static void\nfudge_closedir(struct SFTP_OPENDIR *od)\n{\n\tfree_sftp_dirents(od->dir);\n\tfree(od);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <dirent.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdlib.h>\n#include <dirent.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nfudge_closedir(struct SFTP_OPENDIR *od)\n{\n\tfree_sftp_dirents(od->dir);\n\tfree(od);\n}"
        }
      },
      {
        "call_info": {
          "callee": "source",
          "args": [
            "1",
            "vect"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "rsource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "915-962",
          "snippet": "void\nrsource(char *name, struct stat *statp)\n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *last, *vect[1], path[PATH_MAX];\n\n\tif (!(dirp = opendir(name))) {\n\t\trun_err(\"%s: %s\", name, strerror(errno));\n\t\treturn;\n\t}\n\tlast = strrchr(name, '/');\n\tif (last == NULL)\n\t\tlast = name;\n\telse\n\t\tlast++;\n\tif (pflag) {\n\t\tif (do_times(remout, verbose_mode, statp) < 0) {\n\t\t\tclosedir(dirp);\n\t\t\treturn;\n\t\t}\n\t}\n\t(void) snprintf(path, sizeof path, \"D%04o %d %.1024s\\n\",\n\t    (u_int) (statp->st_mode & FILEMODEMASK), 0, last);\n\tif (verbose_mode)\n\t\tfmprintf(stderr, \"Entering directory: %s\", path);\n\t(void) atomicio(vwrite, remout, path, strlen(path));\n\tif (response() < 0) {\n\t\tclosedir(dirp);\n\t\treturn;\n\t}\n\twhile ((dp = readdir(dirp)) != NULL) {\n\t\tif (dp->d_ino == 0)\n\t\t\tcontinue;\n\t\tif (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tif (strlen(name) + 1 + strlen(dp->d_name) >= sizeof(path) - 1) {\n\t\t\trun_err(\"%s/%s: name too long\", name, dp->d_name);\n\t\t\tcontinue;\n\t\t}\n\t\t(void) snprintf(path, sizeof path, \"%s/%s\", name, dp->d_name);\n\t\tvect[0] = path;\n\t\tsource(1, vect);\n\t}\n\t(void) closedir(dirp);\n\t(void) atomicio(vwrite, remout, \"E\\n\", 2);\n\t(void) response();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "sizeof path",
            "\"%s/%s\"",
            "name",
            "dp->d_name"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "run_err",
          "args": [
            "\"%s/%s: name too long\"",
            "name",
            "dp->d_name"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "run_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1323-1346",
          "snippet": "void\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void run_err(const char *,...);",
            "int errs, remin, remout;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid run_err(const char *,...);\nint errs, remin, remout;\n\nvoid\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dp->d_name"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dp->d_name",
            "\"..\""
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dirp"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "process_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1034-1088",
          "snippet": "static void\nprocess_readdir(u_int32_t id)\n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *path;\n\tint r, handle;\n\n\tif ((r = get_handle(iqueue, &handle)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug(\"request %u: readdir \\\"%s\\\" (handle %d)\", id,\n\t    handle_to_name(handle), handle);\n\tdirp = handle_to_dir(handle);\n\tpath = handle_to_name(handle);\n\tif (dirp == NULL || path == NULL) {\n\t\tsend_status(id, SSH2_FX_FAILURE);\n\t} else {\n\t\tstruct stat st;\n\t\tchar pathname[PATH_MAX];\n\t\tStat *stats;\n\t\tint nstats = 10, count = 0, i;\n\n\t\tstats = xcalloc(nstats, sizeof(Stat));\n\t\twhile ((dp = readdir(dirp)) != NULL) {\n\t\t\tif (count >= nstats) {\n\t\t\t\tnstats *= 2;\n\t\t\t\tstats = xreallocarray(stats, nstats, sizeof(Stat));\n\t\t\t}\n/* XXX OVERFLOW ? */\n\t\t\tsnprintf(pathname, sizeof pathname, \"%s%s%s\", path,\n\t\t\t    strcmp(path, \"/\") ? \"/\" : \"\", dp->d_name);\n\t\t\tif (lstat(pathname, &st) < 0)\n\t\t\t\tcontinue;\n\t\t\tstat_to_attrib(&st, &(stats[count].attrib));\n\t\t\tstats[count].name = xstrdup(dp->d_name);\n\t\t\tstats[count].long_name = ls_file(dp->d_name, &st, 0, 0);\n\t\t\tcount++;\n\t\t\t/* send up to 100 entries in one message */\n\t\t\t/* XXX check packet size instead */\n\t\t\tif (count == 100)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (count > 0) {\n\t\t\tsend_names(id, count, stats);\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tfree(stats[i].name);\n\t\t\t\tfree(stats[i].long_name);\n\t\t\t}\n\t\t} else {\n\t\t\tsend_status(id, SSH2_FX_EOF);\n\t\t}\n\t\tfree(stats);\n\t}\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct sshbuf *iqueue;",
            "static void process_open(u_int32_t id);",
            "static void process_close(u_int32_t id);",
            "static void process_read(u_int32_t id);",
            "static void process_write(u_int32_t id);",
            "static void process_stat(u_int32_t id);",
            "static void process_lstat(u_int32_t id);",
            "static void process_fstat(u_int32_t id);",
            "static void process_setstat(u_int32_t id);",
            "static void process_fsetstat(u_int32_t id);",
            "static void process_opendir(u_int32_t id);",
            "static void process_readdir(u_int32_t id);",
            "static void process_remove(u_int32_t id);",
            "static void process_mkdir(u_int32_t id);",
            "static void process_rmdir(u_int32_t id);",
            "static void process_realpath(u_int32_t id);",
            "static void process_rename(u_int32_t id);",
            "static void process_readlink(u_int32_t id);",
            "static void process_symlink(u_int32_t id);",
            "static void process_extended_posix_rename(u_int32_t id);",
            "static void process_extended_statvfs(u_int32_t id);",
            "static void process_extended_fstatvfs(u_int32_t id);",
            "static void process_extended_hardlink(u_int32_t id);",
            "static void process_extended_fsync(u_int32_t id);",
            "static void process_extended(u_int32_t id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *iqueue;\nstatic void process_open(u_int32_t id);\nstatic void process_close(u_int32_t id);\nstatic void process_read(u_int32_t id);\nstatic void process_write(u_int32_t id);\nstatic void process_stat(u_int32_t id);\nstatic void process_lstat(u_int32_t id);\nstatic void process_fstat(u_int32_t id);\nstatic void process_setstat(u_int32_t id);\nstatic void process_fsetstat(u_int32_t id);\nstatic void process_opendir(u_int32_t id);\nstatic void process_readdir(u_int32_t id);\nstatic void process_remove(u_int32_t id);\nstatic void process_mkdir(u_int32_t id);\nstatic void process_rmdir(u_int32_t id);\nstatic void process_realpath(u_int32_t id);\nstatic void process_rename(u_int32_t id);\nstatic void process_readlink(u_int32_t id);\nstatic void process_symlink(u_int32_t id);\nstatic void process_extended_posix_rename(u_int32_t id);\nstatic void process_extended_statvfs(u_int32_t id);\nstatic void process_extended_fstatvfs(u_int32_t id);\nstatic void process_extended_hardlink(u_int32_t id);\nstatic void process_extended_fsync(u_int32_t id);\nstatic void process_extended(u_int32_t id);\n\nstatic void\nprocess_readdir(u_int32_t id)\n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *path;\n\tint r, handle;\n\n\tif ((r = get_handle(iqueue, &handle)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug(\"request %u: readdir \\\"%s\\\" (handle %d)\", id,\n\t    handle_to_name(handle), handle);\n\tdirp = handle_to_dir(handle);\n\tpath = handle_to_name(handle);\n\tif (dirp == NULL || path == NULL) {\n\t\tsend_status(id, SSH2_FX_FAILURE);\n\t} else {\n\t\tstruct stat st;\n\t\tchar pathname[PATH_MAX];\n\t\tStat *stats;\n\t\tint nstats = 10, count = 0, i;\n\n\t\tstats = xcalloc(nstats, sizeof(Stat));\n\t\twhile ((dp = readdir(dirp)) != NULL) {\n\t\t\tif (count >= nstats) {\n\t\t\t\tnstats *= 2;\n\t\t\t\tstats = xreallocarray(stats, nstats, sizeof(Stat));\n\t\t\t}\n/* XXX OVERFLOW ? */\n\t\t\tsnprintf(pathname, sizeof pathname, \"%s%s%s\", path,\n\t\t\t    strcmp(path, \"/\") ? \"/\" : \"\", dp->d_name);\n\t\t\tif (lstat(pathname, &st) < 0)\n\t\t\t\tcontinue;\n\t\t\tstat_to_attrib(&st, &(stats[count].attrib));\n\t\t\tstats[count].name = xstrdup(dp->d_name);\n\t\t\tstats[count].long_name = ls_file(dp->d_name, &st, 0, 0);\n\t\t\tcount++;\n\t\t\t/* send up to 100 entries in one message */\n\t\t\t/* XXX check packet size instead */\n\t\t\tif (count == 100)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (count > 0) {\n\t\t\tsend_names(id, count, stats);\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tfree(stats[i].name);\n\t\t\t\tfree(stats[i].long_name);\n\t\t\t}\n\t\t} else {\n\t\t\tsend_status(id, SSH2_FX_EOF);\n\t\t}\n\t\tfree(stats);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmprintf",
          "args": [
            "stderr",
            "\"Entering directory: %s\"",
            "path"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "fmprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "277-287",
          "snippet": "int\nfmprintf(FILE *stream, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stream, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nfmprintf(FILE *stream, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stream, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "statp->st_mode & FILEMODEMASK"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_times",
          "args": [
            "remout",
            "verbose_mode",
            "statp"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "do_times",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "593-609",
          "snippet": "static int\ndo_times(int fd, int verb, const struct stat *sb)\n{\n\t/* strlen(2^64) == 20; strlen(10^6) == 7 */\n\tchar buf[(20 + 7 + 2) * 2 + 2];\n\n\t(void)snprintf(buf, sizeof(buf), \"T%llu 0 %llu 0\\n\",\n\t    (unsigned long long) (sb->st_mtime < 0 ? 0 : sb->st_mtime),\n\t    (unsigned long long) (sb->st_atime < 0 ? 0 : sb->st_atime));\n\tif (verb) {\n\t\tfprintf(stderr, \"File mtime %lld atime %lld\\n\",\n\t\t    (long long)sb->st_mtime, (long long)sb->st_atime);\n\t\tfprintf(stderr, \"Sending file timestamps: %s\", buf);\n\t}\n\t(void) atomicio(vwrite, fd, buf, strlen(buf));\n\treturn (response());\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tmtime\ttv[1]",
            "#define\tatime\ttv[0]"
          ],
          "globals_used": [
            "int response(void);",
            "void rsource(char *, struct stat *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define\tmtime\ttv[1]\n#define\tatime\ttv[0]\n\nint response(void);\nvoid rsource(char *, struct stat *);\n\nstatic int\ndo_times(int fd, int verb, const struct stat *sb)\n{\n\t/* strlen(2^64) == 20; strlen(10^6) == 7 */\n\tchar buf[(20 + 7 + 2) * 2 + 2];\n\n\t(void)snprintf(buf, sizeof(buf), \"T%llu 0 %llu 0\\n\",\n\t    (unsigned long long) (sb->st_mtime < 0 ? 0 : sb->st_mtime),\n\t    (unsigned long long) (sb->st_atime < 0 ? 0 : sb->st_atime));\n\tif (verb) {\n\t\tfprintf(stderr, \"File mtime %lld atime %lld\\n\",\n\t\t    (long long)sb->st_mtime, (long long)sb->st_atime);\n\t\tfprintf(stderr, \"Sending file timestamps: %s\", buf);\n\t}\n\t(void) atomicio(vwrite, fd, buf, strlen(buf));\n\treturn (response());\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "name",
            "'/'"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "name"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "process_opendir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1004-1032",
          "snippet": "static void\nprocess_opendir(u_int32_t id)\n{\n\tDIR *dirp = NULL;\n\tchar *path;\n\tint r, handle, status = SSH2_FX_FAILURE;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"request %u: opendir\", id);\n\tlogit(\"opendir \\\"%s\\\"\", path);\n\tdirp = opendir(path);\n\tif (dirp == NULL) {\n\t\tstatus = errno_to_portable(errno);\n\t} else {\n\t\thandle = handle_new(HANDLE_DIR, path, 0, 0, dirp);\n\t\tif (handle < 0) {\n\t\t\tclosedir(dirp);\n\t\t} else {\n\t\t\tsend_handle(id, handle);\n\t\t\tstatus = SSH2_FX_OK;\n\t\t}\n\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(path);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct sshbuf *iqueue;",
            "static void process_open(u_int32_t id);",
            "static void process_close(u_int32_t id);",
            "static void process_read(u_int32_t id);",
            "static void process_write(u_int32_t id);",
            "static void process_stat(u_int32_t id);",
            "static void process_lstat(u_int32_t id);",
            "static void process_fstat(u_int32_t id);",
            "static void process_setstat(u_int32_t id);",
            "static void process_fsetstat(u_int32_t id);",
            "static void process_opendir(u_int32_t id);",
            "static void process_readdir(u_int32_t id);",
            "static void process_remove(u_int32_t id);",
            "static void process_mkdir(u_int32_t id);",
            "static void process_rmdir(u_int32_t id);",
            "static void process_realpath(u_int32_t id);",
            "static void process_rename(u_int32_t id);",
            "static void process_readlink(u_int32_t id);",
            "static void process_symlink(u_int32_t id);",
            "static void process_extended_posix_rename(u_int32_t id);",
            "static void process_extended_statvfs(u_int32_t id);",
            "static void process_extended_fstatvfs(u_int32_t id);",
            "static void process_extended_hardlink(u_int32_t id);",
            "static void process_extended_fsync(u_int32_t id);",
            "static void process_extended(u_int32_t id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *iqueue;\nstatic void process_open(u_int32_t id);\nstatic void process_close(u_int32_t id);\nstatic void process_read(u_int32_t id);\nstatic void process_write(u_int32_t id);\nstatic void process_stat(u_int32_t id);\nstatic void process_lstat(u_int32_t id);\nstatic void process_fstat(u_int32_t id);\nstatic void process_setstat(u_int32_t id);\nstatic void process_fsetstat(u_int32_t id);\nstatic void process_opendir(u_int32_t id);\nstatic void process_readdir(u_int32_t id);\nstatic void process_remove(u_int32_t id);\nstatic void process_mkdir(u_int32_t id);\nstatic void process_rmdir(u_int32_t id);\nstatic void process_realpath(u_int32_t id);\nstatic void process_rename(u_int32_t id);\nstatic void process_readlink(u_int32_t id);\nstatic void process_symlink(u_int32_t id);\nstatic void process_extended_posix_rename(u_int32_t id);\nstatic void process_extended_statvfs(u_int32_t id);\nstatic void process_extended_fstatvfs(u_int32_t id);\nstatic void process_extended_hardlink(u_int32_t id);\nstatic void process_extended_fsync(u_int32_t id);\nstatic void process_extended(u_int32_t id);\n\nstatic void\nprocess_opendir(u_int32_t id)\n{\n\tDIR *dirp = NULL;\n\tchar *path;\n\tint r, handle, status = SSH2_FX_FAILURE;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"request %u: opendir\", id);\n\tlogit(\"opendir \\\"%s\\\"\", path);\n\tdirp = opendir(path);\n\tif (dirp == NULL) {\n\t\tstatus = errno_to_portable(errno);\n\t} else {\n\t\thandle = handle_new(HANDLE_DIR, path, 0, 0, dirp);\n\t\tif (handle < 0) {\n\t\t\tclosedir(dirp);\n\t\t} else {\n\t\t\tsend_handle(id, handle);\n\t\t\tstatus = SSH2_FX_OK;\n\t\t}\n\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(path);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define\tFILEMODEMASK\t(S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO)\n\nint verbose_mode = 0;\nvoid run_err(const char *,...);\nint errs, remin, remout;\nint response(void);\nvoid rsource(char *, struct stat *);\nvoid source(int, char *[]);\nchar ch, *cp, *np, *targ, *why, *vect[1], buf[2048], visbuf[2048];\n\nvoid\nrsource(char *name, struct stat *statp)\n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *last, *vect[1], path[PATH_MAX];\n\n\tif (!(dirp = opendir(name))) {\n\t\trun_err(\"%s: %s\", name, strerror(errno));\n\t\treturn;\n\t}\n\tlast = strrchr(name, '/');\n\tif (last == NULL)\n\t\tlast = name;\n\telse\n\t\tlast++;\n\tif (pflag) {\n\t\tif (do_times(remout, verbose_mode, statp) < 0) {\n\t\t\tclosedir(dirp);\n\t\t\treturn;\n\t\t}\n\t}\n\t(void) snprintf(path, sizeof path, \"D%04o %d %.1024s\\n\",\n\t    (u_int) (statp->st_mode & FILEMODEMASK), 0, last);\n\tif (verbose_mode)\n\t\tfmprintf(stderr, \"Entering directory: %s\", path);\n\t(void) atomicio(vwrite, remout, path, strlen(path));\n\tif (response() < 0) {\n\t\tclosedir(dirp);\n\t\treturn;\n\t}\n\twhile ((dp = readdir(dirp)) != NULL) {\n\t\tif (dp->d_ino == 0)\n\t\t\tcontinue;\n\t\tif (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tif (strlen(name) + 1 + strlen(dp->d_name) >= sizeof(path) - 1) {\n\t\t\trun_err(\"%s/%s: name too long\", name, dp->d_name);\n\t\t\tcontinue;\n\t\t}\n\t\t(void) snprintf(path, sizeof path, \"%s/%s\", name, dp->d_name);\n\t\tvect[0] = path;\n\t\tsource(1, vect);\n\t}\n\t(void) closedir(dirp);\n\t(void) atomicio(vwrite, remout, \"E\\n\", 2);\n\t(void) response();\n}"
  },
  {
    "function_name": "source",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
    "lines": "803-913",
    "snippet": "void\nsource(int argc, char **argv)\n{\n\tstruct stat stb;\n\tstatic BUF buffer;\n\tBUF *bp;\n\toff_t i, statbytes;\n\tsize_t amt, nr;\n\tint fd = -1, haderr, indx;\n\tchar *last, *name, buf[2048], encname[PATH_MAX];\n\tint len;\n\n\tfor (indx = 0; indx < argc; ++indx) {\n\t\tname = argv[indx];\n\t\tstatbytes = 0;\n\t\tlen = strlen(name);\n\t\twhile (len > 1 && name[len-1] == '/')\n\t\t\tname[--len] = '\\0';\n\t\tif ((fd = open(name, O_RDONLY|O_NONBLOCK, 0)) < 0)\n\t\t\tgoto syserr;\n\t\tif (strchr(name, '\\n') != NULL) {\n\t\t\tstrnvis(encname, name, sizeof(encname), VIS_NL);\n\t\t\tname = encname;\n\t\t}\n\t\tif (fstat(fd, &stb) < 0) {\nsyserr:\t\t\trun_err(\"%s: %s\", name, strerror(errno));\n\t\t\tgoto next;\n\t\t}\n\t\tif (stb.st_size < 0) {\n\t\t\trun_err(\"%s: %s\", name, \"Negative file size\");\n\t\t\tgoto next;\n\t\t}\n\t\tunset_nonblock(fd);\n\t\tswitch (stb.st_mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tif (iamrecursive) {\n\t\t\t\trsource(name, &stb);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tdefault:\n\t\t\trun_err(\"%s: not a regular file\", name);\n\t\t\tgoto next;\n\t\t}\n\t\tif ((last = strrchr(name, '/')) == NULL)\n\t\t\tlast = name;\n\t\telse\n\t\t\t++last;\n\t\tcurfile = last;\n\t\tif (pflag) {\n\t\t\tif (do_times(remout, verbose_mode, &stb) < 0)\n\t\t\t\tgoto next;\n\t\t}\n#define\tFILEMODEMASK\t(S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO)\n\t\tsnprintf(buf, sizeof buf, \"C%04o %lld %s\\n\",\n\t\t    (u_int) (stb.st_mode & FILEMODEMASK),\n\t\t    (long long)stb.st_size, last);\n\t\tif (verbose_mode)\n\t\t\tfmprintf(stderr, \"Sending file modes: %s\", buf);\n\t\t(void) atomicio(vwrite, remout, buf, strlen(buf));\n\t\tif (response() < 0)\n\t\t\tgoto next;\n\t\tif ((bp = allocbuf(&buffer, fd, COPY_BUFLEN)) == NULL) {\nnext:\t\t\tif (fd != -1) {\n\t\t\t\t(void) close(fd);\n\t\t\t\tfd = -1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (showprogress)\n\t\t\tstart_progress_meter(curfile, stb.st_size, &statbytes);\n\t\tset_nonblock(remout);\n\t\tfor (haderr = i = 0; i < stb.st_size; i += bp->cnt) {\n\t\t\tamt = bp->cnt;\n\t\t\tif (i + (off_t)amt > stb.st_size)\n\t\t\t\tamt = stb.st_size - i;\n\t\t\tif (!haderr) {\n\t\t\t\tif ((nr = atomicio(read, fd,\n\t\t\t\t    bp->buf, amt)) != amt) {\n\t\t\t\t\thaderr = errno;\n\t\t\t\t\tmemset(bp->buf + nr, 0, amt - nr);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Keep writing after error to retain sync */\n\t\t\tif (haderr) {\n\t\t\t\t(void)atomicio(vwrite, remout, bp->buf, amt);\n\t\t\t\tmemset(bp->buf, 0, amt);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (atomicio6(vwrite, remout, bp->buf, amt, scpio,\n\t\t\t    &statbytes) != amt)\n\t\t\t\thaderr = errno;\n\t\t}\n\t\tunset_nonblock(remout);\n\n\t\tif (fd != -1) {\n\t\t\tif (close(fd) < 0 && !haderr)\n\t\t\t\thaderr = errno;\n\t\t\tfd = -1;\n\t\t}\n\t\tif (!haderr)\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\telse\n\t\t\trun_err(\"%s: %s\", name, strerror(haderr));\n\t\t(void) response();\n\t\tif (showprogress)\n\t\t\tstop_progress_meter();\n\t}\n}",
    "includes": [
      "#include \"utf8.h\"",
      "#include \"progressmeter.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include <sys/uio.h>",
      "#include <sys/wait.h>",
      "# include <sys/time.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define\tFILEMODEMASK\t(S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO)",
      "#define COPY_BUFLEN\t16384"
    ],
    "globals_used": [
      "char *curfile;",
      "int verbose_mode = 0;",
      "int showprogress = 1;",
      "BUF *allocbuf(BUF *, int, int);",
      "void run_err(const char *,...);",
      "int errs, remin, remout;",
      "int response(void);",
      "void rsource(char *, struct stat *);",
      "void source(int, char *[]);",
      "static BUF buffer;",
      "struct stat stb;",
      "BUF *bp;",
      "off_t i;",
      "off_t size, statbytes;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stop_progress_meter",
          "args": [],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "stop_progress_meter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/progressmeter.c",
          "lines": "270-283",
          "snippet": "void\nstop_progress_meter(void)\n{\n\talarm(0);\n\n\tif (!can_output())\n\t\treturn;\n\n\t/* Ensure we complete the progress */\n\tif (cur_pos != end_pos)\n\t\trefresh_progress_meter();\n\n\tatomicio(vwrite, STDOUT_FILENO, \"\\n\", 1);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"progressmeter.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_output(void);",
            "void refresh_progress_meter(void);",
            "static off_t end_pos;",
            "static off_t cur_pos;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"progressmeter.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int can_output(void);\nvoid refresh_progress_meter(void);\nstatic off_t end_pos;\nstatic off_t cur_pos;\n\nvoid\nstop_progress_meter(void)\n{\n\talarm(0);\n\n\tif (!can_output())\n\t\treturn;\n\n\t/* Ensure we complete the progress */\n\tif (cur_pos != end_pos)\n\t\trefresh_progress_meter();\n\n\tatomicio(vwrite, STDOUT_FILENO, \"\\n\", 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "response",
          "args": [],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1276-1312",
          "snippet": "int\nresponse(void)\n{\n\tchar ch, *cp, resp, rbuf[2048], visbuf[2048];\n\n\tif (atomicio(read, remin, &resp, sizeof(resp)) != sizeof(resp))\n\t\tlostconn(0);\n\n\tcp = rbuf;\n\tswitch (resp) {\n\tcase 0:\t\t/* ok */\n\t\treturn (0);\n\tdefault:\n\t\t*cp++ = resp;\n\t\t/* FALLTHROUGH */\n\tcase 1:\t\t/* error, followed by error msg */\n\tcase 2:\t\t/* fatal error, \"\" */\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tlostconn(0);\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &rbuf[sizeof(rbuf) - 1] && ch != '\\n');\n\n\t\tif (!iamremote) {\n\t\t\tcp[-1] = '\\0';\n\t\t\t(void) snmprintf(visbuf, sizeof(visbuf),\n\t\t\t    NULL, \"%s\\n\", rbuf);\n\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t    visbuf, strlen(visbuf));\n\t\t}\n\t\t++errs;\n\t\tif (resp == 1)\n\t\t\treturn (-1);\n\t\texit(1);\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void lostconn(int);",
            "int response(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid lostconn(int);\nint response(void);\n\nint\nresponse(void)\n{\n\tchar ch, *cp, resp, rbuf[2048], visbuf[2048];\n\n\tif (atomicio(read, remin, &resp, sizeof(resp)) != sizeof(resp))\n\t\tlostconn(0);\n\n\tcp = rbuf;\n\tswitch (resp) {\n\tcase 0:\t\t/* ok */\n\t\treturn (0);\n\tdefault:\n\t\t*cp++ = resp;\n\t\t/* FALLTHROUGH */\n\tcase 1:\t\t/* error, followed by error msg */\n\tcase 2:\t\t/* fatal error, \"\" */\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tlostconn(0);\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &rbuf[sizeof(rbuf) - 1] && ch != '\\n');\n\n\t\tif (!iamremote) {\n\t\t\tcp[-1] = '\\0';\n\t\t\t(void) snmprintf(visbuf, sizeof(visbuf),\n\t\t\t    NULL, \"%s\\n\", rbuf);\n\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t    visbuf, strlen(visbuf));\n\t\t}\n\t\t++errs;\n\t\tif (resp == 1)\n\t\t\treturn (-1);\n\t\texit(1);\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "run_err",
          "args": [
            "\"%s: %s\"",
            "name",
            "strerror(haderr)"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "run_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1323-1346",
          "snippet": "void\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void run_err(const char *,...);",
            "int errs, remin, remout;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid run_err(const char *,...);\nint errs, remin, remout;\n\nvoid\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "haderr"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomicio",
          "args": [
            "vwrite",
            "remout",
            "\"\"",
            "1"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "atomiciov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "165-170",
          "snippet": "size_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unset_nonblock",
          "args": [
            "remout"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "unset_nonblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "116-138",
          "snippet": "int\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomicio6",
          "args": [
            "vwrite",
            "remout",
            "bp->buf",
            "amt",
            "scpio",
            "&statbytes"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "atomicio6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "51-89",
          "snippet": "size_t\natomicio6(ssize_t (*f) (int, void *, size_t), int fd, void *_s, size_t n,\n    int (*cb)(void *, size_t), void *cb_arg)\n{\n\tchar *s = _s;\n\tsize_t pos = 0;\n\tssize_t res;\n\tstruct pollfd pfd;\n\n#ifndef BROKEN_READ_COMPARISON\n\tpfd.fd = fd;\n\tpfd.events = f == read ? POLLIN : POLLOUT;\n#endif\n\twhile (n > pos) {\n\t\tres = (f) (fd, s + pos, n - pos);\n\t\tswitch (res) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tif (errno == EAGAIN || errno == EWOULDBLOCK) {\n#ifndef BROKEN_READ_COMPARISON\n\t\t\t\t(void)poll(&pfd, 1, -1);\n#endif\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase 0:\n\t\t\terrno = EPIPE;\n\t\t\treturn pos;\n\t\tdefault:\n\t\t\tpos += (size_t)res;\n\t\t\tif (cb != NULL && cb(cb_arg, (size_t)res) == -1) {\n\t\t\t\terrno = EINTR;\n\t\t\t\treturn pos;\n\t\t\t}\n\t\t}\n\t}\n\treturn pos;\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomicio6(ssize_t (*f) (int, void *, size_t), int fd, void *_s, size_t n,\n    int (*cb)(void *, size_t), void *cb_arg)\n{\n\tchar *s = _s;\n\tsize_t pos = 0;\n\tssize_t res;\n\tstruct pollfd pfd;\n\n#ifndef BROKEN_READ_COMPARISON\n\tpfd.fd = fd;\n\tpfd.events = f == read ? POLLIN : POLLOUT;\n#endif\n\twhile (n > pos) {\n\t\tres = (f) (fd, s + pos, n - pos);\n\t\tswitch (res) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tif (errno == EAGAIN || errno == EWOULDBLOCK) {\n#ifndef BROKEN_READ_COMPARISON\n\t\t\t\t(void)poll(&pfd, 1, -1);\n#endif\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase 0:\n\t\t\terrno = EPIPE;\n\t\t\treturn pos;\n\t\tdefault:\n\t\t\tpos += (size_t)res;\n\t\t\tif (cb != NULL && cb(cb_arg, (size_t)res) == -1) {\n\t\t\t\terrno = EINTR;\n\t\t\t\treturn pos;\n\t\t\t}\n\t\t}\n\t}\n\treturn pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bp->buf",
            "0",
            "amt"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bp->buf + nr",
            "0",
            "amt - nr"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_progress_meter",
          "args": [
            "curfile",
            "stb.st_size",
            "&statbytes"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "start_progress_meter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/progressmeter.c",
          "lines": "249-268",
          "snippet": "void\nstart_progress_meter(const char *f, off_t filesize, off_t *ctr)\n{\n\tstart = last_update = monotime_double();\n\tfile = f;\n\tstart_pos = *ctr;\n\tend_pos = filesize;\n\tcur_pos = 0;\n\tcounter = ctr;\n\tstalled = 0;\n\tbytes_per_second = 0;\n\n\tsetscreensize();\n\tif (can_output())\n\t\trefresh_progress_meter();\n\n\tsignal(SIGALRM, update_progress_meter);\n\tsignal(SIGWINCH, sig_winch);\n\talarm(UPDATE_INTERVAL);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"progressmeter.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define UPDATE_INTERVAL 1\t/* update the progress meter every second */"
          ],
          "globals_used": [
            "static int can_output(void);",
            "static void format_size(char *, int, off_t);",
            "static void format_rate(char *, int, off_t);",
            "static void sig_winch(int);",
            "static void setscreensize(void);",
            "void refresh_progress_meter(void);",
            "static void update_progress_meter(int);",
            "static double start;",
            "static double last_update;",
            "static const char *file;",
            "static off_t start_pos;",
            "static off_t end_pos;",
            "static off_t cur_pos;",
            "static volatile off_t *counter;",
            "static long stalled;",
            "static int bytes_per_second;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"progressmeter.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define UPDATE_INTERVAL 1\t/* update the progress meter every second */\n\nstatic int can_output(void);\nstatic void format_size(char *, int, off_t);\nstatic void format_rate(char *, int, off_t);\nstatic void sig_winch(int);\nstatic void setscreensize(void);\nvoid refresh_progress_meter(void);\nstatic void update_progress_meter(int);\nstatic double start;\nstatic double last_update;\nstatic const char *file;\nstatic off_t start_pos;\nstatic off_t end_pos;\nstatic off_t cur_pos;\nstatic volatile off_t *counter;\nstatic long stalled;\nstatic int bytes_per_second;\n\nvoid\nstart_progress_meter(const char *f, off_t filesize, off_t *ctr)\n{\n\tstart = last_update = monotime_double();\n\tfile = f;\n\tstart_pos = *ctr;\n\tend_pos = filesize;\n\tcur_pos = 0;\n\tcounter = ctr;\n\tstalled = 0;\n\tbytes_per_second = 0;\n\n\tsetscreensize();\n\tif (can_output())\n\t\trefresh_progress_meter();\n\n\tsignal(SIGALRM, update_progress_meter);\n\tsignal(SIGWINCH, sig_winch);\n\talarm(UPDATE_INTERVAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "allocbuf",
          "args": [
            "&buffer",
            "fd",
            "COPY_BUFLEN"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "allocbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1392-1414",
          "snippet": "BUF *\nallocbuf(BUF *bp, int fd, int blksize)\n{\n\tsize_t size;\n#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE\n\tstruct stat stb;\n\n\tif (fstat(fd, &stb) < 0) {\n\t\trun_err(\"fstat: %s\", strerror(errno));\n\t\treturn (0);\n\t}\n\tsize = ROUNDUP(stb.st_blksize, blksize);\n\tif (size == 0)\n\t\tsize = blksize;\n#else /* HAVE_STRUCT_STAT_ST_BLKSIZE */\n\tsize = blksize;\n#endif /* HAVE_STRUCT_STAT_ST_BLKSIZE */\n\tif (bp->cnt >= size)\n\t\treturn (bp);\n\tbp->buf = xrecallocarray(bp->buf, bp->cnt, size, 1);\n\tbp->cnt = size;\n\treturn (bp);\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "BUF *allocbuf(BUF *, int, int);",
            "void run_err(const char *,...);",
            "void rsource(char *, struct stat *);",
            "struct stat stb;",
            "BUF *bp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nBUF *allocbuf(BUF *, int, int);\nvoid run_err(const char *,...);\nvoid rsource(char *, struct stat *);\nstruct stat stb;\nBUF *bp;\n\nBUF *\nallocbuf(BUF *bp, int fd, int blksize)\n{\n\tsize_t size;\n#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE\n\tstruct stat stb;\n\n\tif (fstat(fd, &stb) < 0) {\n\t\trun_err(\"fstat: %s\", strerror(errno));\n\t\treturn (0);\n\t}\n\tsize = ROUNDUP(stb.st_blksize, blksize);\n\tif (size == 0)\n\t\tsize = blksize;\n#else /* HAVE_STRUCT_STAT_ST_BLKSIZE */\n\tsize = blksize;\n#endif /* HAVE_STRUCT_STAT_ST_BLKSIZE */\n\tif (bp->cnt >= size)\n\t\treturn (bp);\n\tbp->buf = xrecallocarray(bp->buf, bp->cnt, size, 1);\n\tbp->cnt = size;\n\treturn (bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmprintf",
          "args": [
            "stderr",
            "\"Sending file modes: %s\"",
            "buf"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "fmprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "277-287",
          "snippet": "int\nfmprintf(FILE *stream, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stream, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nfmprintf(FILE *stream, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stream, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof buf",
            "\"C%04o %lld %s\\n\"",
            "(u_int) (stb.st_mode & FILEMODEMASK)",
            "(long long)stb.st_size",
            "last"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "stb.st_mode & FILEMODEMASK"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_times",
          "args": [
            "remout",
            "verbose_mode",
            "&stb"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "do_times",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "593-609",
          "snippet": "static int\ndo_times(int fd, int verb, const struct stat *sb)\n{\n\t/* strlen(2^64) == 20; strlen(10^6) == 7 */\n\tchar buf[(20 + 7 + 2) * 2 + 2];\n\n\t(void)snprintf(buf, sizeof(buf), \"T%llu 0 %llu 0\\n\",\n\t    (unsigned long long) (sb->st_mtime < 0 ? 0 : sb->st_mtime),\n\t    (unsigned long long) (sb->st_atime < 0 ? 0 : sb->st_atime));\n\tif (verb) {\n\t\tfprintf(stderr, \"File mtime %lld atime %lld\\n\",\n\t\t    (long long)sb->st_mtime, (long long)sb->st_atime);\n\t\tfprintf(stderr, \"Sending file timestamps: %s\", buf);\n\t}\n\t(void) atomicio(vwrite, fd, buf, strlen(buf));\n\treturn (response());\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tmtime\ttv[1]",
            "#define\tatime\ttv[0]"
          ],
          "globals_used": [
            "int response(void);",
            "void rsource(char *, struct stat *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define\tmtime\ttv[1]\n#define\tatime\ttv[0]\n\nint response(void);\nvoid rsource(char *, struct stat *);\n\nstatic int\ndo_times(int fd, int verb, const struct stat *sb)\n{\n\t/* strlen(2^64) == 20; strlen(10^6) == 7 */\n\tchar buf[(20 + 7 + 2) * 2 + 2];\n\n\t(void)snprintf(buf, sizeof(buf), \"T%llu 0 %llu 0\\n\",\n\t    (unsigned long long) (sb->st_mtime < 0 ? 0 : sb->st_mtime),\n\t    (unsigned long long) (sb->st_atime < 0 ? 0 : sb->st_atime));\n\tif (verb) {\n\t\tfprintf(stderr, \"File mtime %lld atime %lld\\n\",\n\t\t    (long long)sb->st_mtime, (long long)sb->st_atime);\n\t\tfprintf(stderr, \"Sending file timestamps: %s\", buf);\n\t}\n\t(void) atomicio(vwrite, fd, buf, strlen(buf));\n\treturn (response());\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "name",
            "'/'"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsource",
          "args": [
            "name",
            "&stb"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "rsource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "915-962",
          "snippet": "void\nrsource(char *name, struct stat *statp)\n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *last, *vect[1], path[PATH_MAX];\n\n\tif (!(dirp = opendir(name))) {\n\t\trun_err(\"%s: %s\", name, strerror(errno));\n\t\treturn;\n\t}\n\tlast = strrchr(name, '/');\n\tif (last == NULL)\n\t\tlast = name;\n\telse\n\t\tlast++;\n\tif (pflag) {\n\t\tif (do_times(remout, verbose_mode, statp) < 0) {\n\t\t\tclosedir(dirp);\n\t\t\treturn;\n\t\t}\n\t}\n\t(void) snprintf(path, sizeof path, \"D%04o %d %.1024s\\n\",\n\t    (u_int) (statp->st_mode & FILEMODEMASK), 0, last);\n\tif (verbose_mode)\n\t\tfmprintf(stderr, \"Entering directory: %s\", path);\n\t(void) atomicio(vwrite, remout, path, strlen(path));\n\tif (response() < 0) {\n\t\tclosedir(dirp);\n\t\treturn;\n\t}\n\twhile ((dp = readdir(dirp)) != NULL) {\n\t\tif (dp->d_ino == 0)\n\t\t\tcontinue;\n\t\tif (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tif (strlen(name) + 1 + strlen(dp->d_name) >= sizeof(path) - 1) {\n\t\t\trun_err(\"%s/%s: name too long\", name, dp->d_name);\n\t\t\tcontinue;\n\t\t}\n\t\t(void) snprintf(path, sizeof path, \"%s/%s\", name, dp->d_name);\n\t\tvect[0] = path;\n\t\tsource(1, vect);\n\t}\n\t(void) closedir(dirp);\n\t(void) atomicio(vwrite, remout, \"E\\n\", 2);\n\t(void) response();\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tFILEMODEMASK\t(S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO)"
          ],
          "globals_used": [
            "int verbose_mode = 0;",
            "void run_err(const char *,...);",
            "int errs, remin, remout;",
            "int response(void);",
            "void rsource(char *, struct stat *);",
            "void source(int, char *[]);",
            "char ch, *cp, *np, *targ, *why, *vect[1], buf[2048], visbuf[2048];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define\tFILEMODEMASK\t(S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO)\n\nint verbose_mode = 0;\nvoid run_err(const char *,...);\nint errs, remin, remout;\nint response(void);\nvoid rsource(char *, struct stat *);\nvoid source(int, char *[]);\nchar ch, *cp, *np, *targ, *why, *vect[1], buf[2048], visbuf[2048];\n\nvoid\nrsource(char *name, struct stat *statp)\n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *last, *vect[1], path[PATH_MAX];\n\n\tif (!(dirp = opendir(name))) {\n\t\trun_err(\"%s: %s\", name, strerror(errno));\n\t\treturn;\n\t}\n\tlast = strrchr(name, '/');\n\tif (last == NULL)\n\t\tlast = name;\n\telse\n\t\tlast++;\n\tif (pflag) {\n\t\tif (do_times(remout, verbose_mode, statp) < 0) {\n\t\t\tclosedir(dirp);\n\t\t\treturn;\n\t\t}\n\t}\n\t(void) snprintf(path, sizeof path, \"D%04o %d %.1024s\\n\",\n\t    (u_int) (statp->st_mode & FILEMODEMASK), 0, last);\n\tif (verbose_mode)\n\t\tfmprintf(stderr, \"Entering directory: %s\", path);\n\t(void) atomicio(vwrite, remout, path, strlen(path));\n\tif (response() < 0) {\n\t\tclosedir(dirp);\n\t\treturn;\n\t}\n\twhile ((dp = readdir(dirp)) != NULL) {\n\t\tif (dp->d_ino == 0)\n\t\t\tcontinue;\n\t\tif (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tif (strlen(name) + 1 + strlen(dp->d_name) >= sizeof(path) - 1) {\n\t\t\trun_err(\"%s/%s: name too long\", name, dp->d_name);\n\t\t\tcontinue;\n\t\t}\n\t\t(void) snprintf(path, sizeof path, \"%s/%s\", name, dp->d_name);\n\t\tvect[0] = path;\n\t\tsource(1, vect);\n\t}\n\t(void) closedir(dirp);\n\t(void) atomicio(vwrite, remout, \"E\\n\", 2);\n\t(void) response();\n}"
        }
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&stb"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "fstatvfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-statvfs.c",
          "lines": "71-85",
          "snippet": "int fstatvfs(int fd, struct statvfs *buf)\n{\n#  ifdef HAVE_FSTATFS\n\tstruct statfs fs;\n\n\tmemset(&fs, 0, sizeof(fs));\n\tif (fstatfs(fd, &fs) == -1)\n\t\treturn -1;\n\tcopy_statfs_to_statvfs(buf, &fs);\n\treturn 0;\n#  else\n\terrno = ENOSYS;\n\treturn -1;\n#  endif\n}",
          "includes": [
            "#include <errno.h>",
            "# include <sys/mount.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n# include <sys/mount.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nint fstatvfs(int fd, struct statvfs *buf)\n{\n#  ifdef HAVE_FSTATFS\n\tstruct statfs fs;\n\n\tmemset(&fs, 0, sizeof(fs));\n\tif (fstatfs(fd, &fs) == -1)\n\t\treturn -1;\n\tcopy_statfs_to_statvfs(buf, &fs);\n\treturn 0;\n#  else\n\terrno = ENOSYS;\n\treturn -1;\n#  endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strnvis",
          "args": [
            "encname",
            "name",
            "sizeof(encname)",
            "VIS_NL"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "strnvis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/vis.c",
          "lines": "173-214",
          "snippet": "int\nstrnvis(char *dst, const char *src, size_t siz, int flag)\n{\n\tchar *start, *end;\n\tchar tbuf[5];\n\tint c, i;\n\n\ti = 0;\n\tfor (start = dst, end = start + siz - 1; (c = *src) && dst < end; ) {\n\t\tif (isvisible(c, flag)) {\n\t\t\tif ((c == '\"' && (flag & VIS_DQ) != 0) ||\n\t\t\t    (c == '\\\\' && (flag & VIS_NOSLASH) == 0)) {\n\t\t\t\t/* need space for the extra '\\\\' */\n\t\t\t\tif (dst + 1 >= end) {\n\t\t\t\t\ti = 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*dst++ = '\\\\';\n\t\t\t}\n\t\t\ti = 1;\n\t\t\t*dst++ = c;\n\t\t\tsrc++;\n\t\t} else {\n\t\t\ti = vis(tbuf, c, flag, *++src) - tbuf;\n\t\t\tif (dst + i <= end) {\n\t\t\t\tmemcpy(dst, tbuf, i);\n\t\t\t\tdst += i;\n\t\t\t} else {\n\t\t\t\tsrc--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (siz > 0)\n\t\t*dst = '\\0';\n\tif (dst + i > end) {\n\t\t/* adjust return value for truncation */\n\t\twhile ((c = *src))\n\t\t\tdst += vis(tbuf, c, flag, *++src) - tbuf;\n\t}\n\treturn (dst - start);\n}",
          "includes": [
            "#include \"vis.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vis.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nstrnvis(char *dst, const char *src, size_t siz, int flag)\n{\n\tchar *start, *end;\n\tchar tbuf[5];\n\tint c, i;\n\n\ti = 0;\n\tfor (start = dst, end = start + siz - 1; (c = *src) && dst < end; ) {\n\t\tif (isvisible(c, flag)) {\n\t\t\tif ((c == '\"' && (flag & VIS_DQ) != 0) ||\n\t\t\t    (c == '\\\\' && (flag & VIS_NOSLASH) == 0)) {\n\t\t\t\t/* need space for the extra '\\\\' */\n\t\t\t\tif (dst + 1 >= end) {\n\t\t\t\t\ti = 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*dst++ = '\\\\';\n\t\t\t}\n\t\t\ti = 1;\n\t\t\t*dst++ = c;\n\t\t\tsrc++;\n\t\t} else {\n\t\t\ti = vis(tbuf, c, flag, *++src) - tbuf;\n\t\t\tif (dst + i <= end) {\n\t\t\t\tmemcpy(dst, tbuf, i);\n\t\t\t\tdst += i;\n\t\t\t} else {\n\t\t\t\tsrc--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (siz > 0)\n\t\t*dst = '\\0';\n\tif (dst + i > end) {\n\t\t/* adjust return value for truncation */\n\t\twhile ((c = *src))\n\t\t\tdst += vis(tbuf, c, flag, *++src) - tbuf;\n\t}\n\treturn (dst - start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "name",
            "'\\n'"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "name",
            "O_RDONLY|O_NONBLOCK",
            "0"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "lastlog_openseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/loginrec.c",
          "lines": "1471-1514",
          "snippet": "static int\nlastlog_openseek(struct logininfo *li, int *fd, int filemode)\n{\n\toff_t offset;\n\tchar lastlog_file[1024];\n\tstruct stat st;\n\n\tif (stat(LASTLOG_FILE, &st) != 0) {\n\t\tlogit(\"%s: Couldn't stat %s: %s\", __func__,\n\t\t    LASTLOG_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (S_ISDIR(st.st_mode)) {\n\t\tsnprintf(lastlog_file, sizeof(lastlog_file), \"%s/%s\",\n\t\t    LASTLOG_FILE, li->username);\n\t} else if (S_ISREG(st.st_mode)) {\n\t\tstrlcpy(lastlog_file, LASTLOG_FILE, sizeof(lastlog_file));\n\t} else {\n\t\tlogit(\"%s: %.100s is not a file or directory!\", __func__,\n\t\t    LASTLOG_FILE);\n\t\treturn (0);\n\t}\n\n\t*fd = open(lastlog_file, filemode, 0600);\n\tif (*fd < 0) {\n\t\tdebug(\"%s: Couldn't open %s: %s\", __func__,\n\t\t    lastlog_file, strerror(errno));\n\t\treturn (0);\n\t}\n\n\tif (S_ISREG(st.st_mode)) {\n\t\t/* find this uid's offset in the lastlog file */\n\t\toffset = (off_t) ((u_long)li->uid * sizeof(struct lastlog));\n\n\t\tif (lseek(*fd, offset, SEEK_SET) != offset) {\n\t\t\tlogit(\"%s: %s->lseek(): %s\", __func__,\n\t\t\t    lastlog_file, strerror(errno));\n\t\t\tclose(*fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}",
          "includes": [
            "# include <util.h>",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"canohost.h\"",
            "#include \"packet.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"loginrec.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int utmp_write_entry(struct logininfo *li);",
            "int utmpx_write_entry(struct logininfo *li);",
            "int wtmp_write_entry(struct logininfo *li);",
            "int wtmpx_write_entry(struct logininfo *li);",
            "int lastlog_write_entry(struct logininfo *li);",
            "int syslogin_write_entry(struct logininfo *li);",
            "int getlast_entry(struct logininfo *li);",
            "int lastlog_get_entry(struct logininfo *li);",
            "int utmpx_get_entry(struct logininfo *li);",
            "int wtmp_get_entry(struct logininfo *li);",
            "int wtmpx_get_entry(struct logininfo *li);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <util.h>\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"canohost.h\"\n#include \"packet.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"loginrec.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint utmp_write_entry(struct logininfo *li);\nint utmpx_write_entry(struct logininfo *li);\nint wtmp_write_entry(struct logininfo *li);\nint wtmpx_write_entry(struct logininfo *li);\nint lastlog_write_entry(struct logininfo *li);\nint syslogin_write_entry(struct logininfo *li);\nint getlast_entry(struct logininfo *li);\nint lastlog_get_entry(struct logininfo *li);\nint utmpx_get_entry(struct logininfo *li);\nint wtmp_get_entry(struct logininfo *li);\nint wtmpx_get_entry(struct logininfo *li);\n\nstatic int\nlastlog_openseek(struct logininfo *li, int *fd, int filemode)\n{\n\toff_t offset;\n\tchar lastlog_file[1024];\n\tstruct stat st;\n\n\tif (stat(LASTLOG_FILE, &st) != 0) {\n\t\tlogit(\"%s: Couldn't stat %s: %s\", __func__,\n\t\t    LASTLOG_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (S_ISDIR(st.st_mode)) {\n\t\tsnprintf(lastlog_file, sizeof(lastlog_file), \"%s/%s\",\n\t\t    LASTLOG_FILE, li->username);\n\t} else if (S_ISREG(st.st_mode)) {\n\t\tstrlcpy(lastlog_file, LASTLOG_FILE, sizeof(lastlog_file));\n\t} else {\n\t\tlogit(\"%s: %.100s is not a file or directory!\", __func__,\n\t\t    LASTLOG_FILE);\n\t\treturn (0);\n\t}\n\n\t*fd = open(lastlog_file, filemode, 0600);\n\tif (*fd < 0) {\n\t\tdebug(\"%s: Couldn't open %s: %s\", __func__,\n\t\t    lastlog_file, strerror(errno));\n\t\treturn (0);\n\t}\n\n\tif (S_ISREG(st.st_mode)) {\n\t\t/* find this uid's offset in the lastlog file */\n\t\toffset = (off_t) ((u_long)li->uid * sizeof(struct lastlog));\n\n\t\tif (lseek(*fd, offset, SEEK_SET) != offset) {\n\t\t\tlogit(\"%s: %s->lseek(): %s\", __func__,\n\t\t\t    lastlog_file, strerror(errno));\n\t\t\tclose(*fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define\tFILEMODEMASK\t(S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO)\n#define COPY_BUFLEN\t16384\n\nchar *curfile;\nint verbose_mode = 0;\nint showprogress = 1;\nBUF *allocbuf(BUF *, int, int);\nvoid run_err(const char *,...);\nint errs, remin, remout;\nint response(void);\nvoid rsource(char *, struct stat *);\nvoid source(int, char *[]);\nstatic BUF buffer;\nstruct stat stb;\nBUF *bp;\noff_t i;\noff_t size, statbytes;\n\nvoid\nsource(int argc, char **argv)\n{\n\tstruct stat stb;\n\tstatic BUF buffer;\n\tBUF *bp;\n\toff_t i, statbytes;\n\tsize_t amt, nr;\n\tint fd = -1, haderr, indx;\n\tchar *last, *name, buf[2048], encname[PATH_MAX];\n\tint len;\n\n\tfor (indx = 0; indx < argc; ++indx) {\n\t\tname = argv[indx];\n\t\tstatbytes = 0;\n\t\tlen = strlen(name);\n\t\twhile (len > 1 && name[len-1] == '/')\n\t\t\tname[--len] = '\\0';\n\t\tif ((fd = open(name, O_RDONLY|O_NONBLOCK, 0)) < 0)\n\t\t\tgoto syserr;\n\t\tif (strchr(name, '\\n') != NULL) {\n\t\t\tstrnvis(encname, name, sizeof(encname), VIS_NL);\n\t\t\tname = encname;\n\t\t}\n\t\tif (fstat(fd, &stb) < 0) {\nsyserr:\t\t\trun_err(\"%s: %s\", name, strerror(errno));\n\t\t\tgoto next;\n\t\t}\n\t\tif (stb.st_size < 0) {\n\t\t\trun_err(\"%s: %s\", name, \"Negative file size\");\n\t\t\tgoto next;\n\t\t}\n\t\tunset_nonblock(fd);\n\t\tswitch (stb.st_mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tif (iamrecursive) {\n\t\t\t\trsource(name, &stb);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tdefault:\n\t\t\trun_err(\"%s: not a regular file\", name);\n\t\t\tgoto next;\n\t\t}\n\t\tif ((last = strrchr(name, '/')) == NULL)\n\t\t\tlast = name;\n\t\telse\n\t\t\t++last;\n\t\tcurfile = last;\n\t\tif (pflag) {\n\t\t\tif (do_times(remout, verbose_mode, &stb) < 0)\n\t\t\t\tgoto next;\n\t\t}\n#define\tFILEMODEMASK\t(S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO)\n\t\tsnprintf(buf, sizeof buf, \"C%04o %lld %s\\n\",\n\t\t    (u_int) (stb.st_mode & FILEMODEMASK),\n\t\t    (long long)stb.st_size, last);\n\t\tif (verbose_mode)\n\t\t\tfmprintf(stderr, \"Sending file modes: %s\", buf);\n\t\t(void) atomicio(vwrite, remout, buf, strlen(buf));\n\t\tif (response() < 0)\n\t\t\tgoto next;\n\t\tif ((bp = allocbuf(&buffer, fd, COPY_BUFLEN)) == NULL) {\nnext:\t\t\tif (fd != -1) {\n\t\t\t\t(void) close(fd);\n\t\t\t\tfd = -1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (showprogress)\n\t\t\tstart_progress_meter(curfile, stb.st_size, &statbytes);\n\t\tset_nonblock(remout);\n\t\tfor (haderr = i = 0; i < stb.st_size; i += bp->cnt) {\n\t\t\tamt = bp->cnt;\n\t\t\tif (i + (off_t)amt > stb.st_size)\n\t\t\t\tamt = stb.st_size - i;\n\t\t\tif (!haderr) {\n\t\t\t\tif ((nr = atomicio(read, fd,\n\t\t\t\t    bp->buf, amt)) != amt) {\n\t\t\t\t\thaderr = errno;\n\t\t\t\t\tmemset(bp->buf + nr, 0, amt - nr);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Keep writing after error to retain sync */\n\t\t\tif (haderr) {\n\t\t\t\t(void)atomicio(vwrite, remout, bp->buf, amt);\n\t\t\t\tmemset(bp->buf, 0, amt);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (atomicio6(vwrite, remout, bp->buf, amt, scpio,\n\t\t\t    &statbytes) != amt)\n\t\t\t\thaderr = errno;\n\t\t}\n\t\tunset_nonblock(remout);\n\n\t\tif (fd != -1) {\n\t\t\tif (close(fd) < 0 && !haderr)\n\t\t\t\thaderr = errno;\n\t\t\tfd = -1;\n\t\t}\n\t\tif (!haderr)\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\telse\n\t\t\trun_err(\"%s: %s\", name, strerror(haderr));\n\t\t(void) response();\n\t\tif (showprogress)\n\t\t\tstop_progress_meter();\n\t}\n}"
  },
  {
    "function_name": "tolocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
    "lines": "745-801",
    "snippet": "void\ntolocal(int argc, char **argv)\n{\n\tchar *bp, *host = NULL, *src = NULL, *suser = NULL;\n\targlist alist;\n\tint i, r, sport = -1;\n\n\tmemset(&alist, '\\0', sizeof(alist));\n\talist.list = NULL;\n\n\tfor (i = 0; i < argc - 1; i++) {\n\t\tfree(suser);\n\t\tfree(host);\n\t\tfree(src);\n\t\tr = parse_scp_uri(argv[i], &suser, &host, &sport, &src);\n\t\tif (r == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[i]);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (r != 0)\n\t\t\tparse_user_host_path(argv[i], &suser, &host, &src);\n\t\tif (suser != NULL && !okname(suser)) {\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!host) {\t/* Local to local. */\n\t\t\tfreeargs(&alist);\n\t\t\taddargs(&alist, \"%s\", _PATH_CP);\n\t\t\tif (iamrecursive)\n\t\t\t\taddargs(&alist, \"-r\");\n\t\t\tif (pflag)\n\t\t\t\taddargs(&alist, \"-p\");\n\t\t\taddargs(&alist, \"--\");\n\t\t\taddargs(&alist, \"%s\", argv[i]);\n\t\t\taddargs(&alist, \"%s\", argv[argc-1]);\n\t\t\tif (do_local_cmd(&alist))\n\t\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Remote to local. */\n\t\txasprintf(&bp, \"%s -f %s%s\",\n\t\t    cmd, *src == '-' ? \"-- \" : \"\", src);\n\t\tif (do_cmd(host, suser, sport, bp, &remin, &remout) < 0) {\n\t\t\tfree(bp);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tfree(bp);\n\t\tsink(1, argv + argc - 1);\n\t\t(void) close(remin);\n\t\tremin = remout = -1;\n\t}\n\tfree(suser);\n\tfree(host);\n\tfree(src);\n}",
    "includes": [
      "#include \"utf8.h\"",
      "#include \"progressmeter.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include <sys/uio.h>",
      "#include <sys/wait.h>",
      "# include <sys/time.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int okname(char *);",
      "int errs, remin, remout;",
      "char cmd[CMDNEEDS];",
      "void sink(int, char *[]);",
      "void tolocal(int, char *[]);",
      "BUF *bp;",
      "off_t i;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "src"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "remin"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sink",
          "args": [
            "1",
            "argv + argc - 1"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_cmd",
          "args": [
            "host",
            "suser",
            "sport",
            "bp",
            "&remin",
            "&remout"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "do_cmd2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "318-362",
          "snippet": "int\ndo_cmd2(char *host, char *remuser, int port, char *cmd, int fdin, int fdout)\n{\n\tpid_t pid;\n\tint status;\n\n\tif (verbose_mode)\n\t\tfmprintf(stderr,\n\t\t    \"Executing: 2nd program %s host %s, user %s, command %s\\n\",\n\t\t    ssh_program, host,\n\t\t    remuser ? remuser : \"(unspecified)\", cmd);\n\n\tif (port == -1)\n\t\tport = sshport;\n\n\t/* Fork a child to execute the command on the remote host using ssh. */\n\tpid = fork();\n\tif (pid == 0) {\n\t\tdup2(fdin, 0);\n\t\tdup2(fdout, 1);\n\n\t\treplacearg(&args, 0, \"%s\", ssh_program);\n\t\tif (port != -1) {\n\t\t\taddargs(&args, \"-p\");\n\t\t\taddargs(&args, \"%d\", port);\n\t\t}\n\t\tif (remuser != NULL) {\n\t\t\taddargs(&args, \"-l\");\n\t\t\taddargs(&args, \"%s\", remuser);\n\t\t}\n\t\taddargs(&args, \"--\");\n\t\taddargs(&args, \"%s\", host);\n\t\taddargs(&args, \"%s\", cmd);\n\n\t\texecvp(ssh_program, args.list);\n\t\tperror(ssh_program);\n\t\texit(1);\n\t} else if (pid == -1) {\n\t\tfatal(\"fork: %s\", strerror(errno));\n\t}\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"do_cmd2: waitpid: %s\", strerror(errno));\n\treturn 0;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int do_cmd(char *host, char *remuser, int port, char *cmd, int *fdin, int *fdout);",
            "int do_cmd2(char *host, char *remuser, int port, char *cmd, int fdin, int fdout);",
            "arglist args;",
            "int verbose_mode = 0;",
            "int sshport = -1;",
            "char *ssh_program = _PATH_SSH_PROGRAM;",
            "char cmd[CMDNEEDS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint do_cmd(char *host, char *remuser, int port, char *cmd, int *fdin, int *fdout);\nint do_cmd2(char *host, char *remuser, int port, char *cmd, int fdin, int fdout);\narglist args;\nint verbose_mode = 0;\nint sshport = -1;\nchar *ssh_program = _PATH_SSH_PROGRAM;\nchar cmd[CMDNEEDS];\n\nint\ndo_cmd2(char *host, char *remuser, int port, char *cmd, int fdin, int fdout)\n{\n\tpid_t pid;\n\tint status;\n\n\tif (verbose_mode)\n\t\tfmprintf(stderr,\n\t\t    \"Executing: 2nd program %s host %s, user %s, command %s\\n\",\n\t\t    ssh_program, host,\n\t\t    remuser ? remuser : \"(unspecified)\", cmd);\n\n\tif (port == -1)\n\t\tport = sshport;\n\n\t/* Fork a child to execute the command on the remote host using ssh. */\n\tpid = fork();\n\tif (pid == 0) {\n\t\tdup2(fdin, 0);\n\t\tdup2(fdout, 1);\n\n\t\treplacearg(&args, 0, \"%s\", ssh_program);\n\t\tif (port != -1) {\n\t\t\taddargs(&args, \"-p\");\n\t\t\taddargs(&args, \"%d\", port);\n\t\t}\n\t\tif (remuser != NULL) {\n\t\t\taddargs(&args, \"-l\");\n\t\t\taddargs(&args, \"%s\", remuser);\n\t\t}\n\t\taddargs(&args, \"--\");\n\t\taddargs(&args, \"%s\", host);\n\t\taddargs(&args, \"%s\", cmd);\n\n\t\texecvp(ssh_program, args.list);\n\t\tperror(ssh_program);\n\t\texit(1);\n\t} else if (pid == -1) {\n\t\tfatal(\"fork: %s\", strerror(errno));\n\t}\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"do_cmd2: waitpid: %s\", strerror(errno));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&bp",
            "\"%s -f %s%s\"",
            "cmd",
            "*src == '-' ? \"-- \" : \"\"",
            "src"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_local_cmd",
          "args": [
            "&alist"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "do_local_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "189-229",
          "snippet": "static int\ndo_local_cmd(arglist *a)\n{\n\tu_int i;\n\tint status;\n\tpid_t pid;\n\n\tif (a->num == 0)\n\t\tfatal(\"do_local_cmd: no arguments\");\n\n\tif (verbose_mode) {\n\t\tfprintf(stderr, \"Executing:\");\n\t\tfor (i = 0; i < a->num; i++)\n\t\t\tfmprintf(stderr, \" %s\", a->list[i]);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\tif ((pid = fork()) == -1)\n\t\tfatal(\"do_local_cmd: fork: %s\", strerror(errno));\n\n\tif (pid == 0) {\n\t\texecvp(a->list[0], a->list);\n\t\tperror(a->list[0]);\n\t\texit(1);\n\t}\n\n\tdo_cmd_pid = pid;\n\tsignal(SIGTERM, killchild);\n\tsignal(SIGINT, killchild);\n\tsignal(SIGHUP, killchild);\n\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"do_local_cmd: waitpid: %s\", strerror(errno));\n\n\tdo_cmd_pid = -1;\n\n\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\treturn (-1);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int verbose_mode = 0;",
            "pid_t do_cmd_pid = -1;",
            "off_t i;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint verbose_mode = 0;\npid_t do_cmd_pid = -1;\noff_t i;\n\nstatic int\ndo_local_cmd(arglist *a)\n{\n\tu_int i;\n\tint status;\n\tpid_t pid;\n\n\tif (a->num == 0)\n\t\tfatal(\"do_local_cmd: no arguments\");\n\n\tif (verbose_mode) {\n\t\tfprintf(stderr, \"Executing:\");\n\t\tfor (i = 0; i < a->num; i++)\n\t\t\tfmprintf(stderr, \" %s\", a->list[i]);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\tif ((pid = fork()) == -1)\n\t\tfatal(\"do_local_cmd: fork: %s\", strerror(errno));\n\n\tif (pid == 0) {\n\t\texecvp(a->list[0], a->list);\n\t\tperror(a->list[0]);\n\t\texit(1);\n\t}\n\n\tdo_cmd_pid = pid;\n\tsignal(SIGTERM, killchild);\n\tsignal(SIGINT, killchild);\n\tsignal(SIGHUP, killchild);\n\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"do_local_cmd: waitpid: %s\", strerror(errno));\n\n\tdo_cmd_pid = -1;\n\n\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\treturn (-1);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "addargs",
          "args": [
            "&alist",
            "\"%s\"",
            "argv[argc-1]"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "addargs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "861-886",
          "snippet": "void\naddargs(arglist *args, char *fmt, ...)\n{\n\tva_list ap;\n\tchar *cp;\n\tu_int nalloc;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vasprintf(&cp, fmt, ap);\n\tva_end(ap);\n\tif (r == -1)\n\t\tfatal(\"addargs: argument too long\");\n\n\tnalloc = args->nalloc;\n\tif (args->list == NULL) {\n\t\tnalloc = 32;\n\t\targs->num = 0;\n\t} else if (args->num+2 >= nalloc)\n\t\tnalloc *= 2;\n\n\targs->list = xrecallocarray(args->list, args->nalloc, nalloc, sizeof(char *));\n\targs->nalloc = nalloc;\n\targs->list[args->num++] = cp;\n\targs->list[args->num] = NULL;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\naddargs(arglist *args, char *fmt, ...)\n{\n\tva_list ap;\n\tchar *cp;\n\tu_int nalloc;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vasprintf(&cp, fmt, ap);\n\tva_end(ap);\n\tif (r == -1)\n\t\tfatal(\"addargs: argument too long\");\n\n\tnalloc = args->nalloc;\n\tif (args->list == NULL) {\n\t\tnalloc = 32;\n\t\targs->num = 0;\n\t} else if (args->num+2 >= nalloc)\n\t\tnalloc *= 2;\n\n\targs->list = xrecallocarray(args->list, args->nalloc, nalloc, sizeof(char *));\n\targs->nalloc = nalloc;\n\targs->list[args->num++] = cp;\n\targs->list[args->num] = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeargs",
          "args": [
            "&alist"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "freeargs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "908-920",
          "snippet": "void\nfreeargs(arglist *args)\n{\n\tu_int i;\n\n\tif (args->list != NULL) {\n\t\tfor (i = 0; i < args->num; i++)\n\t\t\tfree(args->list[i]);\n\t\tfree(args->list);\n\t\targs->nalloc = args->num = 0;\n\t\targs->list = NULL;\n\t}\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfreeargs(arglist *args)\n{\n\tu_int i;\n\n\tif (args->list != NULL) {\n\t\tfor (i = 0; i < args->num; i++)\n\t\t\tfree(args->list[i]);\n\t\tfree(args->list);\n\t\targs->nalloc = args->num = 0;\n\t\targs->list = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "okname",
          "args": [
            "suser"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "okname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1362-1390",
          "snippet": "int\nokname(char *cp0)\n{\n\tint c;\n\tchar *cp;\n\n\tcp = cp0;\n\tdo {\n\t\tc = (int)*cp;\n\t\tif (c & 0200)\n\t\t\tgoto bad;\n\t\tif (!isalpha(c) && !isdigit((unsigned char)c)) {\n\t\t\tswitch (c) {\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\tcase '`':\n\t\t\tcase ' ':\n\t\t\tcase '#':\n\t\t\t\tgoto bad;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (*++cp);\n\treturn (1);\n\nbad:\tfmprintf(stderr, \"%s: invalid user name\\n\", cp0);\n\treturn (0);\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int okname(char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint okname(char *);\n\nint\nokname(char *cp0)\n{\n\tint c;\n\tchar *cp;\n\n\tcp = cp0;\n\tdo {\n\t\tc = (int)*cp;\n\t\tif (c & 0200)\n\t\t\tgoto bad;\n\t\tif (!isalpha(c) && !isdigit((unsigned char)c)) {\n\t\t\tswitch (c) {\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\tcase '`':\n\t\t\tcase ' ':\n\t\t\tcase '#':\n\t\t\t\tgoto bad;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (*++cp);\n\treturn (1);\n\nbad:\tfmprintf(stderr, \"%s: invalid user name\\n\", cp0);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_user_host_path",
          "args": [
            "argv[i]",
            "&suser",
            "&host",
            "&src"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "parse_user_host_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "577-635",
          "snippet": "int\nparse_user_host_path(const char *s, char **userp, char **hostp, char **pathp)\n{\n\tchar *user = NULL, *host = NULL, *path = NULL;\n\tchar *sdup, *tmp;\n\tint ret = -1;\n\n\tif (userp != NULL)\n\t\t*userp = NULL;\n\tif (hostp != NULL)\n\t\t*hostp = NULL;\n\tif (pathp != NULL)\n\t\t*pathp = NULL;\n\n\tsdup = xstrdup(s);\n\n\t/* Check for remote syntax: [user@]host:[path] */\n\tif ((tmp = colon(sdup)) == NULL)\n\t\tgoto out;\n\n\t/* Extract optional path */\n\t*tmp++ = '\\0';\n\tif (*tmp == '\\0')\n\t\ttmp = \".\";\n\tpath = xstrdup(tmp);\n\n\t/* Extract optional user and mandatory host */\n\ttmp = strrchr(sdup, '@');\n\tif (tmp != NULL) {\n\t\t*tmp++ = '\\0';\n\t\thost = xstrdup(cleanhostname(tmp));\n\t\tif (*sdup != '\\0')\n\t\t\tuser = xstrdup(sdup);\n\t} else {\n\t\thost = xstrdup(cleanhostname(sdup));\n\t\tuser = NULL;\n\t}\n\n\t/* Success */\n\tif (userp != NULL) {\n\t\t*userp = user;\n\t\tuser = NULL;\n\t}\n\tif (hostp != NULL) {\n\t\t*hostp = host;\n\t\thost = NULL;\n\t}\n\tif (pathp != NULL) {\n\t\t*pathp = path;\n\t\tpath = NULL;\n\t}\n\tret = 0;\nout:\n\tfree(sdup);\n\tfree(user);\n\tfree(host);\n\tfree(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nparse_user_host_path(const char *s, char **userp, char **hostp, char **pathp)\n{\n\tchar *user = NULL, *host = NULL, *path = NULL;\n\tchar *sdup, *tmp;\n\tint ret = -1;\n\n\tif (userp != NULL)\n\t\t*userp = NULL;\n\tif (hostp != NULL)\n\t\t*hostp = NULL;\n\tif (pathp != NULL)\n\t\t*pathp = NULL;\n\n\tsdup = xstrdup(s);\n\n\t/* Check for remote syntax: [user@]host:[path] */\n\tif ((tmp = colon(sdup)) == NULL)\n\t\tgoto out;\n\n\t/* Extract optional path */\n\t*tmp++ = '\\0';\n\tif (*tmp == '\\0')\n\t\ttmp = \".\";\n\tpath = xstrdup(tmp);\n\n\t/* Extract optional user and mandatory host */\n\ttmp = strrchr(sdup, '@');\n\tif (tmp != NULL) {\n\t\t*tmp++ = '\\0';\n\t\thost = xstrdup(cleanhostname(tmp));\n\t\tif (*sdup != '\\0')\n\t\t\tuser = xstrdup(sdup);\n\t} else {\n\t\thost = xstrdup(cleanhostname(sdup));\n\t\tuser = NULL;\n\t}\n\n\t/* Success */\n\tif (userp != NULL) {\n\t\t*userp = user;\n\t\tuser = NULL;\n\t}\n\tif (hostp != NULL) {\n\t\t*hostp = host;\n\t\thost = NULL;\n\t}\n\tif (pathp != NULL) {\n\t\t*pathp = path;\n\t\tpath = NULL;\n\t}\n\tret = 0;\nout:\n\tfree(sdup);\n\tfree(user);\n\tfree(host);\n\tfree(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmprintf",
          "args": [
            "stderr",
            "\"%s: invalid uri\\n\"",
            "argv[i]"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "fmprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "277-287",
          "snippet": "int\nfmprintf(FILE *stream, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stream, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nfmprintf(FILE *stream, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stream, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_scp_uri",
          "args": [
            "argv[i]",
            "&suser",
            "&host",
            "&sport",
            "&src"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "parse_scp_uri",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "611-621",
          "snippet": "static int\nparse_scp_uri(const char *uri, char **userp, char **hostp, int *portp,\n     char **pathp)\n{\n\tint r;\n\n\tr = parse_uri(\"scp\", uri, userp, hostp, portp, pathp);\n\tif (r == 0 && *pathp == NULL)\n\t\t*pathp = xstrdup(\".\");\n\treturn r;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nparse_scp_uri(const char *uri, char **userp, char **hostp, int *portp,\n     char **pathp)\n{\n\tint r;\n\n\tr = parse_uri(\"scp\", uri, userp, hostp, portp, pathp);\n\tif (r == 0 && *pathp == NULL)\n\t\t*pathp = xstrdup(\".\");\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&alist",
            "'\\0'",
            "sizeof(alist)"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint okname(char *);\nint errs, remin, remout;\nchar cmd[CMDNEEDS];\nvoid sink(int, char *[]);\nvoid tolocal(int, char *[]);\nBUF *bp;\noff_t i;\n\nvoid\ntolocal(int argc, char **argv)\n{\n\tchar *bp, *host = NULL, *src = NULL, *suser = NULL;\n\targlist alist;\n\tint i, r, sport = -1;\n\n\tmemset(&alist, '\\0', sizeof(alist));\n\talist.list = NULL;\n\n\tfor (i = 0; i < argc - 1; i++) {\n\t\tfree(suser);\n\t\tfree(host);\n\t\tfree(src);\n\t\tr = parse_scp_uri(argv[i], &suser, &host, &sport, &src);\n\t\tif (r == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[i]);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (r != 0)\n\t\t\tparse_user_host_path(argv[i], &suser, &host, &src);\n\t\tif (suser != NULL && !okname(suser)) {\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!host) {\t/* Local to local. */\n\t\t\tfreeargs(&alist);\n\t\t\taddargs(&alist, \"%s\", _PATH_CP);\n\t\t\tif (iamrecursive)\n\t\t\t\taddargs(&alist, \"-r\");\n\t\t\tif (pflag)\n\t\t\t\taddargs(&alist, \"-p\");\n\t\t\taddargs(&alist, \"--\");\n\t\t\taddargs(&alist, \"%s\", argv[i]);\n\t\t\taddargs(&alist, \"%s\", argv[argc-1]);\n\t\t\tif (do_local_cmd(&alist))\n\t\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Remote to local. */\n\t\txasprintf(&bp, \"%s -f %s%s\",\n\t\t    cmd, *src == '-' ? \"-- \" : \"\", src);\n\t\tif (do_cmd(host, suser, sport, bp, &remin, &remout) < 0) {\n\t\t\tfree(bp);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tfree(bp);\n\t\tsink(1, argv + argc - 1);\n\t\t(void) close(remin);\n\t\tremin = remout = -1;\n\t}\n\tfree(suser);\n\tfree(host);\n\tfree(src);\n}"
  },
  {
    "function_name": "toremote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
    "lines": "623-743",
    "snippet": "void\ntoremote(int argc, char **argv)\n{\n\tchar *suser = NULL, *host = NULL, *src = NULL;\n\tchar *bp, *tuser, *thost, *targ;\n\tint sport = -1, tport = -1;\n\targlist alist;\n\tint i, r;\n\tu_int j;\n\n\tmemset(&alist, '\\0', sizeof(alist));\n\talist.list = NULL;\n\n\t/* Parse target */\n\tr = parse_scp_uri(argv[argc - 1], &tuser, &thost, &tport, &targ);\n\tif (r == -1) {\n\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[argc - 1]);\n\t\t++errs;\n\t\tgoto out;\n\t}\n\tif (r != 0) {\n\t\tif (parse_user_host_path(argv[argc - 1], &tuser, &thost,\n\t\t    &targ) == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid target\\n\", argv[argc - 1]);\n\t\t\t++errs;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (tuser != NULL && !okname(tuser)) {\n\t\t++errs;\n\t\tgoto out;\n\t}\n\n\t/* Parse source files */\n\tfor (i = 0; i < argc - 1; i++) {\n\t\tfree(suser);\n\t\tfree(host);\n\t\tfree(src);\n\t\tr = parse_scp_uri(argv[i], &suser, &host, &sport, &src);\n\t\tif (r == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[i]);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (r != 0) {\n\t\t\tparse_user_host_path(argv[i], &suser, &host, &src);\n\t\t}\n\t\tif (suser != NULL && !okname(suser)) {\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (host && throughlocal) {\t/* extended remote to remote */\n\t\t\txasprintf(&bp, \"%s -f %s%s\", cmd,\n\t\t\t    *src == '-' ? \"-- \" : \"\", src);\n\t\t\tif (do_cmd(host, suser, sport, bp, &remin, &remout) < 0)\n\t\t\t\texit(1);\n\t\t\tfree(bp);\n\t\t\txasprintf(&bp, \"%s -t %s%s\", cmd,\n\t\t\t    *targ == '-' ? \"-- \" : \"\", targ);\n\t\t\tif (do_cmd2(thost, tuser, tport, bp, remin, remout) < 0)\n\t\t\t\texit(1);\n\t\t\tfree(bp);\n\t\t\t(void) close(remin);\n\t\t\t(void) close(remout);\n\t\t\tremin = remout = -1;\n\t\t} else if (host) {\t/* standard remote to remote */\n\t\t\tif (tport != -1 && tport != SSH_DEFAULT_PORT) {\n\t\t\t\t/* This would require the remote support URIs */\n\t\t\t\tfatal(\"target port not supported with two \"\n\t\t\t\t    \"remote hosts without the -3 option\");\n\t\t\t}\n\n\t\t\tfreeargs(&alist);\n\t\t\taddargs(&alist, \"%s\", ssh_program);\n\t\t\taddargs(&alist, \"-x\");\n\t\t\taddargs(&alist, \"-oClearAllForwardings=yes\");\n\t\t\taddargs(&alist, \"-n\");\n\t\t\tfor (j = 0; j < remote_remote_args.num; j++) {\n\t\t\t\taddargs(&alist, \"%s\",\n\t\t\t\t    remote_remote_args.list[j]);\n\t\t\t}\n\n\t\t\tif (sport != -1) {\n\t\t\t\taddargs(&alist, \"-p\");\n\t\t\t\taddargs(&alist, \"%d\", sport);\n\t\t\t}\n\t\t\tif (suser) {\n\t\t\t\taddargs(&alist, \"-l\");\n\t\t\t\taddargs(&alist, \"%s\", suser);\n\t\t\t}\n\t\t\taddargs(&alist, \"--\");\n\t\t\taddargs(&alist, \"%s\", host);\n\t\t\taddargs(&alist, \"%s\", cmd);\n\t\t\taddargs(&alist, \"%s\", src);\n\t\t\taddargs(&alist, \"%s%s%s:%s\",\n\t\t\t    tuser ? tuser : \"\", tuser ? \"@\" : \"\",\n\t\t\t    thost, targ);\n\t\t\tif (do_local_cmd(&alist) != 0)\n\t\t\t\terrs = 1;\n\t\t} else {\t/* local to remote */\n\t\t\tif (remin == -1) {\n\t\t\t\txasprintf(&bp, \"%s -t %s%s\", cmd,\n\t\t\t\t    *targ == '-' ? \"-- \" : \"\", targ);\n\t\t\t\tif (do_cmd(thost, tuser, tport, bp, &remin,\n\t\t\t\t    &remout) < 0)\n\t\t\t\t\texit(1);\n\t\t\t\tif (response() < 0)\n\t\t\t\t\texit(1);\n\t\t\t\tfree(bp);\n\t\t\t}\n\t\t\tsource(1, argv + i);\n\t\t}\n\t}\nout:\n\tfree(tuser);\n\tfree(thost);\n\tfree(targ);\n\tfree(suser);\n\tfree(host);\n\tfree(src);\n}",
    "includes": [
      "#include \"utf8.h\"",
      "#include \"progressmeter.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include <sys/uio.h>",
      "#include <sys/wait.h>",
      "# include <sys/time.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "arglist remote_remote_args;",
      "int throughlocal = 0;",
      "char *ssh_program = _PATH_SSH_PROGRAM;",
      "int okname(char *);",
      "int errs, remin, remout;",
      "char cmd[CMDNEEDS];",
      "int response(void);",
      "void source(int, char *[]);",
      "void toremote(int, char *[]);",
      "BUF *bp;",
      "off_t i;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "src"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "source",
          "args": [
            "1",
            "argv + i"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "rsource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "915-962",
          "snippet": "void\nrsource(char *name, struct stat *statp)\n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *last, *vect[1], path[PATH_MAX];\n\n\tif (!(dirp = opendir(name))) {\n\t\trun_err(\"%s: %s\", name, strerror(errno));\n\t\treturn;\n\t}\n\tlast = strrchr(name, '/');\n\tif (last == NULL)\n\t\tlast = name;\n\telse\n\t\tlast++;\n\tif (pflag) {\n\t\tif (do_times(remout, verbose_mode, statp) < 0) {\n\t\t\tclosedir(dirp);\n\t\t\treturn;\n\t\t}\n\t}\n\t(void) snprintf(path, sizeof path, \"D%04o %d %.1024s\\n\",\n\t    (u_int) (statp->st_mode & FILEMODEMASK), 0, last);\n\tif (verbose_mode)\n\t\tfmprintf(stderr, \"Entering directory: %s\", path);\n\t(void) atomicio(vwrite, remout, path, strlen(path));\n\tif (response() < 0) {\n\t\tclosedir(dirp);\n\t\treturn;\n\t}\n\twhile ((dp = readdir(dirp)) != NULL) {\n\t\tif (dp->d_ino == 0)\n\t\t\tcontinue;\n\t\tif (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tif (strlen(name) + 1 + strlen(dp->d_name) >= sizeof(path) - 1) {\n\t\t\trun_err(\"%s/%s: name too long\", name, dp->d_name);\n\t\t\tcontinue;\n\t\t}\n\t\t(void) snprintf(path, sizeof path, \"%s/%s\", name, dp->d_name);\n\t\tvect[0] = path;\n\t\tsource(1, vect);\n\t}\n\t(void) closedir(dirp);\n\t(void) atomicio(vwrite, remout, \"E\\n\", 2);\n\t(void) response();\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tFILEMODEMASK\t(S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO)"
          ],
          "globals_used": [
            "int verbose_mode = 0;",
            "void run_err(const char *,...);",
            "int errs, remin, remout;",
            "int response(void);",
            "void rsource(char *, struct stat *);",
            "void source(int, char *[]);",
            "char ch, *cp, *np, *targ, *why, *vect[1], buf[2048], visbuf[2048];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define\tFILEMODEMASK\t(S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO)\n\nint verbose_mode = 0;\nvoid run_err(const char *,...);\nint errs, remin, remout;\nint response(void);\nvoid rsource(char *, struct stat *);\nvoid source(int, char *[]);\nchar ch, *cp, *np, *targ, *why, *vect[1], buf[2048], visbuf[2048];\n\nvoid\nrsource(char *name, struct stat *statp)\n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *last, *vect[1], path[PATH_MAX];\n\n\tif (!(dirp = opendir(name))) {\n\t\trun_err(\"%s: %s\", name, strerror(errno));\n\t\treturn;\n\t}\n\tlast = strrchr(name, '/');\n\tif (last == NULL)\n\t\tlast = name;\n\telse\n\t\tlast++;\n\tif (pflag) {\n\t\tif (do_times(remout, verbose_mode, statp) < 0) {\n\t\t\tclosedir(dirp);\n\t\t\treturn;\n\t\t}\n\t}\n\t(void) snprintf(path, sizeof path, \"D%04o %d %.1024s\\n\",\n\t    (u_int) (statp->st_mode & FILEMODEMASK), 0, last);\n\tif (verbose_mode)\n\t\tfmprintf(stderr, \"Entering directory: %s\", path);\n\t(void) atomicio(vwrite, remout, path, strlen(path));\n\tif (response() < 0) {\n\t\tclosedir(dirp);\n\t\treturn;\n\t}\n\twhile ((dp = readdir(dirp)) != NULL) {\n\t\tif (dp->d_ino == 0)\n\t\t\tcontinue;\n\t\tif (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tif (strlen(name) + 1 + strlen(dp->d_name) >= sizeof(path) - 1) {\n\t\t\trun_err(\"%s/%s: name too long\", name, dp->d_name);\n\t\t\tcontinue;\n\t\t}\n\t\t(void) snprintf(path, sizeof path, \"%s/%s\", name, dp->d_name);\n\t\tvect[0] = path;\n\t\tsource(1, vect);\n\t}\n\t(void) closedir(dirp);\n\t(void) atomicio(vwrite, remout, \"E\\n\", 2);\n\t(void) response();\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "response",
          "args": [],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1276-1312",
          "snippet": "int\nresponse(void)\n{\n\tchar ch, *cp, resp, rbuf[2048], visbuf[2048];\n\n\tif (atomicio(read, remin, &resp, sizeof(resp)) != sizeof(resp))\n\t\tlostconn(0);\n\n\tcp = rbuf;\n\tswitch (resp) {\n\tcase 0:\t\t/* ok */\n\t\treturn (0);\n\tdefault:\n\t\t*cp++ = resp;\n\t\t/* FALLTHROUGH */\n\tcase 1:\t\t/* error, followed by error msg */\n\tcase 2:\t\t/* fatal error, \"\" */\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tlostconn(0);\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &rbuf[sizeof(rbuf) - 1] && ch != '\\n');\n\n\t\tif (!iamremote) {\n\t\t\tcp[-1] = '\\0';\n\t\t\t(void) snmprintf(visbuf, sizeof(visbuf),\n\t\t\t    NULL, \"%s\\n\", rbuf);\n\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t    visbuf, strlen(visbuf));\n\t\t}\n\t\t++errs;\n\t\tif (resp == 1)\n\t\t\treturn (-1);\n\t\texit(1);\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void lostconn(int);",
            "int response(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid lostconn(int);\nint response(void);\n\nint\nresponse(void)\n{\n\tchar ch, *cp, resp, rbuf[2048], visbuf[2048];\n\n\tif (atomicio(read, remin, &resp, sizeof(resp)) != sizeof(resp))\n\t\tlostconn(0);\n\n\tcp = rbuf;\n\tswitch (resp) {\n\tcase 0:\t\t/* ok */\n\t\treturn (0);\n\tdefault:\n\t\t*cp++ = resp;\n\t\t/* FALLTHROUGH */\n\tcase 1:\t\t/* error, followed by error msg */\n\tcase 2:\t\t/* fatal error, \"\" */\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tlostconn(0);\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &rbuf[sizeof(rbuf) - 1] && ch != '\\n');\n\n\t\tif (!iamremote) {\n\t\t\tcp[-1] = '\\0';\n\t\t\t(void) snmprintf(visbuf, sizeof(visbuf),\n\t\t\t    NULL, \"%s\\n\", rbuf);\n\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t    visbuf, strlen(visbuf));\n\t\t}\n\t\t++errs;\n\t\tif (resp == 1)\n\t\t\treturn (-1);\n\t\texit(1);\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_cmd",
          "args": [
            "thost",
            "tuser",
            "tport",
            "bp",
            "&remin",
            "&remout"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "do_cmd2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "318-362",
          "snippet": "int\ndo_cmd2(char *host, char *remuser, int port, char *cmd, int fdin, int fdout)\n{\n\tpid_t pid;\n\tint status;\n\n\tif (verbose_mode)\n\t\tfmprintf(stderr,\n\t\t    \"Executing: 2nd program %s host %s, user %s, command %s\\n\",\n\t\t    ssh_program, host,\n\t\t    remuser ? remuser : \"(unspecified)\", cmd);\n\n\tif (port == -1)\n\t\tport = sshport;\n\n\t/* Fork a child to execute the command on the remote host using ssh. */\n\tpid = fork();\n\tif (pid == 0) {\n\t\tdup2(fdin, 0);\n\t\tdup2(fdout, 1);\n\n\t\treplacearg(&args, 0, \"%s\", ssh_program);\n\t\tif (port != -1) {\n\t\t\taddargs(&args, \"-p\");\n\t\t\taddargs(&args, \"%d\", port);\n\t\t}\n\t\tif (remuser != NULL) {\n\t\t\taddargs(&args, \"-l\");\n\t\t\taddargs(&args, \"%s\", remuser);\n\t\t}\n\t\taddargs(&args, \"--\");\n\t\taddargs(&args, \"%s\", host);\n\t\taddargs(&args, \"%s\", cmd);\n\n\t\texecvp(ssh_program, args.list);\n\t\tperror(ssh_program);\n\t\texit(1);\n\t} else if (pid == -1) {\n\t\tfatal(\"fork: %s\", strerror(errno));\n\t}\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"do_cmd2: waitpid: %s\", strerror(errno));\n\treturn 0;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int do_cmd(char *host, char *remuser, int port, char *cmd, int *fdin, int *fdout);",
            "int do_cmd2(char *host, char *remuser, int port, char *cmd, int fdin, int fdout);",
            "arglist args;",
            "int verbose_mode = 0;",
            "int sshport = -1;",
            "char *ssh_program = _PATH_SSH_PROGRAM;",
            "char cmd[CMDNEEDS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint do_cmd(char *host, char *remuser, int port, char *cmd, int *fdin, int *fdout);\nint do_cmd2(char *host, char *remuser, int port, char *cmd, int fdin, int fdout);\narglist args;\nint verbose_mode = 0;\nint sshport = -1;\nchar *ssh_program = _PATH_SSH_PROGRAM;\nchar cmd[CMDNEEDS];\n\nint\ndo_cmd2(char *host, char *remuser, int port, char *cmd, int fdin, int fdout)\n{\n\tpid_t pid;\n\tint status;\n\n\tif (verbose_mode)\n\t\tfmprintf(stderr,\n\t\t    \"Executing: 2nd program %s host %s, user %s, command %s\\n\",\n\t\t    ssh_program, host,\n\t\t    remuser ? remuser : \"(unspecified)\", cmd);\n\n\tif (port == -1)\n\t\tport = sshport;\n\n\t/* Fork a child to execute the command on the remote host using ssh. */\n\tpid = fork();\n\tif (pid == 0) {\n\t\tdup2(fdin, 0);\n\t\tdup2(fdout, 1);\n\n\t\treplacearg(&args, 0, \"%s\", ssh_program);\n\t\tif (port != -1) {\n\t\t\taddargs(&args, \"-p\");\n\t\t\taddargs(&args, \"%d\", port);\n\t\t}\n\t\tif (remuser != NULL) {\n\t\t\taddargs(&args, \"-l\");\n\t\t\taddargs(&args, \"%s\", remuser);\n\t\t}\n\t\taddargs(&args, \"--\");\n\t\taddargs(&args, \"%s\", host);\n\t\taddargs(&args, \"%s\", cmd);\n\n\t\texecvp(ssh_program, args.list);\n\t\tperror(ssh_program);\n\t\texit(1);\n\t} else if (pid == -1) {\n\t\tfatal(\"fork: %s\", strerror(errno));\n\t}\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"do_cmd2: waitpid: %s\", strerror(errno));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&bp",
            "\"%s -t %s%s\"",
            "cmd",
            "*targ == '-' ? \"-- \" : \"\"",
            "targ"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_local_cmd",
          "args": [
            "&alist"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "do_local_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "189-229",
          "snippet": "static int\ndo_local_cmd(arglist *a)\n{\n\tu_int i;\n\tint status;\n\tpid_t pid;\n\n\tif (a->num == 0)\n\t\tfatal(\"do_local_cmd: no arguments\");\n\n\tif (verbose_mode) {\n\t\tfprintf(stderr, \"Executing:\");\n\t\tfor (i = 0; i < a->num; i++)\n\t\t\tfmprintf(stderr, \" %s\", a->list[i]);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\tif ((pid = fork()) == -1)\n\t\tfatal(\"do_local_cmd: fork: %s\", strerror(errno));\n\n\tif (pid == 0) {\n\t\texecvp(a->list[0], a->list);\n\t\tperror(a->list[0]);\n\t\texit(1);\n\t}\n\n\tdo_cmd_pid = pid;\n\tsignal(SIGTERM, killchild);\n\tsignal(SIGINT, killchild);\n\tsignal(SIGHUP, killchild);\n\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"do_local_cmd: waitpid: %s\", strerror(errno));\n\n\tdo_cmd_pid = -1;\n\n\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\treturn (-1);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int verbose_mode = 0;",
            "pid_t do_cmd_pid = -1;",
            "off_t i;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint verbose_mode = 0;\npid_t do_cmd_pid = -1;\noff_t i;\n\nstatic int\ndo_local_cmd(arglist *a)\n{\n\tu_int i;\n\tint status;\n\tpid_t pid;\n\n\tif (a->num == 0)\n\t\tfatal(\"do_local_cmd: no arguments\");\n\n\tif (verbose_mode) {\n\t\tfprintf(stderr, \"Executing:\");\n\t\tfor (i = 0; i < a->num; i++)\n\t\t\tfmprintf(stderr, \" %s\", a->list[i]);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\tif ((pid = fork()) == -1)\n\t\tfatal(\"do_local_cmd: fork: %s\", strerror(errno));\n\n\tif (pid == 0) {\n\t\texecvp(a->list[0], a->list);\n\t\tperror(a->list[0]);\n\t\texit(1);\n\t}\n\n\tdo_cmd_pid = pid;\n\tsignal(SIGTERM, killchild);\n\tsignal(SIGINT, killchild);\n\tsignal(SIGHUP, killchild);\n\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"do_local_cmd: waitpid: %s\", strerror(errno));\n\n\tdo_cmd_pid = -1;\n\n\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\treturn (-1);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "addargs",
          "args": [
            "&alist",
            "\"%s%s%s:%s\"",
            "tuser ? tuser : \"\"",
            "tuser ? \"@\" : \"\"",
            "thost",
            "targ"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "addargs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "861-886",
          "snippet": "void\naddargs(arglist *args, char *fmt, ...)\n{\n\tva_list ap;\n\tchar *cp;\n\tu_int nalloc;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vasprintf(&cp, fmt, ap);\n\tva_end(ap);\n\tif (r == -1)\n\t\tfatal(\"addargs: argument too long\");\n\n\tnalloc = args->nalloc;\n\tif (args->list == NULL) {\n\t\tnalloc = 32;\n\t\targs->num = 0;\n\t} else if (args->num+2 >= nalloc)\n\t\tnalloc *= 2;\n\n\targs->list = xrecallocarray(args->list, args->nalloc, nalloc, sizeof(char *));\n\targs->nalloc = nalloc;\n\targs->list[args->num++] = cp;\n\targs->list[args->num] = NULL;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\naddargs(arglist *args, char *fmt, ...)\n{\n\tva_list ap;\n\tchar *cp;\n\tu_int nalloc;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vasprintf(&cp, fmt, ap);\n\tva_end(ap);\n\tif (r == -1)\n\t\tfatal(\"addargs: argument too long\");\n\n\tnalloc = args->nalloc;\n\tif (args->list == NULL) {\n\t\tnalloc = 32;\n\t\targs->num = 0;\n\t} else if (args->num+2 >= nalloc)\n\t\tnalloc *= 2;\n\n\targs->list = xrecallocarray(args->list, args->nalloc, nalloc, sizeof(char *));\n\targs->nalloc = nalloc;\n\targs->list[args->num++] = cp;\n\targs->list[args->num] = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeargs",
          "args": [
            "&alist"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "freeargs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "908-920",
          "snippet": "void\nfreeargs(arglist *args)\n{\n\tu_int i;\n\n\tif (args->list != NULL) {\n\t\tfor (i = 0; i < args->num; i++)\n\t\t\tfree(args->list[i]);\n\t\tfree(args->list);\n\t\targs->nalloc = args->num = 0;\n\t\targs->list = NULL;\n\t}\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfreeargs(arglist *args)\n{\n\tu_int i;\n\n\tif (args->list != NULL) {\n\t\tfor (i = 0; i < args->num; i++)\n\t\t\tfree(args->list[i]);\n\t\tfree(args->list);\n\t\targs->nalloc = args->num = 0;\n\t\targs->list = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"target port not supported with two \"\n\t\t\t\t    \"remote hosts without the -3 option\""
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "remout"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "okname",
          "args": [
            "suser"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "okname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1362-1390",
          "snippet": "int\nokname(char *cp0)\n{\n\tint c;\n\tchar *cp;\n\n\tcp = cp0;\n\tdo {\n\t\tc = (int)*cp;\n\t\tif (c & 0200)\n\t\t\tgoto bad;\n\t\tif (!isalpha(c) && !isdigit((unsigned char)c)) {\n\t\t\tswitch (c) {\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\tcase '`':\n\t\t\tcase ' ':\n\t\t\tcase '#':\n\t\t\t\tgoto bad;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (*++cp);\n\treturn (1);\n\nbad:\tfmprintf(stderr, \"%s: invalid user name\\n\", cp0);\n\treturn (0);\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int okname(char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint okname(char *);\n\nint\nokname(char *cp0)\n{\n\tint c;\n\tchar *cp;\n\n\tcp = cp0;\n\tdo {\n\t\tc = (int)*cp;\n\t\tif (c & 0200)\n\t\t\tgoto bad;\n\t\tif (!isalpha(c) && !isdigit((unsigned char)c)) {\n\t\t\tswitch (c) {\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\tcase '`':\n\t\t\tcase ' ':\n\t\t\tcase '#':\n\t\t\t\tgoto bad;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (*++cp);\n\treturn (1);\n\nbad:\tfmprintf(stderr, \"%s: invalid user name\\n\", cp0);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_user_host_path",
          "args": [
            "argv[i]",
            "&suser",
            "&host",
            "&src"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "parse_user_host_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "577-635",
          "snippet": "int\nparse_user_host_path(const char *s, char **userp, char **hostp, char **pathp)\n{\n\tchar *user = NULL, *host = NULL, *path = NULL;\n\tchar *sdup, *tmp;\n\tint ret = -1;\n\n\tif (userp != NULL)\n\t\t*userp = NULL;\n\tif (hostp != NULL)\n\t\t*hostp = NULL;\n\tif (pathp != NULL)\n\t\t*pathp = NULL;\n\n\tsdup = xstrdup(s);\n\n\t/* Check for remote syntax: [user@]host:[path] */\n\tif ((tmp = colon(sdup)) == NULL)\n\t\tgoto out;\n\n\t/* Extract optional path */\n\t*tmp++ = '\\0';\n\tif (*tmp == '\\0')\n\t\ttmp = \".\";\n\tpath = xstrdup(tmp);\n\n\t/* Extract optional user and mandatory host */\n\ttmp = strrchr(sdup, '@');\n\tif (tmp != NULL) {\n\t\t*tmp++ = '\\0';\n\t\thost = xstrdup(cleanhostname(tmp));\n\t\tif (*sdup != '\\0')\n\t\t\tuser = xstrdup(sdup);\n\t} else {\n\t\thost = xstrdup(cleanhostname(sdup));\n\t\tuser = NULL;\n\t}\n\n\t/* Success */\n\tif (userp != NULL) {\n\t\t*userp = user;\n\t\tuser = NULL;\n\t}\n\tif (hostp != NULL) {\n\t\t*hostp = host;\n\t\thost = NULL;\n\t}\n\tif (pathp != NULL) {\n\t\t*pathp = path;\n\t\tpath = NULL;\n\t}\n\tret = 0;\nout:\n\tfree(sdup);\n\tfree(user);\n\tfree(host);\n\tfree(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nparse_user_host_path(const char *s, char **userp, char **hostp, char **pathp)\n{\n\tchar *user = NULL, *host = NULL, *path = NULL;\n\tchar *sdup, *tmp;\n\tint ret = -1;\n\n\tif (userp != NULL)\n\t\t*userp = NULL;\n\tif (hostp != NULL)\n\t\t*hostp = NULL;\n\tif (pathp != NULL)\n\t\t*pathp = NULL;\n\n\tsdup = xstrdup(s);\n\n\t/* Check for remote syntax: [user@]host:[path] */\n\tif ((tmp = colon(sdup)) == NULL)\n\t\tgoto out;\n\n\t/* Extract optional path */\n\t*tmp++ = '\\0';\n\tif (*tmp == '\\0')\n\t\ttmp = \".\";\n\tpath = xstrdup(tmp);\n\n\t/* Extract optional user and mandatory host */\n\ttmp = strrchr(sdup, '@');\n\tif (tmp != NULL) {\n\t\t*tmp++ = '\\0';\n\t\thost = xstrdup(cleanhostname(tmp));\n\t\tif (*sdup != '\\0')\n\t\t\tuser = xstrdup(sdup);\n\t} else {\n\t\thost = xstrdup(cleanhostname(sdup));\n\t\tuser = NULL;\n\t}\n\n\t/* Success */\n\tif (userp != NULL) {\n\t\t*userp = user;\n\t\tuser = NULL;\n\t}\n\tif (hostp != NULL) {\n\t\t*hostp = host;\n\t\thost = NULL;\n\t}\n\tif (pathp != NULL) {\n\t\t*pathp = path;\n\t\tpath = NULL;\n\t}\n\tret = 0;\nout:\n\tfree(sdup);\n\tfree(user);\n\tfree(host);\n\tfree(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmprintf",
          "args": [
            "stderr",
            "\"%s: invalid uri\\n\"",
            "argv[i]"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "fmprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "277-287",
          "snippet": "int\nfmprintf(FILE *stream, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stream, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nfmprintf(FILE *stream, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stream, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_scp_uri",
          "args": [
            "argv[i]",
            "&suser",
            "&host",
            "&sport",
            "&src"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "parse_scp_uri",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "611-621",
          "snippet": "static int\nparse_scp_uri(const char *uri, char **userp, char **hostp, int *portp,\n     char **pathp)\n{\n\tint r;\n\n\tr = parse_uri(\"scp\", uri, userp, hostp, portp, pathp);\n\tif (r == 0 && *pathp == NULL)\n\t\t*pathp = xstrdup(\".\");\n\treturn r;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nparse_scp_uri(const char *uri, char **userp, char **hostp, int *portp,\n     char **pathp)\n{\n\tint r;\n\n\tr = parse_uri(\"scp\", uri, userp, hostp, portp, pathp);\n\tif (r == 0 && *pathp == NULL)\n\t\t*pathp = xstrdup(\".\");\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&alist",
            "'\\0'",
            "sizeof(alist)"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\narglist remote_remote_args;\nint throughlocal = 0;\nchar *ssh_program = _PATH_SSH_PROGRAM;\nint okname(char *);\nint errs, remin, remout;\nchar cmd[CMDNEEDS];\nint response(void);\nvoid source(int, char *[]);\nvoid toremote(int, char *[]);\nBUF *bp;\noff_t i;\n\nvoid\ntoremote(int argc, char **argv)\n{\n\tchar *suser = NULL, *host = NULL, *src = NULL;\n\tchar *bp, *tuser, *thost, *targ;\n\tint sport = -1, tport = -1;\n\targlist alist;\n\tint i, r;\n\tu_int j;\n\n\tmemset(&alist, '\\0', sizeof(alist));\n\talist.list = NULL;\n\n\t/* Parse target */\n\tr = parse_scp_uri(argv[argc - 1], &tuser, &thost, &tport, &targ);\n\tif (r == -1) {\n\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[argc - 1]);\n\t\t++errs;\n\t\tgoto out;\n\t}\n\tif (r != 0) {\n\t\tif (parse_user_host_path(argv[argc - 1], &tuser, &thost,\n\t\t    &targ) == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid target\\n\", argv[argc - 1]);\n\t\t\t++errs;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (tuser != NULL && !okname(tuser)) {\n\t\t++errs;\n\t\tgoto out;\n\t}\n\n\t/* Parse source files */\n\tfor (i = 0; i < argc - 1; i++) {\n\t\tfree(suser);\n\t\tfree(host);\n\t\tfree(src);\n\t\tr = parse_scp_uri(argv[i], &suser, &host, &sport, &src);\n\t\tif (r == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[i]);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (r != 0) {\n\t\t\tparse_user_host_path(argv[i], &suser, &host, &src);\n\t\t}\n\t\tif (suser != NULL && !okname(suser)) {\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (host && throughlocal) {\t/* extended remote to remote */\n\t\t\txasprintf(&bp, \"%s -f %s%s\", cmd,\n\t\t\t    *src == '-' ? \"-- \" : \"\", src);\n\t\t\tif (do_cmd(host, suser, sport, bp, &remin, &remout) < 0)\n\t\t\t\texit(1);\n\t\t\tfree(bp);\n\t\t\txasprintf(&bp, \"%s -t %s%s\", cmd,\n\t\t\t    *targ == '-' ? \"-- \" : \"\", targ);\n\t\t\tif (do_cmd2(thost, tuser, tport, bp, remin, remout) < 0)\n\t\t\t\texit(1);\n\t\t\tfree(bp);\n\t\t\t(void) close(remin);\n\t\t\t(void) close(remout);\n\t\t\tremin = remout = -1;\n\t\t} else if (host) {\t/* standard remote to remote */\n\t\t\tif (tport != -1 && tport != SSH_DEFAULT_PORT) {\n\t\t\t\t/* This would require the remote support URIs */\n\t\t\t\tfatal(\"target port not supported with two \"\n\t\t\t\t    \"remote hosts without the -3 option\");\n\t\t\t}\n\n\t\t\tfreeargs(&alist);\n\t\t\taddargs(&alist, \"%s\", ssh_program);\n\t\t\taddargs(&alist, \"-x\");\n\t\t\taddargs(&alist, \"-oClearAllForwardings=yes\");\n\t\t\taddargs(&alist, \"-n\");\n\t\t\tfor (j = 0; j < remote_remote_args.num; j++) {\n\t\t\t\taddargs(&alist, \"%s\",\n\t\t\t\t    remote_remote_args.list[j]);\n\t\t\t}\n\n\t\t\tif (sport != -1) {\n\t\t\t\taddargs(&alist, \"-p\");\n\t\t\t\taddargs(&alist, \"%d\", sport);\n\t\t\t}\n\t\t\tif (suser) {\n\t\t\t\taddargs(&alist, \"-l\");\n\t\t\t\taddargs(&alist, \"%s\", suser);\n\t\t\t}\n\t\t\taddargs(&alist, \"--\");\n\t\t\taddargs(&alist, \"%s\", host);\n\t\t\taddargs(&alist, \"%s\", cmd);\n\t\t\taddargs(&alist, \"%s\", src);\n\t\t\taddargs(&alist, \"%s%s%s:%s\",\n\t\t\t    tuser ? tuser : \"\", tuser ? \"@\" : \"\",\n\t\t\t    thost, targ);\n\t\t\tif (do_local_cmd(&alist) != 0)\n\t\t\t\terrs = 1;\n\t\t} else {\t/* local to remote */\n\t\t\tif (remin == -1) {\n\t\t\t\txasprintf(&bp, \"%s -t %s%s\", cmd,\n\t\t\t\t    *targ == '-' ? \"-- \" : \"\", targ);\n\t\t\t\tif (do_cmd(thost, tuser, tport, bp, &remin,\n\t\t\t\t    &remout) < 0)\n\t\t\t\t\texit(1);\n\t\t\t\tif (response() < 0)\n\t\t\t\t\texit(1);\n\t\t\t\tfree(bp);\n\t\t\t}\n\t\t\tsource(1, argv + i);\n\t\t}\n\t}\nout:\n\tfree(tuser);\n\tfree(thost);\n\tfree(targ);\n\tfree(suser);\n\tfree(host);\n\tfree(src);\n}"
  },
  {
    "function_name": "parse_scp_uri",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
    "lines": "611-621",
    "snippet": "static int\nparse_scp_uri(const char *uri, char **userp, char **hostp, int *portp,\n     char **pathp)\n{\n\tint r;\n\n\tr = parse_uri(\"scp\", uri, userp, hostp, portp, pathp);\n\tif (r == 0 && *pathp == NULL)\n\t\t*pathp = xstrdup(\".\");\n\treturn r;\n}",
    "includes": [
      "#include \"utf8.h\"",
      "#include \"progressmeter.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include <sys/uio.h>",
      "#include <sys/wait.h>",
      "# include <sys/time.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "\".\""
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_uri",
          "args": [
            "\"scp\"",
            "uri",
            "userp",
            "hostp",
            "portp",
            "pathp"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "parse_uri",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "769-858",
          "snippet": "int\nparse_uri(const char *scheme, const char *uri, char **userp, char **hostp,\n    int *portp, char **pathp)\n{\n\tchar *uridup, *cp, *tmp, ch;\n\tchar *user = NULL, *host = NULL, *path = NULL;\n\tint port = -1, ret = -1;\n\tsize_t len;\n\n\tlen = strlen(scheme);\n\tif (strncmp(uri, scheme, len) != 0 || strncmp(uri + len, \"://\", 3) != 0)\n\t\treturn 1;\n\turi += len + 3;\n\n\tif (userp != NULL)\n\t\t*userp = NULL;\n\tif (hostp != NULL)\n\t\t*hostp = NULL;\n\tif (portp != NULL)\n\t\t*portp = -1;\n\tif (pathp != NULL)\n\t\t*pathp = NULL;\n\n\turidup = tmp = xstrdup(uri);\n\n\t/* Extract optional ssh-info (username + connection params) */\n\tif ((cp = strchr(tmp, '@')) != NULL) {\n\t\tchar *delim;\n\n\t\t*cp = '\\0';\n\t\t/* Extract username and connection params */\n\t\tif ((delim = strchr(tmp, ';')) != NULL) {\n\t\t\t/* Just ignore connection params for now */\n\t\t\t*delim = '\\0';\n\t\t}\n\t\tif (*tmp == '\\0') {\n\t\t\t/* Empty username */\n\t\t\tgoto out;\n\t\t}\n\t\tif ((user = urldecode(tmp)) == NULL)\n\t\t\tgoto out;\n\t\ttmp = cp + 1;\n\t}\n\n\t/* Extract mandatory hostname */\n\tif ((cp = hpdelim2(&tmp, &ch)) == NULL || *cp == '\\0')\n\t\tgoto out;\n\thost = xstrdup(cleanhostname(cp));\n\tif (!valid_domain(host, 0, NULL))\n\t\tgoto out;\n\n\tif (tmp != NULL && *tmp != '\\0') {\n\t\tif (ch == ':') {\n\t\t\t/* Convert and verify port. */\n\t\t\tif ((cp = strchr(tmp, '/')) != NULL)\n\t\t\t\t*cp = '\\0';\n\t\t\tif ((port = a2port(tmp)) <= 0)\n\t\t\t\tgoto out;\n\t\t\ttmp = cp ? cp + 1 : NULL;\n\t\t}\n\t\tif (tmp != NULL && *tmp != '\\0') {\n\t\t\t/* Extract optional path */\n\t\t\tif ((path = urldecode(tmp)) == NULL)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Success */\n\tif (userp != NULL) {\n\t\t*userp = user;\n\t\tuser = NULL;\n\t}\n\tif (hostp != NULL) {\n\t\t*hostp = host;\n\t\thost = NULL;\n\t}\n\tif (portp != NULL)\n\t\t*portp = port;\n\tif (pathp != NULL) {\n\t\t*pathp = path;\n\t\tpath = NULL;\n\t}\n\tret = 0;\n out:\n\tfree(uridup);\n\tfree(user);\n\tfree(host);\n\tfree(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nparse_uri(const char *scheme, const char *uri, char **userp, char **hostp,\n    int *portp, char **pathp)\n{\n\tchar *uridup, *cp, *tmp, ch;\n\tchar *user = NULL, *host = NULL, *path = NULL;\n\tint port = -1, ret = -1;\n\tsize_t len;\n\n\tlen = strlen(scheme);\n\tif (strncmp(uri, scheme, len) != 0 || strncmp(uri + len, \"://\", 3) != 0)\n\t\treturn 1;\n\turi += len + 3;\n\n\tif (userp != NULL)\n\t\t*userp = NULL;\n\tif (hostp != NULL)\n\t\t*hostp = NULL;\n\tif (portp != NULL)\n\t\t*portp = -1;\n\tif (pathp != NULL)\n\t\t*pathp = NULL;\n\n\turidup = tmp = xstrdup(uri);\n\n\t/* Extract optional ssh-info (username + connection params) */\n\tif ((cp = strchr(tmp, '@')) != NULL) {\n\t\tchar *delim;\n\n\t\t*cp = '\\0';\n\t\t/* Extract username and connection params */\n\t\tif ((delim = strchr(tmp, ';')) != NULL) {\n\t\t\t/* Just ignore connection params for now */\n\t\t\t*delim = '\\0';\n\t\t}\n\t\tif (*tmp == '\\0') {\n\t\t\t/* Empty username */\n\t\t\tgoto out;\n\t\t}\n\t\tif ((user = urldecode(tmp)) == NULL)\n\t\t\tgoto out;\n\t\ttmp = cp + 1;\n\t}\n\n\t/* Extract mandatory hostname */\n\tif ((cp = hpdelim2(&tmp, &ch)) == NULL || *cp == '\\0')\n\t\tgoto out;\n\thost = xstrdup(cleanhostname(cp));\n\tif (!valid_domain(host, 0, NULL))\n\t\tgoto out;\n\n\tif (tmp != NULL && *tmp != '\\0') {\n\t\tif (ch == ':') {\n\t\t\t/* Convert and verify port. */\n\t\t\tif ((cp = strchr(tmp, '/')) != NULL)\n\t\t\t\t*cp = '\\0';\n\t\t\tif ((port = a2port(tmp)) <= 0)\n\t\t\t\tgoto out;\n\t\t\ttmp = cp ? cp + 1 : NULL;\n\t\t}\n\t\tif (tmp != NULL && *tmp != '\\0') {\n\t\t\t/* Extract optional path */\n\t\t\tif ((path = urldecode(tmp)) == NULL)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Success */\n\tif (userp != NULL) {\n\t\t*userp = user;\n\t\tuser = NULL;\n\t}\n\tif (hostp != NULL) {\n\t\t*hostp = host;\n\t\thost = NULL;\n\t}\n\tif (portp != NULL)\n\t\t*portp = port;\n\tif (pathp != NULL) {\n\t\t*pathp = path;\n\t\tpath = NULL;\n\t}\n\tret = 0;\n out:\n\tfree(uridup);\n\tfree(user);\n\tfree(host);\n\tfree(path);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nparse_scp_uri(const char *uri, char **userp, char **hostp, int *portp,\n     char **pathp)\n{\n\tint r;\n\n\tr = parse_uri(\"scp\", uri, userp, hostp, portp, pathp);\n\tif (r == 0 && *pathp == NULL)\n\t\t*pathp = xstrdup(\".\");\n\treturn r;\n}"
  },
  {
    "function_name": "do_times",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
    "lines": "593-609",
    "snippet": "static int\ndo_times(int fd, int verb, const struct stat *sb)\n{\n\t/* strlen(2^64) == 20; strlen(10^6) == 7 */\n\tchar buf[(20 + 7 + 2) * 2 + 2];\n\n\t(void)snprintf(buf, sizeof(buf), \"T%llu 0 %llu 0\\n\",\n\t    (unsigned long long) (sb->st_mtime < 0 ? 0 : sb->st_mtime),\n\t    (unsigned long long) (sb->st_atime < 0 ? 0 : sb->st_atime));\n\tif (verb) {\n\t\tfprintf(stderr, \"File mtime %lld atime %lld\\n\",\n\t\t    (long long)sb->st_mtime, (long long)sb->st_atime);\n\t\tfprintf(stderr, \"Sending file timestamps: %s\", buf);\n\t}\n\t(void) atomicio(vwrite, fd, buf, strlen(buf));\n\treturn (response());\n}",
    "includes": [
      "#include \"utf8.h\"",
      "#include \"progressmeter.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include <sys/uio.h>",
      "#include <sys/wait.h>",
      "# include <sys/time.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define\tmtime\ttv[1]",
      "#define\tatime\ttv[0]"
    ],
    "globals_used": [
      "int response(void);",
      "void rsource(char *, struct stat *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "response",
          "args": [],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1276-1312",
          "snippet": "int\nresponse(void)\n{\n\tchar ch, *cp, resp, rbuf[2048], visbuf[2048];\n\n\tif (atomicio(read, remin, &resp, sizeof(resp)) != sizeof(resp))\n\t\tlostconn(0);\n\n\tcp = rbuf;\n\tswitch (resp) {\n\tcase 0:\t\t/* ok */\n\t\treturn (0);\n\tdefault:\n\t\t*cp++ = resp;\n\t\t/* FALLTHROUGH */\n\tcase 1:\t\t/* error, followed by error msg */\n\tcase 2:\t\t/* fatal error, \"\" */\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tlostconn(0);\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &rbuf[sizeof(rbuf) - 1] && ch != '\\n');\n\n\t\tif (!iamremote) {\n\t\t\tcp[-1] = '\\0';\n\t\t\t(void) snmprintf(visbuf, sizeof(visbuf),\n\t\t\t    NULL, \"%s\\n\", rbuf);\n\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t    visbuf, strlen(visbuf));\n\t\t}\n\t\t++errs;\n\t\tif (resp == 1)\n\t\t\treturn (-1);\n\t\texit(1);\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void lostconn(int);",
            "int response(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid lostconn(int);\nint response(void);\n\nint\nresponse(void)\n{\n\tchar ch, *cp, resp, rbuf[2048], visbuf[2048];\n\n\tif (atomicio(read, remin, &resp, sizeof(resp)) != sizeof(resp))\n\t\tlostconn(0);\n\n\tcp = rbuf;\n\tswitch (resp) {\n\tcase 0:\t\t/* ok */\n\t\treturn (0);\n\tdefault:\n\t\t*cp++ = resp;\n\t\t/* FALLTHROUGH */\n\tcase 1:\t\t/* error, followed by error msg */\n\tcase 2:\t\t/* fatal error, \"\" */\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tlostconn(0);\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &rbuf[sizeof(rbuf) - 1] && ch != '\\n');\n\n\t\tif (!iamremote) {\n\t\t\tcp[-1] = '\\0';\n\t\t\t(void) snmprintf(visbuf, sizeof(visbuf),\n\t\t\t    NULL, \"%s\\n\", rbuf);\n\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t    visbuf, strlen(visbuf));\n\t\t}\n\t\t++errs;\n\t\tif (resp == 1)\n\t\t\treturn (-1);\n\t\texit(1);\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomicio",
          "args": [
            "vwrite",
            "fd",
            "buf",
            "strlen(buf)"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "atomiciov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "165-170",
          "snippet": "size_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Sending file timestamps: %s\"",
            "buf"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"File mtime %lld atime %lld\\n\"",
            "(long long)sb->st_mtime",
            "(long long)sb->st_atime"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"T%llu 0 %llu 0\\n\"",
            "(unsigned long long) (sb->st_mtime < 0 ? 0 : sb->st_mtime)",
            "(unsigned long long) (sb->st_atime < 0 ? 0 : sb->st_atime)"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define\tmtime\ttv[1]\n#define\tatime\ttv[0]\n\nint response(void);\nvoid rsource(char *, struct stat *);\n\nstatic int\ndo_times(int fd, int verb, const struct stat *sb)\n{\n\t/* strlen(2^64) == 20; strlen(10^6) == 7 */\n\tchar buf[(20 + 7 + 2) * 2 + 2];\n\n\t(void)snprintf(buf, sizeof(buf), \"T%llu 0 %llu 0\\n\",\n\t    (unsigned long long) (sb->st_mtime < 0 ? 0 : sb->st_mtime),\n\t    (unsigned long long) (sb->st_atime < 0 ? 0 : sb->st_atime));\n\tif (verb) {\n\t\tfprintf(stderr, \"File mtime %lld atime %lld\\n\",\n\t\t    (long long)sb->st_mtime, (long long)sb->st_atime);\n\t\tfprintf(stderr, \"Sending file timestamps: %s\", buf);\n\t}\n\t(void) atomicio(vwrite, fd, buf, strlen(buf));\n\treturn (response());\n}"
  },
  {
    "function_name": "scpio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
    "lines": "582-591",
    "snippet": "static int\nscpio(void *_cnt, size_t s)\n{\n\toff_t *cnt = (off_t *)_cnt;\n\n\t*cnt += s;\n\tif (limit_kbps > 0)\n\t\tbandwidth_limit(&bwlimit, s);\n\treturn 0;\n}",
    "includes": [
      "#include \"utf8.h\"",
      "#include \"progressmeter.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include <sys/uio.h>",
      "#include <sys/wait.h>",
      "# include <sys/time.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "long long limit_kbps = 0;",
      "struct bwlimit bwlimit;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bandwidth_limit",
          "args": [
            "&bwlimit",
            "s"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "bandwidth_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1345-1395",
          "snippet": "void\nbandwidth_limit(struct bwlimit *bw, size_t read_len)\n{\n\tu_int64_t waitlen;\n\tstruct timespec ts, rm;\n\n\tif (!timerisset(&bw->bwstart)) {\n\t\tmonotime_tv(&bw->bwstart);\n\t\treturn;\n\t}\n\n\tbw->lamt += read_len;\n\tif (bw->lamt < bw->thresh)\n\t\treturn;\n\n\tmonotime_tv(&bw->bwend);\n\ttimersub(&bw->bwend, &bw->bwstart, &bw->bwend);\n\tif (!timerisset(&bw->bwend))\n\t\treturn;\n\n\tbw->lamt *= 8;\n\twaitlen = (double)1000000L * bw->lamt / bw->rate;\n\n\tbw->bwstart.tv_sec = waitlen / 1000000L;\n\tbw->bwstart.tv_usec = waitlen % 1000000L;\n\n\tif (timercmp(&bw->bwstart, &bw->bwend, >)) {\n\t\ttimersub(&bw->bwstart, &bw->bwend, &bw->bwend);\n\n\t\t/* Adjust the wait time */\n\t\tif (bw->bwend.tv_sec) {\n\t\t\tbw->thresh /= 2;\n\t\t\tif (bw->thresh < bw->buflen / 4)\n\t\t\t\tbw->thresh = bw->buflen / 4;\n\t\t} else if (bw->bwend.tv_usec < 10000) {\n\t\t\tbw->thresh *= 2;\n\t\t\tif (bw->thresh > bw->buflen * 8)\n\t\t\t\tbw->thresh = bw->buflen * 8;\n\t\t}\n\n\t\tTIMEVAL_TO_TIMESPEC(&bw->bwend, &ts);\n\t\twhile (nanosleep(&ts, &rm) == -1) {\n\t\t\tif (errno != EINTR)\n\t\t\t\tbreak;\n\t\t\tts = rm;\n\t\t}\n\t}\n\n\tbw->lamt = 0;\n\tmonotime_tv(&bw->bwstart);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nbandwidth_limit(struct bwlimit *bw, size_t read_len)\n{\n\tu_int64_t waitlen;\n\tstruct timespec ts, rm;\n\n\tif (!timerisset(&bw->bwstart)) {\n\t\tmonotime_tv(&bw->bwstart);\n\t\treturn;\n\t}\n\n\tbw->lamt += read_len;\n\tif (bw->lamt < bw->thresh)\n\t\treturn;\n\n\tmonotime_tv(&bw->bwend);\n\ttimersub(&bw->bwend, &bw->bwstart, &bw->bwend);\n\tif (!timerisset(&bw->bwend))\n\t\treturn;\n\n\tbw->lamt *= 8;\n\twaitlen = (double)1000000L * bw->lamt / bw->rate;\n\n\tbw->bwstart.tv_sec = waitlen / 1000000L;\n\tbw->bwstart.tv_usec = waitlen % 1000000L;\n\n\tif (timercmp(&bw->bwstart, &bw->bwend, >)) {\n\t\ttimersub(&bw->bwstart, &bw->bwend, &bw->bwend);\n\n\t\t/* Adjust the wait time */\n\t\tif (bw->bwend.tv_sec) {\n\t\t\tbw->thresh /= 2;\n\t\t\tif (bw->thresh < bw->buflen / 4)\n\t\t\t\tbw->thresh = bw->buflen / 4;\n\t\t} else if (bw->bwend.tv_usec < 10000) {\n\t\t\tbw->thresh *= 2;\n\t\t\tif (bw->thresh > bw->buflen * 8)\n\t\t\t\tbw->thresh = bw->buflen * 8;\n\t\t}\n\n\t\tTIMEVAL_TO_TIMESPEC(&bw->bwend, &ts);\n\t\twhile (nanosleep(&ts, &rm) == -1) {\n\t\t\tif (errno != EINTR)\n\t\t\t\tbreak;\n\t\t\tts = rm;\n\t\t}\n\t}\n\n\tbw->lamt = 0;\n\tmonotime_tv(&bw->bwstart);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nlong long limit_kbps = 0;\nstruct bwlimit bwlimit;\n\nstatic int\nscpio(void *_cnt, size_t s)\n{\n\toff_t *cnt = (off_t *)_cnt;\n\n\t*cnt += s;\n\tif (limit_kbps > 0)\n\t\tbandwidth_limit(&bwlimit, s);\n\treturn 0;\n}"
  },
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
    "lines": "391-579",
    "snippet": "int\nmain(int argc, char **argv)\n{\n\tint ch, fflag, tflag, status, n;\n\tchar **newargv;\n\tconst char *errstr;\n\textern char *optarg;\n\textern int optind;\n\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\tmsetlocale();\n\n\t/* Copy argv, because we modify it */\n\tnewargv = xcalloc(MAXIMUM(argc + 1, 1), sizeof(*newargv));\n\tfor (n = 0; n < argc; n++)\n\t\tnewargv[n] = xstrdup(argv[n]);\n\targv = newargv;\n\n\t__progname = ssh_get_progname(argv[0]);\n\n\tmemset(&args, '\\0', sizeof(args));\n\tmemset(&remote_remote_args, '\\0', sizeof(remote_remote_args));\n\targs.list = remote_remote_args.list = NULL;\n\taddargs(&args, \"%s\", ssh_program);\n\taddargs(&args, \"-x\");\n\taddargs(&args, \"-oForwardAgent=no\");\n\taddargs(&args, \"-oPermitLocalCommand=no\");\n\taddargs(&args, \"-oClearAllForwardings=yes\");\n\taddargs(&args, \"-oRemoteCommand=none\");\n\taddargs(&args, \"-oRequestTTY=no\");\n\n\tfflag = tflag = 0;\n\twhile ((ch = getopt(argc, argv, \"dfl:prtvBCc:i:P:q12346S:o:F:\")) != -1)\n\t\tswitch (ch) {\n\t\t/* User-visible flags. */\n\t\tcase '1':\n\t\t\tfatal(\"SSH protocol v.1 is no longer supported\");\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\t/* Ignored */\n\t\t\tbreak;\n\t\tcase '4':\n\t\tcase '6':\n\t\tcase 'C':\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\taddargs(&remote_remote_args, \"-%c\", ch);\n\t\t\tbreak;\n\t\tcase '3':\n\t\t\tthroughlocal = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\tcase 'c':\n\t\tcase 'i':\n\t\tcase 'F':\n\t\t\taddargs(&remote_remote_args, \"-%c\", ch);\n\t\t\taddargs(&remote_remote_args, \"%s\", optarg);\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\taddargs(&args, \"%s\", optarg);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tsshport = a2port(optarg);\n\t\t\tif (sshport <= 0)\n\t\t\t\tfatal(\"bad port \\\"%s\\\"\\n\", optarg);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\taddargs(&remote_remote_args, \"-oBatchmode=yes\");\n\t\t\taddargs(&args, \"-oBatchmode=yes\");\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlimit_kbps = strtonum(optarg, 1, 100 * 1024 * 1024,\n\t\t\t    &errstr);\n\t\t\tif (errstr != NULL)\n\t\t\t\tusage();\n\t\t\tlimit_kbps *= 1024; /* kbps */\n\t\t\tbandwidth_limit_init(&bwlimit, limit_kbps, COPY_BUFLEN);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpflag = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tiamrecursive = 1;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tssh_program = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\taddargs(&args, \"-v\");\n\t\t\taddargs(&remote_remote_args, \"-v\");\n\t\t\tverbose_mode = 1;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\taddargs(&args, \"-q\");\n\t\t\taddargs(&remote_remote_args, \"-q\");\n\t\t\tshowprogress = 0;\n\t\t\tbreak;\n\n\t\t/* Server options. */\n\t\tcase 'd':\n\t\t\ttargetshouldbedirectory = 1;\n\t\t\tbreak;\n\t\tcase 'f':\t/* \"from\" */\n\t\t\tiamremote = 1;\n\t\t\tfflag = 1;\n\t\t\tbreak;\n\t\tcase 't':\t/* \"to\" */\n\t\t\tiamremote = 1;\n\t\t\ttflag = 1;\n#ifdef HAVE_CYGWIN\n\t\t\tsetmode(0, O_BINARY);\n#endif\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\targc -= optind;\n\targv += optind;\n\n\tif ((pwd = getpwuid(userid = getuid())) == NULL)\n\t\tfatal(\"unknown user %u\", (u_int) userid);\n\n\tif (!isatty(STDOUT_FILENO))\n\t\tshowprogress = 0;\n\n\tif (pflag) {\n\t\t/* Cannot pledge: -p allows setuid/setgid files... */\n\t} else {\n\t\tif (pledge(\"stdio rpath wpath cpath fattr tty proc exec\",\n\t\t    NULL) == -1) {\n\t\t\tperror(\"pledge\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tremin = STDIN_FILENO;\n\tremout = STDOUT_FILENO;\n\n\tif (fflag) {\n\t\t/* Follow \"protocol\", send data. */\n\t\t(void) response();\n\t\tsource(argc, argv);\n\t\texit(errs != 0);\n\t}\n\tif (tflag) {\n\t\t/* Receive data. */\n\t\tsink(argc, argv);\n\t\texit(errs != 0);\n\t}\n\tif (argc < 2)\n\t\tusage();\n\tif (argc > 2)\n\t\ttargetshouldbedirectory = 1;\n\n\tremin = remout = -1;\n\tdo_cmd_pid = -1;\n\t/* Command to be executed on remote system using \"ssh\". */\n\t(void) snprintf(cmd, sizeof cmd, \"scp%s%s%s%s\",\n\t    verbose_mode ? \" -v\" : \"\",\n\t    iamrecursive ? \" -r\" : \"\", pflag ? \" -p\" : \"\",\n\t    targetshouldbedirectory ? \" -d\" : \"\");\n\n\t(void) signal(SIGPIPE, lostconn);\n\n\tif (colon(argv[argc - 1]))\t/* Dest is remote host. */\n\t\ttoremote(argc, argv);\n\telse {\n\t\tif (targetshouldbedirectory)\n\t\t\tverifydir(argv[argc - 1]);\n\t\ttolocal(argc, argv);\t/* Dest is local host. */\n\t}\n\t/*\n\t * Finally check the exit status of the ssh process, if one was forked\n\t * and no error has occurred yet\n\t */\n\tif (do_cmd_pid != -1 && errs == 0) {\n\t\tif (remin != -1)\n\t\t    (void) close(remin);\n\t\tif (remout != -1)\n\t\t    (void) close(remout);\n\t\tif (waitpid(do_cmd_pid, &status, 0) == -1)\n\t\t\terrs = 1;\n\t\telse {\n\t\t\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\t\t\terrs = 1;\n\t\t}\n\t}\n\texit(errs != 0);\n}",
    "includes": [
      "#include \"utf8.h\"",
      "#include \"progressmeter.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include <sys/uio.h>",
      "#include <sys/wait.h>",
      "# include <sys/time.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define COPY_BUFLEN\t16384"
    ],
    "globals_used": [
      "extern char *__progname;",
      "arglist args;",
      "arglist remote_remote_args;",
      "long long limit_kbps = 0;",
      "struct bwlimit bwlimit;",
      "int verbose_mode = 0;",
      "int showprogress = 1;",
      "int throughlocal = 0;",
      "int sshport = -1;",
      "char *ssh_program = _PATH_SSH_PROGRAM;",
      "pid_t do_cmd_pid = -1;",
      "void lostconn(int);",
      "void verifydir(char *);",
      "struct passwd *pwd;",
      "uid_t userid;",
      "int errs, remin, remout;",
      "int pflag, iamremote, iamrecursive, targetshouldbedirectory;",
      "char cmd[CMDNEEDS];",
      "int response(void);",
      "void sink(int, char *[]);",
      "void source(int, char *[]);",
      "void tolocal(int, char *[]);",
      "void toremote(int, char *[]);",
      "void usage(void);",
      "off_t i;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "errs != 0"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "do_cmd_pid",
            "&status",
            "0"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "waitpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-waitpid.c",
          "lines": "32-51",
          "snippet": "pid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}",
          "includes": [
            "#include \"bsd-waitpid.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-waitpid.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\npid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "remout"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tolocal",
          "args": [
            "argc",
            "argv"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "tolocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "745-801",
          "snippet": "void\ntolocal(int argc, char **argv)\n{\n\tchar *bp, *host = NULL, *src = NULL, *suser = NULL;\n\targlist alist;\n\tint i, r, sport = -1;\n\n\tmemset(&alist, '\\0', sizeof(alist));\n\talist.list = NULL;\n\n\tfor (i = 0; i < argc - 1; i++) {\n\t\tfree(suser);\n\t\tfree(host);\n\t\tfree(src);\n\t\tr = parse_scp_uri(argv[i], &suser, &host, &sport, &src);\n\t\tif (r == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[i]);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (r != 0)\n\t\t\tparse_user_host_path(argv[i], &suser, &host, &src);\n\t\tif (suser != NULL && !okname(suser)) {\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!host) {\t/* Local to local. */\n\t\t\tfreeargs(&alist);\n\t\t\taddargs(&alist, \"%s\", _PATH_CP);\n\t\t\tif (iamrecursive)\n\t\t\t\taddargs(&alist, \"-r\");\n\t\t\tif (pflag)\n\t\t\t\taddargs(&alist, \"-p\");\n\t\t\taddargs(&alist, \"--\");\n\t\t\taddargs(&alist, \"%s\", argv[i]);\n\t\t\taddargs(&alist, \"%s\", argv[argc-1]);\n\t\t\tif (do_local_cmd(&alist))\n\t\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Remote to local. */\n\t\txasprintf(&bp, \"%s -f %s%s\",\n\t\t    cmd, *src == '-' ? \"-- \" : \"\", src);\n\t\tif (do_cmd(host, suser, sport, bp, &remin, &remout) < 0) {\n\t\t\tfree(bp);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tfree(bp);\n\t\tsink(1, argv + argc - 1);\n\t\t(void) close(remin);\n\t\tremin = remout = -1;\n\t}\n\tfree(suser);\n\tfree(host);\n\tfree(src);\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int okname(char *);",
            "int errs, remin, remout;",
            "char cmd[CMDNEEDS];",
            "void sink(int, char *[]);",
            "void tolocal(int, char *[]);",
            "BUF *bp;",
            "off_t i;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint okname(char *);\nint errs, remin, remout;\nchar cmd[CMDNEEDS];\nvoid sink(int, char *[]);\nvoid tolocal(int, char *[]);\nBUF *bp;\noff_t i;\n\nvoid\ntolocal(int argc, char **argv)\n{\n\tchar *bp, *host = NULL, *src = NULL, *suser = NULL;\n\targlist alist;\n\tint i, r, sport = -1;\n\n\tmemset(&alist, '\\0', sizeof(alist));\n\talist.list = NULL;\n\n\tfor (i = 0; i < argc - 1; i++) {\n\t\tfree(suser);\n\t\tfree(host);\n\t\tfree(src);\n\t\tr = parse_scp_uri(argv[i], &suser, &host, &sport, &src);\n\t\tif (r == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[i]);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (r != 0)\n\t\t\tparse_user_host_path(argv[i], &suser, &host, &src);\n\t\tif (suser != NULL && !okname(suser)) {\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!host) {\t/* Local to local. */\n\t\t\tfreeargs(&alist);\n\t\t\taddargs(&alist, \"%s\", _PATH_CP);\n\t\t\tif (iamrecursive)\n\t\t\t\taddargs(&alist, \"-r\");\n\t\t\tif (pflag)\n\t\t\t\taddargs(&alist, \"-p\");\n\t\t\taddargs(&alist, \"--\");\n\t\t\taddargs(&alist, \"%s\", argv[i]);\n\t\t\taddargs(&alist, \"%s\", argv[argc-1]);\n\t\t\tif (do_local_cmd(&alist))\n\t\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Remote to local. */\n\t\txasprintf(&bp, \"%s -f %s%s\",\n\t\t    cmd, *src == '-' ? \"-- \" : \"\", src);\n\t\tif (do_cmd(host, suser, sport, bp, &remin, &remout) < 0) {\n\t\t\tfree(bp);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tfree(bp);\n\t\tsink(1, argv + argc - 1);\n\t\t(void) close(remin);\n\t\tremin = remout = -1;\n\t}\n\tfree(suser);\n\tfree(host);\n\tfree(src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "verifydir",
          "args": [
            "argv[argc - 1]"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "verifydir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1348-1360",
          "snippet": "void\nverifydir(char *cp)\n{\n\tstruct stat stb;\n\n\tif (!stat(cp, &stb)) {\n\t\tif (S_ISDIR(stb.st_mode))\n\t\t\treturn;\n\t\terrno = ENOTDIR;\n\t}\n\trun_err(\"%s: %s\", cp, strerror(errno));\n\tkillchild(0);\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void run_err(const char *,...);",
            "void verifydir(char *);",
            "void rsource(char *, struct stat *);",
            "struct stat stb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid run_err(const char *,...);\nvoid verifydir(char *);\nvoid rsource(char *, struct stat *);\nstruct stat stb;\n\nvoid\nverifydir(char *cp)\n{\n\tstruct stat stb;\n\n\tif (!stat(cp, &stb)) {\n\t\tif (S_ISDIR(stb.st_mode))\n\t\t\treturn;\n\t\terrno = ENOTDIR;\n\t}\n\trun_err(\"%s: %s\", cp, strerror(errno));\n\tkillchild(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "toremote",
          "args": [
            "argc",
            "argv"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "toremote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "623-743",
          "snippet": "void\ntoremote(int argc, char **argv)\n{\n\tchar *suser = NULL, *host = NULL, *src = NULL;\n\tchar *bp, *tuser, *thost, *targ;\n\tint sport = -1, tport = -1;\n\targlist alist;\n\tint i, r;\n\tu_int j;\n\n\tmemset(&alist, '\\0', sizeof(alist));\n\talist.list = NULL;\n\n\t/* Parse target */\n\tr = parse_scp_uri(argv[argc - 1], &tuser, &thost, &tport, &targ);\n\tif (r == -1) {\n\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[argc - 1]);\n\t\t++errs;\n\t\tgoto out;\n\t}\n\tif (r != 0) {\n\t\tif (parse_user_host_path(argv[argc - 1], &tuser, &thost,\n\t\t    &targ) == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid target\\n\", argv[argc - 1]);\n\t\t\t++errs;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (tuser != NULL && !okname(tuser)) {\n\t\t++errs;\n\t\tgoto out;\n\t}\n\n\t/* Parse source files */\n\tfor (i = 0; i < argc - 1; i++) {\n\t\tfree(suser);\n\t\tfree(host);\n\t\tfree(src);\n\t\tr = parse_scp_uri(argv[i], &suser, &host, &sport, &src);\n\t\tif (r == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[i]);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (r != 0) {\n\t\t\tparse_user_host_path(argv[i], &suser, &host, &src);\n\t\t}\n\t\tif (suser != NULL && !okname(suser)) {\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (host && throughlocal) {\t/* extended remote to remote */\n\t\t\txasprintf(&bp, \"%s -f %s%s\", cmd,\n\t\t\t    *src == '-' ? \"-- \" : \"\", src);\n\t\t\tif (do_cmd(host, suser, sport, bp, &remin, &remout) < 0)\n\t\t\t\texit(1);\n\t\t\tfree(bp);\n\t\t\txasprintf(&bp, \"%s -t %s%s\", cmd,\n\t\t\t    *targ == '-' ? \"-- \" : \"\", targ);\n\t\t\tif (do_cmd2(thost, tuser, tport, bp, remin, remout) < 0)\n\t\t\t\texit(1);\n\t\t\tfree(bp);\n\t\t\t(void) close(remin);\n\t\t\t(void) close(remout);\n\t\t\tremin = remout = -1;\n\t\t} else if (host) {\t/* standard remote to remote */\n\t\t\tif (tport != -1 && tport != SSH_DEFAULT_PORT) {\n\t\t\t\t/* This would require the remote support URIs */\n\t\t\t\tfatal(\"target port not supported with two \"\n\t\t\t\t    \"remote hosts without the -3 option\");\n\t\t\t}\n\n\t\t\tfreeargs(&alist);\n\t\t\taddargs(&alist, \"%s\", ssh_program);\n\t\t\taddargs(&alist, \"-x\");\n\t\t\taddargs(&alist, \"-oClearAllForwardings=yes\");\n\t\t\taddargs(&alist, \"-n\");\n\t\t\tfor (j = 0; j < remote_remote_args.num; j++) {\n\t\t\t\taddargs(&alist, \"%s\",\n\t\t\t\t    remote_remote_args.list[j]);\n\t\t\t}\n\n\t\t\tif (sport != -1) {\n\t\t\t\taddargs(&alist, \"-p\");\n\t\t\t\taddargs(&alist, \"%d\", sport);\n\t\t\t}\n\t\t\tif (suser) {\n\t\t\t\taddargs(&alist, \"-l\");\n\t\t\t\taddargs(&alist, \"%s\", suser);\n\t\t\t}\n\t\t\taddargs(&alist, \"--\");\n\t\t\taddargs(&alist, \"%s\", host);\n\t\t\taddargs(&alist, \"%s\", cmd);\n\t\t\taddargs(&alist, \"%s\", src);\n\t\t\taddargs(&alist, \"%s%s%s:%s\",\n\t\t\t    tuser ? tuser : \"\", tuser ? \"@\" : \"\",\n\t\t\t    thost, targ);\n\t\t\tif (do_local_cmd(&alist) != 0)\n\t\t\t\terrs = 1;\n\t\t} else {\t/* local to remote */\n\t\t\tif (remin == -1) {\n\t\t\t\txasprintf(&bp, \"%s -t %s%s\", cmd,\n\t\t\t\t    *targ == '-' ? \"-- \" : \"\", targ);\n\t\t\t\tif (do_cmd(thost, tuser, tport, bp, &remin,\n\t\t\t\t    &remout) < 0)\n\t\t\t\t\texit(1);\n\t\t\t\tif (response() < 0)\n\t\t\t\t\texit(1);\n\t\t\t\tfree(bp);\n\t\t\t}\n\t\t\tsource(1, argv + i);\n\t\t}\n\t}\nout:\n\tfree(tuser);\n\tfree(thost);\n\tfree(targ);\n\tfree(suser);\n\tfree(host);\n\tfree(src);\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "arglist remote_remote_args;",
            "int throughlocal = 0;",
            "char *ssh_program = _PATH_SSH_PROGRAM;",
            "int okname(char *);",
            "int errs, remin, remout;",
            "char cmd[CMDNEEDS];",
            "int response(void);",
            "void source(int, char *[]);",
            "void toremote(int, char *[]);",
            "BUF *bp;",
            "off_t i;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\narglist remote_remote_args;\nint throughlocal = 0;\nchar *ssh_program = _PATH_SSH_PROGRAM;\nint okname(char *);\nint errs, remin, remout;\nchar cmd[CMDNEEDS];\nint response(void);\nvoid source(int, char *[]);\nvoid toremote(int, char *[]);\nBUF *bp;\noff_t i;\n\nvoid\ntoremote(int argc, char **argv)\n{\n\tchar *suser = NULL, *host = NULL, *src = NULL;\n\tchar *bp, *tuser, *thost, *targ;\n\tint sport = -1, tport = -1;\n\targlist alist;\n\tint i, r;\n\tu_int j;\n\n\tmemset(&alist, '\\0', sizeof(alist));\n\talist.list = NULL;\n\n\t/* Parse target */\n\tr = parse_scp_uri(argv[argc - 1], &tuser, &thost, &tport, &targ);\n\tif (r == -1) {\n\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[argc - 1]);\n\t\t++errs;\n\t\tgoto out;\n\t}\n\tif (r != 0) {\n\t\tif (parse_user_host_path(argv[argc - 1], &tuser, &thost,\n\t\t    &targ) == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid target\\n\", argv[argc - 1]);\n\t\t\t++errs;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (tuser != NULL && !okname(tuser)) {\n\t\t++errs;\n\t\tgoto out;\n\t}\n\n\t/* Parse source files */\n\tfor (i = 0; i < argc - 1; i++) {\n\t\tfree(suser);\n\t\tfree(host);\n\t\tfree(src);\n\t\tr = parse_scp_uri(argv[i], &suser, &host, &sport, &src);\n\t\tif (r == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[i]);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (r != 0) {\n\t\t\tparse_user_host_path(argv[i], &suser, &host, &src);\n\t\t}\n\t\tif (suser != NULL && !okname(suser)) {\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (host && throughlocal) {\t/* extended remote to remote */\n\t\t\txasprintf(&bp, \"%s -f %s%s\", cmd,\n\t\t\t    *src == '-' ? \"-- \" : \"\", src);\n\t\t\tif (do_cmd(host, suser, sport, bp, &remin, &remout) < 0)\n\t\t\t\texit(1);\n\t\t\tfree(bp);\n\t\t\txasprintf(&bp, \"%s -t %s%s\", cmd,\n\t\t\t    *targ == '-' ? \"-- \" : \"\", targ);\n\t\t\tif (do_cmd2(thost, tuser, tport, bp, remin, remout) < 0)\n\t\t\t\texit(1);\n\t\t\tfree(bp);\n\t\t\t(void) close(remin);\n\t\t\t(void) close(remout);\n\t\t\tremin = remout = -1;\n\t\t} else if (host) {\t/* standard remote to remote */\n\t\t\tif (tport != -1 && tport != SSH_DEFAULT_PORT) {\n\t\t\t\t/* This would require the remote support URIs */\n\t\t\t\tfatal(\"target port not supported with two \"\n\t\t\t\t    \"remote hosts without the -3 option\");\n\t\t\t}\n\n\t\t\tfreeargs(&alist);\n\t\t\taddargs(&alist, \"%s\", ssh_program);\n\t\t\taddargs(&alist, \"-x\");\n\t\t\taddargs(&alist, \"-oClearAllForwardings=yes\");\n\t\t\taddargs(&alist, \"-n\");\n\t\t\tfor (j = 0; j < remote_remote_args.num; j++) {\n\t\t\t\taddargs(&alist, \"%s\",\n\t\t\t\t    remote_remote_args.list[j]);\n\t\t\t}\n\n\t\t\tif (sport != -1) {\n\t\t\t\taddargs(&alist, \"-p\");\n\t\t\t\taddargs(&alist, \"%d\", sport);\n\t\t\t}\n\t\t\tif (suser) {\n\t\t\t\taddargs(&alist, \"-l\");\n\t\t\t\taddargs(&alist, \"%s\", suser);\n\t\t\t}\n\t\t\taddargs(&alist, \"--\");\n\t\t\taddargs(&alist, \"%s\", host);\n\t\t\taddargs(&alist, \"%s\", cmd);\n\t\t\taddargs(&alist, \"%s\", src);\n\t\t\taddargs(&alist, \"%s%s%s:%s\",\n\t\t\t    tuser ? tuser : \"\", tuser ? \"@\" : \"\",\n\t\t\t    thost, targ);\n\t\t\tif (do_local_cmd(&alist) != 0)\n\t\t\t\terrs = 1;\n\t\t} else {\t/* local to remote */\n\t\t\tif (remin == -1) {\n\t\t\t\txasprintf(&bp, \"%s -t %s%s\", cmd,\n\t\t\t\t    *targ == '-' ? \"-- \" : \"\", targ);\n\t\t\t\tif (do_cmd(thost, tuser, tport, bp, &remin,\n\t\t\t\t    &remout) < 0)\n\t\t\t\t\texit(1);\n\t\t\t\tif (response() < 0)\n\t\t\t\t\texit(1);\n\t\t\t\tfree(bp);\n\t\t\t}\n\t\t\tsource(1, argv + i);\n\t\t}\n\t}\nout:\n\tfree(tuser);\n\tfree(thost);\n\tfree(targ);\n\tfree(suser);\n\tfree(host);\n\tfree(src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "colon",
          "args": [
            "argv[argc - 1]"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "colon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "545-566",
          "snippet": "char *\ncolon(char *cp)\n{\n\tint flag = 0;\n\n\tif (*cp == ':')\t\t/* Leading colon is part of file name. */\n\t\treturn NULL;\n\tif (*cp == '[')\n\t\tflag = 1;\n\n\tfor (; *cp; ++cp) {\n\t\tif (*cp == '@' && *(cp+1) == '[')\n\t\t\tflag = 1;\n\t\tif (*cp == ']' && *(cp+1) == ':' && flag)\n\t\t\treturn (cp+1);\n\t\tif (*cp == ':' && !flag)\n\t\t\treturn (cp);\n\t\tif (*cp == '/')\n\t\t\treturn NULL;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ncolon(char *cp)\n{\n\tint flag = 0;\n\n\tif (*cp == ':')\t\t/* Leading colon is part of file name. */\n\t\treturn NULL;\n\tif (*cp == '[')\n\t\tflag = 1;\n\n\tfor (; *cp; ++cp) {\n\t\tif (*cp == '@' && *(cp+1) == '[')\n\t\t\tflag = 1;\n\t\tif (*cp == ']' && *(cp+1) == ':' && flag)\n\t\t\treturn (cp+1);\n\t\tif (*cp == ':' && !flag)\n\t\t\treturn (cp);\n\t\tif (*cp == '/')\n\t\t\treturn NULL;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGPIPE",
            "lostconn"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "cmd",
            "sizeof cmd",
            "\"scp%s%s%s%s\"",
            "verbose_mode ? \" -v\" : \"\"",
            "iamrecursive ? \" -r\" : \"\"",
            "pflag ? \" -p\" : \"\"",
            "targetshouldbedirectory ? \" -d\" : \"\""
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1314-1321",
          "snippet": "void\nusage(void)\n{\n\t(void) fprintf(stderr,\n\t    \"usage: scp [-346BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]\\n\"\n\t    \"           [-l limit] [-o ssh_option] [-P port] [-S program] source ... target\\n\");\n\texit(1);\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void source(int, char *[]);",
            "void usage(void);",
            "off_t i;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid source(int, char *[]);\nvoid usage(void);\noff_t i;\n\nvoid\nusage(void)\n{\n\t(void) fprintf(stderr,\n\t    \"usage: scp [-346BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]\\n\"\n\t    \"           [-l limit] [-o ssh_option] [-P port] [-S program] source ... target\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sink",
          "args": [
            "argc",
            "argv"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "source",
          "args": [
            "argc",
            "argv"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "rsource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "915-962",
          "snippet": "void\nrsource(char *name, struct stat *statp)\n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *last, *vect[1], path[PATH_MAX];\n\n\tif (!(dirp = opendir(name))) {\n\t\trun_err(\"%s: %s\", name, strerror(errno));\n\t\treturn;\n\t}\n\tlast = strrchr(name, '/');\n\tif (last == NULL)\n\t\tlast = name;\n\telse\n\t\tlast++;\n\tif (pflag) {\n\t\tif (do_times(remout, verbose_mode, statp) < 0) {\n\t\t\tclosedir(dirp);\n\t\t\treturn;\n\t\t}\n\t}\n\t(void) snprintf(path, sizeof path, \"D%04o %d %.1024s\\n\",\n\t    (u_int) (statp->st_mode & FILEMODEMASK), 0, last);\n\tif (verbose_mode)\n\t\tfmprintf(stderr, \"Entering directory: %s\", path);\n\t(void) atomicio(vwrite, remout, path, strlen(path));\n\tif (response() < 0) {\n\t\tclosedir(dirp);\n\t\treturn;\n\t}\n\twhile ((dp = readdir(dirp)) != NULL) {\n\t\tif (dp->d_ino == 0)\n\t\t\tcontinue;\n\t\tif (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tif (strlen(name) + 1 + strlen(dp->d_name) >= sizeof(path) - 1) {\n\t\t\trun_err(\"%s/%s: name too long\", name, dp->d_name);\n\t\t\tcontinue;\n\t\t}\n\t\t(void) snprintf(path, sizeof path, \"%s/%s\", name, dp->d_name);\n\t\tvect[0] = path;\n\t\tsource(1, vect);\n\t}\n\t(void) closedir(dirp);\n\t(void) atomicio(vwrite, remout, \"E\\n\", 2);\n\t(void) response();\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tFILEMODEMASK\t(S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO)"
          ],
          "globals_used": [
            "int verbose_mode = 0;",
            "void run_err(const char *,...);",
            "int errs, remin, remout;",
            "int response(void);",
            "void rsource(char *, struct stat *);",
            "void source(int, char *[]);",
            "char ch, *cp, *np, *targ, *why, *vect[1], buf[2048], visbuf[2048];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define\tFILEMODEMASK\t(S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO)\n\nint verbose_mode = 0;\nvoid run_err(const char *,...);\nint errs, remin, remout;\nint response(void);\nvoid rsource(char *, struct stat *);\nvoid source(int, char *[]);\nchar ch, *cp, *np, *targ, *why, *vect[1], buf[2048], visbuf[2048];\n\nvoid\nrsource(char *name, struct stat *statp)\n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *last, *vect[1], path[PATH_MAX];\n\n\tif (!(dirp = opendir(name))) {\n\t\trun_err(\"%s: %s\", name, strerror(errno));\n\t\treturn;\n\t}\n\tlast = strrchr(name, '/');\n\tif (last == NULL)\n\t\tlast = name;\n\telse\n\t\tlast++;\n\tif (pflag) {\n\t\tif (do_times(remout, verbose_mode, statp) < 0) {\n\t\t\tclosedir(dirp);\n\t\t\treturn;\n\t\t}\n\t}\n\t(void) snprintf(path, sizeof path, \"D%04o %d %.1024s\\n\",\n\t    (u_int) (statp->st_mode & FILEMODEMASK), 0, last);\n\tif (verbose_mode)\n\t\tfmprintf(stderr, \"Entering directory: %s\", path);\n\t(void) atomicio(vwrite, remout, path, strlen(path));\n\tif (response() < 0) {\n\t\tclosedir(dirp);\n\t\treturn;\n\t}\n\twhile ((dp = readdir(dirp)) != NULL) {\n\t\tif (dp->d_ino == 0)\n\t\t\tcontinue;\n\t\tif (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tif (strlen(name) + 1 + strlen(dp->d_name) >= sizeof(path) - 1) {\n\t\t\trun_err(\"%s/%s: name too long\", name, dp->d_name);\n\t\t\tcontinue;\n\t\t}\n\t\t(void) snprintf(path, sizeof path, \"%s/%s\", name, dp->d_name);\n\t\tvect[0] = path;\n\t\tsource(1, vect);\n\t}\n\t(void) closedir(dirp);\n\t(void) atomicio(vwrite, remout, \"E\\n\", 2);\n\t(void) response();\n}"
        }
      },
      {
        "call_info": {
          "callee": "response",
          "args": [],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1276-1312",
          "snippet": "int\nresponse(void)\n{\n\tchar ch, *cp, resp, rbuf[2048], visbuf[2048];\n\n\tif (atomicio(read, remin, &resp, sizeof(resp)) != sizeof(resp))\n\t\tlostconn(0);\n\n\tcp = rbuf;\n\tswitch (resp) {\n\tcase 0:\t\t/* ok */\n\t\treturn (0);\n\tdefault:\n\t\t*cp++ = resp;\n\t\t/* FALLTHROUGH */\n\tcase 1:\t\t/* error, followed by error msg */\n\tcase 2:\t\t/* fatal error, \"\" */\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tlostconn(0);\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &rbuf[sizeof(rbuf) - 1] && ch != '\\n');\n\n\t\tif (!iamremote) {\n\t\t\tcp[-1] = '\\0';\n\t\t\t(void) snmprintf(visbuf, sizeof(visbuf),\n\t\t\t    NULL, \"%s\\n\", rbuf);\n\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t    visbuf, strlen(visbuf));\n\t\t}\n\t\t++errs;\n\t\tif (resp == 1)\n\t\t\treturn (-1);\n\t\texit(1);\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void lostconn(int);",
            "int response(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid lostconn(int);\nint response(void);\n\nint\nresponse(void)\n{\n\tchar ch, *cp, resp, rbuf[2048], visbuf[2048];\n\n\tif (atomicio(read, remin, &resp, sizeof(resp)) != sizeof(resp))\n\t\tlostconn(0);\n\n\tcp = rbuf;\n\tswitch (resp) {\n\tcase 0:\t\t/* ok */\n\t\treturn (0);\n\tdefault:\n\t\t*cp++ = resp;\n\t\t/* FALLTHROUGH */\n\tcase 1:\t\t/* error, followed by error msg */\n\tcase 2:\t\t/* fatal error, \"\" */\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tlostconn(0);\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &rbuf[sizeof(rbuf) - 1] && ch != '\\n');\n\n\t\tif (!iamremote) {\n\t\t\tcp[-1] = '\\0';\n\t\t\t(void) snmprintf(visbuf, sizeof(visbuf),\n\t\t\t    NULL, \"%s\\n\", rbuf);\n\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t    visbuf, strlen(visbuf));\n\t\t}\n\t\t++errs;\n\t\tif (resp == 1)\n\t\t\treturn (-1);\n\t\texit(1);\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"pledge\""
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pledge",
          "args": [
            "\"stdio rpath wpath cpath fattr tty proc exec\"",
            "NULL"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "pledge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "255-259",
          "snippet": "int\npledge(const char *promises, const char *paths[])\n{\n\treturn 0;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\npledge(const char *promises, const char *paths[])\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "STDOUT_FILENO"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"unknown user %u\"",
            "(u_int) userid"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpwuid",
          "args": [
            "userid = getuid()"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setmode",
          "args": [
            "0",
            "O_BINARY"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addargs",
          "args": [
            "&remote_remote_args",
            "\"-q\""
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "addargs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "861-886",
          "snippet": "void\naddargs(arglist *args, char *fmt, ...)\n{\n\tva_list ap;\n\tchar *cp;\n\tu_int nalloc;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vasprintf(&cp, fmt, ap);\n\tva_end(ap);\n\tif (r == -1)\n\t\tfatal(\"addargs: argument too long\");\n\n\tnalloc = args->nalloc;\n\tif (args->list == NULL) {\n\t\tnalloc = 32;\n\t\targs->num = 0;\n\t} else if (args->num+2 >= nalloc)\n\t\tnalloc *= 2;\n\n\targs->list = xrecallocarray(args->list, args->nalloc, nalloc, sizeof(char *));\n\targs->nalloc = nalloc;\n\targs->list[args->num++] = cp;\n\targs->list[args->num] = NULL;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\naddargs(arglist *args, char *fmt, ...)\n{\n\tva_list ap;\n\tchar *cp;\n\tu_int nalloc;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vasprintf(&cp, fmt, ap);\n\tva_end(ap);\n\tif (r == -1)\n\t\tfatal(\"addargs: argument too long\");\n\n\tnalloc = args->nalloc;\n\tif (args->list == NULL) {\n\t\tnalloc = 32;\n\t\targs->num = 0;\n\t} else if (args->num+2 >= nalloc)\n\t\tnalloc *= 2;\n\n\targs->list = xrecallocarray(args->list, args->nalloc, nalloc, sizeof(char *));\n\targs->nalloc = nalloc;\n\targs->list[args->num++] = cp;\n\targs->list[args->num] = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "optarg"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bandwidth_limit_init",
          "args": [
            "&bwlimit",
            "limit_kbps",
            "COPY_BUFLEN"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "bandwidth_limit_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1333-1342",
          "snippet": "void\nbandwidth_limit_init(struct bwlimit *bw, u_int64_t kbps, size_t buflen)\n{\n\tbw->buflen = buflen;\n\tbw->rate = kbps;\n\tbw->thresh = bw->rate;\n\tbw->lamt = 0;\n\ttimerclear(&bw->bwstart);\n\ttimerclear(&bw->bwend);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nbandwidth_limit_init(struct bwlimit *bw, u_int64_t kbps, size_t buflen)\n{\n\tbw->buflen = buflen;\n\tbw->rate = kbps;\n\tbw->thresh = bw->rate;\n\tbw->lamt = 0;\n\ttimerclear(&bw->bwstart);\n\ttimerclear(&bw->bwend);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtonum",
          "args": [
            "optarg",
            "1",
            "100 * 1024 * 1024",
            "&errstr"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "strtonum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strtonum.c",
          "lines": "33-70",
          "snippet": "long long\nstrtonum(const char *numstr, long long minval, long long maxval,\n    const char **errstrp)\n{\n\tlong long ll = 0;\n\tchar *ep;\n\tint error = 0;\n\tstruct errval {\n\t\tconst char *errstr;\n\t\tint err;\n\t} ev[4] = {\n\t\t{ NULL,\t\t0 },\n\t\t{ \"invalid\",\tEINVAL },\n\t\t{ \"too small\",\tERANGE },\n\t\t{ \"too large\",\tERANGE },\n\t};\n\n\tev[0].err = errno;\n\terrno = 0;\n\tif (minval > maxval)\n\t\terror = INVALID;\n\telse {\n\t\tll = strtoll(numstr, &ep, 10);\n\t\tif (numstr == ep || *ep != '\\0')\n\t\t\terror = INVALID;\n\t\telse if ((ll == LLONG_MIN && errno == ERANGE) || ll < minval)\n\t\t\terror = TOOSMALL;\n\t\telse if ((ll == LLONG_MAX && errno == ERANGE) || ll > maxval)\n\t\t\terror = TOOLARGE;\n\t}\n\tif (errstrp != NULL)\n\t\t*errstrp = ev[error].errstr;\n\terrno = ev[error].err;\n\tif (error)\n\t\tll = 0;\n\n\treturn (ll);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define TOOLARGE \t3",
            "#define TOOSMALL \t2",
            "#define INVALID \t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\n#define TOOLARGE \t3\n#define TOOSMALL \t2\n#define INVALID \t1\n\nlong long\nstrtonum(const char *numstr, long long minval, long long maxval,\n    const char **errstrp)\n{\n\tlong long ll = 0;\n\tchar *ep;\n\tint error = 0;\n\tstruct errval {\n\t\tconst char *errstr;\n\t\tint err;\n\t} ev[4] = {\n\t\t{ NULL,\t\t0 },\n\t\t{ \"invalid\",\tEINVAL },\n\t\t{ \"too small\",\tERANGE },\n\t\t{ \"too large\",\tERANGE },\n\t};\n\n\tev[0].err = errno;\n\terrno = 0;\n\tif (minval > maxval)\n\t\terror = INVALID;\n\telse {\n\t\tll = strtoll(numstr, &ep, 10);\n\t\tif (numstr == ep || *ep != '\\0')\n\t\t\terror = INVALID;\n\t\telse if ((ll == LLONG_MIN && errno == ERANGE) || ll < minval)\n\t\t\terror = TOOSMALL;\n\t\telse if ((ll == LLONG_MAX && errno == ERANGE) || ll > maxval)\n\t\t\terror = TOOLARGE;\n\t}\n\tif (errstrp != NULL)\n\t\t*errstrp = ev[error].errstr;\n\terrno = ev[error].err;\n\tif (error)\n\t\tll = 0;\n\n\treturn (ll);\n}"
        }
      },
      {
        "call_info": {
          "callee": "a2port",
          "args": [
            "optarg"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "a2port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "333-346",
          "snippet": "int\na2port(const char *s)\n{\n\tstruct servent *se;\n\tlong long port;\n\tconst char *errstr;\n\n\tport = strtonum(s, 0, 65535, &errstr);\n\tif (errstr == NULL)\n\t\treturn (int)port;\n\tif ((se = getservbyname(s, \"tcp\")) != NULL)\n\t\treturn ntohs(se->s_port);\n\treturn -1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\na2port(const char *s)\n{\n\tstruct servent *se;\n\tlong long port;\n\tconst char *errstr;\n\n\tport = strtonum(s, 0, 65535, &errstr);\n\tif (errstr == NULL)\n\t\treturn (int)port;\n\tif ((se = getservbyname(s, \"tcp\")) != NULL)\n\t\treturn ntohs(se->s_port);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"SSH protocol v.1 is no longer supported\""
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getopt",
          "args": [
            "argc",
            "argv",
            "\"dfl:prtvBCc:i:P:q12346S:o:F:\""
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "getopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
          "lines": "489-502",
          "snippet": "int\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <getopt.h>",
            "#include <err.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\n#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */\n\nint\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&remote_remote_args",
            "'\\0'",
            "sizeof(remote_remote_args)"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&args",
            "'\\0'",
            "sizeof(args)"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_get_progname",
          "args": [
            "argv[0]"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_get_progname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "43-64",
          "snippet": "char *ssh_get_progname(char *argv0)\n{\n\tchar *p, *q;\n#ifdef HAVE___PROGNAME\n\textern char *__progname;\n\n\tp = __progname;\n#else\n\tif (argv0 == NULL)\n\t\treturn (\"unknown\");\t/* XXX */\n\tp = strrchr(argv0, '/');\n\tif (p == NULL)\n\t\tp = argv0;\n\telse\n\t\tp++;\n#endif\n\tif ((q = strdup(p)) == NULL) {\n\t\tperror(\"strdup\");\n\t\texit(1);\n\t}\n\treturn q;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *ssh_get_progname(char *argv0)\n{\n\tchar *p, *q;\n#ifdef HAVE___PROGNAME\n\textern char *__progname;\n\n\tp = __progname;\n#else\n\tif (argv0 == NULL)\n\t\treturn (\"unknown\");\t/* XXX */\n\tp = strrchr(argv0, '/');\n\tif (p == NULL)\n\t\tp = argv0;\n\telse\n\t\tp++;\n#endif\n\tif ((q = strdup(p)) == NULL) {\n\t\tperror(\"strdup\");\n\t\texit(1);\n\t}\n\treturn q;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "MAXIMUM(argc + 1, 1)",
            "sizeof(*newargv)"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAXIMUM",
          "args": [
            "argc + 1",
            "1"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msetlocale",
          "args": [],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "msetlocale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "310-340",
          "snippet": "void\nmsetlocale(void)\n{\n\tconst char *vars[] = { \"LC_ALL\", \"LC_CTYPE\", \"LANG\", NULL };\n\tchar *cp;\n\tint i;\n\n\t/*\n\t * We can't yet cope with dotless/dotted I in Turkish locales,\n\t * so fall back to the C locale for these.\n\t */\n\tfor (i = 0; vars[i] != NULL; i++) {\n\t\tif ((cp = getenv(vars[i])) == NULL)\n\t\t\tcontinue;\n\t\tif (strncasecmp(cp, \"TR\", 2) != 0)\n\t\t\tbreak;\n\t\t/*\n\t\t * If we're in a UTF-8 locale then prefer to use\n\t\t * the C.UTF-8 locale (or equivalent) if it exists.\n\t\t */\n\t\tif ((strcasestr(cp, \"UTF-8\") != NULL ||\n\t\t    strcasestr(cp, \"UTF8\") != NULL) &&\n\t\t    (setlocale(LC_CTYPE, \"C.UTF-8\") != NULL ||\n\t\t    setlocale(LC_CTYPE, \"POSIX.UTF-8\") != NULL))\n\t\t\treturn;\n\t\tsetlocale(LC_CTYPE, \"C\");\n\t\treturn;\n\t}\n\t/* We can handle this locale */\n\tsetlocale(LC_CTYPE, \"\");\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmsetlocale(void)\n{\n\tconst char *vars[] = { \"LC_ALL\", \"LC_CTYPE\", \"LANG\", NULL };\n\tchar *cp;\n\tint i;\n\n\t/*\n\t * We can't yet cope with dotless/dotted I in Turkish locales,\n\t * so fall back to the C locale for these.\n\t */\n\tfor (i = 0; vars[i] != NULL; i++) {\n\t\tif ((cp = getenv(vars[i])) == NULL)\n\t\t\tcontinue;\n\t\tif (strncasecmp(cp, \"TR\", 2) != 0)\n\t\t\tbreak;\n\t\t/*\n\t\t * If we're in a UTF-8 locale then prefer to use\n\t\t * the C.UTF-8 locale (or equivalent) if it exists.\n\t\t */\n\t\tif ((strcasestr(cp, \"UTF-8\") != NULL ||\n\t\t    strcasestr(cp, \"UTF8\") != NULL) &&\n\t\t    (setlocale(LC_CTYPE, \"C.UTF-8\") != NULL ||\n\t\t    setlocale(LC_CTYPE, \"POSIX.UTF-8\") != NULL))\n\t\t\treturn;\n\t\tsetlocale(LC_CTYPE, \"C\");\n\t\treturn;\n\t}\n\t/* We can handle this locale */\n\tsetlocale(LC_CTYPE, \"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "sanitise_stdfd",
          "args": [],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "sanitise_stdfd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1109-1130",
          "snippet": "void\nsanitise_stdfd(void)\n{\n\tint nullfd, dupfd;\n\n\tif ((nullfd = dupfd = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\tfprintf(stderr, \"Couldn't open /dev/null: %s\\n\",\n\t\t    strerror(errno));\n\t\texit(1);\n\t}\n\twhile (++dupfd <= STDERR_FILENO) {\n\t\t/* Only populate closed fds. */\n\t\tif (fcntl(dupfd, F_GETFL) == -1 && errno == EBADF) {\n\t\t\tif (dup2(nullfd, dupfd) == -1) {\n\t\t\t\tfprintf(stderr, \"dup2: %s\\n\", strerror(errno));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\tif (nullfd > STDERR_FILENO)\n\t\tclose(nullfd);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsanitise_stdfd(void)\n{\n\tint nullfd, dupfd;\n\n\tif ((nullfd = dupfd = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\tfprintf(stderr, \"Couldn't open /dev/null: %s\\n\",\n\t\t    strerror(errno));\n\t\texit(1);\n\t}\n\twhile (++dupfd <= STDERR_FILENO) {\n\t\t/* Only populate closed fds. */\n\t\tif (fcntl(dupfd, F_GETFL) == -1 && errno == EBADF) {\n\t\t\tif (dup2(nullfd, dupfd) == -1) {\n\t\t\t\tfprintf(stderr, \"dup2: %s\\n\", strerror(errno));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\tif (nullfd > STDERR_FILENO)\n\t\tclose(nullfd);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define COPY_BUFLEN\t16384\n\nextern char *__progname;\narglist args;\narglist remote_remote_args;\nlong long limit_kbps = 0;\nstruct bwlimit bwlimit;\nint verbose_mode = 0;\nint showprogress = 1;\nint throughlocal = 0;\nint sshport = -1;\nchar *ssh_program = _PATH_SSH_PROGRAM;\npid_t do_cmd_pid = -1;\nvoid lostconn(int);\nvoid verifydir(char *);\nstruct passwd *pwd;\nuid_t userid;\nint errs, remin, remout;\nint pflag, iamremote, iamrecursive, targetshouldbedirectory;\nchar cmd[CMDNEEDS];\nint response(void);\nvoid sink(int, char *[]);\nvoid source(int, char *[]);\nvoid tolocal(int, char *[]);\nvoid toremote(int, char *[]);\nvoid usage(void);\noff_t i;\n\nint\nmain(int argc, char **argv)\n{\n\tint ch, fflag, tflag, status, n;\n\tchar **newargv;\n\tconst char *errstr;\n\textern char *optarg;\n\textern int optind;\n\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\tmsetlocale();\n\n\t/* Copy argv, because we modify it */\n\tnewargv = xcalloc(MAXIMUM(argc + 1, 1), sizeof(*newargv));\n\tfor (n = 0; n < argc; n++)\n\t\tnewargv[n] = xstrdup(argv[n]);\n\targv = newargv;\n\n\t__progname = ssh_get_progname(argv[0]);\n\n\tmemset(&args, '\\0', sizeof(args));\n\tmemset(&remote_remote_args, '\\0', sizeof(remote_remote_args));\n\targs.list = remote_remote_args.list = NULL;\n\taddargs(&args, \"%s\", ssh_program);\n\taddargs(&args, \"-x\");\n\taddargs(&args, \"-oForwardAgent=no\");\n\taddargs(&args, \"-oPermitLocalCommand=no\");\n\taddargs(&args, \"-oClearAllForwardings=yes\");\n\taddargs(&args, \"-oRemoteCommand=none\");\n\taddargs(&args, \"-oRequestTTY=no\");\n\n\tfflag = tflag = 0;\n\twhile ((ch = getopt(argc, argv, \"dfl:prtvBCc:i:P:q12346S:o:F:\")) != -1)\n\t\tswitch (ch) {\n\t\t/* User-visible flags. */\n\t\tcase '1':\n\t\t\tfatal(\"SSH protocol v.1 is no longer supported\");\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\t/* Ignored */\n\t\t\tbreak;\n\t\tcase '4':\n\t\tcase '6':\n\t\tcase 'C':\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\taddargs(&remote_remote_args, \"-%c\", ch);\n\t\t\tbreak;\n\t\tcase '3':\n\t\t\tthroughlocal = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\tcase 'c':\n\t\tcase 'i':\n\t\tcase 'F':\n\t\t\taddargs(&remote_remote_args, \"-%c\", ch);\n\t\t\taddargs(&remote_remote_args, \"%s\", optarg);\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\taddargs(&args, \"%s\", optarg);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tsshport = a2port(optarg);\n\t\t\tif (sshport <= 0)\n\t\t\t\tfatal(\"bad port \\\"%s\\\"\\n\", optarg);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\taddargs(&remote_remote_args, \"-oBatchmode=yes\");\n\t\t\taddargs(&args, \"-oBatchmode=yes\");\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlimit_kbps = strtonum(optarg, 1, 100 * 1024 * 1024,\n\t\t\t    &errstr);\n\t\t\tif (errstr != NULL)\n\t\t\t\tusage();\n\t\t\tlimit_kbps *= 1024; /* kbps */\n\t\t\tbandwidth_limit_init(&bwlimit, limit_kbps, COPY_BUFLEN);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpflag = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tiamrecursive = 1;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tssh_program = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\taddargs(&args, \"-v\");\n\t\t\taddargs(&remote_remote_args, \"-v\");\n\t\t\tverbose_mode = 1;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\taddargs(&args, \"-q\");\n\t\t\taddargs(&remote_remote_args, \"-q\");\n\t\t\tshowprogress = 0;\n\t\t\tbreak;\n\n\t\t/* Server options. */\n\t\tcase 'd':\n\t\t\ttargetshouldbedirectory = 1;\n\t\t\tbreak;\n\t\tcase 'f':\t/* \"from\" */\n\t\t\tiamremote = 1;\n\t\t\tfflag = 1;\n\t\t\tbreak;\n\t\tcase 't':\t/* \"to\" */\n\t\t\tiamremote = 1;\n\t\t\ttflag = 1;\n#ifdef HAVE_CYGWIN\n\t\t\tsetmode(0, O_BINARY);\n#endif\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\targc -= optind;\n\targv += optind;\n\n\tif ((pwd = getpwuid(userid = getuid())) == NULL)\n\t\tfatal(\"unknown user %u\", (u_int) userid);\n\n\tif (!isatty(STDOUT_FILENO))\n\t\tshowprogress = 0;\n\n\tif (pflag) {\n\t\t/* Cannot pledge: -p allows setuid/setgid files... */\n\t} else {\n\t\tif (pledge(\"stdio rpath wpath cpath fattr tty proc exec\",\n\t\t    NULL) == -1) {\n\t\t\tperror(\"pledge\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tremin = STDIN_FILENO;\n\tremout = STDOUT_FILENO;\n\n\tif (fflag) {\n\t\t/* Follow \"protocol\", send data. */\n\t\t(void) response();\n\t\tsource(argc, argv);\n\t\texit(errs != 0);\n\t}\n\tif (tflag) {\n\t\t/* Receive data. */\n\t\tsink(argc, argv);\n\t\texit(errs != 0);\n\t}\n\tif (argc < 2)\n\t\tusage();\n\tif (argc > 2)\n\t\ttargetshouldbedirectory = 1;\n\n\tremin = remout = -1;\n\tdo_cmd_pid = -1;\n\t/* Command to be executed on remote system using \"ssh\". */\n\t(void) snprintf(cmd, sizeof cmd, \"scp%s%s%s%s\",\n\t    verbose_mode ? \" -v\" : \"\",\n\t    iamrecursive ? \" -r\" : \"\", pflag ? \" -p\" : \"\",\n\t    targetshouldbedirectory ? \" -d\" : \"\");\n\n\t(void) signal(SIGPIPE, lostconn);\n\n\tif (colon(argv[argc - 1]))\t/* Dest is remote host. */\n\t\ttoremote(argc, argv);\n\telse {\n\t\tif (targetshouldbedirectory)\n\t\t\tverifydir(argv[argc - 1]);\n\t\ttolocal(argc, argv);\t/* Dest is local host. */\n\t}\n\t/*\n\t * Finally check the exit status of the ssh process, if one was forked\n\t * and no error has occurred yet\n\t */\n\tif (do_cmd_pid != -1 && errs == 0) {\n\t\tif (remin != -1)\n\t\t    (void) close(remin);\n\t\tif (remout != -1)\n\t\t    (void) close(remout);\n\t\tif (waitpid(do_cmd_pid, &status, 0) == -1)\n\t\t\terrs = 1;\n\t\telse {\n\t\t\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\t\t\terrs = 1;\n\t\t}\n\t}\n\texit(errs != 0);\n}"
  },
  {
    "function_name": "do_cmd2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
    "lines": "318-362",
    "snippet": "int\ndo_cmd2(char *host, char *remuser, int port, char *cmd, int fdin, int fdout)\n{\n\tpid_t pid;\n\tint status;\n\n\tif (verbose_mode)\n\t\tfmprintf(stderr,\n\t\t    \"Executing: 2nd program %s host %s, user %s, command %s\\n\",\n\t\t    ssh_program, host,\n\t\t    remuser ? remuser : \"(unspecified)\", cmd);\n\n\tif (port == -1)\n\t\tport = sshport;\n\n\t/* Fork a child to execute the command on the remote host using ssh. */\n\tpid = fork();\n\tif (pid == 0) {\n\t\tdup2(fdin, 0);\n\t\tdup2(fdout, 1);\n\n\t\treplacearg(&args, 0, \"%s\", ssh_program);\n\t\tif (port != -1) {\n\t\t\taddargs(&args, \"-p\");\n\t\t\taddargs(&args, \"%d\", port);\n\t\t}\n\t\tif (remuser != NULL) {\n\t\t\taddargs(&args, \"-l\");\n\t\t\taddargs(&args, \"%s\", remuser);\n\t\t}\n\t\taddargs(&args, \"--\");\n\t\taddargs(&args, \"%s\", host);\n\t\taddargs(&args, \"%s\", cmd);\n\n\t\texecvp(ssh_program, args.list);\n\t\tperror(ssh_program);\n\t\texit(1);\n\t} else if (pid == -1) {\n\t\tfatal(\"fork: %s\", strerror(errno));\n\t}\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"do_cmd2: waitpid: %s\", strerror(errno));\n\treturn 0;\n}",
    "includes": [
      "#include \"utf8.h\"",
      "#include \"progressmeter.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include <sys/uio.h>",
      "#include <sys/wait.h>",
      "# include <sys/time.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int do_cmd(char *host, char *remuser, int port, char *cmd, int *fdin, int *fdout);",
      "int do_cmd2(char *host, char *remuser, int port, char *cmd, int fdin, int fdout);",
      "arglist args;",
      "int verbose_mode = 0;",
      "int sshport = -1;",
      "char *ssh_program = _PATH_SSH_PROGRAM;",
      "char cmd[CMDNEEDS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"do_cmd2: waitpid: %s\"",
            "strerror(errno)"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "0"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "waitpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-waitpid.c",
          "lines": "32-51",
          "snippet": "pid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}",
          "includes": [
            "#include \"bsd-waitpid.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-waitpid.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\npid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "ssh_program"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "ssh_program",
            "args.list"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addargs",
          "args": [
            "&args",
            "\"%s\"",
            "cmd"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "addargs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "861-886",
          "snippet": "void\naddargs(arglist *args, char *fmt, ...)\n{\n\tva_list ap;\n\tchar *cp;\n\tu_int nalloc;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vasprintf(&cp, fmt, ap);\n\tva_end(ap);\n\tif (r == -1)\n\t\tfatal(\"addargs: argument too long\");\n\n\tnalloc = args->nalloc;\n\tif (args->list == NULL) {\n\t\tnalloc = 32;\n\t\targs->num = 0;\n\t} else if (args->num+2 >= nalloc)\n\t\tnalloc *= 2;\n\n\targs->list = xrecallocarray(args->list, args->nalloc, nalloc, sizeof(char *));\n\targs->nalloc = nalloc;\n\targs->list[args->num++] = cp;\n\targs->list[args->num] = NULL;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\naddargs(arglist *args, char *fmt, ...)\n{\n\tva_list ap;\n\tchar *cp;\n\tu_int nalloc;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vasprintf(&cp, fmt, ap);\n\tva_end(ap);\n\tif (r == -1)\n\t\tfatal(\"addargs: argument too long\");\n\n\tnalloc = args->nalloc;\n\tif (args->list == NULL) {\n\t\tnalloc = 32;\n\t\targs->num = 0;\n\t} else if (args->num+2 >= nalloc)\n\t\tnalloc *= 2;\n\n\targs->list = xrecallocarray(args->list, args->nalloc, nalloc, sizeof(char *));\n\targs->nalloc = nalloc;\n\targs->list[args->num++] = cp;\n\targs->list[args->num] = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "replacearg",
          "args": [
            "&args",
            "0",
            "\"%s\"",
            "ssh_program"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "replacearg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "888-906",
          "snippet": "void\nreplacearg(arglist *args, u_int which, char *fmt, ...)\n{\n\tva_list ap;\n\tchar *cp;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vasprintf(&cp, fmt, ap);\n\tva_end(ap);\n\tif (r == -1)\n\t\tfatal(\"replacearg: argument too long\");\n\n\tif (which >= args->num)\n\t\tfatal(\"replacearg: tried to replace invalid arg %d >= %d\",\n\t\t    which, args->num);\n\tfree(args->list[which]);\n\targs->list[which] = cp;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nreplacearg(arglist *args, u_int which, char *fmt, ...)\n{\n\tva_list ap;\n\tchar *cp;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vasprintf(&cp, fmt, ap);\n\tva_end(ap);\n\tif (r == -1)\n\t\tfatal(\"replacearg: argument too long\");\n\n\tif (which >= args->num)\n\t\tfatal(\"replacearg: tried to replace invalid arg %d >= %d\",\n\t\t    which, args->num);\n\tfree(args->list[which]);\n\targs->list[which] = cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fdout",
            "1"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fdin",
            "0"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "platform_post_fork_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
          "lines": "69-78",
          "snippet": "void\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmprintf",
          "args": [
            "stderr",
            "\"Executing: 2nd program %s host %s, user %s, command %s\\n\"",
            "ssh_program",
            "host",
            "remuser ? remuser : \"(unspecified)\"",
            "cmd"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "fmprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "277-287",
          "snippet": "int\nfmprintf(FILE *stream, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stream, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nfmprintf(FILE *stream, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stream, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint do_cmd(char *host, char *remuser, int port, char *cmd, int *fdin, int *fdout);\nint do_cmd2(char *host, char *remuser, int port, char *cmd, int fdin, int fdout);\narglist args;\nint verbose_mode = 0;\nint sshport = -1;\nchar *ssh_program = _PATH_SSH_PROGRAM;\nchar cmd[CMDNEEDS];\n\nint\ndo_cmd2(char *host, char *remuser, int port, char *cmd, int fdin, int fdout)\n{\n\tpid_t pid;\n\tint status;\n\n\tif (verbose_mode)\n\t\tfmprintf(stderr,\n\t\t    \"Executing: 2nd program %s host %s, user %s, command %s\\n\",\n\t\t    ssh_program, host,\n\t\t    remuser ? remuser : \"(unspecified)\", cmd);\n\n\tif (port == -1)\n\t\tport = sshport;\n\n\t/* Fork a child to execute the command on the remote host using ssh. */\n\tpid = fork();\n\tif (pid == 0) {\n\t\tdup2(fdin, 0);\n\t\tdup2(fdout, 1);\n\n\t\treplacearg(&args, 0, \"%s\", ssh_program);\n\t\tif (port != -1) {\n\t\t\taddargs(&args, \"-p\");\n\t\t\taddargs(&args, \"%d\", port);\n\t\t}\n\t\tif (remuser != NULL) {\n\t\t\taddargs(&args, \"-l\");\n\t\t\taddargs(&args, \"%s\", remuser);\n\t\t}\n\t\taddargs(&args, \"--\");\n\t\taddargs(&args, \"%s\", host);\n\t\taddargs(&args, \"%s\", cmd);\n\n\t\texecvp(ssh_program, args.list);\n\t\tperror(ssh_program);\n\t\texit(1);\n\t} else if (pid == -1) {\n\t\tfatal(\"fork: %s\", strerror(errno));\n\t}\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"do_cmd2: waitpid: %s\", strerror(errno));\n\treturn 0;\n}"
  },
  {
    "function_name": "do_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
    "lines": "237-311",
    "snippet": "int\ndo_cmd(char *host, char *remuser, int port, char *cmd, int *fdin, int *fdout)\n{\n\tint pin[2], pout[2], reserved[2];\n\n\tif (verbose_mode)\n\t\tfmprintf(stderr,\n\t\t    \"Executing: program %s host %s, user %s, command %s\\n\",\n\t\t    ssh_program, host,\n\t\t    remuser ? remuser : \"(unspecified)\", cmd);\n\n\tif (port == -1)\n\t\tport = sshport;\n\n\t/*\n\t * Reserve two descriptors so that the real pipes won't get\n\t * descriptors 0 and 1 because that will screw up dup2 below.\n\t */\n\tif (pipe(reserved) < 0)\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\n\t/* Create a socket pair for communicating with ssh. */\n\tif (pipe(pin) < 0)\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\tif (pipe(pout) < 0)\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\n\t/* Free the reserved descriptors. */\n\tclose(reserved[0]);\n\tclose(reserved[1]);\n\n\tsignal(SIGTSTP, suspchild);\n\tsignal(SIGTTIN, suspchild);\n\tsignal(SIGTTOU, suspchild);\n\n\t/* Fork a child to execute the command on the remote host using ssh. */\n\tdo_cmd_pid = fork();\n\tif (do_cmd_pid == 0) {\n\t\t/* Child. */\n\t\tclose(pin[1]);\n\t\tclose(pout[0]);\n\t\tdup2(pin[0], 0);\n\t\tdup2(pout[1], 1);\n\t\tclose(pin[0]);\n\t\tclose(pout[1]);\n\n\t\treplacearg(&args, 0, \"%s\", ssh_program);\n\t\tif (port != -1) {\n\t\t\taddargs(&args, \"-p\");\n\t\t\taddargs(&args, \"%d\", port);\n\t\t}\n\t\tif (remuser != NULL) {\n\t\t\taddargs(&args, \"-l\");\n\t\t\taddargs(&args, \"%s\", remuser);\n\t\t}\n\t\taddargs(&args, \"--\");\n\t\taddargs(&args, \"%s\", host);\n\t\taddargs(&args, \"%s\", cmd);\n\n\t\texecvp(ssh_program, args.list);\n\t\tperror(ssh_program);\n\t\texit(1);\n\t} else if (do_cmd_pid == -1) {\n\t\tfatal(\"fork: %s\", strerror(errno));\n\t}\n\t/* Parent.  Close the other side, and return the local side. */\n\tclose(pin[0]);\n\t*fdout = pin[1];\n\tclose(pout[1]);\n\t*fdin = pout[0];\n\tsignal(SIGTERM, killchild);\n\tsignal(SIGINT, killchild);\n\tsignal(SIGHUP, killchild);\n\treturn 0;\n}",
    "includes": [
      "#include \"utf8.h\"",
      "#include \"progressmeter.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include <sys/uio.h>",
      "#include <sys/wait.h>",
      "# include <sys/time.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int do_cmd(char *host, char *remuser, int port, char *cmd, int *fdin, int *fdout);",
      "int do_cmd2(char *host, char *remuser, int port, char *cmd, int fdin, int fdout);",
      "arglist args;",
      "int verbose_mode = 0;",
      "int sshport = -1;",
      "char *ssh_program = _PATH_SSH_PROGRAM;",
      "pid_t do_cmd_pid = -1;",
      "char cmd[CMDNEEDS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGHUP",
            "killchild"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pout[1]"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"fork: %s\"",
            "strerror(errno)"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "ssh_program"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "ssh_program",
            "args.list"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addargs",
          "args": [
            "&args",
            "\"%s\"",
            "cmd"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "addargs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "861-886",
          "snippet": "void\naddargs(arglist *args, char *fmt, ...)\n{\n\tva_list ap;\n\tchar *cp;\n\tu_int nalloc;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vasprintf(&cp, fmt, ap);\n\tva_end(ap);\n\tif (r == -1)\n\t\tfatal(\"addargs: argument too long\");\n\n\tnalloc = args->nalloc;\n\tif (args->list == NULL) {\n\t\tnalloc = 32;\n\t\targs->num = 0;\n\t} else if (args->num+2 >= nalloc)\n\t\tnalloc *= 2;\n\n\targs->list = xrecallocarray(args->list, args->nalloc, nalloc, sizeof(char *));\n\targs->nalloc = nalloc;\n\targs->list[args->num++] = cp;\n\targs->list[args->num] = NULL;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\naddargs(arglist *args, char *fmt, ...)\n{\n\tva_list ap;\n\tchar *cp;\n\tu_int nalloc;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vasprintf(&cp, fmt, ap);\n\tva_end(ap);\n\tif (r == -1)\n\t\tfatal(\"addargs: argument too long\");\n\n\tnalloc = args->nalloc;\n\tif (args->list == NULL) {\n\t\tnalloc = 32;\n\t\targs->num = 0;\n\t} else if (args->num+2 >= nalloc)\n\t\tnalloc *= 2;\n\n\targs->list = xrecallocarray(args->list, args->nalloc, nalloc, sizeof(char *));\n\targs->nalloc = nalloc;\n\targs->list[args->num++] = cp;\n\targs->list[args->num] = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "replacearg",
          "args": [
            "&args",
            "0",
            "\"%s\"",
            "ssh_program"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "replacearg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "888-906",
          "snippet": "void\nreplacearg(arglist *args, u_int which, char *fmt, ...)\n{\n\tva_list ap;\n\tchar *cp;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vasprintf(&cp, fmt, ap);\n\tva_end(ap);\n\tif (r == -1)\n\t\tfatal(\"replacearg: argument too long\");\n\n\tif (which >= args->num)\n\t\tfatal(\"replacearg: tried to replace invalid arg %d >= %d\",\n\t\t    which, args->num);\n\tfree(args->list[which]);\n\targs->list[which] = cp;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nreplacearg(arglist *args, u_int which, char *fmt, ...)\n{\n\tva_list ap;\n\tchar *cp;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vasprintf(&cp, fmt, ap);\n\tva_end(ap);\n\tif (r == -1)\n\t\tfatal(\"replacearg: argument too long\");\n\n\tif (which >= args->num)\n\t\tfatal(\"replacearg: tried to replace invalid arg %d >= %d\",\n\t\t    which, args->num);\n\tfree(args->list[which]);\n\targs->list[which] = cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "pout[1]",
            "1"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "pin[0]",
            "0"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "platform_post_fork_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
          "lines": "69-78",
          "snippet": "void\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pout"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "pin"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "reserved"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmprintf",
          "args": [
            "stderr",
            "\"Executing: program %s host %s, user %s, command %s\\n\"",
            "ssh_program",
            "host",
            "remuser ? remuser : \"(unspecified)\"",
            "cmd"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "fmprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "277-287",
          "snippet": "int\nfmprintf(FILE *stream, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stream, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nfmprintf(FILE *stream, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stream, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint do_cmd(char *host, char *remuser, int port, char *cmd, int *fdin, int *fdout);\nint do_cmd2(char *host, char *remuser, int port, char *cmd, int fdin, int fdout);\narglist args;\nint verbose_mode = 0;\nint sshport = -1;\nchar *ssh_program = _PATH_SSH_PROGRAM;\npid_t do_cmd_pid = -1;\nchar cmd[CMDNEEDS];\n\nint\ndo_cmd(char *host, char *remuser, int port, char *cmd, int *fdin, int *fdout)\n{\n\tint pin[2], pout[2], reserved[2];\n\n\tif (verbose_mode)\n\t\tfmprintf(stderr,\n\t\t    \"Executing: program %s host %s, user %s, command %s\\n\",\n\t\t    ssh_program, host,\n\t\t    remuser ? remuser : \"(unspecified)\", cmd);\n\n\tif (port == -1)\n\t\tport = sshport;\n\n\t/*\n\t * Reserve two descriptors so that the real pipes won't get\n\t * descriptors 0 and 1 because that will screw up dup2 below.\n\t */\n\tif (pipe(reserved) < 0)\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\n\t/* Create a socket pair for communicating with ssh. */\n\tif (pipe(pin) < 0)\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\tif (pipe(pout) < 0)\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\n\t/* Free the reserved descriptors. */\n\tclose(reserved[0]);\n\tclose(reserved[1]);\n\n\tsignal(SIGTSTP, suspchild);\n\tsignal(SIGTTIN, suspchild);\n\tsignal(SIGTTOU, suspchild);\n\n\t/* Fork a child to execute the command on the remote host using ssh. */\n\tdo_cmd_pid = fork();\n\tif (do_cmd_pid == 0) {\n\t\t/* Child. */\n\t\tclose(pin[1]);\n\t\tclose(pout[0]);\n\t\tdup2(pin[0], 0);\n\t\tdup2(pout[1], 1);\n\t\tclose(pin[0]);\n\t\tclose(pout[1]);\n\n\t\treplacearg(&args, 0, \"%s\", ssh_program);\n\t\tif (port != -1) {\n\t\t\taddargs(&args, \"-p\");\n\t\t\taddargs(&args, \"%d\", port);\n\t\t}\n\t\tif (remuser != NULL) {\n\t\t\taddargs(&args, \"-l\");\n\t\t\taddargs(&args, \"%s\", remuser);\n\t\t}\n\t\taddargs(&args, \"--\");\n\t\taddargs(&args, \"%s\", host);\n\t\taddargs(&args, \"%s\", cmd);\n\n\t\texecvp(ssh_program, args.list);\n\t\tperror(ssh_program);\n\t\texit(1);\n\t} else if (do_cmd_pid == -1) {\n\t\tfatal(\"fork: %s\", strerror(errno));\n\t}\n\t/* Parent.  Close the other side, and return the local side. */\n\tclose(pin[0]);\n\t*fdout = pin[1];\n\tclose(pout[1]);\n\t*fdin = pout[0];\n\tsignal(SIGTERM, killchild);\n\tsignal(SIGINT, killchild);\n\tsignal(SIGHUP, killchild);\n\treturn 0;\n}"
  },
  {
    "function_name": "do_local_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
    "lines": "189-229",
    "snippet": "static int\ndo_local_cmd(arglist *a)\n{\n\tu_int i;\n\tint status;\n\tpid_t pid;\n\n\tif (a->num == 0)\n\t\tfatal(\"do_local_cmd: no arguments\");\n\n\tif (verbose_mode) {\n\t\tfprintf(stderr, \"Executing:\");\n\t\tfor (i = 0; i < a->num; i++)\n\t\t\tfmprintf(stderr, \" %s\", a->list[i]);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\tif ((pid = fork()) == -1)\n\t\tfatal(\"do_local_cmd: fork: %s\", strerror(errno));\n\n\tif (pid == 0) {\n\t\texecvp(a->list[0], a->list);\n\t\tperror(a->list[0]);\n\t\texit(1);\n\t}\n\n\tdo_cmd_pid = pid;\n\tsignal(SIGTERM, killchild);\n\tsignal(SIGINT, killchild);\n\tsignal(SIGHUP, killchild);\n\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"do_local_cmd: waitpid: %s\", strerror(errno));\n\n\tdo_cmd_pid = -1;\n\n\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\treturn (-1);\n\n\treturn (0);\n}",
    "includes": [
      "#include \"utf8.h\"",
      "#include \"progressmeter.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include <sys/uio.h>",
      "#include <sys/wait.h>",
      "# include <sys/time.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int verbose_mode = 0;",
      "pid_t do_cmd_pid = -1;",
      "off_t i;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"do_local_cmd: waitpid: %s\"",
            "strerror(errno)"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "0"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "waitpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-waitpid.c",
          "lines": "32-51",
          "snippet": "pid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}",
          "includes": [
            "#include \"bsd-waitpid.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-waitpid.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\npid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGHUP",
            "killchild"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "a->list[0]"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "a->list[0]",
            "a->list"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "platform_post_fork_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
          "lines": "69-78",
          "snippet": "void\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmprintf",
          "args": [
            "stderr",
            "\" %s\"",
            "a->list[i]"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "fmprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "277-287",
          "snippet": "int\nfmprintf(FILE *stream, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stream, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nfmprintf(FILE *stream, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stream, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Executing:\""
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"do_local_cmd: no arguments\""
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint verbose_mode = 0;\npid_t do_cmd_pid = -1;\noff_t i;\n\nstatic int\ndo_local_cmd(arglist *a)\n{\n\tu_int i;\n\tint status;\n\tpid_t pid;\n\n\tif (a->num == 0)\n\t\tfatal(\"do_local_cmd: no arguments\");\n\n\tif (verbose_mode) {\n\t\tfprintf(stderr, \"Executing:\");\n\t\tfor (i = 0; i < a->num; i++)\n\t\t\tfmprintf(stderr, \" %s\", a->list[i]);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\tif ((pid = fork()) == -1)\n\t\tfatal(\"do_local_cmd: fork: %s\", strerror(errno));\n\n\tif (pid == 0) {\n\t\texecvp(a->list[0], a->list);\n\t\tperror(a->list[0]);\n\t\texit(1);\n\t}\n\n\tdo_cmd_pid = pid;\n\tsignal(SIGTERM, killchild);\n\tsignal(SIGINT, killchild);\n\tsignal(SIGHUP, killchild);\n\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"do_local_cmd: waitpid: %s\", strerror(errno));\n\n\tdo_cmd_pid = -1;\n\n\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\treturn (-1);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "suspchild",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
    "lines": "175-187",
    "snippet": "static void\nsuspchild(int signo)\n{\n\tint status;\n\n\tif (do_cmd_pid > 1) {\n\t\tkill(do_cmd_pid, signo);\n\t\twhile (waitpid(do_cmd_pid, &status, WUNTRACED) == -1 &&\n\t\t    errno == EINTR)\n\t\t\t;\n\t\tkill(getpid(), SIGSTOP);\n\t}\n}",
    "includes": [
      "#include \"utf8.h\"",
      "#include \"progressmeter.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include <sys/uio.h>",
      "#include <sys/wait.h>",
      "# include <sys/time.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "pid_t do_cmd_pid = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "getpid()",
            "SIGSTOP"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "do_cmd_pid",
            "&status",
            "WUNTRACED"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "waitpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-waitpid.c",
          "lines": "32-51",
          "snippet": "pid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}",
          "includes": [
            "#include \"bsd-waitpid.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-waitpid.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\npid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "do_cmd_pid",
            "signo"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\npid_t do_cmd_pid = -1;\n\nstatic void\nsuspchild(int signo)\n{\n\tint status;\n\n\tif (do_cmd_pid > 1) {\n\t\tkill(do_cmd_pid, signo);\n\t\twhile (waitpid(do_cmd_pid, &status, WUNTRACED) == -1 &&\n\t\t    errno == EINTR)\n\t\t\t;\n\t\tkill(getpid(), SIGSTOP);\n\t}\n}"
  },
  {
    "function_name": "killchild",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
    "lines": "162-173",
    "snippet": "static void\nkillchild(int signo)\n{\n\tif (do_cmd_pid > 1) {\n\t\tkill(do_cmd_pid, signo ? signo : SIGTERM);\n\t\twaitpid(do_cmd_pid, NULL, 0);\n\t}\n\n\tif (signo)\n\t\t_exit(1);\n\texit(1);\n}",
    "includes": [
      "#include \"utf8.h\"",
      "#include \"progressmeter.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"atomicio.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <locale.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <ctype.h>",
      "#include <sys/uio.h>",
      "#include <sys/wait.h>",
      "# include <sys/time.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "pid_t do_cmd_pid = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "do_cmd_pid",
            "NULL",
            "0"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "waitpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-waitpid.c",
          "lines": "32-51",
          "snippet": "pid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}",
          "includes": [
            "#include \"bsd-waitpid.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-waitpid.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\npid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "do_cmd_pid",
            "signo ? signo : SIGTERM"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\npid_t do_cmd_pid = -1;\n\nstatic void\nkillchild(int signo)\n{\n\tif (do_cmd_pid > 1) {\n\t\tkill(do_cmd_pid, signo ? signo : SIGTERM);\n\t\twaitpid(do_cmd_pid, NULL, 0);\n\t}\n\n\tif (signo)\n\t\t_exit(1);\n\texit(1);\n}"
  }
]