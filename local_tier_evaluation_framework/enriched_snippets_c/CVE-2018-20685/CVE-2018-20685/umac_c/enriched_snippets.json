[
  {
    "function_name": "umac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "1266-1275",
    "snippet": "int umac(struct umac_ctx *ctx, u_char *input,\n         long len, u_char tag[],\n         u_char nonce[8])\n/* All-in-one version simply calls umac_update() and umac_final().        */\n{\n    uhash(&ctx->hash, input, len, (u_char *)tag);\n    pdf_gen_xor(&ctx->pdf, (UINT8 *)nonce, (UINT8 *)tag);\n\n    return (1);\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct umac_ctx {\n    uhash_ctx hash;          /* Hash function for message compression    */\n    pdf_ctx pdf;             /* PDF for hashed output                    */\n    void *free_ptr;          /* Address to free this struct via          */\n} umac_ctx;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pdf_gen_xor",
          "args": [
            "&ctx->pdf",
            "(UINT8 *)nonce",
            "(UINT8 *)tag"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "pdf_gen_xor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "235-278",
          "snippet": "static void pdf_gen_xor(pdf_ctx *pc, const UINT8 nonce[8], UINT8 buf[8])\n{\n    /* 'ndx' indicates that we'll be using the 0th or 1st eight bytes\n     * of the AES output. If last time around we returned the ndx-1st\n     * element, then we may have the result in the cache already.\n     */\n\n#if (UMAC_OUTPUT_LEN == 4)\n#define LOW_BIT_MASK 3\n#elif (UMAC_OUTPUT_LEN == 8)\n#define LOW_BIT_MASK 1\n#elif (UMAC_OUTPUT_LEN > 8)\n#define LOW_BIT_MASK 0\n#endif\n    union {\n        UINT8 tmp_nonce_lo[4];\n        UINT32 align;\n    } t;\n#if LOW_BIT_MASK != 0\n    int ndx = nonce[7] & LOW_BIT_MASK;\n#endif\n    *(UINT32 *)t.tmp_nonce_lo = ((const UINT32 *)nonce)[1];\n    t.tmp_nonce_lo[3] &= ~LOW_BIT_MASK; /* zero last bit */\n\n    if ( (((UINT32 *)t.tmp_nonce_lo)[0] != ((UINT32 *)pc->nonce)[1]) ||\n         (((const UINT32 *)nonce)[0] != ((UINT32 *)pc->nonce)[0]) )\n    {\n        ((UINT32 *)pc->nonce)[0] = ((const UINT32 *)nonce)[0];\n        ((UINT32 *)pc->nonce)[1] = ((UINT32 *)t.tmp_nonce_lo)[0];\n        aes_encryption(pc->nonce, pc->cache, pc->prf_key);\n    }\n\n#if (UMAC_OUTPUT_LEN == 4)\n    *((UINT32 *)buf) ^= ((UINT32 *)pc->cache)[ndx];\n#elif (UMAC_OUTPUT_LEN == 8)\n    *((UINT64 *)buf) ^= ((UINT64 *)pc->cache)[ndx];\n#elif (UMAC_OUTPUT_LEN == 12)\n    ((UINT64 *)buf)[0] ^= ((UINT64 *)pc->cache)[0];\n    ((UINT32 *)buf)[2] ^= ((UINT32 *)pc->cache)[2];\n#elif (UMAC_OUTPUT_LEN == 16)\n    ((UINT64 *)buf)[0] ^= ((UINT64 *)pc->cache)[0];\n    ((UINT64 *)buf)[1] ^= ((UINT64 *)pc->cache)[1];\n#endif\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define LOW_BIT_MASK 0",
            "#define LOW_BIT_MASK 1",
            "#define LOW_BIT_MASK 3",
            "#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define LOW_BIT_MASK 0\n#define LOW_BIT_MASK 1\n#define LOW_BIT_MASK 3\n#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */\n\nstatic void pdf_gen_xor(pdf_ctx *pc, const UINT8 nonce[8], UINT8 buf[8])\n{\n    /* 'ndx' indicates that we'll be using the 0th or 1st eight bytes\n     * of the AES output. If last time around we returned the ndx-1st\n     * element, then we may have the result in the cache already.\n     */\n\n#if (UMAC_OUTPUT_LEN == 4)\n#define LOW_BIT_MASK 3\n#elif (UMAC_OUTPUT_LEN == 8)\n#define LOW_BIT_MASK 1\n#elif (UMAC_OUTPUT_LEN > 8)\n#define LOW_BIT_MASK 0\n#endif\n    union {\n        UINT8 tmp_nonce_lo[4];\n        UINT32 align;\n    } t;\n#if LOW_BIT_MASK != 0\n    int ndx = nonce[7] & LOW_BIT_MASK;\n#endif\n    *(UINT32 *)t.tmp_nonce_lo = ((const UINT32 *)nonce)[1];\n    t.tmp_nonce_lo[3] &= ~LOW_BIT_MASK; /* zero last bit */\n\n    if ( (((UINT32 *)t.tmp_nonce_lo)[0] != ((UINT32 *)pc->nonce)[1]) ||\n         (((const UINT32 *)nonce)[0] != ((UINT32 *)pc->nonce)[0]) )\n    {\n        ((UINT32 *)pc->nonce)[0] = ((const UINT32 *)nonce)[0];\n        ((UINT32 *)pc->nonce)[1] = ((UINT32 *)t.tmp_nonce_lo)[0];\n        aes_encryption(pc->nonce, pc->cache, pc->prf_key);\n    }\n\n#if (UMAC_OUTPUT_LEN == 4)\n    *((UINT32 *)buf) ^= ((UINT32 *)pc->cache)[ndx];\n#elif (UMAC_OUTPUT_LEN == 8)\n    *((UINT64 *)buf) ^= ((UINT64 *)pc->cache)[ndx];\n#elif (UMAC_OUTPUT_LEN == 12)\n    ((UINT64 *)buf)[0] ^= ((UINT64 *)pc->cache)[0];\n    ((UINT32 *)buf)[2] ^= ((UINT32 *)pc->cache)[2];\n#elif (UMAC_OUTPUT_LEN == 16)\n    ((UINT64 *)buf)[0] ^= ((UINT64 *)pc->cache)[0];\n    ((UINT64 *)buf)[1] ^= ((UINT64 *)pc->cache)[1];\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhash",
          "args": [
            "&ctx->hash",
            "input",
            "len",
            "(u_char *)tag"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "uhash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "1124-1167",
          "snippet": "static int uhash(uhash_ctx_t ahc, u_char *msg, long len, u_char *res)\n/* assumes that msg is in a writable buffer of length divisible by */\n/* L1_PAD_BOUNDARY. Bytes beyond msg[len] may be zeroed.           */\n{\n    UINT8 nh_result[STREAMS*sizeof(UINT64)];\n    UINT32 nh_len;\n    int extra_zeroes_needed;\n\n    /* If the message to be hashed is no longer than L1_HASH_LEN, we skip\n     * the polyhash.\n     */\n    if (len <= L1_KEY_LEN) {\n\tif (len == 0)                  /* If zero length messages will not */\n\t\tnh_len = L1_PAD_BOUNDARY;  /* be seen, comment out this case   */\n\telse\n\t\tnh_len = ((len + (L1_PAD_BOUNDARY - 1)) & ~(L1_PAD_BOUNDARY - 1));\n        extra_zeroes_needed = nh_len - len;\n        zero_pad((UINT8 *)msg + len, extra_zeroes_needed);\n        nh(&ahc->hash, (UINT8 *)msg, nh_len, len, nh_result);\n        ip_short(ahc,nh_result, res);\n    } else {\n        /* Otherwise, we hash each L1_KEY_LEN chunk with NH, passing the NH\n         * output to poly_hash().\n         */\n        do {\n            nh(&ahc->hash, (UINT8 *)msg, L1_KEY_LEN, L1_KEY_LEN, nh_result);\n            poly_hash(ahc,(UINT32 *)nh_result);\n            len -= L1_KEY_LEN;\n            msg += L1_KEY_LEN;\n        } while (len >= L1_KEY_LEN);\n        if (len) {\n            nh_len = ((len + (L1_PAD_BOUNDARY - 1)) & ~(L1_PAD_BOUNDARY - 1));\n            extra_zeroes_needed = nh_len - len;\n            zero_pad((UINT8 *)msg + len, extra_zeroes_needed);\n            nh(&ahc->hash, (UINT8 *)msg, nh_len, len, nh_result);\n            poly_hash(ahc,(UINT32 *)nh_result);\n        }\n\n        ip_long(ahc, res);\n    }\n\n    uhash_reset(ahc);\n    return 1;\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define L1_PAD_BOUNDARY      32     /* pad message to boundary multiple   */",
            "#define L1_KEY_LEN         1024     /* Internal key bytes                 */",
            "#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define L1_PAD_BOUNDARY      32     /* pad message to boundary multiple   */\n#define L1_KEY_LEN         1024     /* Internal key bytes                 */\n#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */\n\nstatic int uhash(uhash_ctx_t ahc, u_char *msg, long len, u_char *res)\n/* assumes that msg is in a writable buffer of length divisible by */\n/* L1_PAD_BOUNDARY. Bytes beyond msg[len] may be zeroed.           */\n{\n    UINT8 nh_result[STREAMS*sizeof(UINT64)];\n    UINT32 nh_len;\n    int extra_zeroes_needed;\n\n    /* If the message to be hashed is no longer than L1_HASH_LEN, we skip\n     * the polyhash.\n     */\n    if (len <= L1_KEY_LEN) {\n\tif (len == 0)                  /* If zero length messages will not */\n\t\tnh_len = L1_PAD_BOUNDARY;  /* be seen, comment out this case   */\n\telse\n\t\tnh_len = ((len + (L1_PAD_BOUNDARY - 1)) & ~(L1_PAD_BOUNDARY - 1));\n        extra_zeroes_needed = nh_len - len;\n        zero_pad((UINT8 *)msg + len, extra_zeroes_needed);\n        nh(&ahc->hash, (UINT8 *)msg, nh_len, len, nh_result);\n        ip_short(ahc,nh_result, res);\n    } else {\n        /* Otherwise, we hash each L1_KEY_LEN chunk with NH, passing the NH\n         * output to poly_hash().\n         */\n        do {\n            nh(&ahc->hash, (UINT8 *)msg, L1_KEY_LEN, L1_KEY_LEN, nh_result);\n            poly_hash(ahc,(UINT32 *)nh_result);\n            len -= L1_KEY_LEN;\n            msg += L1_KEY_LEN;\n        } while (len >= L1_KEY_LEN);\n        if (len) {\n            nh_len = ((len + (L1_PAD_BOUNDARY - 1)) & ~(L1_PAD_BOUNDARY - 1));\n            extra_zeroes_needed = nh_len - len;\n            zero_pad((UINT8 *)msg + len, extra_zeroes_needed);\n            nh(&ahc->hash, (UINT8 *)msg, nh_len, len, nh_result);\n            poly_hash(ahc,(UINT32 *)nh_result);\n        }\n\n        ip_long(ahc, res);\n    }\n\n    uhash_reset(ahc);\n    return 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct umac_ctx {\n    uhash_ctx hash;          /* Hash function for message compression    */\n    pdf_ctx pdf;             /* PDF for hashed output                    */\n    void *free_ptr;          /* Address to free this struct via          */\n} umac_ctx;\n\nint umac(struct umac_ctx *ctx, u_char *input,\n         long len, u_char tag[],\n         u_char nonce[8])\n/* All-in-one version simply calls umac_update() and umac_final().        */\n{\n    uhash(&ctx->hash, input, len, (u_char *)tag);\n    pdf_gen_xor(&ctx->pdf, (UINT8 *)nonce, (UINT8 *)tag);\n\n    return (1);\n}"
  },
  {
    "function_name": "umac_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "1254-1261",
    "snippet": "int umac_update(struct umac_ctx *ctx, const u_char *input, long len)\n/* Given len bytes of data, we parse it into L1_KEY_LEN chunks and   */\n/* hash each one, calling the PDF on the hashed output whenever the hash- */\n/* output buffer is full.                                                 */\n{\n    uhash_update(&ctx->hash, input, len);\n    return (1);\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define L1_KEY_LEN         1024     /* Internal key bytes                 */"
    ],
    "globals_used": [
      "struct umac_ctx {\n    uhash_ctx hash;          /* Hash function for message compression    */\n    pdf_ctx pdf;             /* PDF for hashed output                    */\n    void *free_ptr;          /* Address to free this struct via          */\n} umac_ctx;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhash_update",
          "args": [
            "&ctx->hash",
            "input",
            "len"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "uhash_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "1045-1097",
          "snippet": "static int uhash_update(uhash_ctx_t ctx, const u_char *input, long len)\n/* Given len bytes of data, we parse it into L1_KEY_LEN chunks and\n * hash each one with NH, calling the polyhash on each NH output.\n */\n{\n    UWORD bytes_hashed, bytes_remaining;\n    UINT64 result_buf[STREAMS];\n    UINT8 *nh_result = (UINT8 *)&result_buf;\n\n    if (ctx->msg_len + len <= L1_KEY_LEN) {\n        nh_update(&ctx->hash, (const UINT8 *)input, len);\n        ctx->msg_len += len;\n    } else {\n\n         bytes_hashed = ctx->msg_len % L1_KEY_LEN;\n         if (ctx->msg_len == L1_KEY_LEN)\n             bytes_hashed = L1_KEY_LEN;\n\n         if (bytes_hashed + len >= L1_KEY_LEN) {\n\n             /* If some bytes have been passed to the hash function      */\n             /* then we want to pass at most (L1_KEY_LEN - bytes_hashed) */\n             /* bytes to complete the current nh_block.                  */\n             if (bytes_hashed) {\n                 bytes_remaining = (L1_KEY_LEN - bytes_hashed);\n                 nh_update(&ctx->hash, (const UINT8 *)input, bytes_remaining);\n                 nh_final(&ctx->hash, nh_result);\n                 ctx->msg_len += bytes_remaining;\n                 poly_hash(ctx,(UINT32 *)nh_result);\n                 len -= bytes_remaining;\n                 input += bytes_remaining;\n             }\n\n             /* Hash directly from input stream if enough bytes */\n             while (len >= L1_KEY_LEN) {\n                 nh(&ctx->hash, (const UINT8 *)input, L1_KEY_LEN,\n                                   L1_KEY_LEN, nh_result);\n                 ctx->msg_len += L1_KEY_LEN;\n                 len -= L1_KEY_LEN;\n                 input += L1_KEY_LEN;\n                 poly_hash(ctx,(UINT32 *)nh_result);\n             }\n         }\n\n         /* pass remaining < L1_KEY_LEN bytes of input data to NH */\n         if (len) {\n             nh_update(&ctx->hash, (const UINT8 *)input, len);\n             ctx->msg_len += len;\n         }\n     }\n\n    return (1);\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define L1_KEY_LEN         1024     /* Internal key bytes                 */",
            "#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define L1_KEY_LEN         1024     /* Internal key bytes                 */\n#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */\n\nstatic int uhash_update(uhash_ctx_t ctx, const u_char *input, long len)\n/* Given len bytes of data, we parse it into L1_KEY_LEN chunks and\n * hash each one with NH, calling the polyhash on each NH output.\n */\n{\n    UWORD bytes_hashed, bytes_remaining;\n    UINT64 result_buf[STREAMS];\n    UINT8 *nh_result = (UINT8 *)&result_buf;\n\n    if (ctx->msg_len + len <= L1_KEY_LEN) {\n        nh_update(&ctx->hash, (const UINT8 *)input, len);\n        ctx->msg_len += len;\n    } else {\n\n         bytes_hashed = ctx->msg_len % L1_KEY_LEN;\n         if (ctx->msg_len == L1_KEY_LEN)\n             bytes_hashed = L1_KEY_LEN;\n\n         if (bytes_hashed + len >= L1_KEY_LEN) {\n\n             /* If some bytes have been passed to the hash function      */\n             /* then we want to pass at most (L1_KEY_LEN - bytes_hashed) */\n             /* bytes to complete the current nh_block.                  */\n             if (bytes_hashed) {\n                 bytes_remaining = (L1_KEY_LEN - bytes_hashed);\n                 nh_update(&ctx->hash, (const UINT8 *)input, bytes_remaining);\n                 nh_final(&ctx->hash, nh_result);\n                 ctx->msg_len += bytes_remaining;\n                 poly_hash(ctx,(UINT32 *)nh_result);\n                 len -= bytes_remaining;\n                 input += bytes_remaining;\n             }\n\n             /* Hash directly from input stream if enough bytes */\n             while (len >= L1_KEY_LEN) {\n                 nh(&ctx->hash, (const UINT8 *)input, L1_KEY_LEN,\n                                   L1_KEY_LEN, nh_result);\n                 ctx->msg_len += L1_KEY_LEN;\n                 len -= L1_KEY_LEN;\n                 input += L1_KEY_LEN;\n                 poly_hash(ctx,(UINT32 *)nh_result);\n             }\n         }\n\n         /* pass remaining < L1_KEY_LEN bytes of input data to NH */\n         if (len) {\n             nh_update(&ctx->hash, (const UINT8 *)input, len);\n             ctx->msg_len += len;\n         }\n     }\n\n    return (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define L1_KEY_LEN         1024     /* Internal key bytes                 */\n\nstruct umac_ctx {\n    uhash_ctx hash;          /* Hash function for message compression    */\n    pdf_ctx pdf;             /* PDF for hashed output                    */\n    void *free_ptr;          /* Address to free this struct via          */\n} umac_ctx;\n\nint umac_update(struct umac_ctx *ctx, const u_char *input, long len)\n/* Given len bytes of data, we parse it into L1_KEY_LEN chunks and   */\n/* hash each one, calling the PDF on the hashed output whenever the hash- */\n/* output buffer is full.                                                 */\n{\n    uhash_update(&ctx->hash, input, len);\n    return (1);\n}"
  },
  {
    "function_name": "umac_final",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "1243-1250",
    "snippet": "int umac_final(struct umac_ctx *ctx, u_char tag[], const u_char nonce[8])\n/* Incorporate any pending data, pad, and generate tag */\n{\n    uhash_final(&ctx->hash, (u_char *)tag);\n    pdf_gen_xor(&ctx->pdf, (const UINT8 *)nonce, (UINT8 *)tag);\n\n    return (1);\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct umac_ctx {\n    uhash_ctx hash;          /* Hash function for message compression    */\n    pdf_ctx pdf;             /* PDF for hashed output                    */\n    void *free_ptr;          /* Address to free this struct via          */\n} umac_ctx;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pdf_gen_xor",
          "args": [
            "&ctx->pdf",
            "(const UINT8 *)nonce",
            "(UINT8 *)tag"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "pdf_gen_xor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "235-278",
          "snippet": "static void pdf_gen_xor(pdf_ctx *pc, const UINT8 nonce[8], UINT8 buf[8])\n{\n    /* 'ndx' indicates that we'll be using the 0th or 1st eight bytes\n     * of the AES output. If last time around we returned the ndx-1st\n     * element, then we may have the result in the cache already.\n     */\n\n#if (UMAC_OUTPUT_LEN == 4)\n#define LOW_BIT_MASK 3\n#elif (UMAC_OUTPUT_LEN == 8)\n#define LOW_BIT_MASK 1\n#elif (UMAC_OUTPUT_LEN > 8)\n#define LOW_BIT_MASK 0\n#endif\n    union {\n        UINT8 tmp_nonce_lo[4];\n        UINT32 align;\n    } t;\n#if LOW_BIT_MASK != 0\n    int ndx = nonce[7] & LOW_BIT_MASK;\n#endif\n    *(UINT32 *)t.tmp_nonce_lo = ((const UINT32 *)nonce)[1];\n    t.tmp_nonce_lo[3] &= ~LOW_BIT_MASK; /* zero last bit */\n\n    if ( (((UINT32 *)t.tmp_nonce_lo)[0] != ((UINT32 *)pc->nonce)[1]) ||\n         (((const UINT32 *)nonce)[0] != ((UINT32 *)pc->nonce)[0]) )\n    {\n        ((UINT32 *)pc->nonce)[0] = ((const UINT32 *)nonce)[0];\n        ((UINT32 *)pc->nonce)[1] = ((UINT32 *)t.tmp_nonce_lo)[0];\n        aes_encryption(pc->nonce, pc->cache, pc->prf_key);\n    }\n\n#if (UMAC_OUTPUT_LEN == 4)\n    *((UINT32 *)buf) ^= ((UINT32 *)pc->cache)[ndx];\n#elif (UMAC_OUTPUT_LEN == 8)\n    *((UINT64 *)buf) ^= ((UINT64 *)pc->cache)[ndx];\n#elif (UMAC_OUTPUT_LEN == 12)\n    ((UINT64 *)buf)[0] ^= ((UINT64 *)pc->cache)[0];\n    ((UINT32 *)buf)[2] ^= ((UINT32 *)pc->cache)[2];\n#elif (UMAC_OUTPUT_LEN == 16)\n    ((UINT64 *)buf)[0] ^= ((UINT64 *)pc->cache)[0];\n    ((UINT64 *)buf)[1] ^= ((UINT64 *)pc->cache)[1];\n#endif\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define LOW_BIT_MASK 0",
            "#define LOW_BIT_MASK 1",
            "#define LOW_BIT_MASK 3",
            "#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define LOW_BIT_MASK 0\n#define LOW_BIT_MASK 1\n#define LOW_BIT_MASK 3\n#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */\n\nstatic void pdf_gen_xor(pdf_ctx *pc, const UINT8 nonce[8], UINT8 buf[8])\n{\n    /* 'ndx' indicates that we'll be using the 0th or 1st eight bytes\n     * of the AES output. If last time around we returned the ndx-1st\n     * element, then we may have the result in the cache already.\n     */\n\n#if (UMAC_OUTPUT_LEN == 4)\n#define LOW_BIT_MASK 3\n#elif (UMAC_OUTPUT_LEN == 8)\n#define LOW_BIT_MASK 1\n#elif (UMAC_OUTPUT_LEN > 8)\n#define LOW_BIT_MASK 0\n#endif\n    union {\n        UINT8 tmp_nonce_lo[4];\n        UINT32 align;\n    } t;\n#if LOW_BIT_MASK != 0\n    int ndx = nonce[7] & LOW_BIT_MASK;\n#endif\n    *(UINT32 *)t.tmp_nonce_lo = ((const UINT32 *)nonce)[1];\n    t.tmp_nonce_lo[3] &= ~LOW_BIT_MASK; /* zero last bit */\n\n    if ( (((UINT32 *)t.tmp_nonce_lo)[0] != ((UINT32 *)pc->nonce)[1]) ||\n         (((const UINT32 *)nonce)[0] != ((UINT32 *)pc->nonce)[0]) )\n    {\n        ((UINT32 *)pc->nonce)[0] = ((const UINT32 *)nonce)[0];\n        ((UINT32 *)pc->nonce)[1] = ((UINT32 *)t.tmp_nonce_lo)[0];\n        aes_encryption(pc->nonce, pc->cache, pc->prf_key);\n    }\n\n#if (UMAC_OUTPUT_LEN == 4)\n    *((UINT32 *)buf) ^= ((UINT32 *)pc->cache)[ndx];\n#elif (UMAC_OUTPUT_LEN == 8)\n    *((UINT64 *)buf) ^= ((UINT64 *)pc->cache)[ndx];\n#elif (UMAC_OUTPUT_LEN == 12)\n    ((UINT64 *)buf)[0] ^= ((UINT64 *)pc->cache)[0];\n    ((UINT32 *)buf)[2] ^= ((UINT32 *)pc->cache)[2];\n#elif (UMAC_OUTPUT_LEN == 16)\n    ((UINT64 *)buf)[0] ^= ((UINT64 *)pc->cache)[0];\n    ((UINT64 *)buf)[1] ^= ((UINT64 *)pc->cache)[1];\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhash_final",
          "args": [
            "&ctx->hash",
            "(u_char *)tag"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "uhash_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "1101-1119",
          "snippet": "static int uhash_final(uhash_ctx_t ctx, u_char *res)\n/* Incorporate any pending data, pad, and generate tag */\n{\n    UINT64 result_buf[STREAMS];\n    UINT8 *nh_result = (UINT8 *)&result_buf;\n\n    if (ctx->msg_len > L1_KEY_LEN) {\n        if (ctx->msg_len % L1_KEY_LEN) {\n            nh_final(&ctx->hash, nh_result);\n            poly_hash(ctx,(UINT32 *)nh_result);\n        }\n        ip_long(ctx, res);\n    } else {\n        nh_final(&ctx->hash, nh_result);\n        ip_short(ctx,nh_result, res);\n    }\n    uhash_reset(ctx);\n    return (1);\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define L1_KEY_LEN         1024     /* Internal key bytes                 */",
            "#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define L1_KEY_LEN         1024     /* Internal key bytes                 */\n#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */\n\nstatic int uhash_final(uhash_ctx_t ctx, u_char *res)\n/* Incorporate any pending data, pad, and generate tag */\n{\n    UINT64 result_buf[STREAMS];\n    UINT8 *nh_result = (UINT8 *)&result_buf;\n\n    if (ctx->msg_len > L1_KEY_LEN) {\n        if (ctx->msg_len % L1_KEY_LEN) {\n            nh_final(&ctx->hash, nh_result);\n            poly_hash(ctx,(UINT32 *)nh_result);\n        }\n        ip_long(ctx, res);\n    } else {\n        nh_final(&ctx->hash, nh_result);\n        ip_short(ctx,nh_result, res);\n    }\n    uhash_reset(ctx);\n    return (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct umac_ctx {\n    uhash_ctx hash;          /* Hash function for message compression    */\n    pdf_ctx pdf;             /* PDF for hashed output                    */\n    void *free_ptr;          /* Address to free this struct via          */\n} umac_ctx;\n\nint umac_final(struct umac_ctx *ctx, u_char tag[], const u_char nonce[8])\n/* Incorporate any pending data, pad, and generate tag */\n{\n    uhash_final(&ctx->hash, (u_char *)tag);\n    pdf_gen_xor(&ctx->pdf, (const UINT8 *)nonce, (UINT8 *)tag);\n\n    return (1);\n}"
  },
  {
    "function_name": "umac_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "1215-1239",
    "snippet": "struct umac_ctx *umac_new(const u_char key[])\n/* Dynamically allocate a umac_ctx struct, initialize variables,\n * generate subkeys from key. Align to 16-byte boundary.\n */\n{\n    struct umac_ctx *ctx, *octx;\n    size_t bytes_to_add;\n    aes_int_key prf_key;\n\n    octx = ctx = xcalloc(1, sizeof(*ctx) + ALLOC_BOUNDARY);\n    if (ctx) {\n        if (ALLOC_BOUNDARY) {\n            bytes_to_add = ALLOC_BOUNDARY -\n                              ((ptrdiff_t)ctx & (ALLOC_BOUNDARY - 1));\n            ctx = (struct umac_ctx *)((u_char *)ctx + bytes_to_add);\n        }\n        ctx->free_ptr = octx;\n        aes_key_setup(key, prf_key);\n        pdf_init(&ctx->pdf, prf_key);\n        uhash_init(&ctx->hash, prf_key);\n        explicit_bzero(prf_key, sizeof(prf_key));\n    }\n\n    return (ctx);\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define ALLOC_BOUNDARY       16     /* Keep buffers aligned to this       */"
    ],
    "globals_used": [
      "struct umac_ctx {\n    uhash_ctx hash;          /* Hash function for message compression    */\n    pdf_ctx pdf;             /* PDF for hashed output                    */\n    void *free_ptr;          /* Address to free this struct via          */\n} umac_ctx;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "prf_key",
            "sizeof(prf_key)"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhash_init",
          "args": [
            "&ctx->hash",
            "prf_key"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "uhash_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "957-998",
          "snippet": "static void uhash_init(uhash_ctx_t ahc, aes_int_key prf_key)\n{\n    int i;\n    UINT8 buf[(8*STREAMS+4)*sizeof(UINT64)];\n\n    /* Zero the entire uhash context */\n    memset(ahc, 0, sizeof(uhash_ctx));\n\n    /* Initialize the L1 hash */\n    nh_init(&ahc->hash, prf_key);\n\n    /* Setup L2 hash variables */\n    kdf(buf, prf_key, 2, sizeof(buf));    /* Fill buffer with index 1 key */\n    for (i = 0; i < STREAMS; i++) {\n        /* Fill keys from the buffer, skipping bytes in the buffer not\n         * used by this implementation. Endian reverse the keys if on a\n         * little-endian computer.\n         */\n        memcpy(ahc->poly_key_8+i, buf+24*i, 8);\n        endian_convert_if_le(ahc->poly_key_8+i, 8, 8);\n        /* Mask the 64-bit keys to their special domain */\n        ahc->poly_key_8[i] &= ((UINT64)0x01ffffffu << 32) + 0x01ffffffu;\n        ahc->poly_accum[i] = 1;  /* Our polyhash prepends a non-zero word */\n    }\n\n    /* Setup L3-1 hash variables */\n    kdf(buf, prf_key, 3, sizeof(buf)); /* Fill buffer with index 2 key */\n    for (i = 0; i < STREAMS; i++)\n          memcpy(ahc->ip_keys+4*i, buf+(8*i+4)*sizeof(UINT64),\n                                                 4*sizeof(UINT64));\n    endian_convert_if_le(ahc->ip_keys, sizeof(UINT64),\n                                                  sizeof(ahc->ip_keys));\n    for (i = 0; i < STREAMS*4; i++)\n        ahc->ip_keys[i] %= p36;  /* Bring into Z_p36 */\n\n    /* Setup L3-2 hash variables    */\n    /* Fill buffer with index 4 key */\n    kdf(ahc->ip_trans, prf_key, 4, STREAMS * sizeof(UINT32));\n    endian_convert_if_le(ahc->ip_trans, sizeof(UINT32),\n                         STREAMS * sizeof(UINT32));\n    explicit_bzero(buf, sizeof(buf));\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define p36    ((UINT64)0x0000000FFFFFFFFBull)              /* 2^36 -  5 */",
            "#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define p36    ((UINT64)0x0000000FFFFFFFFBull)              /* 2^36 -  5 */\n#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */\n\nstatic void uhash_init(uhash_ctx_t ahc, aes_int_key prf_key)\n{\n    int i;\n    UINT8 buf[(8*STREAMS+4)*sizeof(UINT64)];\n\n    /* Zero the entire uhash context */\n    memset(ahc, 0, sizeof(uhash_ctx));\n\n    /* Initialize the L1 hash */\n    nh_init(&ahc->hash, prf_key);\n\n    /* Setup L2 hash variables */\n    kdf(buf, prf_key, 2, sizeof(buf));    /* Fill buffer with index 1 key */\n    for (i = 0; i < STREAMS; i++) {\n        /* Fill keys from the buffer, skipping bytes in the buffer not\n         * used by this implementation. Endian reverse the keys if on a\n         * little-endian computer.\n         */\n        memcpy(ahc->poly_key_8+i, buf+24*i, 8);\n        endian_convert_if_le(ahc->poly_key_8+i, 8, 8);\n        /* Mask the 64-bit keys to their special domain */\n        ahc->poly_key_8[i] &= ((UINT64)0x01ffffffu << 32) + 0x01ffffffu;\n        ahc->poly_accum[i] = 1;  /* Our polyhash prepends a non-zero word */\n    }\n\n    /* Setup L3-1 hash variables */\n    kdf(buf, prf_key, 3, sizeof(buf)); /* Fill buffer with index 2 key */\n    for (i = 0; i < STREAMS; i++)\n          memcpy(ahc->ip_keys+4*i, buf+(8*i+4)*sizeof(UINT64),\n                                                 4*sizeof(UINT64));\n    endian_convert_if_le(ahc->ip_keys, sizeof(UINT64),\n                                                  sizeof(ahc->ip_keys));\n    for (i = 0; i < STREAMS*4; i++)\n        ahc->ip_keys[i] %= p36;  /* Bring into Z_p36 */\n\n    /* Setup L3-2 hash variables    */\n    /* Fill buffer with index 4 key */\n    kdf(ahc->ip_trans, prf_key, 4, STREAMS * sizeof(UINT32));\n    endian_convert_if_le(ahc->ip_trans, sizeof(UINT32),\n                         STREAMS * sizeof(UINT32));\n    explicit_bzero(buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdf_init",
          "args": [
            "&ctx->pdf",
            "prf_key"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "pdf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "222-233",
          "snippet": "static void pdf_init(pdf_ctx *pc, aes_int_key prf_key)\n{\n    UINT8 buf[UMAC_KEY_LEN];\n\n    kdf(buf, prf_key, 0, UMAC_KEY_LEN);\n    aes_key_setup(buf, pc->prf_key);\n\n    /* Initialize pdf and cache */\n    memset(pc->nonce, 0, sizeof(pc->nonce));\n    aes_encryption(pc->nonce, pc->cache, pc->prf_key);\n    explicit_bzero(buf, sizeof(buf));\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define UMAC_KEY_LEN           16  /* UMAC takes 16 bytes of external key */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define UMAC_KEY_LEN           16  /* UMAC takes 16 bytes of external key */\n\nstatic void pdf_init(pdf_ctx *pc, aes_int_key prf_key)\n{\n    UINT8 buf[UMAC_KEY_LEN];\n\n    kdf(buf, prf_key, 0, UMAC_KEY_LEN);\n    aes_key_setup(buf, pc->prf_key);\n\n    /* Initialize pdf and cache */\n    memset(pc->nonce, 0, sizeof(pc->nonce));\n    aes_encryption(pc->nonce, pc->cache, pc->prf_key);\n    explicit_bzero(buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "aes_key_setup",
          "args": [
            "key",
            "prf_key"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "1",
            "sizeof(*ctx) + ALLOC_BOUNDARY"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define ALLOC_BOUNDARY       16     /* Keep buffers aligned to this       */\n\nstruct umac_ctx {\n    uhash_ctx hash;          /* Hash function for message compression    */\n    pdf_ctx pdf;             /* PDF for hashed output                    */\n    void *free_ptr;          /* Address to free this struct via          */\n} umac_ctx;\n\nstruct umac_ctx *umac_new(const u_char key[])\n/* Dynamically allocate a umac_ctx struct, initialize variables,\n * generate subkeys from key. Align to 16-byte boundary.\n */\n{\n    struct umac_ctx *ctx, *octx;\n    size_t bytes_to_add;\n    aes_int_key prf_key;\n\n    octx = ctx = xcalloc(1, sizeof(*ctx) + ALLOC_BOUNDARY);\n    if (ctx) {\n        if (ALLOC_BOUNDARY) {\n            bytes_to_add = ALLOC_BOUNDARY -\n                              ((ptrdiff_t)ctx & (ALLOC_BOUNDARY - 1));\n            ctx = (struct umac_ctx *)((u_char *)ctx + bytes_to_add);\n        }\n        ctx->free_ptr = octx;\n        aes_key_setup(key, prf_key);\n        pdf_init(&ctx->pdf, prf_key);\n        uhash_init(&ctx->hash, prf_key);\n        explicit_bzero(prf_key, sizeof(prf_key));\n    }\n\n    return (ctx);\n}"
  },
  {
    "function_name": "umac_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "1201-1211",
    "snippet": "int umac_delete(struct umac_ctx *ctx)\n/* Deallocate the ctx structure */\n{\n    if (ctx) {\n        if (ALLOC_BOUNDARY)\n            ctx = (struct umac_ctx *)ctx->free_ptr;\n        explicit_bzero(ctx, sizeof(*ctx) + ALLOC_BOUNDARY);\n        free(ctx);\n    }\n    return (1);\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define ALLOC_BOUNDARY       16     /* Keep buffers aligned to this       */"
    ],
    "globals_used": [
      "struct umac_ctx {\n    uhash_ctx hash;          /* Hash function for message compression    */\n    pdf_ctx pdf;             /* PDF for hashed output                    */\n    void *free_ptr;          /* Address to free this struct via          */\n} umac_ctx;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ctx"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "uhash_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "1028-1041",
          "snippet": "static int uhash_free(uhash_ctx_t ctx)\n{\n/* Free memory allocated by uhash_alloc */\n    u_char bytes_to_sub;\n\n    if (ctx) {\n        if (ALLOC_BOUNDARY) {\n            bytes_to_sub = *((u_char *)ctx - 1);\n            ctx = (uhash_ctx_t)((u_char *)ctx - bytes_to_sub);\n        }\n        free(ctx);\n    }\n    return (1);\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define ALLOC_BOUNDARY       16     /* Keep buffers aligned to this       */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define ALLOC_BOUNDARY       16     /* Keep buffers aligned to this       */\n\nstatic int uhash_free(uhash_ctx_t ctx)\n{\n/* Free memory allocated by uhash_alloc */\n    u_char bytes_to_sub;\n\n    if (ctx) {\n        if (ALLOC_BOUNDARY) {\n            bytes_to_sub = *((u_char *)ctx - 1);\n            ctx = (uhash_ctx_t)((u_char *)ctx - bytes_to_sub);\n        }\n        free(ctx);\n    }\n    return (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "ctx",
            "sizeof(*ctx) + ALLOC_BOUNDARY"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define ALLOC_BOUNDARY       16     /* Keep buffers aligned to this       */\n\nstruct umac_ctx {\n    uhash_ctx hash;          /* Hash function for message compression    */\n    pdf_ctx pdf;             /* PDF for hashed output                    */\n    void *free_ptr;          /* Address to free this struct via          */\n} umac_ctx;\n\nint umac_delete(struct umac_ctx *ctx)\n/* Deallocate the ctx structure */\n{\n    if (ctx) {\n        if (ALLOC_BOUNDARY)\n            ctx = (struct umac_ctx *)ctx->free_ptr;\n        explicit_bzero(ctx, sizeof(*ctx) + ALLOC_BOUNDARY);\n        free(ctx);\n    }\n    return (1);\n}"
  },
  {
    "function_name": "umac_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "1191-1196",
    "snippet": "int umac_reset(struct umac_ctx *ctx)\n/* Reset the hash function to begin a new authentication.        */\n{\n    uhash_reset(&ctx->hash);\n    return (1);\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct umac_ctx {\n    uhash_ctx hash;          /* Hash function for message compression    */\n    pdf_ctx pdf;             /* PDF for hashed output                    */\n    void *free_ptr;          /* Address to free this struct via          */\n} umac_ctx;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhash_reset",
          "args": [
            "&ctx->hash"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "uhash_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "933-948",
          "snippet": "static int uhash_reset(uhash_ctx_t pc)\n{\n    nh_reset(&pc->hash);\n    pc->msg_len = 0;\n    pc->poly_accum[0] = 1;\n#if (UMAC_OUTPUT_LEN >= 8)\n    pc->poly_accum[1] = 1;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    pc->poly_accum[2] = 1;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    pc->poly_accum[3] = 1;\n#endif\n    return 1;\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */\n\nstatic int uhash_reset(uhash_ctx_t pc)\n{\n    nh_reset(&pc->hash);\n    pc->msg_len = 0;\n    pc->poly_accum[0] = 1;\n#if (UMAC_OUTPUT_LEN >= 8)\n    pc->poly_accum[1] = 1;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    pc->poly_accum[2] = 1;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    pc->poly_accum[3] = 1;\n#endif\n    return 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct umac_ctx {\n    uhash_ctx hash;          /* Hash function for message compression    */\n    pdf_ctx pdf;             /* PDF for hashed output                    */\n    void *free_ptr;          /* Address to free this struct via          */\n} umac_ctx;\n\nint umac_reset(struct umac_ctx *ctx)\n/* Reset the hash function to begin a new authentication.        */\n{\n    uhash_reset(&ctx->hash);\n    return (1);\n}"
  },
  {
    "function_name": "uhash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "1124-1167",
    "snippet": "static int uhash(uhash_ctx_t ahc, u_char *msg, long len, u_char *res)\n/* assumes that msg is in a writable buffer of length divisible by */\n/* L1_PAD_BOUNDARY. Bytes beyond msg[len] may be zeroed.           */\n{\n    UINT8 nh_result[STREAMS*sizeof(UINT64)];\n    UINT32 nh_len;\n    int extra_zeroes_needed;\n\n    /* If the message to be hashed is no longer than L1_HASH_LEN, we skip\n     * the polyhash.\n     */\n    if (len <= L1_KEY_LEN) {\n\tif (len == 0)                  /* If zero length messages will not */\n\t\tnh_len = L1_PAD_BOUNDARY;  /* be seen, comment out this case   */\n\telse\n\t\tnh_len = ((len + (L1_PAD_BOUNDARY - 1)) & ~(L1_PAD_BOUNDARY - 1));\n        extra_zeroes_needed = nh_len - len;\n        zero_pad((UINT8 *)msg + len, extra_zeroes_needed);\n        nh(&ahc->hash, (UINT8 *)msg, nh_len, len, nh_result);\n        ip_short(ahc,nh_result, res);\n    } else {\n        /* Otherwise, we hash each L1_KEY_LEN chunk with NH, passing the NH\n         * output to poly_hash().\n         */\n        do {\n            nh(&ahc->hash, (UINT8 *)msg, L1_KEY_LEN, L1_KEY_LEN, nh_result);\n            poly_hash(ahc,(UINT32 *)nh_result);\n            len -= L1_KEY_LEN;\n            msg += L1_KEY_LEN;\n        } while (len >= L1_KEY_LEN);\n        if (len) {\n            nh_len = ((len + (L1_PAD_BOUNDARY - 1)) & ~(L1_PAD_BOUNDARY - 1));\n            extra_zeroes_needed = nh_len - len;\n            zero_pad((UINT8 *)msg + len, extra_zeroes_needed);\n            nh(&ahc->hash, (UINT8 *)msg, nh_len, len, nh_result);\n            poly_hash(ahc,(UINT32 *)nh_result);\n        }\n\n        ip_long(ahc, res);\n    }\n\n    uhash_reset(ahc);\n    return 1;\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define L1_PAD_BOUNDARY      32     /* pad message to boundary multiple   */",
      "#define L1_KEY_LEN         1024     /* Internal key bytes                 */",
      "#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhash_reset",
          "args": [
            "ahc"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "uhash_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "933-948",
          "snippet": "static int uhash_reset(uhash_ctx_t pc)\n{\n    nh_reset(&pc->hash);\n    pc->msg_len = 0;\n    pc->poly_accum[0] = 1;\n#if (UMAC_OUTPUT_LEN >= 8)\n    pc->poly_accum[1] = 1;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    pc->poly_accum[2] = 1;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    pc->poly_accum[3] = 1;\n#endif\n    return 1;\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */\n\nstatic int uhash_reset(uhash_ctx_t pc)\n{\n    nh_reset(&pc->hash);\n    pc->msg_len = 0;\n    pc->poly_accum[0] = 1;\n#if (UMAC_OUTPUT_LEN >= 8)\n    pc->poly_accum[1] = 1;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    pc->poly_accum[2] = 1;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    pc->poly_accum[3] = 1;\n#endif\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ip_long",
          "args": [
            "ahc",
            "res"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "ip_long",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "912-925",
          "snippet": "static void ip_long(uhash_ctx_t ahc, u_char *res)\n{\n    int i;\n    UINT64 t;\n\n    for (i = 0; i < STREAMS; i++) {\n        /* fix polyhash output not in Z_p64 */\n        if (ahc->poly_accum[i] >= p64)\n            ahc->poly_accum[i] -= p64;\n        t  = ip_aux(0,ahc->ip_keys+(i*4), ahc->poly_accum[i]);\n        STORE_UINT32_BIG((UINT32 *)res+i,\n                         ip_reduce_p36(t) ^ ahc->ip_trans[i]);\n    }\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define p64    ((UINT64)0xFFFFFFFFFFFFFFC5ull)              /* 2^64 - 59 */",
            "#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define p64    ((UINT64)0xFFFFFFFFFFFFFFC5ull)              /* 2^64 - 59 */\n#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */\n\nstatic void ip_long(uhash_ctx_t ahc, u_char *res)\n{\n    int i;\n    UINT64 t;\n\n    for (i = 0; i < STREAMS; i++) {\n        /* fix polyhash output not in Z_p64 */\n        if (ahc->poly_accum[i] >= p64)\n            ahc->poly_accum[i] -= p64;\n        t  = ip_aux(0,ahc->ip_keys+(i*4), ahc->poly_accum[i]);\n        STORE_UINT32_BIG((UINT32 *)res+i,\n                         ip_reduce_p36(t) ^ ahc->ip_trans[i]);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "poly_hash",
          "args": [
            "ahc",
            "(UINT32 *)nh_result"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "poly_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "831-847",
          "snippet": "static void poly_hash(uhash_ctx_t hc, UINT32 data_in[])\n{\n    int i;\n    UINT64 *data=(UINT64*)data_in;\n\n    for (i = 0; i < STREAMS; i++) {\n        if ((UINT32)(data[i] >> 32) == 0xfffffffful) {\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], p64 - 1);\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], (data[i] - 59));\n        } else {\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], data[i]);\n        }\n    }\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define p64    ((UINT64)0xFFFFFFFFFFFFFFC5ull)              /* 2^64 - 59 */",
            "#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define p64    ((UINT64)0xFFFFFFFFFFFFFFC5ull)              /* 2^64 - 59 */\n#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */\n\nstatic void poly_hash(uhash_ctx_t hc, UINT32 data_in[])\n{\n    int i;\n    UINT64 *data=(UINT64*)data_in;\n\n    for (i = 0; i < STREAMS; i++) {\n        if ((UINT32)(data[i] >> 32) == 0xfffffffful) {\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], p64 - 1);\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], (data[i] - 59));\n        } else {\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], data[i]);\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "nh",
          "args": [
            "&ahc->hash",
            "(UINT8 *)msg",
            "nh_len",
            "len",
            "nh_result"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "nh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "706-730",
          "snippet": "static void nh(nh_ctx *hc, const UINT8 *buf, UINT32 padded_len,\n               UINT32 unpadded_len, UINT8 *result)\n/* All-in-one nh_update() and nh_final() equivalent.\n * Assumes that padded_len is divisible by L1_PAD_BOUNDARY and result is\n * well aligned\n */\n{\n    UINT32 nbits;\n\n    /* Initialize the hash state */\n    nbits = (unpadded_len << 3);\n\n    ((UINT64 *)result)[0] = nbits;\n#if (UMAC_OUTPUT_LEN >= 8)\n    ((UINT64 *)result)[1] = nbits;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    ((UINT64 *)result)[2] = nbits;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    ((UINT64 *)result)[3] = nbits;\n#endif\n\n    nh_aux(hc->nh_key, buf, result, padded_len);\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define L1_PAD_BOUNDARY      32     /* pad message to boundary multiple   */",
            "#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define L1_PAD_BOUNDARY      32     /* pad message to boundary multiple   */\n#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */\n\nstatic void nh(nh_ctx *hc, const UINT8 *buf, UINT32 padded_len,\n               UINT32 unpadded_len, UINT8 *result)\n/* All-in-one nh_update() and nh_final() equivalent.\n * Assumes that padded_len is divisible by L1_PAD_BOUNDARY and result is\n * well aligned\n */\n{\n    UINT32 nbits;\n\n    /* Initialize the hash state */\n    nbits = (unpadded_len << 3);\n\n    ((UINT64 *)result)[0] = nbits;\n#if (UMAC_OUTPUT_LEN >= 8)\n    ((UINT64 *)result)[1] = nbits;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    ((UINT64 *)result)[2] = nbits;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    ((UINT64 *)result)[3] = nbits;\n#endif\n\n    nh_aux(hc->nh_key, buf, result, padded_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_pad",
          "args": [
            "(UINT8 *)msg + len",
            "extra_zeroes_needed"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "zero_pad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "642-662",
          "snippet": "static void zero_pad(UINT8 *p, int nbytes)\n{\n/* Write \"nbytes\" of zeroes, beginning at \"p\" */\n    if (nbytes >= (int)sizeof(UWORD)) {\n        while ((ptrdiff_t)p % sizeof(UWORD)) {\n            *p = 0;\n            nbytes--;\n            p++;\n        }\n        while (nbytes >= (int)sizeof(UWORD)) {\n            *(UWORD *)p = 0;\n            nbytes -= sizeof(UWORD);\n            p += sizeof(UWORD);\n        }\n    }\n    while (nbytes) {\n        *p = 0;\n        nbytes--;\n        p++;\n    }\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void zero_pad(UINT8 *p, int nbytes)\n{\n/* Write \"nbytes\" of zeroes, beginning at \"p\" */\n    if (nbytes >= (int)sizeof(UWORD)) {\n        while ((ptrdiff_t)p % sizeof(UWORD)) {\n            *p = 0;\n            nbytes--;\n            p++;\n        }\n        while (nbytes >= (int)sizeof(UWORD)) {\n            *(UWORD *)p = 0;\n            nbytes -= sizeof(UWORD);\n            p += sizeof(UWORD);\n        }\n    }\n    while (nbytes) {\n        *p = 0;\n        nbytes--;\n        p++;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ip_short",
          "args": [
            "ahc",
            "nh_result",
            "res"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "ip_short",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "887-906",
          "snippet": "static void ip_short(uhash_ctx_t ahc, UINT8 *nh_res, u_char *res)\n{\n    UINT64 t;\n    UINT64 *nhp = (UINT64 *)nh_res;\n\n    t  = ip_aux(0,ahc->ip_keys, nhp[0]);\n    STORE_UINT32_BIG((UINT32 *)res+0, ip_reduce_p36(t) ^ ahc->ip_trans[0]);\n#if (UMAC_OUTPUT_LEN >= 8)\n    t  = ip_aux(0,ahc->ip_keys+4, nhp[1]);\n    STORE_UINT32_BIG((UINT32 *)res+1, ip_reduce_p36(t) ^ ahc->ip_trans[1]);\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    t  = ip_aux(0,ahc->ip_keys+8, nhp[2]);\n    STORE_UINT32_BIG((UINT32 *)res+2, ip_reduce_p36(t) ^ ahc->ip_trans[2]);\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    t  = ip_aux(0,ahc->ip_keys+12, nhp[3]);\n    STORE_UINT32_BIG((UINT32 *)res+3, ip_reduce_p36(t) ^ ahc->ip_trans[3]);\n#endif\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */\n\nstatic void ip_short(uhash_ctx_t ahc, UINT8 *nh_res, u_char *res)\n{\n    UINT64 t;\n    UINT64 *nhp = (UINT64 *)nh_res;\n\n    t  = ip_aux(0,ahc->ip_keys, nhp[0]);\n    STORE_UINT32_BIG((UINT32 *)res+0, ip_reduce_p36(t) ^ ahc->ip_trans[0]);\n#if (UMAC_OUTPUT_LEN >= 8)\n    t  = ip_aux(0,ahc->ip_keys+4, nhp[1]);\n    STORE_UINT32_BIG((UINT32 *)res+1, ip_reduce_p36(t) ^ ahc->ip_trans[1]);\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    t  = ip_aux(0,ahc->ip_keys+8, nhp[2]);\n    STORE_UINT32_BIG((UINT32 *)res+2, ip_reduce_p36(t) ^ ahc->ip_trans[2]);\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    t  = ip_aux(0,ahc->ip_keys+12, nhp[3]);\n    STORE_UINT32_BIG((UINT32 *)res+3, ip_reduce_p36(t) ^ ahc->ip_trans[3]);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define L1_PAD_BOUNDARY      32     /* pad message to boundary multiple   */\n#define L1_KEY_LEN         1024     /* Internal key bytes                 */\n#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */\n\nstatic int uhash(uhash_ctx_t ahc, u_char *msg, long len, u_char *res)\n/* assumes that msg is in a writable buffer of length divisible by */\n/* L1_PAD_BOUNDARY. Bytes beyond msg[len] may be zeroed.           */\n{\n    UINT8 nh_result[STREAMS*sizeof(UINT64)];\n    UINT32 nh_len;\n    int extra_zeroes_needed;\n\n    /* If the message to be hashed is no longer than L1_HASH_LEN, we skip\n     * the polyhash.\n     */\n    if (len <= L1_KEY_LEN) {\n\tif (len == 0)                  /* If zero length messages will not */\n\t\tnh_len = L1_PAD_BOUNDARY;  /* be seen, comment out this case   */\n\telse\n\t\tnh_len = ((len + (L1_PAD_BOUNDARY - 1)) & ~(L1_PAD_BOUNDARY - 1));\n        extra_zeroes_needed = nh_len - len;\n        zero_pad((UINT8 *)msg + len, extra_zeroes_needed);\n        nh(&ahc->hash, (UINT8 *)msg, nh_len, len, nh_result);\n        ip_short(ahc,nh_result, res);\n    } else {\n        /* Otherwise, we hash each L1_KEY_LEN chunk with NH, passing the NH\n         * output to poly_hash().\n         */\n        do {\n            nh(&ahc->hash, (UINT8 *)msg, L1_KEY_LEN, L1_KEY_LEN, nh_result);\n            poly_hash(ahc,(UINT32 *)nh_result);\n            len -= L1_KEY_LEN;\n            msg += L1_KEY_LEN;\n        } while (len >= L1_KEY_LEN);\n        if (len) {\n            nh_len = ((len + (L1_PAD_BOUNDARY - 1)) & ~(L1_PAD_BOUNDARY - 1));\n            extra_zeroes_needed = nh_len - len;\n            zero_pad((UINT8 *)msg + len, extra_zeroes_needed);\n            nh(&ahc->hash, (UINT8 *)msg, nh_len, len, nh_result);\n            poly_hash(ahc,(UINT32 *)nh_result);\n        }\n\n        ip_long(ahc, res);\n    }\n\n    uhash_reset(ahc);\n    return 1;\n}"
  },
  {
    "function_name": "uhash_final",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "1101-1119",
    "snippet": "static int uhash_final(uhash_ctx_t ctx, u_char *res)\n/* Incorporate any pending data, pad, and generate tag */\n{\n    UINT64 result_buf[STREAMS];\n    UINT8 *nh_result = (UINT8 *)&result_buf;\n\n    if (ctx->msg_len > L1_KEY_LEN) {\n        if (ctx->msg_len % L1_KEY_LEN) {\n            nh_final(&ctx->hash, nh_result);\n            poly_hash(ctx,(UINT32 *)nh_result);\n        }\n        ip_long(ctx, res);\n    } else {\n        nh_final(&ctx->hash, nh_result);\n        ip_short(ctx,nh_result, res);\n    }\n    uhash_reset(ctx);\n    return (1);\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define L1_KEY_LEN         1024     /* Internal key bytes                 */",
      "#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhash_reset",
          "args": [
            "ctx"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "uhash_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "933-948",
          "snippet": "static int uhash_reset(uhash_ctx_t pc)\n{\n    nh_reset(&pc->hash);\n    pc->msg_len = 0;\n    pc->poly_accum[0] = 1;\n#if (UMAC_OUTPUT_LEN >= 8)\n    pc->poly_accum[1] = 1;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    pc->poly_accum[2] = 1;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    pc->poly_accum[3] = 1;\n#endif\n    return 1;\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */\n\nstatic int uhash_reset(uhash_ctx_t pc)\n{\n    nh_reset(&pc->hash);\n    pc->msg_len = 0;\n    pc->poly_accum[0] = 1;\n#if (UMAC_OUTPUT_LEN >= 8)\n    pc->poly_accum[1] = 1;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    pc->poly_accum[2] = 1;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    pc->poly_accum[3] = 1;\n#endif\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ip_short",
          "args": [
            "ctx",
            "nh_result",
            "res"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "ip_short",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "887-906",
          "snippet": "static void ip_short(uhash_ctx_t ahc, UINT8 *nh_res, u_char *res)\n{\n    UINT64 t;\n    UINT64 *nhp = (UINT64 *)nh_res;\n\n    t  = ip_aux(0,ahc->ip_keys, nhp[0]);\n    STORE_UINT32_BIG((UINT32 *)res+0, ip_reduce_p36(t) ^ ahc->ip_trans[0]);\n#if (UMAC_OUTPUT_LEN >= 8)\n    t  = ip_aux(0,ahc->ip_keys+4, nhp[1]);\n    STORE_UINT32_BIG((UINT32 *)res+1, ip_reduce_p36(t) ^ ahc->ip_trans[1]);\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    t  = ip_aux(0,ahc->ip_keys+8, nhp[2]);\n    STORE_UINT32_BIG((UINT32 *)res+2, ip_reduce_p36(t) ^ ahc->ip_trans[2]);\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    t  = ip_aux(0,ahc->ip_keys+12, nhp[3]);\n    STORE_UINT32_BIG((UINT32 *)res+3, ip_reduce_p36(t) ^ ahc->ip_trans[3]);\n#endif\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */\n\nstatic void ip_short(uhash_ctx_t ahc, UINT8 *nh_res, u_char *res)\n{\n    UINT64 t;\n    UINT64 *nhp = (UINT64 *)nh_res;\n\n    t  = ip_aux(0,ahc->ip_keys, nhp[0]);\n    STORE_UINT32_BIG((UINT32 *)res+0, ip_reduce_p36(t) ^ ahc->ip_trans[0]);\n#if (UMAC_OUTPUT_LEN >= 8)\n    t  = ip_aux(0,ahc->ip_keys+4, nhp[1]);\n    STORE_UINT32_BIG((UINT32 *)res+1, ip_reduce_p36(t) ^ ahc->ip_trans[1]);\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    t  = ip_aux(0,ahc->ip_keys+8, nhp[2]);\n    STORE_UINT32_BIG((UINT32 *)res+2, ip_reduce_p36(t) ^ ahc->ip_trans[2]);\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    t  = ip_aux(0,ahc->ip_keys+12, nhp[3]);\n    STORE_UINT32_BIG((UINT32 *)res+3, ip_reduce_p36(t) ^ ahc->ip_trans[3]);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "nh_final",
          "args": [
            "&ctx->hash",
            "nh_result"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "nh_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "666-702",
          "snippet": "static void nh_final(nh_ctx *hc, UINT8 *result)\n/* After passing some number of data buffers to nh_update() for integration\n * into an NH context, nh_final is called to produce a hash result. If any\n * bytes are in the buffer hc->data, incorporate them into the\n * NH context. Finally, add into the NH accumulation \"state\" the total number\n * of bits hashed. The resulting numbers are written to the buffer \"result\".\n * If nh_update was never called, L1_PAD_BOUNDARY zeroes are incorporated.\n */\n{\n    int nh_len, nbits;\n\n    if (hc->next_data_empty != 0) {\n        nh_len = ((hc->next_data_empty + (L1_PAD_BOUNDARY - 1)) &\n                                                ~(L1_PAD_BOUNDARY - 1));\n        zero_pad(hc->data + hc->next_data_empty,\n                                          nh_len - hc->next_data_empty);\n        nh_transform(hc, hc->data, nh_len);\n        hc->bytes_hashed += hc->next_data_empty;\n    } else if (hc->bytes_hashed == 0) {\n\tnh_len = L1_PAD_BOUNDARY;\n        zero_pad(hc->data, L1_PAD_BOUNDARY);\n        nh_transform(hc, hc->data, nh_len);\n    }\n\n    nbits = (hc->bytes_hashed << 3);\n    ((UINT64 *)result)[0] = ((UINT64 *)hc->state)[0] + nbits;\n#if (UMAC_OUTPUT_LEN >= 8)\n    ((UINT64 *)result)[1] = ((UINT64 *)hc->state)[1] + nbits;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    ((UINT64 *)result)[2] = ((UINT64 *)hc->state)[2] + nbits;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    ((UINT64 *)result)[3] = ((UINT64 *)hc->state)[3] + nbits;\n#endif\n    nh_reset(hc);\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define L1_PAD_BOUNDARY      32     /* pad message to boundary multiple   */",
            "#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define L1_PAD_BOUNDARY      32     /* pad message to boundary multiple   */\n#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */\n\nstatic void nh_final(nh_ctx *hc, UINT8 *result)\n/* After passing some number of data buffers to nh_update() for integration\n * into an NH context, nh_final is called to produce a hash result. If any\n * bytes are in the buffer hc->data, incorporate them into the\n * NH context. Finally, add into the NH accumulation \"state\" the total number\n * of bits hashed. The resulting numbers are written to the buffer \"result\".\n * If nh_update was never called, L1_PAD_BOUNDARY zeroes are incorporated.\n */\n{\n    int nh_len, nbits;\n\n    if (hc->next_data_empty != 0) {\n        nh_len = ((hc->next_data_empty + (L1_PAD_BOUNDARY - 1)) &\n                                                ~(L1_PAD_BOUNDARY - 1));\n        zero_pad(hc->data + hc->next_data_empty,\n                                          nh_len - hc->next_data_empty);\n        nh_transform(hc, hc->data, nh_len);\n        hc->bytes_hashed += hc->next_data_empty;\n    } else if (hc->bytes_hashed == 0) {\n\tnh_len = L1_PAD_BOUNDARY;\n        zero_pad(hc->data, L1_PAD_BOUNDARY);\n        nh_transform(hc, hc->data, nh_len);\n    }\n\n    nbits = (hc->bytes_hashed << 3);\n    ((UINT64 *)result)[0] = ((UINT64 *)hc->state)[0] + nbits;\n#if (UMAC_OUTPUT_LEN >= 8)\n    ((UINT64 *)result)[1] = ((UINT64 *)hc->state)[1] + nbits;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    ((UINT64 *)result)[2] = ((UINT64 *)hc->state)[2] + nbits;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    ((UINT64 *)result)[3] = ((UINT64 *)hc->state)[3] + nbits;\n#endif\n    nh_reset(hc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ip_long",
          "args": [
            "ctx",
            "res"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "ip_long",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "912-925",
          "snippet": "static void ip_long(uhash_ctx_t ahc, u_char *res)\n{\n    int i;\n    UINT64 t;\n\n    for (i = 0; i < STREAMS; i++) {\n        /* fix polyhash output not in Z_p64 */\n        if (ahc->poly_accum[i] >= p64)\n            ahc->poly_accum[i] -= p64;\n        t  = ip_aux(0,ahc->ip_keys+(i*4), ahc->poly_accum[i]);\n        STORE_UINT32_BIG((UINT32 *)res+i,\n                         ip_reduce_p36(t) ^ ahc->ip_trans[i]);\n    }\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define p64    ((UINT64)0xFFFFFFFFFFFFFFC5ull)              /* 2^64 - 59 */",
            "#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define p64    ((UINT64)0xFFFFFFFFFFFFFFC5ull)              /* 2^64 - 59 */\n#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */\n\nstatic void ip_long(uhash_ctx_t ahc, u_char *res)\n{\n    int i;\n    UINT64 t;\n\n    for (i = 0; i < STREAMS; i++) {\n        /* fix polyhash output not in Z_p64 */\n        if (ahc->poly_accum[i] >= p64)\n            ahc->poly_accum[i] -= p64;\n        t  = ip_aux(0,ahc->ip_keys+(i*4), ahc->poly_accum[i]);\n        STORE_UINT32_BIG((UINT32 *)res+i,\n                         ip_reduce_p36(t) ^ ahc->ip_trans[i]);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "poly_hash",
          "args": [
            "ctx",
            "(UINT32 *)nh_result"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "poly_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "831-847",
          "snippet": "static void poly_hash(uhash_ctx_t hc, UINT32 data_in[])\n{\n    int i;\n    UINT64 *data=(UINT64*)data_in;\n\n    for (i = 0; i < STREAMS; i++) {\n        if ((UINT32)(data[i] >> 32) == 0xfffffffful) {\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], p64 - 1);\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], (data[i] - 59));\n        } else {\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], data[i]);\n        }\n    }\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define p64    ((UINT64)0xFFFFFFFFFFFFFFC5ull)              /* 2^64 - 59 */",
            "#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define p64    ((UINT64)0xFFFFFFFFFFFFFFC5ull)              /* 2^64 - 59 */\n#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */\n\nstatic void poly_hash(uhash_ctx_t hc, UINT32 data_in[])\n{\n    int i;\n    UINT64 *data=(UINT64*)data_in;\n\n    for (i = 0; i < STREAMS; i++) {\n        if ((UINT32)(data[i] >> 32) == 0xfffffffful) {\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], p64 - 1);\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], (data[i] - 59));\n        } else {\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], data[i]);\n        }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define L1_KEY_LEN         1024     /* Internal key bytes                 */\n#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */\n\nstatic int uhash_final(uhash_ctx_t ctx, u_char *res)\n/* Incorporate any pending data, pad, and generate tag */\n{\n    UINT64 result_buf[STREAMS];\n    UINT8 *nh_result = (UINT8 *)&result_buf;\n\n    if (ctx->msg_len > L1_KEY_LEN) {\n        if (ctx->msg_len % L1_KEY_LEN) {\n            nh_final(&ctx->hash, nh_result);\n            poly_hash(ctx,(UINT32 *)nh_result);\n        }\n        ip_long(ctx, res);\n    } else {\n        nh_final(&ctx->hash, nh_result);\n        ip_short(ctx,nh_result, res);\n    }\n    uhash_reset(ctx);\n    return (1);\n}"
  },
  {
    "function_name": "uhash_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "1045-1097",
    "snippet": "static int uhash_update(uhash_ctx_t ctx, const u_char *input, long len)\n/* Given len bytes of data, we parse it into L1_KEY_LEN chunks and\n * hash each one with NH, calling the polyhash on each NH output.\n */\n{\n    UWORD bytes_hashed, bytes_remaining;\n    UINT64 result_buf[STREAMS];\n    UINT8 *nh_result = (UINT8 *)&result_buf;\n\n    if (ctx->msg_len + len <= L1_KEY_LEN) {\n        nh_update(&ctx->hash, (const UINT8 *)input, len);\n        ctx->msg_len += len;\n    } else {\n\n         bytes_hashed = ctx->msg_len % L1_KEY_LEN;\n         if (ctx->msg_len == L1_KEY_LEN)\n             bytes_hashed = L1_KEY_LEN;\n\n         if (bytes_hashed + len >= L1_KEY_LEN) {\n\n             /* If some bytes have been passed to the hash function      */\n             /* then we want to pass at most (L1_KEY_LEN - bytes_hashed) */\n             /* bytes to complete the current nh_block.                  */\n             if (bytes_hashed) {\n                 bytes_remaining = (L1_KEY_LEN - bytes_hashed);\n                 nh_update(&ctx->hash, (const UINT8 *)input, bytes_remaining);\n                 nh_final(&ctx->hash, nh_result);\n                 ctx->msg_len += bytes_remaining;\n                 poly_hash(ctx,(UINT32 *)nh_result);\n                 len -= bytes_remaining;\n                 input += bytes_remaining;\n             }\n\n             /* Hash directly from input stream if enough bytes */\n             while (len >= L1_KEY_LEN) {\n                 nh(&ctx->hash, (const UINT8 *)input, L1_KEY_LEN,\n                                   L1_KEY_LEN, nh_result);\n                 ctx->msg_len += L1_KEY_LEN;\n                 len -= L1_KEY_LEN;\n                 input += L1_KEY_LEN;\n                 poly_hash(ctx,(UINT32 *)nh_result);\n             }\n         }\n\n         /* pass remaining < L1_KEY_LEN bytes of input data to NH */\n         if (len) {\n             nh_update(&ctx->hash, (const UINT8 *)input, len);\n             ctx->msg_len += len;\n         }\n     }\n\n    return (1);\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define L1_KEY_LEN         1024     /* Internal key bytes                 */",
      "#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nh_update",
          "args": [
            "&ctx->hash",
            "(const UINT8 *)input",
            "len"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "nh_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "611-638",
          "snippet": "static void nh_update(nh_ctx *hc, const UINT8 *buf, UINT32 nbytes)\n/* Incorporate nbytes of data into a nh_ctx, buffer whatever is not an    */\n/* even multiple of HASH_BUF_BYTES.                                       */\n{\n    UINT32 i,j;\n\n    j = hc->next_data_empty;\n    if ((j + nbytes) >= HASH_BUF_BYTES) {\n        if (j) {\n            i = HASH_BUF_BYTES - j;\n            memcpy(hc->data+j, buf, i);\n            nh_transform(hc,hc->data,HASH_BUF_BYTES);\n            nbytes -= i;\n            buf += i;\n            hc->bytes_hashed += HASH_BUF_BYTES;\n        }\n        if (nbytes >= HASH_BUF_BYTES) {\n            i = nbytes & ~(HASH_BUF_BYTES - 1);\n            nh_transform(hc, buf, i);\n            nbytes -= i;\n            buf += i;\n            hc->bytes_hashed += i;\n        }\n        j = 0;\n    }\n    memcpy(hc->data + j, buf, nbytes);\n    hc->next_data_empty = j + nbytes;\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define HASH_BUF_BYTES       64     /* nh_aux_hb buffer multiple          */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define HASH_BUF_BYTES       64     /* nh_aux_hb buffer multiple          */\n\nstatic void nh_update(nh_ctx *hc, const UINT8 *buf, UINT32 nbytes)\n/* Incorporate nbytes of data into a nh_ctx, buffer whatever is not an    */\n/* even multiple of HASH_BUF_BYTES.                                       */\n{\n    UINT32 i,j;\n\n    j = hc->next_data_empty;\n    if ((j + nbytes) >= HASH_BUF_BYTES) {\n        if (j) {\n            i = HASH_BUF_BYTES - j;\n            memcpy(hc->data+j, buf, i);\n            nh_transform(hc,hc->data,HASH_BUF_BYTES);\n            nbytes -= i;\n            buf += i;\n            hc->bytes_hashed += HASH_BUF_BYTES;\n        }\n        if (nbytes >= HASH_BUF_BYTES) {\n            i = nbytes & ~(HASH_BUF_BYTES - 1);\n            nh_transform(hc, buf, i);\n            nbytes -= i;\n            buf += i;\n            hc->bytes_hashed += i;\n        }\n        j = 0;\n    }\n    memcpy(hc->data + j, buf, nbytes);\n    hc->next_data_empty = j + nbytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "poly_hash",
          "args": [
            "ctx",
            "(UINT32 *)nh_result"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "poly_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "831-847",
          "snippet": "static void poly_hash(uhash_ctx_t hc, UINT32 data_in[])\n{\n    int i;\n    UINT64 *data=(UINT64*)data_in;\n\n    for (i = 0; i < STREAMS; i++) {\n        if ((UINT32)(data[i] >> 32) == 0xfffffffful) {\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], p64 - 1);\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], (data[i] - 59));\n        } else {\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], data[i]);\n        }\n    }\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define p64    ((UINT64)0xFFFFFFFFFFFFFFC5ull)              /* 2^64 - 59 */",
            "#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define p64    ((UINT64)0xFFFFFFFFFFFFFFC5ull)              /* 2^64 - 59 */\n#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */\n\nstatic void poly_hash(uhash_ctx_t hc, UINT32 data_in[])\n{\n    int i;\n    UINT64 *data=(UINT64*)data_in;\n\n    for (i = 0; i < STREAMS; i++) {\n        if ((UINT32)(data[i] >> 32) == 0xfffffffful) {\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], p64 - 1);\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], (data[i] - 59));\n        } else {\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], data[i]);\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "nh",
          "args": [
            "&ctx->hash",
            "(const UINT8 *)input",
            "L1_KEY_LEN",
            "L1_KEY_LEN",
            "nh_result"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "nh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "706-730",
          "snippet": "static void nh(nh_ctx *hc, const UINT8 *buf, UINT32 padded_len,\n               UINT32 unpadded_len, UINT8 *result)\n/* All-in-one nh_update() and nh_final() equivalent.\n * Assumes that padded_len is divisible by L1_PAD_BOUNDARY and result is\n * well aligned\n */\n{\n    UINT32 nbits;\n\n    /* Initialize the hash state */\n    nbits = (unpadded_len << 3);\n\n    ((UINT64 *)result)[0] = nbits;\n#if (UMAC_OUTPUT_LEN >= 8)\n    ((UINT64 *)result)[1] = nbits;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    ((UINT64 *)result)[2] = nbits;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    ((UINT64 *)result)[3] = nbits;\n#endif\n\n    nh_aux(hc->nh_key, buf, result, padded_len);\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define L1_PAD_BOUNDARY      32     /* pad message to boundary multiple   */",
            "#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define L1_PAD_BOUNDARY      32     /* pad message to boundary multiple   */\n#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */\n\nstatic void nh(nh_ctx *hc, const UINT8 *buf, UINT32 padded_len,\n               UINT32 unpadded_len, UINT8 *result)\n/* All-in-one nh_update() and nh_final() equivalent.\n * Assumes that padded_len is divisible by L1_PAD_BOUNDARY and result is\n * well aligned\n */\n{\n    UINT32 nbits;\n\n    /* Initialize the hash state */\n    nbits = (unpadded_len << 3);\n\n    ((UINT64 *)result)[0] = nbits;\n#if (UMAC_OUTPUT_LEN >= 8)\n    ((UINT64 *)result)[1] = nbits;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    ((UINT64 *)result)[2] = nbits;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    ((UINT64 *)result)[3] = nbits;\n#endif\n\n    nh_aux(hc->nh_key, buf, result, padded_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nh_final",
          "args": [
            "&ctx->hash",
            "nh_result"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "nh_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "666-702",
          "snippet": "static void nh_final(nh_ctx *hc, UINT8 *result)\n/* After passing some number of data buffers to nh_update() for integration\n * into an NH context, nh_final is called to produce a hash result. If any\n * bytes are in the buffer hc->data, incorporate them into the\n * NH context. Finally, add into the NH accumulation \"state\" the total number\n * of bits hashed. The resulting numbers are written to the buffer \"result\".\n * If nh_update was never called, L1_PAD_BOUNDARY zeroes are incorporated.\n */\n{\n    int nh_len, nbits;\n\n    if (hc->next_data_empty != 0) {\n        nh_len = ((hc->next_data_empty + (L1_PAD_BOUNDARY - 1)) &\n                                                ~(L1_PAD_BOUNDARY - 1));\n        zero_pad(hc->data + hc->next_data_empty,\n                                          nh_len - hc->next_data_empty);\n        nh_transform(hc, hc->data, nh_len);\n        hc->bytes_hashed += hc->next_data_empty;\n    } else if (hc->bytes_hashed == 0) {\n\tnh_len = L1_PAD_BOUNDARY;\n        zero_pad(hc->data, L1_PAD_BOUNDARY);\n        nh_transform(hc, hc->data, nh_len);\n    }\n\n    nbits = (hc->bytes_hashed << 3);\n    ((UINT64 *)result)[0] = ((UINT64 *)hc->state)[0] + nbits;\n#if (UMAC_OUTPUT_LEN >= 8)\n    ((UINT64 *)result)[1] = ((UINT64 *)hc->state)[1] + nbits;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    ((UINT64 *)result)[2] = ((UINT64 *)hc->state)[2] + nbits;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    ((UINT64 *)result)[3] = ((UINT64 *)hc->state)[3] + nbits;\n#endif\n    nh_reset(hc);\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define L1_PAD_BOUNDARY      32     /* pad message to boundary multiple   */",
            "#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define L1_PAD_BOUNDARY      32     /* pad message to boundary multiple   */\n#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */\n\nstatic void nh_final(nh_ctx *hc, UINT8 *result)\n/* After passing some number of data buffers to nh_update() for integration\n * into an NH context, nh_final is called to produce a hash result. If any\n * bytes are in the buffer hc->data, incorporate them into the\n * NH context. Finally, add into the NH accumulation \"state\" the total number\n * of bits hashed. The resulting numbers are written to the buffer \"result\".\n * If nh_update was never called, L1_PAD_BOUNDARY zeroes are incorporated.\n */\n{\n    int nh_len, nbits;\n\n    if (hc->next_data_empty != 0) {\n        nh_len = ((hc->next_data_empty + (L1_PAD_BOUNDARY - 1)) &\n                                                ~(L1_PAD_BOUNDARY - 1));\n        zero_pad(hc->data + hc->next_data_empty,\n                                          nh_len - hc->next_data_empty);\n        nh_transform(hc, hc->data, nh_len);\n        hc->bytes_hashed += hc->next_data_empty;\n    } else if (hc->bytes_hashed == 0) {\n\tnh_len = L1_PAD_BOUNDARY;\n        zero_pad(hc->data, L1_PAD_BOUNDARY);\n        nh_transform(hc, hc->data, nh_len);\n    }\n\n    nbits = (hc->bytes_hashed << 3);\n    ((UINT64 *)result)[0] = ((UINT64 *)hc->state)[0] + nbits;\n#if (UMAC_OUTPUT_LEN >= 8)\n    ((UINT64 *)result)[1] = ((UINT64 *)hc->state)[1] + nbits;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    ((UINT64 *)result)[2] = ((UINT64 *)hc->state)[2] + nbits;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    ((UINT64 *)result)[3] = ((UINT64 *)hc->state)[3] + nbits;\n#endif\n    nh_reset(hc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define L1_KEY_LEN         1024     /* Internal key bytes                 */\n#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */\n\nstatic int uhash_update(uhash_ctx_t ctx, const u_char *input, long len)\n/* Given len bytes of data, we parse it into L1_KEY_LEN chunks and\n * hash each one with NH, calling the polyhash on each NH output.\n */\n{\n    UWORD bytes_hashed, bytes_remaining;\n    UINT64 result_buf[STREAMS];\n    UINT8 *nh_result = (UINT8 *)&result_buf;\n\n    if (ctx->msg_len + len <= L1_KEY_LEN) {\n        nh_update(&ctx->hash, (const UINT8 *)input, len);\n        ctx->msg_len += len;\n    } else {\n\n         bytes_hashed = ctx->msg_len % L1_KEY_LEN;\n         if (ctx->msg_len == L1_KEY_LEN)\n             bytes_hashed = L1_KEY_LEN;\n\n         if (bytes_hashed + len >= L1_KEY_LEN) {\n\n             /* If some bytes have been passed to the hash function      */\n             /* then we want to pass at most (L1_KEY_LEN - bytes_hashed) */\n             /* bytes to complete the current nh_block.                  */\n             if (bytes_hashed) {\n                 bytes_remaining = (L1_KEY_LEN - bytes_hashed);\n                 nh_update(&ctx->hash, (const UINT8 *)input, bytes_remaining);\n                 nh_final(&ctx->hash, nh_result);\n                 ctx->msg_len += bytes_remaining;\n                 poly_hash(ctx,(UINT32 *)nh_result);\n                 len -= bytes_remaining;\n                 input += bytes_remaining;\n             }\n\n             /* Hash directly from input stream if enough bytes */\n             while (len >= L1_KEY_LEN) {\n                 nh(&ctx->hash, (const UINT8 *)input, L1_KEY_LEN,\n                                   L1_KEY_LEN, nh_result);\n                 ctx->msg_len += L1_KEY_LEN;\n                 len -= L1_KEY_LEN;\n                 input += L1_KEY_LEN;\n                 poly_hash(ctx,(UINT32 *)nh_result);\n             }\n         }\n\n         /* pass remaining < L1_KEY_LEN bytes of input data to NH */\n         if (len) {\n             nh_update(&ctx->hash, (const UINT8 *)input, len);\n             ctx->msg_len += len;\n         }\n     }\n\n    return (1);\n}"
  },
  {
    "function_name": "uhash_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "1028-1041",
    "snippet": "static int uhash_free(uhash_ctx_t ctx)\n{\n/* Free memory allocated by uhash_alloc */\n    u_char bytes_to_sub;\n\n    if (ctx) {\n        if (ALLOC_BOUNDARY) {\n            bytes_to_sub = *((u_char *)ctx - 1);\n            ctx = (uhash_ctx_t)((u_char *)ctx - bytes_to_sub);\n        }\n        free(ctx);\n    }\n    return (1);\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define ALLOC_BOUNDARY       16     /* Keep buffers aligned to this       */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ctx"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "uhash_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "1028-1041",
          "snippet": "static int uhash_free(uhash_ctx_t ctx)\n{\n/* Free memory allocated by uhash_alloc */\n    u_char bytes_to_sub;\n\n    if (ctx) {\n        if (ALLOC_BOUNDARY) {\n            bytes_to_sub = *((u_char *)ctx - 1);\n            ctx = (uhash_ctx_t)((u_char *)ctx - bytes_to_sub);\n        }\n        free(ctx);\n    }\n    return (1);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(u_char *)ctx - bytes_to_sub"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define ALLOC_BOUNDARY       16     /* Keep buffers aligned to this       */\n\nstatic int uhash_free(uhash_ctx_t ctx)\n{\n/* Free memory allocated by uhash_alloc */\n    u_char bytes_to_sub;\n\n    if (ctx) {\n        if (ALLOC_BOUNDARY) {\n            bytes_to_sub = *((u_char *)ctx - 1);\n            ctx = (uhash_ctx_t)((u_char *)ctx - bytes_to_sub);\n        }\n        free(ctx);\n    }\n    return (1);\n}"
  },
  {
    "function_name": "uhash_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "1003-1022",
    "snippet": "static uhash_ctx_t uhash_alloc(u_char key[])\n{\n/* Allocate memory and force to a 16-byte boundary. */\n    uhash_ctx_t ctx;\n    u_char bytes_to_add;\n    aes_int_key prf_key;\n\n    ctx = (uhash_ctx_t)malloc(sizeof(uhash_ctx)+ALLOC_BOUNDARY);\n    if (ctx) {\n        if (ALLOC_BOUNDARY) {\n            bytes_to_add = ALLOC_BOUNDARY -\n                              ((ptrdiff_t)ctx & (ALLOC_BOUNDARY -1));\n            ctx = (uhash_ctx_t)((u_char *)ctx + bytes_to_add);\n            *((u_char *)ctx - 1) = bytes_to_add;\n        }\n        aes_key_setup(key,prf_key);\n        uhash_init(ctx, prf_key);\n    }\n    return (ctx);\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define ALLOC_BOUNDARY       16     /* Keep buffers aligned to this       */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhash_init",
          "args": [
            "ctx",
            "prf_key"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "uhash_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "957-998",
          "snippet": "static void uhash_init(uhash_ctx_t ahc, aes_int_key prf_key)\n{\n    int i;\n    UINT8 buf[(8*STREAMS+4)*sizeof(UINT64)];\n\n    /* Zero the entire uhash context */\n    memset(ahc, 0, sizeof(uhash_ctx));\n\n    /* Initialize the L1 hash */\n    nh_init(&ahc->hash, prf_key);\n\n    /* Setup L2 hash variables */\n    kdf(buf, prf_key, 2, sizeof(buf));    /* Fill buffer with index 1 key */\n    for (i = 0; i < STREAMS; i++) {\n        /* Fill keys from the buffer, skipping bytes in the buffer not\n         * used by this implementation. Endian reverse the keys if on a\n         * little-endian computer.\n         */\n        memcpy(ahc->poly_key_8+i, buf+24*i, 8);\n        endian_convert_if_le(ahc->poly_key_8+i, 8, 8);\n        /* Mask the 64-bit keys to their special domain */\n        ahc->poly_key_8[i] &= ((UINT64)0x01ffffffu << 32) + 0x01ffffffu;\n        ahc->poly_accum[i] = 1;  /* Our polyhash prepends a non-zero word */\n    }\n\n    /* Setup L3-1 hash variables */\n    kdf(buf, prf_key, 3, sizeof(buf)); /* Fill buffer with index 2 key */\n    for (i = 0; i < STREAMS; i++)\n          memcpy(ahc->ip_keys+4*i, buf+(8*i+4)*sizeof(UINT64),\n                                                 4*sizeof(UINT64));\n    endian_convert_if_le(ahc->ip_keys, sizeof(UINT64),\n                                                  sizeof(ahc->ip_keys));\n    for (i = 0; i < STREAMS*4; i++)\n        ahc->ip_keys[i] %= p36;  /* Bring into Z_p36 */\n\n    /* Setup L3-2 hash variables    */\n    /* Fill buffer with index 4 key */\n    kdf(ahc->ip_trans, prf_key, 4, STREAMS * sizeof(UINT32));\n    endian_convert_if_le(ahc->ip_trans, sizeof(UINT32),\n                         STREAMS * sizeof(UINT32));\n    explicit_bzero(buf, sizeof(buf));\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define p36    ((UINT64)0x0000000FFFFFFFFBull)              /* 2^36 -  5 */",
            "#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define p36    ((UINT64)0x0000000FFFFFFFFBull)              /* 2^36 -  5 */\n#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */\n\nstatic void uhash_init(uhash_ctx_t ahc, aes_int_key prf_key)\n{\n    int i;\n    UINT8 buf[(8*STREAMS+4)*sizeof(UINT64)];\n\n    /* Zero the entire uhash context */\n    memset(ahc, 0, sizeof(uhash_ctx));\n\n    /* Initialize the L1 hash */\n    nh_init(&ahc->hash, prf_key);\n\n    /* Setup L2 hash variables */\n    kdf(buf, prf_key, 2, sizeof(buf));    /* Fill buffer with index 1 key */\n    for (i = 0; i < STREAMS; i++) {\n        /* Fill keys from the buffer, skipping bytes in the buffer not\n         * used by this implementation. Endian reverse the keys if on a\n         * little-endian computer.\n         */\n        memcpy(ahc->poly_key_8+i, buf+24*i, 8);\n        endian_convert_if_le(ahc->poly_key_8+i, 8, 8);\n        /* Mask the 64-bit keys to their special domain */\n        ahc->poly_key_8[i] &= ((UINT64)0x01ffffffu << 32) + 0x01ffffffu;\n        ahc->poly_accum[i] = 1;  /* Our polyhash prepends a non-zero word */\n    }\n\n    /* Setup L3-1 hash variables */\n    kdf(buf, prf_key, 3, sizeof(buf)); /* Fill buffer with index 2 key */\n    for (i = 0; i < STREAMS; i++)\n          memcpy(ahc->ip_keys+4*i, buf+(8*i+4)*sizeof(UINT64),\n                                                 4*sizeof(UINT64));\n    endian_convert_if_le(ahc->ip_keys, sizeof(UINT64),\n                                                  sizeof(ahc->ip_keys));\n    for (i = 0; i < STREAMS*4; i++)\n        ahc->ip_keys[i] %= p36;  /* Bring into Z_p36 */\n\n    /* Setup L3-2 hash variables    */\n    /* Fill buffer with index 4 key */\n    kdf(ahc->ip_trans, prf_key, 4, STREAMS * sizeof(UINT32));\n    endian_convert_if_le(ahc->ip_trans, sizeof(UINT32),\n                         STREAMS * sizeof(UINT32));\n    explicit_bzero(buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "aes_key_setup",
          "args": [
            "key",
            "prf_key"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(u_char *)ctx + bytes_to_add"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(uhash_ctx)+ALLOC_BOUNDARY"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define ALLOC_BOUNDARY       16     /* Keep buffers aligned to this       */\n\nstatic uhash_ctx_t uhash_alloc(u_char key[])\n{\n/* Allocate memory and force to a 16-byte boundary. */\n    uhash_ctx_t ctx;\n    u_char bytes_to_add;\n    aes_int_key prf_key;\n\n    ctx = (uhash_ctx_t)malloc(sizeof(uhash_ctx)+ALLOC_BOUNDARY);\n    if (ctx) {\n        if (ALLOC_BOUNDARY) {\n            bytes_to_add = ALLOC_BOUNDARY -\n                              ((ptrdiff_t)ctx & (ALLOC_BOUNDARY -1));\n            ctx = (uhash_ctx_t)((u_char *)ctx + bytes_to_add);\n            *((u_char *)ctx - 1) = bytes_to_add;\n        }\n        aes_key_setup(key,prf_key);\n        uhash_init(ctx, prf_key);\n    }\n    return (ctx);\n}"
  },
  {
    "function_name": "uhash_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "957-998",
    "snippet": "static void uhash_init(uhash_ctx_t ahc, aes_int_key prf_key)\n{\n    int i;\n    UINT8 buf[(8*STREAMS+4)*sizeof(UINT64)];\n\n    /* Zero the entire uhash context */\n    memset(ahc, 0, sizeof(uhash_ctx));\n\n    /* Initialize the L1 hash */\n    nh_init(&ahc->hash, prf_key);\n\n    /* Setup L2 hash variables */\n    kdf(buf, prf_key, 2, sizeof(buf));    /* Fill buffer with index 1 key */\n    for (i = 0; i < STREAMS; i++) {\n        /* Fill keys from the buffer, skipping bytes in the buffer not\n         * used by this implementation. Endian reverse the keys if on a\n         * little-endian computer.\n         */\n        memcpy(ahc->poly_key_8+i, buf+24*i, 8);\n        endian_convert_if_le(ahc->poly_key_8+i, 8, 8);\n        /* Mask the 64-bit keys to their special domain */\n        ahc->poly_key_8[i] &= ((UINT64)0x01ffffffu << 32) + 0x01ffffffu;\n        ahc->poly_accum[i] = 1;  /* Our polyhash prepends a non-zero word */\n    }\n\n    /* Setup L3-1 hash variables */\n    kdf(buf, prf_key, 3, sizeof(buf)); /* Fill buffer with index 2 key */\n    for (i = 0; i < STREAMS; i++)\n          memcpy(ahc->ip_keys+4*i, buf+(8*i+4)*sizeof(UINT64),\n                                                 4*sizeof(UINT64));\n    endian_convert_if_le(ahc->ip_keys, sizeof(UINT64),\n                                                  sizeof(ahc->ip_keys));\n    for (i = 0; i < STREAMS*4; i++)\n        ahc->ip_keys[i] %= p36;  /* Bring into Z_p36 */\n\n    /* Setup L3-2 hash variables    */\n    /* Fill buffer with index 4 key */\n    kdf(ahc->ip_trans, prf_key, 4, STREAMS * sizeof(UINT32));\n    endian_convert_if_le(ahc->ip_trans, sizeof(UINT32),\n                         STREAMS * sizeof(UINT32));\n    explicit_bzero(buf, sizeof(buf));\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define p36    ((UINT64)0x0000000FFFFFFFFBull)              /* 2^36 -  5 */",
      "#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "buf",
            "sizeof(buf)"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "endian_convert_if_le",
          "args": [
            "ahc->ip_trans",
            "sizeof(UINT32)",
            "STREAMS * sizeof(UINT32)"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdf",
          "args": [
            "ahc->ip_trans",
            "prf_key",
            "4",
            "STREAMS * sizeof(UINT32)"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "kdf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "184-208",
          "snippet": "static void kdf(void *bufp, aes_int_key key, UINT8 ndx, int nbytes)\n{\n    UINT8 in_buf[AES_BLOCK_LEN] = {0};\n    UINT8 out_buf[AES_BLOCK_LEN];\n    UINT8 *dst_buf = (UINT8 *)bufp;\n    int i;\n\n    /* Setup the initial value */\n    in_buf[AES_BLOCK_LEN-9] = ndx;\n    in_buf[AES_BLOCK_LEN-1] = i = 1;\n\n    while (nbytes >= AES_BLOCK_LEN) {\n        aes_encryption(in_buf, out_buf, key);\n        memcpy(dst_buf,out_buf,AES_BLOCK_LEN);\n        in_buf[AES_BLOCK_LEN-1] = ++i;\n        nbytes -= AES_BLOCK_LEN;\n        dst_buf += AES_BLOCK_LEN;\n    }\n    if (nbytes) {\n        aes_encryption(in_buf, out_buf, key);\n        memcpy(dst_buf,out_buf,nbytes);\n    }\n    explicit_bzero(in_buf, sizeof(in_buf));\n    explicit_bzero(out_buf, sizeof(out_buf));\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define AES_BLOCK_LEN  16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define AES_BLOCK_LEN  16\n\nstatic void kdf(void *bufp, aes_int_key key, UINT8 ndx, int nbytes)\n{\n    UINT8 in_buf[AES_BLOCK_LEN] = {0};\n    UINT8 out_buf[AES_BLOCK_LEN];\n    UINT8 *dst_buf = (UINT8 *)bufp;\n    int i;\n\n    /* Setup the initial value */\n    in_buf[AES_BLOCK_LEN-9] = ndx;\n    in_buf[AES_BLOCK_LEN-1] = i = 1;\n\n    while (nbytes >= AES_BLOCK_LEN) {\n        aes_encryption(in_buf, out_buf, key);\n        memcpy(dst_buf,out_buf,AES_BLOCK_LEN);\n        in_buf[AES_BLOCK_LEN-1] = ++i;\n        nbytes -= AES_BLOCK_LEN;\n        dst_buf += AES_BLOCK_LEN;\n    }\n    if (nbytes) {\n        aes_encryption(in_buf, out_buf, key);\n        memcpy(dst_buf,out_buf,nbytes);\n    }\n    explicit_bzero(in_buf, sizeof(in_buf));\n    explicit_bzero(out_buf, sizeof(out_buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "endian_convert_if_le",
          "args": [
            "ahc->ip_keys",
            "sizeof(UINT64)",
            "sizeof(ahc->ip_keys)"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ahc->ip_keys+4*i",
            "buf+(8*i+4)*sizeof(UINT64)",
            "4*sizeof(UINT64)"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "endian_convert_if_le",
          "args": [
            "ahc->poly_key_8+i",
            "8",
            "8"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ahc->poly_key_8+i",
            "buf+24*i",
            "8"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nh_init",
          "args": [
            "&ahc->hash",
            "prf_key"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "nh_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "601-607",
          "snippet": "static void nh_init(nh_ctx *hc, aes_int_key prf_key)\n/* Generate nh_key, endian convert and reset to be ready for hashing.   */\n{\n    kdf(hc->nh_key, prf_key, 1, sizeof(hc->nh_key));\n    endian_convert_if_le(hc->nh_key, 4, sizeof(hc->nh_key));\n    nh_reset(hc);\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void nh_init(nh_ctx *hc, aes_int_key prf_key)\n/* Generate nh_key, endian convert and reset to be ready for hashing.   */\n{\n    kdf(hc->nh_key, prf_key, 1, sizeof(hc->nh_key));\n    endian_convert_if_le(hc->nh_key, 4, sizeof(hc->nh_key));\n    nh_reset(hc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ahc",
            "0",
            "sizeof(uhash_ctx)"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define p36    ((UINT64)0x0000000FFFFFFFFBull)              /* 2^36 -  5 */\n#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */\n\nstatic void uhash_init(uhash_ctx_t ahc, aes_int_key prf_key)\n{\n    int i;\n    UINT8 buf[(8*STREAMS+4)*sizeof(UINT64)];\n\n    /* Zero the entire uhash context */\n    memset(ahc, 0, sizeof(uhash_ctx));\n\n    /* Initialize the L1 hash */\n    nh_init(&ahc->hash, prf_key);\n\n    /* Setup L2 hash variables */\n    kdf(buf, prf_key, 2, sizeof(buf));    /* Fill buffer with index 1 key */\n    for (i = 0; i < STREAMS; i++) {\n        /* Fill keys from the buffer, skipping bytes in the buffer not\n         * used by this implementation. Endian reverse the keys if on a\n         * little-endian computer.\n         */\n        memcpy(ahc->poly_key_8+i, buf+24*i, 8);\n        endian_convert_if_le(ahc->poly_key_8+i, 8, 8);\n        /* Mask the 64-bit keys to their special domain */\n        ahc->poly_key_8[i] &= ((UINT64)0x01ffffffu << 32) + 0x01ffffffu;\n        ahc->poly_accum[i] = 1;  /* Our polyhash prepends a non-zero word */\n    }\n\n    /* Setup L3-1 hash variables */\n    kdf(buf, prf_key, 3, sizeof(buf)); /* Fill buffer with index 2 key */\n    for (i = 0; i < STREAMS; i++)\n          memcpy(ahc->ip_keys+4*i, buf+(8*i+4)*sizeof(UINT64),\n                                                 4*sizeof(UINT64));\n    endian_convert_if_le(ahc->ip_keys, sizeof(UINT64),\n                                                  sizeof(ahc->ip_keys));\n    for (i = 0; i < STREAMS*4; i++)\n        ahc->ip_keys[i] %= p36;  /* Bring into Z_p36 */\n\n    /* Setup L3-2 hash variables    */\n    /* Fill buffer with index 4 key */\n    kdf(ahc->ip_trans, prf_key, 4, STREAMS * sizeof(UINT32));\n    endian_convert_if_le(ahc->ip_trans, sizeof(UINT32),\n                         STREAMS * sizeof(UINT32));\n    explicit_bzero(buf, sizeof(buf));\n}"
  },
  {
    "function_name": "uhash_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "933-948",
    "snippet": "static int uhash_reset(uhash_ctx_t pc)\n{\n    nh_reset(&pc->hash);\n    pc->msg_len = 0;\n    pc->poly_accum[0] = 1;\n#if (UMAC_OUTPUT_LEN >= 8)\n    pc->poly_accum[1] = 1;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    pc->poly_accum[2] = 1;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    pc->poly_accum[3] = 1;\n#endif\n    return 1;\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nh_reset",
          "args": [
            "&pc->hash"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "nh_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "581-597",
          "snippet": "static void nh_reset(nh_ctx *hc)\n/* Reset nh_ctx to ready for hashing of new data */\n{\n    hc->bytes_hashed = 0;\n    hc->next_data_empty = 0;\n    hc->state[0] = 0;\n#if (UMAC_OUTPUT_LEN >= 8)\n    hc->state[1] = 0;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    hc->state[2] = 0;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    hc->state[3] = 0;\n#endif\n\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */\n\nstatic void nh_reset(nh_ctx *hc)\n/* Reset nh_ctx to ready for hashing of new data */\n{\n    hc->bytes_hashed = 0;\n    hc->next_data_empty = 0;\n    hc->state[0] = 0;\n#if (UMAC_OUTPUT_LEN >= 8)\n    hc->state[1] = 0;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    hc->state[2] = 0;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    hc->state[3] = 0;\n#endif\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */\n\nstatic int uhash_reset(uhash_ctx_t pc)\n{\n    nh_reset(&pc->hash);\n    pc->msg_len = 0;\n    pc->poly_accum[0] = 1;\n#if (UMAC_OUTPUT_LEN >= 8)\n    pc->poly_accum[1] = 1;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    pc->poly_accum[2] = 1;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    pc->poly_accum[3] = 1;\n#endif\n    return 1;\n}"
  },
  {
    "function_name": "ip_long",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "912-925",
    "snippet": "static void ip_long(uhash_ctx_t ahc, u_char *res)\n{\n    int i;\n    UINT64 t;\n\n    for (i = 0; i < STREAMS; i++) {\n        /* fix polyhash output not in Z_p64 */\n        if (ahc->poly_accum[i] >= p64)\n            ahc->poly_accum[i] -= p64;\n        t  = ip_aux(0,ahc->ip_keys+(i*4), ahc->poly_accum[i]);\n        STORE_UINT32_BIG((UINT32 *)res+i,\n                         ip_reduce_p36(t) ^ ahc->ip_trans[i]);\n    }\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define p64    ((UINT64)0xFFFFFFFFFFFFFFC5ull)              /* 2^64 - 59 */",
      "#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STORE_UINT32_BIG",
          "args": [
            "(UINT32 *)res+i",
            "ip_reduce_p36(t) ^ ahc->ip_trans[i]"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_reduce_p36",
          "args": [
            "t"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "ip_reduce_p36",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "869-880",
          "snippet": "static UINT32 ip_reduce_p36(UINT64 t)\n{\n/* Divisionless modular reduction */\n    UINT64 ret;\n\n    ret = (t & m36) + 5 * (t >> 36);\n    if (ret >= p36)\n        ret -= p36;\n\n    /* return least significant 32 bits */\n    return (UINT32)(ret);\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define m36    ((UINT64)0x0000000FFFFFFFFFull)  /* The low 36 of 64 bits */",
            "#define p36    ((UINT64)0x0000000FFFFFFFFBull)              /* 2^36 -  5 */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define m36    ((UINT64)0x0000000FFFFFFFFFull)  /* The low 36 of 64 bits */\n#define p36    ((UINT64)0x0000000FFFFFFFFBull)              /* 2^36 -  5 */\n\nstatic UINT32 ip_reduce_p36(UINT64 t)\n{\n/* Divisionless modular reduction */\n    UINT64 ret;\n\n    ret = (t & m36) + 5 * (t >> 36);\n    if (ret >= p36)\n        ret -= p36;\n\n    /* return least significant 32 bits */\n    return (UINT32)(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ip_aux",
          "args": [
            "0",
            "ahc->ip_keys+(i*4)",
            "ahc->poly_accum[i]"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "ip_aux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "859-867",
          "snippet": "static UINT64 ip_aux(UINT64 t, UINT64 *ipkp, UINT64 data)\n{\n    t = t + ipkp[0] * (UINT64)(UINT16)(data >> 48);\n    t = t + ipkp[1] * (UINT64)(UINT16)(data >> 32);\n    t = t + ipkp[2] * (UINT64)(UINT16)(data >> 16);\n    t = t + ipkp[3] * (UINT64)(UINT16)(data);\n\n    return t;\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic UINT64 ip_aux(UINT64 t, UINT64 *ipkp, UINT64 data)\n{\n    t = t + ipkp[0] * (UINT64)(UINT16)(data >> 48);\n    t = t + ipkp[1] * (UINT64)(UINT16)(data >> 32);\n    t = t + ipkp[2] * (UINT64)(UINT16)(data >> 16);\n    t = t + ipkp[3] * (UINT64)(UINT16)(data);\n\n    return t;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define p64    ((UINT64)0xFFFFFFFFFFFFFFC5ull)              /* 2^64 - 59 */\n#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */\n\nstatic void ip_long(uhash_ctx_t ahc, u_char *res)\n{\n    int i;\n    UINT64 t;\n\n    for (i = 0; i < STREAMS; i++) {\n        /* fix polyhash output not in Z_p64 */\n        if (ahc->poly_accum[i] >= p64)\n            ahc->poly_accum[i] -= p64;\n        t  = ip_aux(0,ahc->ip_keys+(i*4), ahc->poly_accum[i]);\n        STORE_UINT32_BIG((UINT32 *)res+i,\n                         ip_reduce_p36(t) ^ ahc->ip_trans[i]);\n    }\n}"
  },
  {
    "function_name": "ip_short",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "887-906",
    "snippet": "static void ip_short(uhash_ctx_t ahc, UINT8 *nh_res, u_char *res)\n{\n    UINT64 t;\n    UINT64 *nhp = (UINT64 *)nh_res;\n\n    t  = ip_aux(0,ahc->ip_keys, nhp[0]);\n    STORE_UINT32_BIG((UINT32 *)res+0, ip_reduce_p36(t) ^ ahc->ip_trans[0]);\n#if (UMAC_OUTPUT_LEN >= 8)\n    t  = ip_aux(0,ahc->ip_keys+4, nhp[1]);\n    STORE_UINT32_BIG((UINT32 *)res+1, ip_reduce_p36(t) ^ ahc->ip_trans[1]);\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    t  = ip_aux(0,ahc->ip_keys+8, nhp[2]);\n    STORE_UINT32_BIG((UINT32 *)res+2, ip_reduce_p36(t) ^ ahc->ip_trans[2]);\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    t  = ip_aux(0,ahc->ip_keys+12, nhp[3]);\n    STORE_UINT32_BIG((UINT32 *)res+3, ip_reduce_p36(t) ^ ahc->ip_trans[3]);\n#endif\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STORE_UINT32_BIG",
          "args": [
            "(UINT32 *)res+3",
            "ip_reduce_p36(t) ^ ahc->ip_trans[3]"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_reduce_p36",
          "args": [
            "t"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "ip_reduce_p36",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "869-880",
          "snippet": "static UINT32 ip_reduce_p36(UINT64 t)\n{\n/* Divisionless modular reduction */\n    UINT64 ret;\n\n    ret = (t & m36) + 5 * (t >> 36);\n    if (ret >= p36)\n        ret -= p36;\n\n    /* return least significant 32 bits */\n    return (UINT32)(ret);\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define m36    ((UINT64)0x0000000FFFFFFFFFull)  /* The low 36 of 64 bits */",
            "#define p36    ((UINT64)0x0000000FFFFFFFFBull)              /* 2^36 -  5 */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define m36    ((UINT64)0x0000000FFFFFFFFFull)  /* The low 36 of 64 bits */\n#define p36    ((UINT64)0x0000000FFFFFFFFBull)              /* 2^36 -  5 */\n\nstatic UINT32 ip_reduce_p36(UINT64 t)\n{\n/* Divisionless modular reduction */\n    UINT64 ret;\n\n    ret = (t & m36) + 5 * (t >> 36);\n    if (ret >= p36)\n        ret -= p36;\n\n    /* return least significant 32 bits */\n    return (UINT32)(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ip_aux",
          "args": [
            "0",
            "ahc->ip_keys+12",
            "nhp[3]"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "ip_aux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "859-867",
          "snippet": "static UINT64 ip_aux(UINT64 t, UINT64 *ipkp, UINT64 data)\n{\n    t = t + ipkp[0] * (UINT64)(UINT16)(data >> 48);\n    t = t + ipkp[1] * (UINT64)(UINT16)(data >> 32);\n    t = t + ipkp[2] * (UINT64)(UINT16)(data >> 16);\n    t = t + ipkp[3] * (UINT64)(UINT16)(data);\n\n    return t;\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic UINT64 ip_aux(UINT64 t, UINT64 *ipkp, UINT64 data)\n{\n    t = t + ipkp[0] * (UINT64)(UINT16)(data >> 48);\n    t = t + ipkp[1] * (UINT64)(UINT16)(data >> 32);\n    t = t + ipkp[2] * (UINT64)(UINT16)(data >> 16);\n    t = t + ipkp[3] * (UINT64)(UINT16)(data);\n\n    return t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STORE_UINT32_BIG",
          "args": [
            "(UINT32 *)res+2",
            "ip_reduce_p36(t) ^ ahc->ip_trans[2]"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STORE_UINT32_BIG",
          "args": [
            "(UINT32 *)res+1",
            "ip_reduce_p36(t) ^ ahc->ip_trans[1]"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STORE_UINT32_BIG",
          "args": [
            "(UINT32 *)res+0",
            "ip_reduce_p36(t) ^ ahc->ip_trans[0]"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */\n\nstatic void ip_short(uhash_ctx_t ahc, UINT8 *nh_res, u_char *res)\n{\n    UINT64 t;\n    UINT64 *nhp = (UINT64 *)nh_res;\n\n    t  = ip_aux(0,ahc->ip_keys, nhp[0]);\n    STORE_UINT32_BIG((UINT32 *)res+0, ip_reduce_p36(t) ^ ahc->ip_trans[0]);\n#if (UMAC_OUTPUT_LEN >= 8)\n    t  = ip_aux(0,ahc->ip_keys+4, nhp[1]);\n    STORE_UINT32_BIG((UINT32 *)res+1, ip_reduce_p36(t) ^ ahc->ip_trans[1]);\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    t  = ip_aux(0,ahc->ip_keys+8, nhp[2]);\n    STORE_UINT32_BIG((UINT32 *)res+2, ip_reduce_p36(t) ^ ahc->ip_trans[2]);\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    t  = ip_aux(0,ahc->ip_keys+12, nhp[3]);\n    STORE_UINT32_BIG((UINT32 *)res+3, ip_reduce_p36(t) ^ ahc->ip_trans[3]);\n#endif\n}"
  },
  {
    "function_name": "ip_reduce_p36",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "869-880",
    "snippet": "static UINT32 ip_reduce_p36(UINT64 t)\n{\n/* Divisionless modular reduction */\n    UINT64 ret;\n\n    ret = (t & m36) + 5 * (t >> 36);\n    if (ret >= p36)\n        ret -= p36;\n\n    /* return least significant 32 bits */\n    return (UINT32)(ret);\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define m36    ((UINT64)0x0000000FFFFFFFFFull)  /* The low 36 of 64 bits */",
      "#define p36    ((UINT64)0x0000000FFFFFFFFBull)              /* 2^36 -  5 */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "ret"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define m36    ((UINT64)0x0000000FFFFFFFFFull)  /* The low 36 of 64 bits */\n#define p36    ((UINT64)0x0000000FFFFFFFFBull)              /* 2^36 -  5 */\n\nstatic UINT32 ip_reduce_p36(UINT64 t)\n{\n/* Divisionless modular reduction */\n    UINT64 ret;\n\n    ret = (t & m36) + 5 * (t >> 36);\n    if (ret >= p36)\n        ret -= p36;\n\n    /* return least significant 32 bits */\n    return (UINT32)(ret);\n}"
  },
  {
    "function_name": "ip_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "859-867",
    "snippet": "static UINT64 ip_aux(UINT64 t, UINT64 *ipkp, UINT64 data)\n{\n    t = t + ipkp[0] * (UINT64)(UINT16)(data >> 48);\n    t = t + ipkp[1] * (UINT64)(UINT16)(data >> 32);\n    t = t + ipkp[2] * (UINT64)(UINT16)(data >> 16);\n    t = t + ipkp[3] * (UINT64)(UINT16)(data);\n\n    return t;\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "data"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "UINT16"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "data >> 16"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "UINT16"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "data >> 32"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "UINT16"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "data >> 48"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "UINT16"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic UINT64 ip_aux(UINT64 t, UINT64 *ipkp, UINT64 data)\n{\n    t = t + ipkp[0] * (UINT64)(UINT16)(data >> 48);\n    t = t + ipkp[1] * (UINT64)(UINT16)(data >> 32);\n    t = t + ipkp[2] * (UINT64)(UINT16)(data >> 16);\n    t = t + ipkp[3] * (UINT64)(UINT16)(data);\n\n    return t;\n}"
  },
  {
    "function_name": "poly_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "831-847",
    "snippet": "static void poly_hash(uhash_ctx_t hc, UINT32 data_in[])\n{\n    int i;\n    UINT64 *data=(UINT64*)data_in;\n\n    for (i = 0; i < STREAMS; i++) {\n        if ((UINT32)(data[i] >> 32) == 0xfffffffful) {\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], p64 - 1);\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], (data[i] - 59));\n        } else {\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], data[i]);\n        }\n    }\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define p64    ((UINT64)0xFFFFFFFFFFFFFFC5ull)              /* 2^64 - 59 */",
      "#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "poly64",
          "args": [
            "hc->poly_accum[i]",
            "hc->poly_key_8[i]",
            "data[i]"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "poly64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "796-822",
          "snippet": "static UINT64 poly64(UINT64 cur, UINT64 key, UINT64 data)\n{\n    UINT32 key_hi = (UINT32)(key >> 32),\n           key_lo = (UINT32)key,\n           cur_hi = (UINT32)(cur >> 32),\n           cur_lo = (UINT32)cur,\n           x_lo,\n           x_hi;\n    UINT64 X,T,res;\n\n    X =  MUL64(key_hi, cur_lo) + MUL64(cur_hi, key_lo);\n    x_lo = (UINT32)X;\n    x_hi = (UINT32)(X >> 32);\n\n    res = (MUL64(key_hi, cur_hi) + x_hi) * 59 + MUL64(key_lo, cur_lo);\n\n    T = ((UINT64)x_lo << 32);\n    res += T;\n    if (res < T)\n        res += 59;\n\n    res += data;\n    if (res < data)\n        res += 59;\n\n    return res;\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic UINT64 poly64(UINT64 cur, UINT64 key, UINT64 data)\n{\n    UINT32 key_hi = (UINT32)(key >> 32),\n           key_lo = (UINT32)key,\n           cur_hi = (UINT32)(cur >> 32),\n           cur_lo = (UINT32)cur,\n           x_lo,\n           x_hi;\n    UINT64 X,T,res;\n\n    X =  MUL64(key_hi, cur_lo) + MUL64(cur_hi, key_lo);\n    x_lo = (UINT32)X;\n    x_hi = (UINT32)(X >> 32);\n\n    res = (MUL64(key_hi, cur_hi) + x_hi) * 59 + MUL64(key_lo, cur_lo);\n\n    T = ((UINT64)x_lo << 32);\n    res += T;\n    if (res < T)\n        res += 59;\n\n    res += data;\n    if (res < data)\n        res += 59;\n\n    return res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "data[i] >> 32"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define p64    ((UINT64)0xFFFFFFFFFFFFFFC5ull)              /* 2^64 - 59 */\n#define STREAMS (UMAC_OUTPUT_LEN / 4) /* Number of times hash is applied  */\n\nstatic void poly_hash(uhash_ctx_t hc, UINT32 data_in[])\n{\n    int i;\n    UINT64 *data=(UINT64*)data_in;\n\n    for (i = 0; i < STREAMS; i++) {\n        if ((UINT32)(data[i] >> 32) == 0xfffffffful) {\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], p64 - 1);\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], (data[i] - 59));\n        } else {\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], data[i]);\n        }\n    }\n}"
  },
  {
    "function_name": "poly64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "796-822",
    "snippet": "static UINT64 poly64(UINT64 cur, UINT64 key, UINT64 data)\n{\n    UINT32 key_hi = (UINT32)(key >> 32),\n           key_lo = (UINT32)key,\n           cur_hi = (UINT32)(cur >> 32),\n           cur_lo = (UINT32)cur,\n           x_lo,\n           x_hi;\n    UINT64 X,T,res;\n\n    X =  MUL64(key_hi, cur_lo) + MUL64(cur_hi, key_lo);\n    x_lo = (UINT32)X;\n    x_hi = (UINT32)(X >> 32);\n\n    res = (MUL64(key_hi, cur_hi) + x_hi) * 59 + MUL64(key_lo, cur_lo);\n\n    T = ((UINT64)x_lo << 32);\n    res += T;\n    if (res < T)\n        res += 59;\n\n    res += data;\n    if (res < data)\n        res += 59;\n\n    return res;\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "key_lo",
            "cur_lo"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "key_hi",
            "cur_hi"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "X >> 32"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "cur_hi",
            "key_lo"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "key_hi",
            "cur_lo"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cur >> 32"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "key >> 32"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic UINT64 poly64(UINT64 cur, UINT64 key, UINT64 data)\n{\n    UINT32 key_hi = (UINT32)(key >> 32),\n           key_lo = (UINT32)key,\n           cur_hi = (UINT32)(cur >> 32),\n           cur_lo = (UINT32)cur,\n           x_lo,\n           x_hi;\n    UINT64 X,T,res;\n\n    X =  MUL64(key_hi, cur_lo) + MUL64(cur_hi, key_lo);\n    x_lo = (UINT32)X;\n    x_hi = (UINT32)(X >> 32);\n\n    res = (MUL64(key_hi, cur_hi) + x_hi) * 59 + MUL64(key_lo, cur_lo);\n\n    T = ((UINT64)x_lo << 32);\n    res += T;\n    if (res < T)\n        res += 59;\n\n    res += data;\n    if (res < data)\n        res += 59;\n\n    return res;\n}"
  },
  {
    "function_name": "nh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "706-730",
    "snippet": "static void nh(nh_ctx *hc, const UINT8 *buf, UINT32 padded_len,\n               UINT32 unpadded_len, UINT8 *result)\n/* All-in-one nh_update() and nh_final() equivalent.\n * Assumes that padded_len is divisible by L1_PAD_BOUNDARY and result is\n * well aligned\n */\n{\n    UINT32 nbits;\n\n    /* Initialize the hash state */\n    nbits = (unpadded_len << 3);\n\n    ((UINT64 *)result)[0] = nbits;\n#if (UMAC_OUTPUT_LEN >= 8)\n    ((UINT64 *)result)[1] = nbits;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    ((UINT64 *)result)[2] = nbits;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    ((UINT64 *)result)[3] = nbits;\n#endif\n\n    nh_aux(hc->nh_key, buf, result, padded_len);\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define L1_PAD_BOUNDARY      32     /* pad message to boundary multiple   */",
      "#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nh_aux",
          "args": [
            "hc->nh_key",
            "buf",
            "result",
            "padded_len"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "nh_aux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "467-527",
          "snippet": "static void nh_aux(void *kp, const void *dp, void *hp, UINT32 dlen)\n/* Same as previous nh_aux, but two streams are handled in one pass,\n * reading and writing 24 bytes of hash-state per call.\n*/\n{\n    UINT64 h1,h2,h3,h4;\n    UWORD c = dlen / 32;\n    UINT32 *k = (UINT32 *)kp;\n    const UINT32 *d = (const UINT32 *)dp;\n    UINT32 d0,d1,d2,d3,d4,d5,d6,d7;\n    UINT32 k0,k1,k2,k3,k4,k5,k6,k7,\n        k8,k9,k10,k11,k12,k13,k14,k15,\n        k16,k17,k18,k19;\n\n    h1 = *((UINT64 *)hp);\n    h2 = *((UINT64 *)hp + 1);\n    h3 = *((UINT64 *)hp + 2);\n    h4 = *((UINT64 *)hp + 3);\n    k0 = *(k+0); k1 = *(k+1); k2 = *(k+2); k3 = *(k+3);\n    k4 = *(k+4); k5 = *(k+5); k6 = *(k+6); k7 = *(k+7);\n    do {\n        d0 = LOAD_UINT32_LITTLE(d+0); d1 = LOAD_UINT32_LITTLE(d+1);\n        d2 = LOAD_UINT32_LITTLE(d+2); d3 = LOAD_UINT32_LITTLE(d+3);\n        d4 = LOAD_UINT32_LITTLE(d+4); d5 = LOAD_UINT32_LITTLE(d+5);\n        d6 = LOAD_UINT32_LITTLE(d+6); d7 = LOAD_UINT32_LITTLE(d+7);\n        k8 = *(k+8); k9 = *(k+9); k10 = *(k+10); k11 = *(k+11);\n        k12 = *(k+12); k13 = *(k+13); k14 = *(k+14); k15 = *(k+15);\n        k16 = *(k+16); k17 = *(k+17); k18 = *(k+18); k19 = *(k+19);\n\n        h1 += MUL64((k0 + d0), (k4 + d4));\n        h2 += MUL64((k4 + d0), (k8 + d4));\n        h3 += MUL64((k8 + d0), (k12 + d4));\n        h4 += MUL64((k12 + d0), (k16 + d4));\n\n        h1 += MUL64((k1 + d1), (k5 + d5));\n        h2 += MUL64((k5 + d1), (k9 + d5));\n        h3 += MUL64((k9 + d1), (k13 + d5));\n        h4 += MUL64((k13 + d1), (k17 + d5));\n\n        h1 += MUL64((k2 + d2), (k6 + d6));\n        h2 += MUL64((k6 + d2), (k10 + d6));\n        h3 += MUL64((k10 + d2), (k14 + d6));\n        h4 += MUL64((k14 + d2), (k18 + d6));\n\n        h1 += MUL64((k3 + d3), (k7 + d7));\n        h2 += MUL64((k7 + d3), (k11 + d7));\n        h3 += MUL64((k11 + d3), (k15 + d7));\n        h4 += MUL64((k15 + d3), (k19 + d7));\n\n        k0 = k8; k1 = k9; k2 = k10; k3 = k11;\n        k4 = k12; k5 = k13; k6 = k14; k7 = k15;\n        k8 = k16; k9 = k17; k10 = k18; k11 = k19;\n\n        d += 8;\n        k += 8;\n    } while (--c);\n    ((UINT64 *)hp)[0] = h1;\n    ((UINT64 *)hp)[1] = h2;\n    ((UINT64 *)hp)[2] = h3;\n    ((UINT64 *)hp)[3] = h4;\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void nh_aux(void *kp, const void *dp, void *hp, UINT32 dlen)\n/* Same as previous nh_aux, but two streams are handled in one pass,\n * reading and writing 24 bytes of hash-state per call.\n*/\n{\n    UINT64 h1,h2,h3,h4;\n    UWORD c = dlen / 32;\n    UINT32 *k = (UINT32 *)kp;\n    const UINT32 *d = (const UINT32 *)dp;\n    UINT32 d0,d1,d2,d3,d4,d5,d6,d7;\n    UINT32 k0,k1,k2,k3,k4,k5,k6,k7,\n        k8,k9,k10,k11,k12,k13,k14,k15,\n        k16,k17,k18,k19;\n\n    h1 = *((UINT64 *)hp);\n    h2 = *((UINT64 *)hp + 1);\n    h3 = *((UINT64 *)hp + 2);\n    h4 = *((UINT64 *)hp + 3);\n    k0 = *(k+0); k1 = *(k+1); k2 = *(k+2); k3 = *(k+3);\n    k4 = *(k+4); k5 = *(k+5); k6 = *(k+6); k7 = *(k+7);\n    do {\n        d0 = LOAD_UINT32_LITTLE(d+0); d1 = LOAD_UINT32_LITTLE(d+1);\n        d2 = LOAD_UINT32_LITTLE(d+2); d3 = LOAD_UINT32_LITTLE(d+3);\n        d4 = LOAD_UINT32_LITTLE(d+4); d5 = LOAD_UINT32_LITTLE(d+5);\n        d6 = LOAD_UINT32_LITTLE(d+6); d7 = LOAD_UINT32_LITTLE(d+7);\n        k8 = *(k+8); k9 = *(k+9); k10 = *(k+10); k11 = *(k+11);\n        k12 = *(k+12); k13 = *(k+13); k14 = *(k+14); k15 = *(k+15);\n        k16 = *(k+16); k17 = *(k+17); k18 = *(k+18); k19 = *(k+19);\n\n        h1 += MUL64((k0 + d0), (k4 + d4));\n        h2 += MUL64((k4 + d0), (k8 + d4));\n        h3 += MUL64((k8 + d0), (k12 + d4));\n        h4 += MUL64((k12 + d0), (k16 + d4));\n\n        h1 += MUL64((k1 + d1), (k5 + d5));\n        h2 += MUL64((k5 + d1), (k9 + d5));\n        h3 += MUL64((k9 + d1), (k13 + d5));\n        h4 += MUL64((k13 + d1), (k17 + d5));\n\n        h1 += MUL64((k2 + d2), (k6 + d6));\n        h2 += MUL64((k6 + d2), (k10 + d6));\n        h3 += MUL64((k10 + d2), (k14 + d6));\n        h4 += MUL64((k14 + d2), (k18 + d6));\n\n        h1 += MUL64((k3 + d3), (k7 + d7));\n        h2 += MUL64((k7 + d3), (k11 + d7));\n        h3 += MUL64((k11 + d3), (k15 + d7));\n        h4 += MUL64((k15 + d3), (k19 + d7));\n\n        k0 = k8; k1 = k9; k2 = k10; k3 = k11;\n        k4 = k12; k5 = k13; k6 = k14; k7 = k15;\n        k8 = k16; k9 = k17; k10 = k18; k11 = k19;\n\n        d += 8;\n        k += 8;\n    } while (--c);\n    ((UINT64 *)hp)[0] = h1;\n    ((UINT64 *)hp)[1] = h2;\n    ((UINT64 *)hp)[2] = h3;\n    ((UINT64 *)hp)[3] = h4;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define L1_PAD_BOUNDARY      32     /* pad message to boundary multiple   */\n#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */\n\nstatic void nh(nh_ctx *hc, const UINT8 *buf, UINT32 padded_len,\n               UINT32 unpadded_len, UINT8 *result)\n/* All-in-one nh_update() and nh_final() equivalent.\n * Assumes that padded_len is divisible by L1_PAD_BOUNDARY and result is\n * well aligned\n */\n{\n    UINT32 nbits;\n\n    /* Initialize the hash state */\n    nbits = (unpadded_len << 3);\n\n    ((UINT64 *)result)[0] = nbits;\n#if (UMAC_OUTPUT_LEN >= 8)\n    ((UINT64 *)result)[1] = nbits;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    ((UINT64 *)result)[2] = nbits;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    ((UINT64 *)result)[3] = nbits;\n#endif\n\n    nh_aux(hc->nh_key, buf, result, padded_len);\n}"
  },
  {
    "function_name": "nh_final",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "666-702",
    "snippet": "static void nh_final(nh_ctx *hc, UINT8 *result)\n/* After passing some number of data buffers to nh_update() for integration\n * into an NH context, nh_final is called to produce a hash result. If any\n * bytes are in the buffer hc->data, incorporate them into the\n * NH context. Finally, add into the NH accumulation \"state\" the total number\n * of bits hashed. The resulting numbers are written to the buffer \"result\".\n * If nh_update was never called, L1_PAD_BOUNDARY zeroes are incorporated.\n */\n{\n    int nh_len, nbits;\n\n    if (hc->next_data_empty != 0) {\n        nh_len = ((hc->next_data_empty + (L1_PAD_BOUNDARY - 1)) &\n                                                ~(L1_PAD_BOUNDARY - 1));\n        zero_pad(hc->data + hc->next_data_empty,\n                                          nh_len - hc->next_data_empty);\n        nh_transform(hc, hc->data, nh_len);\n        hc->bytes_hashed += hc->next_data_empty;\n    } else if (hc->bytes_hashed == 0) {\n\tnh_len = L1_PAD_BOUNDARY;\n        zero_pad(hc->data, L1_PAD_BOUNDARY);\n        nh_transform(hc, hc->data, nh_len);\n    }\n\n    nbits = (hc->bytes_hashed << 3);\n    ((UINT64 *)result)[0] = ((UINT64 *)hc->state)[0] + nbits;\n#if (UMAC_OUTPUT_LEN >= 8)\n    ((UINT64 *)result)[1] = ((UINT64 *)hc->state)[1] + nbits;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    ((UINT64 *)result)[2] = ((UINT64 *)hc->state)[2] + nbits;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    ((UINT64 *)result)[3] = ((UINT64 *)hc->state)[3] + nbits;\n#endif\n    nh_reset(hc);\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define L1_PAD_BOUNDARY      32     /* pad message to boundary multiple   */",
      "#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nh_reset",
          "args": [
            "hc"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "nh_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "581-597",
          "snippet": "static void nh_reset(nh_ctx *hc)\n/* Reset nh_ctx to ready for hashing of new data */\n{\n    hc->bytes_hashed = 0;\n    hc->next_data_empty = 0;\n    hc->state[0] = 0;\n#if (UMAC_OUTPUT_LEN >= 8)\n    hc->state[1] = 0;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    hc->state[2] = 0;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    hc->state[3] = 0;\n#endif\n\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */\n\nstatic void nh_reset(nh_ctx *hc)\n/* Reset nh_ctx to ready for hashing of new data */\n{\n    hc->bytes_hashed = 0;\n    hc->next_data_empty = 0;\n    hc->state[0] = 0;\n#if (UMAC_OUTPUT_LEN >= 8)\n    hc->state[1] = 0;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    hc->state[2] = 0;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    hc->state[3] = 0;\n#endif\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "nh_transform",
          "args": [
            "hc",
            "hc->data",
            "nh_len"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "nh_transform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "536-547",
          "snippet": "static void nh_transform(nh_ctx *hc, const UINT8 *buf, UINT32 nbytes)\n/* This function is a wrapper for the primitive NH hash functions. It takes\n * as argument \"hc\" the current hash context and a buffer which must be a\n * multiple of L1_PAD_BOUNDARY. The key passed to nh_aux is offset\n * appropriately according to how much message has been hashed already.\n */\n{\n    UINT8 *key;\n\n    key = hc->nh_key + hc->bytes_hashed;\n    nh_aux(key, buf, hc->state, nbytes);\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define L1_PAD_BOUNDARY      32     /* pad message to boundary multiple   */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define L1_PAD_BOUNDARY      32     /* pad message to boundary multiple   */\n\nstatic void nh_transform(nh_ctx *hc, const UINT8 *buf, UINT32 nbytes)\n/* This function is a wrapper for the primitive NH hash functions. It takes\n * as argument \"hc\" the current hash context and a buffer which must be a\n * multiple of L1_PAD_BOUNDARY. The key passed to nh_aux is offset\n * appropriately according to how much message has been hashed already.\n */\n{\n    UINT8 *key;\n\n    key = hc->nh_key + hc->bytes_hashed;\n    nh_aux(key, buf, hc->state, nbytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_pad",
          "args": [
            "hc->data",
            "L1_PAD_BOUNDARY"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "zero_pad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "642-662",
          "snippet": "static void zero_pad(UINT8 *p, int nbytes)\n{\n/* Write \"nbytes\" of zeroes, beginning at \"p\" */\n    if (nbytes >= (int)sizeof(UWORD)) {\n        while ((ptrdiff_t)p % sizeof(UWORD)) {\n            *p = 0;\n            nbytes--;\n            p++;\n        }\n        while (nbytes >= (int)sizeof(UWORD)) {\n            *(UWORD *)p = 0;\n            nbytes -= sizeof(UWORD);\n            p += sizeof(UWORD);\n        }\n    }\n    while (nbytes) {\n        *p = 0;\n        nbytes--;\n        p++;\n    }\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void zero_pad(UINT8 *p, int nbytes)\n{\n/* Write \"nbytes\" of zeroes, beginning at \"p\" */\n    if (nbytes >= (int)sizeof(UWORD)) {\n        while ((ptrdiff_t)p % sizeof(UWORD)) {\n            *p = 0;\n            nbytes--;\n            p++;\n        }\n        while (nbytes >= (int)sizeof(UWORD)) {\n            *(UWORD *)p = 0;\n            nbytes -= sizeof(UWORD);\n            p += sizeof(UWORD);\n        }\n    }\n    while (nbytes) {\n        *p = 0;\n        nbytes--;\n        p++;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define L1_PAD_BOUNDARY      32     /* pad message to boundary multiple   */\n#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */\n\nstatic void nh_final(nh_ctx *hc, UINT8 *result)\n/* After passing some number of data buffers to nh_update() for integration\n * into an NH context, nh_final is called to produce a hash result. If any\n * bytes are in the buffer hc->data, incorporate them into the\n * NH context. Finally, add into the NH accumulation \"state\" the total number\n * of bits hashed. The resulting numbers are written to the buffer \"result\".\n * If nh_update was never called, L1_PAD_BOUNDARY zeroes are incorporated.\n */\n{\n    int nh_len, nbits;\n\n    if (hc->next_data_empty != 0) {\n        nh_len = ((hc->next_data_empty + (L1_PAD_BOUNDARY - 1)) &\n                                                ~(L1_PAD_BOUNDARY - 1));\n        zero_pad(hc->data + hc->next_data_empty,\n                                          nh_len - hc->next_data_empty);\n        nh_transform(hc, hc->data, nh_len);\n        hc->bytes_hashed += hc->next_data_empty;\n    } else if (hc->bytes_hashed == 0) {\n\tnh_len = L1_PAD_BOUNDARY;\n        zero_pad(hc->data, L1_PAD_BOUNDARY);\n        nh_transform(hc, hc->data, nh_len);\n    }\n\n    nbits = (hc->bytes_hashed << 3);\n    ((UINT64 *)result)[0] = ((UINT64 *)hc->state)[0] + nbits;\n#if (UMAC_OUTPUT_LEN >= 8)\n    ((UINT64 *)result)[1] = ((UINT64 *)hc->state)[1] + nbits;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    ((UINT64 *)result)[2] = ((UINT64 *)hc->state)[2] + nbits;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    ((UINT64 *)result)[3] = ((UINT64 *)hc->state)[3] + nbits;\n#endif\n    nh_reset(hc);\n}"
  },
  {
    "function_name": "zero_pad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "642-662",
    "snippet": "static void zero_pad(UINT8 *p, int nbytes)\n{\n/* Write \"nbytes\" of zeroes, beginning at \"p\" */\n    if (nbytes >= (int)sizeof(UWORD)) {\n        while ((ptrdiff_t)p % sizeof(UWORD)) {\n            *p = 0;\n            nbytes--;\n            p++;\n        }\n        while (nbytes >= (int)sizeof(UWORD)) {\n            *(UWORD *)p = 0;\n            nbytes -= sizeof(UWORD);\n            p += sizeof(UWORD);\n        }\n    }\n    while (nbytes) {\n        *p = 0;\n        nbytes--;\n        p++;\n    }\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void zero_pad(UINT8 *p, int nbytes)\n{\n/* Write \"nbytes\" of zeroes, beginning at \"p\" */\n    if (nbytes >= (int)sizeof(UWORD)) {\n        while ((ptrdiff_t)p % sizeof(UWORD)) {\n            *p = 0;\n            nbytes--;\n            p++;\n        }\n        while (nbytes >= (int)sizeof(UWORD)) {\n            *(UWORD *)p = 0;\n            nbytes -= sizeof(UWORD);\n            p += sizeof(UWORD);\n        }\n    }\n    while (nbytes) {\n        *p = 0;\n        nbytes--;\n        p++;\n    }\n}"
  },
  {
    "function_name": "nh_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "611-638",
    "snippet": "static void nh_update(nh_ctx *hc, const UINT8 *buf, UINT32 nbytes)\n/* Incorporate nbytes of data into a nh_ctx, buffer whatever is not an    */\n/* even multiple of HASH_BUF_BYTES.                                       */\n{\n    UINT32 i,j;\n\n    j = hc->next_data_empty;\n    if ((j + nbytes) >= HASH_BUF_BYTES) {\n        if (j) {\n            i = HASH_BUF_BYTES - j;\n            memcpy(hc->data+j, buf, i);\n            nh_transform(hc,hc->data,HASH_BUF_BYTES);\n            nbytes -= i;\n            buf += i;\n            hc->bytes_hashed += HASH_BUF_BYTES;\n        }\n        if (nbytes >= HASH_BUF_BYTES) {\n            i = nbytes & ~(HASH_BUF_BYTES - 1);\n            nh_transform(hc, buf, i);\n            nbytes -= i;\n            buf += i;\n            hc->bytes_hashed += i;\n        }\n        j = 0;\n    }\n    memcpy(hc->data + j, buf, nbytes);\n    hc->next_data_empty = j + nbytes;\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define HASH_BUF_BYTES       64     /* nh_aux_hb buffer multiple          */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "hc->data + j",
            "buf",
            "nbytes"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nh_transform",
          "args": [
            "hc",
            "buf",
            "i"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "nh_transform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "536-547",
          "snippet": "static void nh_transform(nh_ctx *hc, const UINT8 *buf, UINT32 nbytes)\n/* This function is a wrapper for the primitive NH hash functions. It takes\n * as argument \"hc\" the current hash context and a buffer which must be a\n * multiple of L1_PAD_BOUNDARY. The key passed to nh_aux is offset\n * appropriately according to how much message has been hashed already.\n */\n{\n    UINT8 *key;\n\n    key = hc->nh_key + hc->bytes_hashed;\n    nh_aux(key, buf, hc->state, nbytes);\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define L1_PAD_BOUNDARY      32     /* pad message to boundary multiple   */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define L1_PAD_BOUNDARY      32     /* pad message to boundary multiple   */\n\nstatic void nh_transform(nh_ctx *hc, const UINT8 *buf, UINT32 nbytes)\n/* This function is a wrapper for the primitive NH hash functions. It takes\n * as argument \"hc\" the current hash context and a buffer which must be a\n * multiple of L1_PAD_BOUNDARY. The key passed to nh_aux is offset\n * appropriately according to how much message has been hashed already.\n */\n{\n    UINT8 *key;\n\n    key = hc->nh_key + hc->bytes_hashed;\n    nh_aux(key, buf, hc->state, nbytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "hc->data+j",
            "buf",
            "i"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define HASH_BUF_BYTES       64     /* nh_aux_hb buffer multiple          */\n\nstatic void nh_update(nh_ctx *hc, const UINT8 *buf, UINT32 nbytes)\n/* Incorporate nbytes of data into a nh_ctx, buffer whatever is not an    */\n/* even multiple of HASH_BUF_BYTES.                                       */\n{\n    UINT32 i,j;\n\n    j = hc->next_data_empty;\n    if ((j + nbytes) >= HASH_BUF_BYTES) {\n        if (j) {\n            i = HASH_BUF_BYTES - j;\n            memcpy(hc->data+j, buf, i);\n            nh_transform(hc,hc->data,HASH_BUF_BYTES);\n            nbytes -= i;\n            buf += i;\n            hc->bytes_hashed += HASH_BUF_BYTES;\n        }\n        if (nbytes >= HASH_BUF_BYTES) {\n            i = nbytes & ~(HASH_BUF_BYTES - 1);\n            nh_transform(hc, buf, i);\n            nbytes -= i;\n            buf += i;\n            hc->bytes_hashed += i;\n        }\n        j = 0;\n    }\n    memcpy(hc->data + j, buf, nbytes);\n    hc->next_data_empty = j + nbytes;\n}"
  },
  {
    "function_name": "nh_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "601-607",
    "snippet": "static void nh_init(nh_ctx *hc, aes_int_key prf_key)\n/* Generate nh_key, endian convert and reset to be ready for hashing.   */\n{\n    kdf(hc->nh_key, prf_key, 1, sizeof(hc->nh_key));\n    endian_convert_if_le(hc->nh_key, 4, sizeof(hc->nh_key));\n    nh_reset(hc);\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nh_reset",
          "args": [
            "hc"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "nh_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "581-597",
          "snippet": "static void nh_reset(nh_ctx *hc)\n/* Reset nh_ctx to ready for hashing of new data */\n{\n    hc->bytes_hashed = 0;\n    hc->next_data_empty = 0;\n    hc->state[0] = 0;\n#if (UMAC_OUTPUT_LEN >= 8)\n    hc->state[1] = 0;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    hc->state[2] = 0;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    hc->state[3] = 0;\n#endif\n\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */\n\nstatic void nh_reset(nh_ctx *hc)\n/* Reset nh_ctx to ready for hashing of new data */\n{\n    hc->bytes_hashed = 0;\n    hc->next_data_empty = 0;\n    hc->state[0] = 0;\n#if (UMAC_OUTPUT_LEN >= 8)\n    hc->state[1] = 0;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    hc->state[2] = 0;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    hc->state[3] = 0;\n#endif\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "endian_convert_if_le",
          "args": [
            "hc->nh_key",
            "4",
            "sizeof(hc->nh_key)"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdf",
          "args": [
            "hc->nh_key",
            "prf_key",
            "1",
            "sizeof(hc->nh_key)"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "kdf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "184-208",
          "snippet": "static void kdf(void *bufp, aes_int_key key, UINT8 ndx, int nbytes)\n{\n    UINT8 in_buf[AES_BLOCK_LEN] = {0};\n    UINT8 out_buf[AES_BLOCK_LEN];\n    UINT8 *dst_buf = (UINT8 *)bufp;\n    int i;\n\n    /* Setup the initial value */\n    in_buf[AES_BLOCK_LEN-9] = ndx;\n    in_buf[AES_BLOCK_LEN-1] = i = 1;\n\n    while (nbytes >= AES_BLOCK_LEN) {\n        aes_encryption(in_buf, out_buf, key);\n        memcpy(dst_buf,out_buf,AES_BLOCK_LEN);\n        in_buf[AES_BLOCK_LEN-1] = ++i;\n        nbytes -= AES_BLOCK_LEN;\n        dst_buf += AES_BLOCK_LEN;\n    }\n    if (nbytes) {\n        aes_encryption(in_buf, out_buf, key);\n        memcpy(dst_buf,out_buf,nbytes);\n    }\n    explicit_bzero(in_buf, sizeof(in_buf));\n    explicit_bzero(out_buf, sizeof(out_buf));\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define AES_BLOCK_LEN  16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define AES_BLOCK_LEN  16\n\nstatic void kdf(void *bufp, aes_int_key key, UINT8 ndx, int nbytes)\n{\n    UINT8 in_buf[AES_BLOCK_LEN] = {0};\n    UINT8 out_buf[AES_BLOCK_LEN];\n    UINT8 *dst_buf = (UINT8 *)bufp;\n    int i;\n\n    /* Setup the initial value */\n    in_buf[AES_BLOCK_LEN-9] = ndx;\n    in_buf[AES_BLOCK_LEN-1] = i = 1;\n\n    while (nbytes >= AES_BLOCK_LEN) {\n        aes_encryption(in_buf, out_buf, key);\n        memcpy(dst_buf,out_buf,AES_BLOCK_LEN);\n        in_buf[AES_BLOCK_LEN-1] = ++i;\n        nbytes -= AES_BLOCK_LEN;\n        dst_buf += AES_BLOCK_LEN;\n    }\n    if (nbytes) {\n        aes_encryption(in_buf, out_buf, key);\n        memcpy(dst_buf,out_buf,nbytes);\n    }\n    explicit_bzero(in_buf, sizeof(in_buf));\n    explicit_bzero(out_buf, sizeof(out_buf));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void nh_init(nh_ctx *hc, aes_int_key prf_key)\n/* Generate nh_key, endian convert and reset to be ready for hashing.   */\n{\n    kdf(hc->nh_key, prf_key, 1, sizeof(hc->nh_key));\n    endian_convert_if_le(hc->nh_key, 4, sizeof(hc->nh_key));\n    nh_reset(hc);\n}"
  },
  {
    "function_name": "nh_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "581-597",
    "snippet": "static void nh_reset(nh_ctx *hc)\n/* Reset nh_ctx to ready for hashing of new data */\n{\n    hc->bytes_hashed = 0;\n    hc->next_data_empty = 0;\n    hc->state[0] = 0;\n#if (UMAC_OUTPUT_LEN >= 8)\n    hc->state[1] = 0;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    hc->state[2] = 0;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    hc->state[3] = 0;\n#endif\n\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */\n\nstatic void nh_reset(nh_ctx *hc)\n/* Reset nh_ctx to ready for hashing of new data */\n{\n    hc->bytes_hashed = 0;\n    hc->next_data_empty = 0;\n    hc->state[0] = 0;\n#if (UMAC_OUTPUT_LEN >= 8)\n    hc->state[1] = 0;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    hc->state[2] = 0;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    hc->state[3] = 0;\n#endif\n\n}"
  },
  {
    "function_name": "endian_convert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "552-573",
    "snippet": "static void endian_convert(void *buf, UWORD bpw, UINT32 num_bytes)\n/* We endian convert the keys on little-endian computers to               */\n/* compensate for the lack of big-endian memory reads during hashing.     */\n{\n    UWORD iters = num_bytes / bpw;\n    if (bpw == 4) {\n        UINT32 *p = (UINT32 *)buf;\n        do {\n            *p = LOAD_UINT32_REVERSED(p);\n            p++;\n        } while (--iters);\n    } else if (bpw == 8) {\n        UINT32 *p = (UINT32 *)buf;\n        UINT32 t;\n        do {\n            t = LOAD_UINT32_REVERSED(p+1);\n            p[1] = LOAD_UINT32_REVERSED(p);\n            p[0] = t;\n            p += 2;\n        } while (--iters);\n    }\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LOAD_UINT32_REVERSED",
          "args": [
            "p"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_REVERSED",
          "args": [
            "p+1"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_REVERSED",
          "args": [
            "p"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void endian_convert(void *buf, UWORD bpw, UINT32 num_bytes)\n/* We endian convert the keys on little-endian computers to               */\n/* compensate for the lack of big-endian memory reads during hashing.     */\n{\n    UWORD iters = num_bytes / bpw;\n    if (bpw == 4) {\n        UINT32 *p = (UINT32 *)buf;\n        do {\n            *p = LOAD_UINT32_REVERSED(p);\n            p++;\n        } while (--iters);\n    } else if (bpw == 8) {\n        UINT32 *p = (UINT32 *)buf;\n        UINT32 t;\n        do {\n            t = LOAD_UINT32_REVERSED(p+1);\n            p[1] = LOAD_UINT32_REVERSED(p);\n            p[0] = t;\n            p += 2;\n        } while (--iters);\n    }\n}"
  },
  {
    "function_name": "nh_transform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "536-547",
    "snippet": "static void nh_transform(nh_ctx *hc, const UINT8 *buf, UINT32 nbytes)\n/* This function is a wrapper for the primitive NH hash functions. It takes\n * as argument \"hc\" the current hash context and a buffer which must be a\n * multiple of L1_PAD_BOUNDARY. The key passed to nh_aux is offset\n * appropriately according to how much message has been hashed already.\n */\n{\n    UINT8 *key;\n\n    key = hc->nh_key + hc->bytes_hashed;\n    nh_aux(key, buf, hc->state, nbytes);\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define L1_PAD_BOUNDARY      32     /* pad message to boundary multiple   */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nh_aux",
          "args": [
            "key",
            "buf",
            "hc->state",
            "nbytes"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "nh_aux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "467-527",
          "snippet": "static void nh_aux(void *kp, const void *dp, void *hp, UINT32 dlen)\n/* Same as previous nh_aux, but two streams are handled in one pass,\n * reading and writing 24 bytes of hash-state per call.\n*/\n{\n    UINT64 h1,h2,h3,h4;\n    UWORD c = dlen / 32;\n    UINT32 *k = (UINT32 *)kp;\n    const UINT32 *d = (const UINT32 *)dp;\n    UINT32 d0,d1,d2,d3,d4,d5,d6,d7;\n    UINT32 k0,k1,k2,k3,k4,k5,k6,k7,\n        k8,k9,k10,k11,k12,k13,k14,k15,\n        k16,k17,k18,k19;\n\n    h1 = *((UINT64 *)hp);\n    h2 = *((UINT64 *)hp + 1);\n    h3 = *((UINT64 *)hp + 2);\n    h4 = *((UINT64 *)hp + 3);\n    k0 = *(k+0); k1 = *(k+1); k2 = *(k+2); k3 = *(k+3);\n    k4 = *(k+4); k5 = *(k+5); k6 = *(k+6); k7 = *(k+7);\n    do {\n        d0 = LOAD_UINT32_LITTLE(d+0); d1 = LOAD_UINT32_LITTLE(d+1);\n        d2 = LOAD_UINT32_LITTLE(d+2); d3 = LOAD_UINT32_LITTLE(d+3);\n        d4 = LOAD_UINT32_LITTLE(d+4); d5 = LOAD_UINT32_LITTLE(d+5);\n        d6 = LOAD_UINT32_LITTLE(d+6); d7 = LOAD_UINT32_LITTLE(d+7);\n        k8 = *(k+8); k9 = *(k+9); k10 = *(k+10); k11 = *(k+11);\n        k12 = *(k+12); k13 = *(k+13); k14 = *(k+14); k15 = *(k+15);\n        k16 = *(k+16); k17 = *(k+17); k18 = *(k+18); k19 = *(k+19);\n\n        h1 += MUL64((k0 + d0), (k4 + d4));\n        h2 += MUL64((k4 + d0), (k8 + d4));\n        h3 += MUL64((k8 + d0), (k12 + d4));\n        h4 += MUL64((k12 + d0), (k16 + d4));\n\n        h1 += MUL64((k1 + d1), (k5 + d5));\n        h2 += MUL64((k5 + d1), (k9 + d5));\n        h3 += MUL64((k9 + d1), (k13 + d5));\n        h4 += MUL64((k13 + d1), (k17 + d5));\n\n        h1 += MUL64((k2 + d2), (k6 + d6));\n        h2 += MUL64((k6 + d2), (k10 + d6));\n        h3 += MUL64((k10 + d2), (k14 + d6));\n        h4 += MUL64((k14 + d2), (k18 + d6));\n\n        h1 += MUL64((k3 + d3), (k7 + d7));\n        h2 += MUL64((k7 + d3), (k11 + d7));\n        h3 += MUL64((k11 + d3), (k15 + d7));\n        h4 += MUL64((k15 + d3), (k19 + d7));\n\n        k0 = k8; k1 = k9; k2 = k10; k3 = k11;\n        k4 = k12; k5 = k13; k6 = k14; k7 = k15;\n        k8 = k16; k9 = k17; k10 = k18; k11 = k19;\n\n        d += 8;\n        k += 8;\n    } while (--c);\n    ((UINT64 *)hp)[0] = h1;\n    ((UINT64 *)hp)[1] = h2;\n    ((UINT64 *)hp)[2] = h3;\n    ((UINT64 *)hp)[3] = h4;\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void nh_aux(void *kp, const void *dp, void *hp, UINT32 dlen)\n/* Same as previous nh_aux, but two streams are handled in one pass,\n * reading and writing 24 bytes of hash-state per call.\n*/\n{\n    UINT64 h1,h2,h3,h4;\n    UWORD c = dlen / 32;\n    UINT32 *k = (UINT32 *)kp;\n    const UINT32 *d = (const UINT32 *)dp;\n    UINT32 d0,d1,d2,d3,d4,d5,d6,d7;\n    UINT32 k0,k1,k2,k3,k4,k5,k6,k7,\n        k8,k9,k10,k11,k12,k13,k14,k15,\n        k16,k17,k18,k19;\n\n    h1 = *((UINT64 *)hp);\n    h2 = *((UINT64 *)hp + 1);\n    h3 = *((UINT64 *)hp + 2);\n    h4 = *((UINT64 *)hp + 3);\n    k0 = *(k+0); k1 = *(k+1); k2 = *(k+2); k3 = *(k+3);\n    k4 = *(k+4); k5 = *(k+5); k6 = *(k+6); k7 = *(k+7);\n    do {\n        d0 = LOAD_UINT32_LITTLE(d+0); d1 = LOAD_UINT32_LITTLE(d+1);\n        d2 = LOAD_UINT32_LITTLE(d+2); d3 = LOAD_UINT32_LITTLE(d+3);\n        d4 = LOAD_UINT32_LITTLE(d+4); d5 = LOAD_UINT32_LITTLE(d+5);\n        d6 = LOAD_UINT32_LITTLE(d+6); d7 = LOAD_UINT32_LITTLE(d+7);\n        k8 = *(k+8); k9 = *(k+9); k10 = *(k+10); k11 = *(k+11);\n        k12 = *(k+12); k13 = *(k+13); k14 = *(k+14); k15 = *(k+15);\n        k16 = *(k+16); k17 = *(k+17); k18 = *(k+18); k19 = *(k+19);\n\n        h1 += MUL64((k0 + d0), (k4 + d4));\n        h2 += MUL64((k4 + d0), (k8 + d4));\n        h3 += MUL64((k8 + d0), (k12 + d4));\n        h4 += MUL64((k12 + d0), (k16 + d4));\n\n        h1 += MUL64((k1 + d1), (k5 + d5));\n        h2 += MUL64((k5 + d1), (k9 + d5));\n        h3 += MUL64((k9 + d1), (k13 + d5));\n        h4 += MUL64((k13 + d1), (k17 + d5));\n\n        h1 += MUL64((k2 + d2), (k6 + d6));\n        h2 += MUL64((k6 + d2), (k10 + d6));\n        h3 += MUL64((k10 + d2), (k14 + d6));\n        h4 += MUL64((k14 + d2), (k18 + d6));\n\n        h1 += MUL64((k3 + d3), (k7 + d7));\n        h2 += MUL64((k7 + d3), (k11 + d7));\n        h3 += MUL64((k11 + d3), (k15 + d7));\n        h4 += MUL64((k15 + d3), (k19 + d7));\n\n        k0 = k8; k1 = k9; k2 = k10; k3 = k11;\n        k4 = k12; k5 = k13; k6 = k14; k7 = k15;\n        k8 = k16; k9 = k17; k10 = k18; k11 = k19;\n\n        d += 8;\n        k += 8;\n    } while (--c);\n    ((UINT64 *)hp)[0] = h1;\n    ((UINT64 *)hp)[1] = h2;\n    ((UINT64 *)hp)[2] = h3;\n    ((UINT64 *)hp)[3] = h4;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define L1_PAD_BOUNDARY      32     /* pad message to boundary multiple   */\n\nstatic void nh_transform(nh_ctx *hc, const UINT8 *buf, UINT32 nbytes)\n/* This function is a wrapper for the primitive NH hash functions. It takes\n * as argument \"hc\" the current hash context and a buffer which must be a\n * multiple of L1_PAD_BOUNDARY. The key passed to nh_aux is offset\n * appropriately according to how much message has been hashed already.\n */\n{\n    UINT8 *key;\n\n    key = hc->nh_key + hc->bytes_hashed;\n    nh_aux(key, buf, hc->state, nbytes);\n}"
  },
  {
    "function_name": "nh_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "467-527",
    "snippet": "static void nh_aux(void *kp, const void *dp, void *hp, UINT32 dlen)\n/* Same as previous nh_aux, but two streams are handled in one pass,\n * reading and writing 24 bytes of hash-state per call.\n*/\n{\n    UINT64 h1,h2,h3,h4;\n    UWORD c = dlen / 32;\n    UINT32 *k = (UINT32 *)kp;\n    const UINT32 *d = (const UINT32 *)dp;\n    UINT32 d0,d1,d2,d3,d4,d5,d6,d7;\n    UINT32 k0,k1,k2,k3,k4,k5,k6,k7,\n        k8,k9,k10,k11,k12,k13,k14,k15,\n        k16,k17,k18,k19;\n\n    h1 = *((UINT64 *)hp);\n    h2 = *((UINT64 *)hp + 1);\n    h3 = *((UINT64 *)hp + 2);\n    h4 = *((UINT64 *)hp + 3);\n    k0 = *(k+0); k1 = *(k+1); k2 = *(k+2); k3 = *(k+3);\n    k4 = *(k+4); k5 = *(k+5); k6 = *(k+6); k7 = *(k+7);\n    do {\n        d0 = LOAD_UINT32_LITTLE(d+0); d1 = LOAD_UINT32_LITTLE(d+1);\n        d2 = LOAD_UINT32_LITTLE(d+2); d3 = LOAD_UINT32_LITTLE(d+3);\n        d4 = LOAD_UINT32_LITTLE(d+4); d5 = LOAD_UINT32_LITTLE(d+5);\n        d6 = LOAD_UINT32_LITTLE(d+6); d7 = LOAD_UINT32_LITTLE(d+7);\n        k8 = *(k+8); k9 = *(k+9); k10 = *(k+10); k11 = *(k+11);\n        k12 = *(k+12); k13 = *(k+13); k14 = *(k+14); k15 = *(k+15);\n        k16 = *(k+16); k17 = *(k+17); k18 = *(k+18); k19 = *(k+19);\n\n        h1 += MUL64((k0 + d0), (k4 + d4));\n        h2 += MUL64((k4 + d0), (k8 + d4));\n        h3 += MUL64((k8 + d0), (k12 + d4));\n        h4 += MUL64((k12 + d0), (k16 + d4));\n\n        h1 += MUL64((k1 + d1), (k5 + d5));\n        h2 += MUL64((k5 + d1), (k9 + d5));\n        h3 += MUL64((k9 + d1), (k13 + d5));\n        h4 += MUL64((k13 + d1), (k17 + d5));\n\n        h1 += MUL64((k2 + d2), (k6 + d6));\n        h2 += MUL64((k6 + d2), (k10 + d6));\n        h3 += MUL64((k10 + d2), (k14 + d6));\n        h4 += MUL64((k14 + d2), (k18 + d6));\n\n        h1 += MUL64((k3 + d3), (k7 + d7));\n        h2 += MUL64((k7 + d3), (k11 + d7));\n        h3 += MUL64((k11 + d3), (k15 + d7));\n        h4 += MUL64((k15 + d3), (k19 + d7));\n\n        k0 = k8; k1 = k9; k2 = k10; k3 = k11;\n        k4 = k12; k5 = k13; k6 = k14; k7 = k15;\n        k8 = k16; k9 = k17; k10 = k18; k11 = k19;\n\n        d += 8;\n        k += 8;\n    } while (--c);\n    ((UINT64 *)hp)[0] = h1;\n    ((UINT64 *)hp)[1] = h2;\n    ((UINT64 *)hp)[2] = h3;\n    ((UINT64 *)hp)[3] = h4;\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k15 + d3)",
            "(k19 + d7)"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k11 + d3)",
            "(k15 + d7)"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k7 + d3)",
            "(k11 + d7)"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k3 + d3)",
            "(k7 + d7)"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k14 + d2)",
            "(k18 + d6)"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k10 + d2)",
            "(k14 + d6)"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k6 + d2)",
            "(k10 + d6)"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k2 + d2)",
            "(k6 + d6)"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k13 + d1)",
            "(k17 + d5)"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k9 + d1)",
            "(k13 + d5)"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k5 + d1)",
            "(k9 + d5)"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k1 + d1)",
            "(k5 + d5)"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k12 + d0)",
            "(k16 + d4)"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k8 + d0)",
            "(k12 + d4)"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k4 + d0)",
            "(k8 + d4)"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k0 + d0)",
            "(k4 + d4)"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+7"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+6"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+5"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+4"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+3"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+2"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+1"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+0"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void nh_aux(void *kp, const void *dp, void *hp, UINT32 dlen)\n/* Same as previous nh_aux, but two streams are handled in one pass,\n * reading and writing 24 bytes of hash-state per call.\n*/\n{\n    UINT64 h1,h2,h3,h4;\n    UWORD c = dlen / 32;\n    UINT32 *k = (UINT32 *)kp;\n    const UINT32 *d = (const UINT32 *)dp;\n    UINT32 d0,d1,d2,d3,d4,d5,d6,d7;\n    UINT32 k0,k1,k2,k3,k4,k5,k6,k7,\n        k8,k9,k10,k11,k12,k13,k14,k15,\n        k16,k17,k18,k19;\n\n    h1 = *((UINT64 *)hp);\n    h2 = *((UINT64 *)hp + 1);\n    h3 = *((UINT64 *)hp + 2);\n    h4 = *((UINT64 *)hp + 3);\n    k0 = *(k+0); k1 = *(k+1); k2 = *(k+2); k3 = *(k+3);\n    k4 = *(k+4); k5 = *(k+5); k6 = *(k+6); k7 = *(k+7);\n    do {\n        d0 = LOAD_UINT32_LITTLE(d+0); d1 = LOAD_UINT32_LITTLE(d+1);\n        d2 = LOAD_UINT32_LITTLE(d+2); d3 = LOAD_UINT32_LITTLE(d+3);\n        d4 = LOAD_UINT32_LITTLE(d+4); d5 = LOAD_UINT32_LITTLE(d+5);\n        d6 = LOAD_UINT32_LITTLE(d+6); d7 = LOAD_UINT32_LITTLE(d+7);\n        k8 = *(k+8); k9 = *(k+9); k10 = *(k+10); k11 = *(k+11);\n        k12 = *(k+12); k13 = *(k+13); k14 = *(k+14); k15 = *(k+15);\n        k16 = *(k+16); k17 = *(k+17); k18 = *(k+18); k19 = *(k+19);\n\n        h1 += MUL64((k0 + d0), (k4 + d4));\n        h2 += MUL64((k4 + d0), (k8 + d4));\n        h3 += MUL64((k8 + d0), (k12 + d4));\n        h4 += MUL64((k12 + d0), (k16 + d4));\n\n        h1 += MUL64((k1 + d1), (k5 + d5));\n        h2 += MUL64((k5 + d1), (k9 + d5));\n        h3 += MUL64((k9 + d1), (k13 + d5));\n        h4 += MUL64((k13 + d1), (k17 + d5));\n\n        h1 += MUL64((k2 + d2), (k6 + d6));\n        h2 += MUL64((k6 + d2), (k10 + d6));\n        h3 += MUL64((k10 + d2), (k14 + d6));\n        h4 += MUL64((k14 + d2), (k18 + d6));\n\n        h1 += MUL64((k3 + d3), (k7 + d7));\n        h2 += MUL64((k7 + d3), (k11 + d7));\n        h3 += MUL64((k11 + d3), (k15 + d7));\n        h4 += MUL64((k15 + d3), (k19 + d7));\n\n        k0 = k8; k1 = k9; k2 = k10; k3 = k11;\n        k4 = k12; k5 = k13; k6 = k14; k7 = k15;\n        k8 = k16; k9 = k17; k10 = k18; k11 = k19;\n\n        d += 8;\n        k += 8;\n    } while (--c);\n    ((UINT64 *)hp)[0] = h1;\n    ((UINT64 *)hp)[1] = h2;\n    ((UINT64 *)hp)[2] = h3;\n    ((UINT64 *)hp)[3] = h4;\n}"
  },
  {
    "function_name": "nh_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "412-463",
    "snippet": "static void nh_aux(void *kp, const void *dp, void *hp, UINT32 dlen)\n/* Same as previous nh_aux, but two streams are handled in one pass,\n * reading and writing 24 bytes of hash-state per call.\n*/\n{\n    UINT64 h1,h2,h3;\n    UWORD c = dlen / 32;\n    UINT32 *k = (UINT32 *)kp;\n    const UINT32 *d = (const UINT32 *)dp;\n    UINT32 d0,d1,d2,d3,d4,d5,d6,d7;\n    UINT32 k0,k1,k2,k3,k4,k5,k6,k7,\n        k8,k9,k10,k11,k12,k13,k14,k15;\n\n    h1 = *((UINT64 *)hp);\n    h2 = *((UINT64 *)hp + 1);\n    h3 = *((UINT64 *)hp + 2);\n    k0 = *(k+0); k1 = *(k+1); k2 = *(k+2); k3 = *(k+3);\n    k4 = *(k+4); k5 = *(k+5); k6 = *(k+6); k7 = *(k+7);\n    do {\n        d0 = LOAD_UINT32_LITTLE(d+0); d1 = LOAD_UINT32_LITTLE(d+1);\n        d2 = LOAD_UINT32_LITTLE(d+2); d3 = LOAD_UINT32_LITTLE(d+3);\n        d4 = LOAD_UINT32_LITTLE(d+4); d5 = LOAD_UINT32_LITTLE(d+5);\n        d6 = LOAD_UINT32_LITTLE(d+6); d7 = LOAD_UINT32_LITTLE(d+7);\n        k8 = *(k+8); k9 = *(k+9); k10 = *(k+10); k11 = *(k+11);\n        k12 = *(k+12); k13 = *(k+13); k14 = *(k+14); k15 = *(k+15);\n\n        h1 += MUL64((k0 + d0), (k4 + d4));\n        h2 += MUL64((k4 + d0), (k8 + d4));\n        h3 += MUL64((k8 + d0), (k12 + d4));\n\n        h1 += MUL64((k1 + d1), (k5 + d5));\n        h2 += MUL64((k5 + d1), (k9 + d5));\n        h3 += MUL64((k9 + d1), (k13 + d5));\n\n        h1 += MUL64((k2 + d2), (k6 + d6));\n        h2 += MUL64((k6 + d2), (k10 + d6));\n        h3 += MUL64((k10 + d2), (k14 + d6));\n\n        h1 += MUL64((k3 + d3), (k7 + d7));\n        h2 += MUL64((k7 + d3), (k11 + d7));\n        h3 += MUL64((k11 + d3), (k15 + d7));\n\n        k0 = k8; k1 = k9; k2 = k10; k3 = k11;\n        k4 = k12; k5 = k13; k6 = k14; k7 = k15;\n\n        d += 8;\n        k += 8;\n    } while (--c);\n    ((UINT64 *)hp)[0] = h1;\n    ((UINT64 *)hp)[1] = h2;\n    ((UINT64 *)hp)[2] = h3;\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k11 + d3)",
            "(k15 + d7)"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k7 + d3)",
            "(k11 + d7)"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k3 + d3)",
            "(k7 + d7)"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k10 + d2)",
            "(k14 + d6)"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k6 + d2)",
            "(k10 + d6)"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k2 + d2)",
            "(k6 + d6)"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k9 + d1)",
            "(k13 + d5)"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k5 + d1)",
            "(k9 + d5)"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k1 + d1)",
            "(k5 + d5)"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k8 + d0)",
            "(k12 + d4)"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k4 + d0)",
            "(k8 + d4)"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k0 + d0)",
            "(k4 + d4)"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+7"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+6"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+5"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+4"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+3"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+2"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+1"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+0"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void nh_aux(void *kp, const void *dp, void *hp, UINT32 dlen)\n/* Same as previous nh_aux, but two streams are handled in one pass,\n * reading and writing 24 bytes of hash-state per call.\n*/\n{\n    UINT64 h1,h2,h3;\n    UWORD c = dlen / 32;\n    UINT32 *k = (UINT32 *)kp;\n    const UINT32 *d = (const UINT32 *)dp;\n    UINT32 d0,d1,d2,d3,d4,d5,d6,d7;\n    UINT32 k0,k1,k2,k3,k4,k5,k6,k7,\n        k8,k9,k10,k11,k12,k13,k14,k15;\n\n    h1 = *((UINT64 *)hp);\n    h2 = *((UINT64 *)hp + 1);\n    h3 = *((UINT64 *)hp + 2);\n    k0 = *(k+0); k1 = *(k+1); k2 = *(k+2); k3 = *(k+3);\n    k4 = *(k+4); k5 = *(k+5); k6 = *(k+6); k7 = *(k+7);\n    do {\n        d0 = LOAD_UINT32_LITTLE(d+0); d1 = LOAD_UINT32_LITTLE(d+1);\n        d2 = LOAD_UINT32_LITTLE(d+2); d3 = LOAD_UINT32_LITTLE(d+3);\n        d4 = LOAD_UINT32_LITTLE(d+4); d5 = LOAD_UINT32_LITTLE(d+5);\n        d6 = LOAD_UINT32_LITTLE(d+6); d7 = LOAD_UINT32_LITTLE(d+7);\n        k8 = *(k+8); k9 = *(k+9); k10 = *(k+10); k11 = *(k+11);\n        k12 = *(k+12); k13 = *(k+13); k14 = *(k+14); k15 = *(k+15);\n\n        h1 += MUL64((k0 + d0), (k4 + d4));\n        h2 += MUL64((k4 + d0), (k8 + d4));\n        h3 += MUL64((k8 + d0), (k12 + d4));\n\n        h1 += MUL64((k1 + d1), (k5 + d5));\n        h2 += MUL64((k5 + d1), (k9 + d5));\n        h3 += MUL64((k9 + d1), (k13 + d5));\n\n        h1 += MUL64((k2 + d2), (k6 + d6));\n        h2 += MUL64((k6 + d2), (k10 + d6));\n        h3 += MUL64((k10 + d2), (k14 + d6));\n\n        h1 += MUL64((k3 + d3), (k7 + d7));\n        h2 += MUL64((k7 + d3), (k11 + d7));\n        h3 += MUL64((k11 + d3), (k15 + d7));\n\n        k0 = k8; k1 = k9; k2 = k10; k3 = k11;\n        k4 = k12; k5 = k13; k6 = k14; k7 = k15;\n\n        d += 8;\n        k += 8;\n    } while (--c);\n    ((UINT64 *)hp)[0] = h1;\n    ((UINT64 *)hp)[1] = h2;\n    ((UINT64 *)hp)[2] = h3;\n}"
  },
  {
    "function_name": "nh_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "365-408",
    "snippet": "static void nh_aux(void *kp, const void *dp, void *hp, UINT32 dlen)\n/* Same as previous nh_aux, but two streams are handled in one pass,\n * reading and writing 16 bytes of hash-state per call.\n */\n{\n  UINT64 h1,h2;\n  UWORD c = dlen / 32;\n  UINT32 *k = (UINT32 *)kp;\n  const UINT32 *d = (const UINT32 *)dp;\n  UINT32 d0,d1,d2,d3,d4,d5,d6,d7;\n  UINT32 k0,k1,k2,k3,k4,k5,k6,k7,\n        k8,k9,k10,k11;\n\n  h1 = *((UINT64 *)hp);\n  h2 = *((UINT64 *)hp + 1);\n  k0 = *(k+0); k1 = *(k+1); k2 = *(k+2); k3 = *(k+3);\n  do {\n    d0 = LOAD_UINT32_LITTLE(d+0); d1 = LOAD_UINT32_LITTLE(d+1);\n    d2 = LOAD_UINT32_LITTLE(d+2); d3 = LOAD_UINT32_LITTLE(d+3);\n    d4 = LOAD_UINT32_LITTLE(d+4); d5 = LOAD_UINT32_LITTLE(d+5);\n    d6 = LOAD_UINT32_LITTLE(d+6); d7 = LOAD_UINT32_LITTLE(d+7);\n    k4 = *(k+4); k5 = *(k+5); k6 = *(k+6); k7 = *(k+7);\n    k8 = *(k+8); k9 = *(k+9); k10 = *(k+10); k11 = *(k+11);\n\n    h1 += MUL64((k0 + d0), (k4 + d4));\n    h2 += MUL64((k4 + d0), (k8 + d4));\n\n    h1 += MUL64((k1 + d1), (k5 + d5));\n    h2 += MUL64((k5 + d1), (k9 + d5));\n\n    h1 += MUL64((k2 + d2), (k6 + d6));\n    h2 += MUL64((k6 + d2), (k10 + d6));\n\n    h1 += MUL64((k3 + d3), (k7 + d7));\n    h2 += MUL64((k7 + d3), (k11 + d7));\n\n    k0 = k8; k1 = k9; k2 = k10; k3 = k11;\n\n    d += 8;\n    k += 8;\n  } while (--c);\n  ((UINT64 *)hp)[0] = h1;\n  ((UINT64 *)hp)[1] = h2;\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k7 + d3)",
            "(k11 + d7)"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k3 + d3)",
            "(k7 + d7)"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k6 + d2)",
            "(k10 + d6)"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k2 + d2)",
            "(k6 + d6)"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k5 + d1)",
            "(k9 + d5)"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k1 + d1)",
            "(k5 + d5)"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k4 + d0)",
            "(k8 + d4)"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k0 + d0)",
            "(k4 + d4)"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+7"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+6"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+5"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+4"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+3"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+2"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+1"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+0"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void nh_aux(void *kp, const void *dp, void *hp, UINT32 dlen)\n/* Same as previous nh_aux, but two streams are handled in one pass,\n * reading and writing 16 bytes of hash-state per call.\n */\n{\n  UINT64 h1,h2;\n  UWORD c = dlen / 32;\n  UINT32 *k = (UINT32 *)kp;\n  const UINT32 *d = (const UINT32 *)dp;\n  UINT32 d0,d1,d2,d3,d4,d5,d6,d7;\n  UINT32 k0,k1,k2,k3,k4,k5,k6,k7,\n        k8,k9,k10,k11;\n\n  h1 = *((UINT64 *)hp);\n  h2 = *((UINT64 *)hp + 1);\n  k0 = *(k+0); k1 = *(k+1); k2 = *(k+2); k3 = *(k+3);\n  do {\n    d0 = LOAD_UINT32_LITTLE(d+0); d1 = LOAD_UINT32_LITTLE(d+1);\n    d2 = LOAD_UINT32_LITTLE(d+2); d3 = LOAD_UINT32_LITTLE(d+3);\n    d4 = LOAD_UINT32_LITTLE(d+4); d5 = LOAD_UINT32_LITTLE(d+5);\n    d6 = LOAD_UINT32_LITTLE(d+6); d7 = LOAD_UINT32_LITTLE(d+7);\n    k4 = *(k+4); k5 = *(k+5); k6 = *(k+6); k7 = *(k+7);\n    k8 = *(k+8); k9 = *(k+9); k10 = *(k+10); k11 = *(k+11);\n\n    h1 += MUL64((k0 + d0), (k4 + d4));\n    h2 += MUL64((k4 + d0), (k8 + d4));\n\n    h1 += MUL64((k1 + d1), (k5 + d5));\n    h2 += MUL64((k5 + d1), (k9 + d5));\n\n    h1 += MUL64((k2 + d2), (k6 + d6));\n    h2 += MUL64((k6 + d2), (k10 + d6));\n\n    h1 += MUL64((k3 + d3), (k7 + d7));\n    h2 += MUL64((k7 + d3), (k11 + d7));\n\n    k0 = k8; k1 = k9; k2 = k10; k3 = k11;\n\n    d += 8;\n    k += 8;\n  } while (--c);\n  ((UINT64 *)hp)[0] = h1;\n  ((UINT64 *)hp)[1] = h2;\n}"
  },
  {
    "function_name": "nh_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "330-361",
    "snippet": "static void nh_aux(void *kp, const void *dp, void *hp, UINT32 dlen)\n/* NH hashing primitive. Previous (partial) hash result is loaded and\n* then stored via hp pointer. The length of the data pointed at by \"dp\",\n* \"dlen\", is guaranteed to be divisible by L1_PAD_BOUNDARY (32).  Key\n* is expected to be endian compensated in memory at key setup.\n*/\n{\n    UINT64 h;\n    UWORD c = dlen / 32;\n    UINT32 *k = (UINT32 *)kp;\n    const UINT32 *d = (const UINT32 *)dp;\n    UINT32 d0,d1,d2,d3,d4,d5,d6,d7;\n    UINT32 k0,k1,k2,k3,k4,k5,k6,k7;\n\n    h = *((UINT64 *)hp);\n    do {\n        d0 = LOAD_UINT32_LITTLE(d+0); d1 = LOAD_UINT32_LITTLE(d+1);\n        d2 = LOAD_UINT32_LITTLE(d+2); d3 = LOAD_UINT32_LITTLE(d+3);\n        d4 = LOAD_UINT32_LITTLE(d+4); d5 = LOAD_UINT32_LITTLE(d+5);\n        d6 = LOAD_UINT32_LITTLE(d+6); d7 = LOAD_UINT32_LITTLE(d+7);\n        k0 = *(k+0); k1 = *(k+1); k2 = *(k+2); k3 = *(k+3);\n        k4 = *(k+4); k5 = *(k+5); k6 = *(k+6); k7 = *(k+7);\n        h += MUL64((k0 + d0), (k4 + d4));\n        h += MUL64((k1 + d1), (k5 + d5));\n        h += MUL64((k2 + d2), (k6 + d6));\n        h += MUL64((k3 + d3), (k7 + d7));\n\n        d += 8;\n        k += 8;\n    } while (--c);\n  *((UINT64 *)hp) = h;\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define L1_PAD_BOUNDARY      32     /* pad message to boundary multiple   */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k3 + d3)",
            "(k7 + d7)"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k2 + d2)",
            "(k6 + d6)"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k1 + d1)",
            "(k5 + d5)"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MUL64",
          "args": [
            "(k0 + d0)",
            "(k4 + d4)"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+7"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+6"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+5"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+4"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+3"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+2"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+1"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_UINT32_LITTLE",
          "args": [
            "d+0"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define L1_PAD_BOUNDARY      32     /* pad message to boundary multiple   */\n\nstatic void nh_aux(void *kp, const void *dp, void *hp, UINT32 dlen)\n/* NH hashing primitive. Previous (partial) hash result is loaded and\n* then stored via hp pointer. The length of the data pointed at by \"dp\",\n* \"dlen\", is guaranteed to be divisible by L1_PAD_BOUNDARY (32).  Key\n* is expected to be endian compensated in memory at key setup.\n*/\n{\n    UINT64 h;\n    UWORD c = dlen / 32;\n    UINT32 *k = (UINT32 *)kp;\n    const UINT32 *d = (const UINT32 *)dp;\n    UINT32 d0,d1,d2,d3,d4,d5,d6,d7;\n    UINT32 k0,k1,k2,k3,k4,k5,k6,k7;\n\n    h = *((UINT64 *)hp);\n    do {\n        d0 = LOAD_UINT32_LITTLE(d+0); d1 = LOAD_UINT32_LITTLE(d+1);\n        d2 = LOAD_UINT32_LITTLE(d+2); d3 = LOAD_UINT32_LITTLE(d+3);\n        d4 = LOAD_UINT32_LITTLE(d+4); d5 = LOAD_UINT32_LITTLE(d+5);\n        d6 = LOAD_UINT32_LITTLE(d+6); d7 = LOAD_UINT32_LITTLE(d+7);\n        k0 = *(k+0); k1 = *(k+1); k2 = *(k+2); k3 = *(k+3);\n        k4 = *(k+4); k5 = *(k+5); k6 = *(k+6); k7 = *(k+7);\n        h += MUL64((k0 + d0), (k4 + d4));\n        h += MUL64((k1 + d1), (k5 + d5));\n        h += MUL64((k2 + d2), (k6 + d6));\n        h += MUL64((k3 + d3), (k7 + d7));\n\n        d += 8;\n        k += 8;\n    } while (--c);\n  *((UINT64 *)hp) = h;\n}"
  },
  {
    "function_name": "pdf_gen_xor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "235-278",
    "snippet": "static void pdf_gen_xor(pdf_ctx *pc, const UINT8 nonce[8], UINT8 buf[8])\n{\n    /* 'ndx' indicates that we'll be using the 0th or 1st eight bytes\n     * of the AES output. If last time around we returned the ndx-1st\n     * element, then we may have the result in the cache already.\n     */\n\n#if (UMAC_OUTPUT_LEN == 4)\n#define LOW_BIT_MASK 3\n#elif (UMAC_OUTPUT_LEN == 8)\n#define LOW_BIT_MASK 1\n#elif (UMAC_OUTPUT_LEN > 8)\n#define LOW_BIT_MASK 0\n#endif\n    union {\n        UINT8 tmp_nonce_lo[4];\n        UINT32 align;\n    } t;\n#if LOW_BIT_MASK != 0\n    int ndx = nonce[7] & LOW_BIT_MASK;\n#endif\n    *(UINT32 *)t.tmp_nonce_lo = ((const UINT32 *)nonce)[1];\n    t.tmp_nonce_lo[3] &= ~LOW_BIT_MASK; /* zero last bit */\n\n    if ( (((UINT32 *)t.tmp_nonce_lo)[0] != ((UINT32 *)pc->nonce)[1]) ||\n         (((const UINT32 *)nonce)[0] != ((UINT32 *)pc->nonce)[0]) )\n    {\n        ((UINT32 *)pc->nonce)[0] = ((const UINT32 *)nonce)[0];\n        ((UINT32 *)pc->nonce)[1] = ((UINT32 *)t.tmp_nonce_lo)[0];\n        aes_encryption(pc->nonce, pc->cache, pc->prf_key);\n    }\n\n#if (UMAC_OUTPUT_LEN == 4)\n    *((UINT32 *)buf) ^= ((UINT32 *)pc->cache)[ndx];\n#elif (UMAC_OUTPUT_LEN == 8)\n    *((UINT64 *)buf) ^= ((UINT64 *)pc->cache)[ndx];\n#elif (UMAC_OUTPUT_LEN == 12)\n    ((UINT64 *)buf)[0] ^= ((UINT64 *)pc->cache)[0];\n    ((UINT32 *)buf)[2] ^= ((UINT32 *)pc->cache)[2];\n#elif (UMAC_OUTPUT_LEN == 16)\n    ((UINT64 *)buf)[0] ^= ((UINT64 *)pc->cache)[0];\n    ((UINT64 *)buf)[1] ^= ((UINT64 *)pc->cache)[1];\n#endif\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define LOW_BIT_MASK 0",
      "#define LOW_BIT_MASK 1",
      "#define LOW_BIT_MASK 3",
      "#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aes_encryption",
          "args": [
            "pc->nonce",
            "pc->cache",
            "pc->prf_key"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define LOW_BIT_MASK 0\n#define LOW_BIT_MASK 1\n#define LOW_BIT_MASK 3\n#define UMAC_OUTPUT_LEN     8  /* Alowable: 4, 8, 12, 16                  */\n\nstatic void pdf_gen_xor(pdf_ctx *pc, const UINT8 nonce[8], UINT8 buf[8])\n{\n    /* 'ndx' indicates that we'll be using the 0th or 1st eight bytes\n     * of the AES output. If last time around we returned the ndx-1st\n     * element, then we may have the result in the cache already.\n     */\n\n#if (UMAC_OUTPUT_LEN == 4)\n#define LOW_BIT_MASK 3\n#elif (UMAC_OUTPUT_LEN == 8)\n#define LOW_BIT_MASK 1\n#elif (UMAC_OUTPUT_LEN > 8)\n#define LOW_BIT_MASK 0\n#endif\n    union {\n        UINT8 tmp_nonce_lo[4];\n        UINT32 align;\n    } t;\n#if LOW_BIT_MASK != 0\n    int ndx = nonce[7] & LOW_BIT_MASK;\n#endif\n    *(UINT32 *)t.tmp_nonce_lo = ((const UINT32 *)nonce)[1];\n    t.tmp_nonce_lo[3] &= ~LOW_BIT_MASK; /* zero last bit */\n\n    if ( (((UINT32 *)t.tmp_nonce_lo)[0] != ((UINT32 *)pc->nonce)[1]) ||\n         (((const UINT32 *)nonce)[0] != ((UINT32 *)pc->nonce)[0]) )\n    {\n        ((UINT32 *)pc->nonce)[0] = ((const UINT32 *)nonce)[0];\n        ((UINT32 *)pc->nonce)[1] = ((UINT32 *)t.tmp_nonce_lo)[0];\n        aes_encryption(pc->nonce, pc->cache, pc->prf_key);\n    }\n\n#if (UMAC_OUTPUT_LEN == 4)\n    *((UINT32 *)buf) ^= ((UINT32 *)pc->cache)[ndx];\n#elif (UMAC_OUTPUT_LEN == 8)\n    *((UINT64 *)buf) ^= ((UINT64 *)pc->cache)[ndx];\n#elif (UMAC_OUTPUT_LEN == 12)\n    ((UINT64 *)buf)[0] ^= ((UINT64 *)pc->cache)[0];\n    ((UINT32 *)buf)[2] ^= ((UINT32 *)pc->cache)[2];\n#elif (UMAC_OUTPUT_LEN == 16)\n    ((UINT64 *)buf)[0] ^= ((UINT64 *)pc->cache)[0];\n    ((UINT64 *)buf)[1] ^= ((UINT64 *)pc->cache)[1];\n#endif\n}"
  },
  {
    "function_name": "pdf_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "222-233",
    "snippet": "static void pdf_init(pdf_ctx *pc, aes_int_key prf_key)\n{\n    UINT8 buf[UMAC_KEY_LEN];\n\n    kdf(buf, prf_key, 0, UMAC_KEY_LEN);\n    aes_key_setup(buf, pc->prf_key);\n\n    /* Initialize pdf and cache */\n    memset(pc->nonce, 0, sizeof(pc->nonce));\n    aes_encryption(pc->nonce, pc->cache, pc->prf_key);\n    explicit_bzero(buf, sizeof(buf));\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define UMAC_KEY_LEN           16  /* UMAC takes 16 bytes of external key */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "buf",
            "sizeof(buf)"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aes_encryption",
          "args": [
            "pc->nonce",
            "pc->cache",
            "pc->prf_key"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pc->nonce",
            "0",
            "sizeof(pc->nonce)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aes_key_setup",
          "args": [
            "buf",
            "pc->prf_key"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdf",
          "args": [
            "buf",
            "prf_key",
            "0",
            "UMAC_KEY_LEN"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "kdf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
          "lines": "184-208",
          "snippet": "static void kdf(void *bufp, aes_int_key key, UINT8 ndx, int nbytes)\n{\n    UINT8 in_buf[AES_BLOCK_LEN] = {0};\n    UINT8 out_buf[AES_BLOCK_LEN];\n    UINT8 *dst_buf = (UINT8 *)bufp;\n    int i;\n\n    /* Setup the initial value */\n    in_buf[AES_BLOCK_LEN-9] = ndx;\n    in_buf[AES_BLOCK_LEN-1] = i = 1;\n\n    while (nbytes >= AES_BLOCK_LEN) {\n        aes_encryption(in_buf, out_buf, key);\n        memcpy(dst_buf,out_buf,AES_BLOCK_LEN);\n        in_buf[AES_BLOCK_LEN-1] = ++i;\n        nbytes -= AES_BLOCK_LEN;\n        dst_buf += AES_BLOCK_LEN;\n    }\n    if (nbytes) {\n        aes_encryption(in_buf, out_buf, key);\n        memcpy(dst_buf,out_buf,nbytes);\n    }\n    explicit_bzero(in_buf, sizeof(in_buf));\n    explicit_bzero(out_buf, sizeof(out_buf));\n}",
          "includes": [
            "#include \"rijndael.h\"",
            "# include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"misc.h\"",
            "#include \"umac.h\"",
            "#include \"xmalloc.h\"",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define AES_BLOCK_LEN  16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define AES_BLOCK_LEN  16\n\nstatic void kdf(void *bufp, aes_int_key key, UINT8 ndx, int nbytes)\n{\n    UINT8 in_buf[AES_BLOCK_LEN] = {0};\n    UINT8 out_buf[AES_BLOCK_LEN];\n    UINT8 *dst_buf = (UINT8 *)bufp;\n    int i;\n\n    /* Setup the initial value */\n    in_buf[AES_BLOCK_LEN-9] = ndx;\n    in_buf[AES_BLOCK_LEN-1] = i = 1;\n\n    while (nbytes >= AES_BLOCK_LEN) {\n        aes_encryption(in_buf, out_buf, key);\n        memcpy(dst_buf,out_buf,AES_BLOCK_LEN);\n        in_buf[AES_BLOCK_LEN-1] = ++i;\n        nbytes -= AES_BLOCK_LEN;\n        dst_buf += AES_BLOCK_LEN;\n    }\n    if (nbytes) {\n        aes_encryption(in_buf, out_buf, key);\n        memcpy(dst_buf,out_buf,nbytes);\n    }\n    explicit_bzero(in_buf, sizeof(in_buf));\n    explicit_bzero(out_buf, sizeof(out_buf));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define UMAC_KEY_LEN           16  /* UMAC takes 16 bytes of external key */\n\nstatic void pdf_init(pdf_ctx *pc, aes_int_key prf_key)\n{\n    UINT8 buf[UMAC_KEY_LEN];\n\n    kdf(buf, prf_key, 0, UMAC_KEY_LEN);\n    aes_key_setup(buf, pc->prf_key);\n\n    /* Initialize pdf and cache */\n    memset(pc->nonce, 0, sizeof(pc->nonce));\n    aes_encryption(pc->nonce, pc->cache, pc->prf_key);\n    explicit_bzero(buf, sizeof(buf));\n}"
  },
  {
    "function_name": "kdf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/umac.c",
    "lines": "184-208",
    "snippet": "static void kdf(void *bufp, aes_int_key key, UINT8 ndx, int nbytes)\n{\n    UINT8 in_buf[AES_BLOCK_LEN] = {0};\n    UINT8 out_buf[AES_BLOCK_LEN];\n    UINT8 *dst_buf = (UINT8 *)bufp;\n    int i;\n\n    /* Setup the initial value */\n    in_buf[AES_BLOCK_LEN-9] = ndx;\n    in_buf[AES_BLOCK_LEN-1] = i = 1;\n\n    while (nbytes >= AES_BLOCK_LEN) {\n        aes_encryption(in_buf, out_buf, key);\n        memcpy(dst_buf,out_buf,AES_BLOCK_LEN);\n        in_buf[AES_BLOCK_LEN-1] = ++i;\n        nbytes -= AES_BLOCK_LEN;\n        dst_buf += AES_BLOCK_LEN;\n    }\n    if (nbytes) {\n        aes_encryption(in_buf, out_buf, key);\n        memcpy(dst_buf,out_buf,nbytes);\n    }\n    explicit_bzero(in_buf, sizeof(in_buf));\n    explicit_bzero(out_buf, sizeof(out_buf));\n}",
    "includes": [
      "#include \"rijndael.h\"",
      "# include <openssl/aes.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"misc.h\"",
      "#include \"umac.h\"",
      "#include \"xmalloc.h\"",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define AES_BLOCK_LEN  16"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "out_buf",
            "sizeof(out_buf)"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst_buf",
            "out_buf",
            "nbytes"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aes_encryption",
          "args": [
            "in_buf",
            "out_buf",
            "key"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst_buf",
            "out_buf",
            "AES_BLOCK_LEN"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aes_encryption",
          "args": [
            "in_buf",
            "out_buf",
            "key"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rijndael.h\"\n# include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"misc.h\"\n#include \"umac.h\"\n#include \"xmalloc.h\"\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define AES_BLOCK_LEN  16\n\nstatic void kdf(void *bufp, aes_int_key key, UINT8 ndx, int nbytes)\n{\n    UINT8 in_buf[AES_BLOCK_LEN] = {0};\n    UINT8 out_buf[AES_BLOCK_LEN];\n    UINT8 *dst_buf = (UINT8 *)bufp;\n    int i;\n\n    /* Setup the initial value */\n    in_buf[AES_BLOCK_LEN-9] = ndx;\n    in_buf[AES_BLOCK_LEN-1] = i = 1;\n\n    while (nbytes >= AES_BLOCK_LEN) {\n        aes_encryption(in_buf, out_buf, key);\n        memcpy(dst_buf,out_buf,AES_BLOCK_LEN);\n        in_buf[AES_BLOCK_LEN-1] = ++i;\n        nbytes -= AES_BLOCK_LEN;\n        dst_buf += AES_BLOCK_LEN;\n    }\n    if (nbytes) {\n        aes_encryption(in_buf, out_buf, key);\n        memcpy(dst_buf,out_buf,nbytes);\n    }\n    explicit_bzero(in_buf, sizeof(in_buf));\n    explicit_bzero(out_buf, sizeof(out_buf));\n}"
  }
]