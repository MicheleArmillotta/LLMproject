[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "1065-1339",
    "snippet": "int\nmain(int ac, char **av)\n{\n\tint c_flag = 0, d_flag = 0, D_flag = 0, k_flag = 0, s_flag = 0;\n\tint sock, fd, ch, result, saved_errno;\n\tchar *shell, *format, *pidstr, *agentsocket = NULL;\n#ifdef HAVE_SETRLIMIT\n\tstruct rlimit rlim;\n#endif\n\textern int optind;\n\textern char *optarg;\n\tpid_t pid;\n\tchar pidstrbuf[1 + 3 * sizeof pid];\n\tsize_t len;\n\tmode_t prev_mask;\n\tint timeout = -1; /* INFTIM */\n\tstruct pollfd *pfd = NULL;\n\tsize_t npfd = 0;\n\tu_int maxfds;\n\n\tssh_malloc_init();\t/* must be called before any mallocs */\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\t/* drop */\n\tsetegid(getgid());\n\tsetgid(getgid());\n\n\tplatform_disable_tracing(0);\t/* strict=no */\n\n\tif (getrlimit(RLIMIT_NOFILE, &rlim) == -1)\n\t\tfatal(\"%s: getrlimit: %s\", __progname, strerror(errno));\n\n#ifdef WITH_OPENSSL\n\tOpenSSL_add_all_algorithms();\n#endif\n\n\t__progname = ssh_get_progname(av[0]);\n\tseed_rng();\n\n\twhile ((ch = getopt(ac, av, \"cDdksE:a:P:t:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'E':\n\t\t\tfingerprint_hash = ssh_digest_alg_by_name(optarg);\n\t\t\tif (fingerprint_hash == -1)\n\t\t\t\tfatal(\"Invalid hash algorithm \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tif (s_flag)\n\t\t\t\tusage();\n\t\t\tc_flag++;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tk_flag++;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (pkcs11_whitelist != NULL)\n\t\t\t\tfatal(\"-P option already specified\");\n\t\t\tpkcs11_whitelist = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (c_flag)\n\t\t\t\tusage();\n\t\t\ts_flag++;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\td_flag++;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\tD_flag++;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tagentsocket = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif ((lifetime = convtime(optarg)) == -1) {\n\t\t\t\tfprintf(stderr, \"Invalid lifetime\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\tac -= optind;\n\tav += optind;\n\n\tif (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))\n\t\tusage();\n\n\tif (pkcs11_whitelist == NULL)\n\t\tpkcs11_whitelist = xstrdup(DEFAULT_PKCS11_WHITELIST);\n\n\tif (ac == 0 && !c_flag && !s_flag) {\n\t\tshell = getenv(\"SHELL\");\n\t\tif (shell != NULL && (len = strlen(shell)) > 2 &&\n\t\t    strncmp(shell + len - 3, \"csh\", 3) == 0)\n\t\t\tc_flag = 1;\n\t}\n\tif (k_flag) {\n\t\tconst char *errstr = NULL;\n\n\t\tpidstr = getenv(SSH_AGENTPID_ENV_NAME);\n\t\tif (pidstr == NULL) {\n\t\t\tfprintf(stderr, \"%s not set, cannot kill agent\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\texit(1);\n\t\t}\n\t\tpid = (int)strtonum(pidstr, 2, INT_MAX, &errstr);\n\t\tif (errstr) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s=\\\"%s\\\", which is not a good PID: %s\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME, pidstr, errstr);\n\t\t\texit(1);\n\t\t}\n\t\tif (kill(pid, SIGTERM) == -1) {\n\t\t\tperror(\"kill\");\n\t\t\texit(1);\n\t\t}\n\t\tformat = c_flag ? \"unsetenv %s;\\n\" : \"unset %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(format, SSH_AGENTPID_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld killed;\\n\", (long)pid);\n\t\texit(0);\n\t}\n\n\t/*\n\t * Minimum file descriptors:\n\t * stdio (3) + listener (1) + syslog (1 maybe) + connection (1) +\n\t * a few spare for libc / stack protectors / sanitisers, etc.\n\t */\n#define SSH_AGENT_MIN_FDS (3+1+1+1+4)\n\tif (rlim.rlim_cur < SSH_AGENT_MIN_FDS)\n\t\tfatal(\"%s: file descriptor rlimit %lld too low (minimum %u)\",\n\t\t    __progname, (long long)rlim.rlim_cur, SSH_AGENT_MIN_FDS);\n\tmaxfds = rlim.rlim_cur - SSH_AGENT_MIN_FDS;\n\n\tparent_pid = getpid();\n\n\tif (agentsocket == NULL) {\n\t\t/* Create private directory for agent socket */\n\t\tmktemp_proto(socket_dir, sizeof(socket_dir));\n\t\tif (mkdtemp(socket_dir) == NULL) {\n\t\t\tperror(\"mkdtemp: private socket dir\");\n\t\t\texit(1);\n\t\t}\n\t\tsnprintf(socket_name, sizeof socket_name, \"%s/agent.%ld\", socket_dir,\n\t\t    (long)parent_pid);\n\t} else {\n\t\t/* Try to use specified agent socket */\n\t\tsocket_dir[0] = '\\0';\n\t\tstrlcpy(socket_name, agentsocket, sizeof socket_name);\n\t}\n\n\t/*\n\t * Create socket early so it will exist before command gets run from\n\t * the parent.\n\t */\n\tprev_mask = umask(0177);\n\tsock = unix_listener(socket_name, SSH_LISTEN_BACKLOG, 0);\n\tif (sock < 0) {\n\t\t/* XXX - unix_listener() calls error() not perror() */\n\t\t*socket_name = '\\0'; /* Don't unlink any existing file */\n\t\tcleanup_exit(1);\n\t}\n\tumask(prev_mask);\n\n\t/*\n\t * Fork, and have the parent execute the command, if any, or present\n\t * the socket data.  The child continues as the authentication agent.\n\t */\n\tif (D_flag || d_flag) {\n\t\tlog_init(__progname,\n\t\t    d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO,\n\t\t    SYSLOG_FACILITY_AUTH, 1);\n\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld;\\n\", (long)parent_pid);\n\t\tfflush(stdout);\n\t\tgoto skip;\n\t}\n\tpid = fork();\n\tif (pid == -1) {\n\t\tperror(\"fork\");\n\t\tcleanup_exit(1);\n\t}\n\tif (pid != 0) {\t\t/* Parent - execute the given command. */\n\t\tclose(sock);\n\t\tsnprintf(pidstrbuf, sizeof pidstrbuf, \"%ld\", (long)pid);\n\t\tif (ac == 0) {\n\t\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\t\tprintf(format, SSH_AGENTPID_ENV_NAME, pidstrbuf,\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\tprintf(\"echo Agent pid %ld;\\n\", (long)pid);\n\t\t\texit(0);\n\t\t}\n\t\tif (setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1) == -1 ||\n\t\t    setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1) == -1) {\n\t\t\tperror(\"setenv\");\n\t\t\texit(1);\n\t\t}\n\t\texecvp(av[0], av);\n\t\tperror(av[0]);\n\t\texit(1);\n\t}\n\t/* child */\n\tlog_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);\n\n\tif (setsid() == -1) {\n\t\terror(\"setsid: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n\n\t(void)chdir(\"/\");\n\tif ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {\n\t\t/* XXX might close listen socket */\n\t\t(void)dup2(fd, STDIN_FILENO);\n\t\t(void)dup2(fd, STDOUT_FILENO);\n\t\t(void)dup2(fd, STDERR_FILENO);\n\t\tif (fd > 2)\n\t\t\tclose(fd);\n\t}\n\n#ifdef HAVE_SETRLIMIT\n\t/* deny core dumps, since memory contains unencrypted private keys */\n\trlim.rlim_cur = rlim.rlim_max = 0;\n\tif (setrlimit(RLIMIT_CORE, &rlim) < 0) {\n\t\terror(\"setrlimit RLIMIT_CORE: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n#endif\n\nskip:\n\n\tcleanup_pid = getpid();\n\n#ifdef ENABLE_PKCS11\n\tpkcs11_init(0);\n#endif\n\tnew_socket(AUTH_SOCKET, sock);\n\tif (ac > 0)\n\t\tparent_alive_interval = 10;\n\tidtab_init();\n\tsignal(SIGPIPE, SIG_IGN);\n\tsignal(SIGINT, (d_flag | D_flag) ? cleanup_handler : SIG_IGN);\n\tsignal(SIGHUP, cleanup_handler);\n\tsignal(SIGTERM, cleanup_handler);\n\n\tif (pledge(\"stdio rpath cpath unix id proc exec\", NULL) == -1)\n\t\tfatal(\"%s: pledge: %s\", __progname, strerror(errno));\n\tplatform_pledge_agent();\n\n\twhile (1) {\n\t\tprepare_poll(&pfd, &npfd, &timeout, maxfds);\n\t\tresult = poll(pfd, npfd, timeout);\n\t\tsaved_errno = errno;\n\t\tif (parent_alive_interval != 0)\n\t\t\tcheck_parent_exists();\n\t\t(void) reaper();\t/* remove expired keys */\n\t\tif (result < 0) {\n\t\t\tif (saved_errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tfatal(\"poll: %s\", strerror(saved_errno));\n\t\t} else if (result > 0)\n\t\t\tafter_poll(pfd, npfd, maxfds);\n\t}\n\t/* NOTREACHED */\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define SSH_AGENT_MIN_FDS (3+1+1+1+4)"
    ],
    "globals_used": [
      "pid_t parent_pid = -1;",
      "time_t parent_alive_interval = 0;",
      "pid_t cleanup_pid = 0;",
      "char socket_name[PATH_MAX];",
      "char socket_dir[PATH_MAX];",
      "static char *pkcs11_whitelist;",
      "extern char *__progname;",
      "static long lifetime = 0;",
      "static int fingerprint_hash = SSH_FP_HASH_DEFAULT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "after_poll",
          "args": [
            "pfd",
            "npfd",
            "maxfds"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "after_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "888-941",
          "snippet": "static void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t/* Find sockets entry */\n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror(\"%s: no socket for fd %d\", __func__, pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Process events */\n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0) {\n\t\t\t\tgoto close_sock;\n\t\t\t}\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int sockets_alloc = 0;",
            "SocketEntry *sockets = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int sockets_alloc = 0;\nSocketEntry *sockets = NULL;\n\nstatic void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t/* Find sockets entry */\n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror(\"%s: no socket for fd %d\", __func__, pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Process events */\n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0) {\n\t\t\t\tgoto close_sock;\n\t\t\t}\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"poll: %s\"",
            "strerror(saved_errno)"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "saved_errno"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reaper",
          "args": [],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "reaper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "376-399",
          "snippet": "static time_t\nreaper(void)\n{\n\ttime_t deadline = 0, now = monotime();\n\tIdentity *id, *nxt;\n\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id; id = nxt) {\n\t\tnxt = TAILQ_NEXT(id, next);\n\t\tif (id->death == 0)\n\t\t\tcontinue;\n\t\tif (now >= id->death) {\n\t\t\tdebug(\"expiring key '%s'\", id->comment);\n\t\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\t\tfree_identity(id);\n\t\t\tidtab->nentries--;\n\t\t} else\n\t\t\tdeadline = (deadline == 0) ? id->death :\n\t\t\t    MINIMUM(deadline, id->death);\n\t}\n\tif (deadline == 0 || deadline <= now)\n\t\treturn 0;\n\telse\n\t\treturn (deadline - now);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct idtable *idtab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct idtable *idtab;\n\nstatic time_t\nreaper(void)\n{\n\ttime_t deadline = 0, now = monotime();\n\tIdentity *id, *nxt;\n\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id; id = nxt) {\n\t\tnxt = TAILQ_NEXT(id, next);\n\t\tif (id->death == 0)\n\t\t\tcontinue;\n\t\tif (now >= id->death) {\n\t\t\tdebug(\"expiring key '%s'\", id->comment);\n\t\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\t\tfree_identity(id);\n\t\t\tidtab->nentries--;\n\t\t} else\n\t\t\tdeadline = (deadline == 0) ? id->death :\n\t\t\t    MINIMUM(deadline, id->death);\n\t}\n\tif (deadline == 0 || deadline <= now)\n\t\treturn 0;\n\telse\n\t\treturn (deadline - now);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_parent_exists",
          "args": [],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "check_parent_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "1041-1053",
          "snippet": "static void\ncheck_parent_exists(void)\n{\n\t/*\n\t * If our parent has exited then getppid() will return (pid_t)1,\n\t * so testing for that should be safe.\n\t */\n\tif (parent_pid != -1 && getppid() != parent_pid) {\n\t\t/* printf(\"Parent has died - Authentication agent exiting.\\n\"); */\n\t\tcleanup_socket();\n\t\t_exit(2);\n\t}\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "pid_t parent_pid = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\npid_t parent_pid = -1;\n\nstatic void\ncheck_parent_exists(void)\n{\n\t/*\n\t * If our parent has exited then getppid() will return (pid_t)1,\n\t * so testing for that should be safe.\n\t */\n\tif (parent_pid != -1 && getppid() != parent_pid) {\n\t\t/* printf(\"Parent has died - Authentication agent exiting.\\n\"); */\n\t\tcleanup_socket();\n\t\t_exit(2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_poll",
          "args": [
            "&pfd",
            "&npfd",
            "&timeout",
            "maxfds"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "943-1009",
          "snippet": "static int\nprepare_poll(struct pollfd **pfdp, size_t *npfdp, int *timeoutp, u_int maxfds)\n{\n\tstruct pollfd *pfd = *pfdp;\n\tsize_t i, j, npfd = 0;\n\ttime_t deadline;\n\n\t/* Count active sockets */\n\tfor (i = 0; i < sockets_alloc; i++) {\n\t\tswitch (sockets[i].type) {\n\t\tcase AUTH_SOCKET:\n\t\tcase AUTH_CONNECTION:\n\t\t\tnpfd++;\n\t\t\tbreak;\n\t\tcase AUTH_UNUSED:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Unknown socket type %d\", sockets[i].type);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (npfd != *npfdp &&\n\t    (pfd = recallocarray(pfd, *npfdp, npfd, sizeof(*pfd))) == NULL)\n\t\tfatal(\"%s: recallocarray failed\", __func__);\n\t*pfdp = pfd;\n\t*npfdp = npfd;\n\n\tfor (i = j = 0; i < sockets_alloc; i++) {\n\t\tswitch (sockets[i].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %zu >= limit %u); \"\n\t\t\t\t    \"skipping arming listener\", npfd, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpfd[j].fd = sockets[i].fd;\n\t\t\tpfd[j].revents = 0;\n\t\t\tpfd[j].events = POLLIN;\n\t\t\tj++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tpfd[j].fd = sockets[i].fd;\n\t\t\tpfd[j].revents = 0;\n\t\t\t/* XXX backoff when input buffer full */\n\t\t\tpfd[j].events = POLLIN;\n\t\t\tif (sshbuf_len(sockets[i].output) > 0)\n\t\t\t\tpfd[j].events |= POLLOUT;\n\t\t\tj++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tdeadline = reaper();\n\tif (parent_alive_interval != 0)\n\t\tdeadline = (deadline == 0) ? parent_alive_interval :\n\t\t    MINIMUM(deadline, parent_alive_interval);\n\tif (deadline == 0) {\n\t\t*timeoutp = -1; /* INFTIM */\n\t} else {\n\t\tif (deadline > INT_MAX / 1000)\n\t\t\t*timeoutp = INT_MAX / 1000;\n\t\telse\n\t\t\t*timeoutp = deadline * 1000;\n\t}\n\treturn (1);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int sockets_alloc = 0;",
            "SocketEntry *sockets = NULL;",
            "time_t parent_alive_interval = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int sockets_alloc = 0;\nSocketEntry *sockets = NULL;\ntime_t parent_alive_interval = 0;\n\nstatic int\nprepare_poll(struct pollfd **pfdp, size_t *npfdp, int *timeoutp, u_int maxfds)\n{\n\tstruct pollfd *pfd = *pfdp;\n\tsize_t i, j, npfd = 0;\n\ttime_t deadline;\n\n\t/* Count active sockets */\n\tfor (i = 0; i < sockets_alloc; i++) {\n\t\tswitch (sockets[i].type) {\n\t\tcase AUTH_SOCKET:\n\t\tcase AUTH_CONNECTION:\n\t\t\tnpfd++;\n\t\t\tbreak;\n\t\tcase AUTH_UNUSED:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Unknown socket type %d\", sockets[i].type);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (npfd != *npfdp &&\n\t    (pfd = recallocarray(pfd, *npfdp, npfd, sizeof(*pfd))) == NULL)\n\t\tfatal(\"%s: recallocarray failed\", __func__);\n\t*pfdp = pfd;\n\t*npfdp = npfd;\n\n\tfor (i = j = 0; i < sockets_alloc; i++) {\n\t\tswitch (sockets[i].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %zu >= limit %u); \"\n\t\t\t\t    \"skipping arming listener\", npfd, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpfd[j].fd = sockets[i].fd;\n\t\t\tpfd[j].revents = 0;\n\t\t\tpfd[j].events = POLLIN;\n\t\t\tj++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tpfd[j].fd = sockets[i].fd;\n\t\t\tpfd[j].revents = 0;\n\t\t\t/* XXX backoff when input buffer full */\n\t\t\tpfd[j].events = POLLIN;\n\t\t\tif (sshbuf_len(sockets[i].output) > 0)\n\t\t\t\tpfd[j].events |= POLLOUT;\n\t\t\tj++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tdeadline = reaper();\n\tif (parent_alive_interval != 0)\n\t\tdeadline = (deadline == 0) ? parent_alive_interval :\n\t\t    MINIMUM(deadline, parent_alive_interval);\n\tif (deadline == 0) {\n\t\t*timeoutp = -1; /* INFTIM */\n\t} else {\n\t\tif (deadline > INT_MAX / 1000)\n\t\t\t*timeoutp = INT_MAX / 1000;\n\t\telse\n\t\t\t*timeoutp = deadline * 1000;\n\t}\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "platform_pledge_agent",
          "args": [],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "platform_pledge_agent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform-pledge.c",
          "lines": "35-45",
          "snippet": "void\nplatform_pledge_agent(void)\n{\n#ifdef USE_SOLARIS_PRIVS\n\t/*\n\t * Note: Solaris priv dropping is closer to tame() than pledge(), but\n\t * we will use what we have.\n\t */\n\tsolaris_drop_privs_root_pinfo_net();\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nplatform_pledge_agent(void)\n{\n#ifdef USE_SOLARIS_PRIVS\n\t/*\n\t * Note: Solaris priv dropping is closer to tame() than pledge(), but\n\t * we will use what we have.\n\t */\n\tsolaris_drop_privs_root_pinfo_net();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: pledge: %s\"",
            "__progname",
            "strerror(errno)"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pledge",
          "args": [
            "\"stdio rpath cpath unix id proc exec\"",
            "NULL"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "pledge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "255-259",
          "snippet": "int\npledge(const char *promises, const char *paths[])\n{\n\treturn 0;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\npledge(const char *promises, const char *paths[])\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGTERM",
            "cleanup_handler"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "idtab_init",
          "args": [],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "idtab_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "176-182",
          "snippet": "static void\nidtab_init(void)\n{\n\tidtab = xcalloc(1, sizeof(*idtab));\n\tTAILQ_INIT(&idtab->idlist);\n\tidtab->nentries = 0;\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct idtable *idtab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct idtable *idtab;\n\nstatic void\nidtab_init(void)\n{\n\tidtab = xcalloc(1, sizeof(*idtab));\n\tTAILQ_INIT(&idtab->idlist);\n\tidtab->nentries = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_socket",
          "args": [
            "AUTH_SOCKET",
            "sock"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "new_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "771-807",
          "snippet": "static void\nnew_socket(sock_type type, int fd)\n{\n\tu_int i, old_alloc, new_alloc;\n\n\tset_nonblock(fd);\n\n\tif (fd > max_fd)\n\t\tmax_fd = fd;\n\n\tfor (i = 0; i < sockets_alloc; i++)\n\t\tif (sockets[i].type == AUTH_UNUSED) {\n\t\t\tsockets[i].fd = fd;\n\t\t\tif ((sockets[i].input = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tif ((sockets[i].output = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tif ((sockets[i].request = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tsockets[i].type = type;\n\t\t\treturn;\n\t\t}\n\told_alloc = sockets_alloc;\n\tnew_alloc = sockets_alloc + 10;\n\tsockets = xreallocarray(sockets, new_alloc, sizeof(sockets[0]));\n\tfor (i = old_alloc; i < new_alloc; i++)\n\t\tsockets[i].type = AUTH_UNUSED;\n\tsockets_alloc = new_alloc;\n\tsockets[old_alloc].fd = fd;\n\tif ((sockets[old_alloc].input = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((sockets[old_alloc].output = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((sockets[old_alloc].request = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tsockets[old_alloc].type = type;\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int sockets_alloc = 0;",
            "SocketEntry *sockets = NULL;",
            "int max_fd = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int sockets_alloc = 0;\nSocketEntry *sockets = NULL;\nint max_fd = 0;\n\nstatic void\nnew_socket(sock_type type, int fd)\n{\n\tu_int i, old_alloc, new_alloc;\n\n\tset_nonblock(fd);\n\n\tif (fd > max_fd)\n\t\tmax_fd = fd;\n\n\tfor (i = 0; i < sockets_alloc; i++)\n\t\tif (sockets[i].type == AUTH_UNUSED) {\n\t\t\tsockets[i].fd = fd;\n\t\t\tif ((sockets[i].input = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tif ((sockets[i].output = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tif ((sockets[i].request = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tsockets[i].type = type;\n\t\t\treturn;\n\t\t}\n\told_alloc = sockets_alloc;\n\tnew_alloc = sockets_alloc + 10;\n\tsockets = xreallocarray(sockets, new_alloc, sizeof(sockets[0]));\n\tfor (i = old_alloc; i < new_alloc; i++)\n\t\tsockets[i].type = AUTH_UNUSED;\n\tsockets_alloc = new_alloc;\n\tsockets[old_alloc].fd = fd;\n\tif ((sockets[old_alloc].input = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((sockets[old_alloc].output = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((sockets[old_alloc].request = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tsockets[old_alloc].type = type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pkcs11_init",
          "args": [
            "0"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "pkcs11_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
          "lines": "102-106",
          "snippet": "int\npkcs11_init(int interactive)\n{\n\treturn (0);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"pathnames.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rsa.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\npkcs11_init(int interactive)\n{\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cleanup_exit",
          "args": [
            "1"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "1023-1028",
          "snippet": "void\ncleanup_exit(int i)\n{\n\tcleanup_socket();\n\t_exit(i);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ncleanup_exit(int i)\n{\n\tcleanup_socket();\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"setrlimit RLIMIT_CORE: %s\"",
            "strerror(errno)"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setrlimit",
          "args": [
            "RLIMIT_CORE",
            "&rlim"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "close_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "165-174",
          "snippet": "static void\nclose_socket(SocketEntry *e)\n{\n\tclose(e->fd);\n\te->fd = -1;\n\te->type = AUTH_UNUSED;\n\tsshbuf_free(e->input);\n\tsshbuf_free(e->output);\n\tsshbuf_free(e->request);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nclose_socket(SocketEntry *e)\n{\n\tclose(e->fd);\n\te->fd = -1;\n\te->type = AUTH_UNUSED;\n\tsshbuf_free(e->input);\n\tsshbuf_free(e->output);\n\tsshbuf_free(e->request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd",
            "STDERR_FILENO"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd",
            "STDOUT_FILENO"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd",
            "STDIN_FILENO"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "_PATH_DEVNULL",
            "O_RDWR",
            "0"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "lastlog_openseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/loginrec.c",
          "lines": "1471-1514",
          "snippet": "static int\nlastlog_openseek(struct logininfo *li, int *fd, int filemode)\n{\n\toff_t offset;\n\tchar lastlog_file[1024];\n\tstruct stat st;\n\n\tif (stat(LASTLOG_FILE, &st) != 0) {\n\t\tlogit(\"%s: Couldn't stat %s: %s\", __func__,\n\t\t    LASTLOG_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (S_ISDIR(st.st_mode)) {\n\t\tsnprintf(lastlog_file, sizeof(lastlog_file), \"%s/%s\",\n\t\t    LASTLOG_FILE, li->username);\n\t} else if (S_ISREG(st.st_mode)) {\n\t\tstrlcpy(lastlog_file, LASTLOG_FILE, sizeof(lastlog_file));\n\t} else {\n\t\tlogit(\"%s: %.100s is not a file or directory!\", __func__,\n\t\t    LASTLOG_FILE);\n\t\treturn (0);\n\t}\n\n\t*fd = open(lastlog_file, filemode, 0600);\n\tif (*fd < 0) {\n\t\tdebug(\"%s: Couldn't open %s: %s\", __func__,\n\t\t    lastlog_file, strerror(errno));\n\t\treturn (0);\n\t}\n\n\tif (S_ISREG(st.st_mode)) {\n\t\t/* find this uid's offset in the lastlog file */\n\t\toffset = (off_t) ((u_long)li->uid * sizeof(struct lastlog));\n\n\t\tif (lseek(*fd, offset, SEEK_SET) != offset) {\n\t\t\tlogit(\"%s: %s->lseek(): %s\", __func__,\n\t\t\t    lastlog_file, strerror(errno));\n\t\t\tclose(*fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}",
          "includes": [
            "# include <util.h>",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"canohost.h\"",
            "#include \"packet.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"loginrec.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int utmp_write_entry(struct logininfo *li);",
            "int utmpx_write_entry(struct logininfo *li);",
            "int wtmp_write_entry(struct logininfo *li);",
            "int wtmpx_write_entry(struct logininfo *li);",
            "int lastlog_write_entry(struct logininfo *li);",
            "int syslogin_write_entry(struct logininfo *li);",
            "int getlast_entry(struct logininfo *li);",
            "int lastlog_get_entry(struct logininfo *li);",
            "int utmpx_get_entry(struct logininfo *li);",
            "int wtmp_get_entry(struct logininfo *li);",
            "int wtmpx_get_entry(struct logininfo *li);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <util.h>\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"canohost.h\"\n#include \"packet.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"loginrec.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint utmp_write_entry(struct logininfo *li);\nint utmpx_write_entry(struct logininfo *li);\nint wtmp_write_entry(struct logininfo *li);\nint wtmpx_write_entry(struct logininfo *li);\nint lastlog_write_entry(struct logininfo *li);\nint syslogin_write_entry(struct logininfo *li);\nint getlast_entry(struct logininfo *li);\nint lastlog_get_entry(struct logininfo *li);\nint utmpx_get_entry(struct logininfo *li);\nint wtmp_get_entry(struct logininfo *li);\nint wtmpx_get_entry(struct logininfo *li);\n\nstatic int\nlastlog_openseek(struct logininfo *li, int *fd, int filemode)\n{\n\toff_t offset;\n\tchar lastlog_file[1024];\n\tstruct stat st;\n\n\tif (stat(LASTLOG_FILE, &st) != 0) {\n\t\tlogit(\"%s: Couldn't stat %s: %s\", __func__,\n\t\t    LASTLOG_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (S_ISDIR(st.st_mode)) {\n\t\tsnprintf(lastlog_file, sizeof(lastlog_file), \"%s/%s\",\n\t\t    LASTLOG_FILE, li->username);\n\t} else if (S_ISREG(st.st_mode)) {\n\t\tstrlcpy(lastlog_file, LASTLOG_FILE, sizeof(lastlog_file));\n\t} else {\n\t\tlogit(\"%s: %.100s is not a file or directory!\", __func__,\n\t\t    LASTLOG_FILE);\n\t\treturn (0);\n\t}\n\n\t*fd = open(lastlog_file, filemode, 0600);\n\tif (*fd < 0) {\n\t\tdebug(\"%s: Couldn't open %s: %s\", __func__,\n\t\t    lastlog_file, strerror(errno));\n\t\treturn (0);\n\t}\n\n\tif (S_ISREG(st.st_mode)) {\n\t\t/* find this uid's offset in the lastlog file */\n\t\toffset = (off_t) ((u_long)li->uid * sizeof(struct lastlog));\n\n\t\tif (lseek(*fd, offset, SEEK_SET) != offset) {\n\t\t\tlogit(\"%s: %s->lseek(): %s\", __func__,\n\t\t\t    lastlog_file, strerror(errno));\n\t\t\tclose(*fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "\"/\""
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsid",
          "args": [],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_init",
          "args": [
            "__progname",
            "SYSLOG_LEVEL_INFO",
            "SYSLOG_FACILITY_AUTH",
            "0"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "log_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "256-336",
          "snippet": "void\nlog_init(char *av0, LogLevel level, SyslogFacility facility, int on_stderr)\n{\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\tstruct syslog_data sdata = SYSLOG_DATA_INIT;\n#endif\n\n\targv0 = av0;\n\n\tif (log_change_level(level) != 0) {\n\t\tfprintf(stderr, \"Unrecognized internal syslog level code %d\\n\",\n\t\t    (int) level);\n\t\texit(1);\n\t}\n\n\tlog_handler = NULL;\n\tlog_handler_ctx = NULL;\n\n\tlog_on_stderr = on_stderr;\n\tif (on_stderr)\n\t\treturn;\n\n\tswitch (facility) {\n\tcase SYSLOG_FACILITY_DAEMON:\n\t\tlog_facility = LOG_DAEMON;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_USER:\n\t\tlog_facility = LOG_USER;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_AUTH:\n\t\tlog_facility = LOG_AUTH;\n\t\tbreak;\n#ifdef LOG_AUTHPRIV\n\tcase SYSLOG_FACILITY_AUTHPRIV:\n\t\tlog_facility = LOG_AUTHPRIV;\n\t\tbreak;\n#endif\n\tcase SYSLOG_FACILITY_LOCAL0:\n\t\tlog_facility = LOG_LOCAL0;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL1:\n\t\tlog_facility = LOG_LOCAL1;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL2:\n\t\tlog_facility = LOG_LOCAL2;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL3:\n\t\tlog_facility = LOG_LOCAL3;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL4:\n\t\tlog_facility = LOG_LOCAL4;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL5:\n\t\tlog_facility = LOG_LOCAL5;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL6:\n\t\tlog_facility = LOG_LOCAL6;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL7:\n\t\tlog_facility = LOG_LOCAL7;\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr,\n\t\t    \"Unrecognized internal syslog facility code %d\\n\",\n\t\t    (int) facility);\n\t\texit(1);\n\t}\n\n\t/*\n\t * If an external library (eg libwrap) attempts to use syslog\n\t * immediately after reexec, syslog may be pointing to the wrong\n\t * facility, so we force an open/close of syslog here.\n\t */\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\topenlog_r(argv0 ? argv0 : __progname, LOG_PID, log_facility, &sdata);\n\tcloselog_r(&sdata);\n#else\n\topenlog(argv0 ? argv0 : __progname, LOG_PID, log_facility);\n\tcloselog();\n#endif\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int log_on_stderr = 1;",
            "static int log_facility = LOG_AUTH;",
            "static char *argv0;",
            "static log_handler_fn *log_handler;",
            "static void *log_handler_ctx;",
            "extern char *__progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int log_on_stderr = 1;\nstatic int log_facility = LOG_AUTH;\nstatic char *argv0;\nstatic log_handler_fn *log_handler;\nstatic void *log_handler_ctx;\nextern char *__progname;\n\nvoid\nlog_init(char *av0, LogLevel level, SyslogFacility facility, int on_stderr)\n{\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\tstruct syslog_data sdata = SYSLOG_DATA_INIT;\n#endif\n\n\targv0 = av0;\n\n\tif (log_change_level(level) != 0) {\n\t\tfprintf(stderr, \"Unrecognized internal syslog level code %d\\n\",\n\t\t    (int) level);\n\t\texit(1);\n\t}\n\n\tlog_handler = NULL;\n\tlog_handler_ctx = NULL;\n\n\tlog_on_stderr = on_stderr;\n\tif (on_stderr)\n\t\treturn;\n\n\tswitch (facility) {\n\tcase SYSLOG_FACILITY_DAEMON:\n\t\tlog_facility = LOG_DAEMON;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_USER:\n\t\tlog_facility = LOG_USER;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_AUTH:\n\t\tlog_facility = LOG_AUTH;\n\t\tbreak;\n#ifdef LOG_AUTHPRIV\n\tcase SYSLOG_FACILITY_AUTHPRIV:\n\t\tlog_facility = LOG_AUTHPRIV;\n\t\tbreak;\n#endif\n\tcase SYSLOG_FACILITY_LOCAL0:\n\t\tlog_facility = LOG_LOCAL0;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL1:\n\t\tlog_facility = LOG_LOCAL1;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL2:\n\t\tlog_facility = LOG_LOCAL2;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL3:\n\t\tlog_facility = LOG_LOCAL3;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL4:\n\t\tlog_facility = LOG_LOCAL4;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL5:\n\t\tlog_facility = LOG_LOCAL5;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL6:\n\t\tlog_facility = LOG_LOCAL6;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL7:\n\t\tlog_facility = LOG_LOCAL7;\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr,\n\t\t    \"Unrecognized internal syslog facility code %d\\n\",\n\t\t    (int) facility);\n\t\texit(1);\n\t}\n\n\t/*\n\t * If an external library (eg libwrap) attempts to use syslog\n\t * immediately after reexec, syslog may be pointing to the wrong\n\t * facility, so we force an open/close of syslog here.\n\t */\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\topenlog_r(argv0 ? argv0 : __progname, LOG_PID, log_facility, &sdata);\n\tcloselog_r(&sdata);\n#else\n\topenlog(argv0 ? argv0 : __progname, LOG_PID, log_facility);\n\tcloselog();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "av[0]"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "av[0]",
            "av"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"setenv\""
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "SSH_AGENTPID_ENV_NAME",
            "pidstrbuf",
            "1"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "setenv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/setenv.c",
          "lines": "131-188",
          "snippet": "int\nsetenv(const char *name, const char *value, int rewrite)\n{\n\tchar *C, **P;\n\tconst char *np;\n\tint l_value, offset = 0;\n\n\tfor (np = name; *np && *np != '='; ++np)\n\t\t;\n#ifdef notyet\n\tif (*np) {\n\t\terrno = EINVAL;\n\t\treturn (-1);\t\t\t/* has `=' in name */\n\t}\n#endif\n\n\tl_value = strlen(value);\n\tif ((C = __findenv(name, (int)(np - name), &offset)) != NULL) {\n\t\tint tmpoff = offset + 1;\n\t\tif (!rewrite)\n\t\t\treturn (0);\n#if 0 /* XXX - existing entry may not be writable */\n\t\tif (strlen(C) >= l_value) {\t/* old larger; copy over */\n\t\t\twhile ((*C++ = *value++))\n\t\t\t\t;\n\t\t\treturn (0);\n\t\t}\n#endif\n\t\t/* could be set multiple times */\n\t\twhile (__findenv(name, (int)(np - name), &tmpoff)) {\n\t\t\tfor (P = &environ[tmpoff];; ++P)\n\t\t\t\tif (!(*P = *(P + 1)))\n\t\t\t\t\tbreak;\n\t\t}\n\t} else {\t\t\t\t\t/* create new slot */\n\t\tsize_t cnt;\n\n\t\tfor (P = environ; *P != NULL; P++)\n\t\t\t;\n\t\tcnt = P - environ;\n\t\tP = (char **)realloc(lastenv, sizeof(char *) * (cnt + 2));\n\t\tif (!P)\n\t\t\treturn (-1);\n\t\tif (lastenv != environ)\n\t\t\tmemcpy(P, environ, cnt * sizeof(char *));\n\t\tlastenv = environ = P;\n\t\toffset = cnt;\n\t\tenviron[cnt + 1] = NULL;\n\t}\n\tif (!(environ[offset] =\t\t\t/* name + `=' + value */\n\t    malloc((size_t)((int)(np - name) + l_value + 2))))\n\t\treturn (-1);\n\tfor (C = environ[offset]; (*C = *name++) && *C != '='; ++C)\n\t\t;\n\tfor (*C++ = '='; (*C++ = *value++); )\n\t\t;\n\treturn (0);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include \"includes.h\"\n\nint\nsetenv(const char *name, const char *value, int rewrite)\n{\n\tchar *C, **P;\n\tconst char *np;\n\tint l_value, offset = 0;\n\n\tfor (np = name; *np && *np != '='; ++np)\n\t\t;\n#ifdef notyet\n\tif (*np) {\n\t\terrno = EINVAL;\n\t\treturn (-1);\t\t\t/* has `=' in name */\n\t}\n#endif\n\n\tl_value = strlen(value);\n\tif ((C = __findenv(name, (int)(np - name), &offset)) != NULL) {\n\t\tint tmpoff = offset + 1;\n\t\tif (!rewrite)\n\t\t\treturn (0);\n#if 0 /* XXX - existing entry may not be writable */\n\t\tif (strlen(C) >= l_value) {\t/* old larger; copy over */\n\t\t\twhile ((*C++ = *value++))\n\t\t\t\t;\n\t\t\treturn (0);\n\t\t}\n#endif\n\t\t/* could be set multiple times */\n\t\twhile (__findenv(name, (int)(np - name), &tmpoff)) {\n\t\t\tfor (P = &environ[tmpoff];; ++P)\n\t\t\t\tif (!(*P = *(P + 1)))\n\t\t\t\t\tbreak;\n\t\t}\n\t} else {\t\t\t\t\t/* create new slot */\n\t\tsize_t cnt;\n\n\t\tfor (P = environ; *P != NULL; P++)\n\t\t\t;\n\t\tcnt = P - environ;\n\t\tP = (char **)realloc(lastenv, sizeof(char *) * (cnt + 2));\n\t\tif (!P)\n\t\t\treturn (-1);\n\t\tif (lastenv != environ)\n\t\t\tmemcpy(P, environ, cnt * sizeof(char *));\n\t\tlastenv = environ = P;\n\t\toffset = cnt;\n\t\tenviron[cnt + 1] = NULL;\n\t}\n\tif (!(environ[offset] =\t\t\t/* name + `=' + value */\n\t    malloc((size_t)((int)(np - name) + l_value + 2))))\n\t\treturn (-1);\n\tfor (C = environ[offset]; (*C = *name++) && *C != '='; ++C)\n\t\t;\n\tfor (*C++ = '='; (*C++ = *value++); )\n\t\t;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"echo Agent pid %ld;\\n\"",
            "(long)pid"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "pidstrbuf",
            "sizeof pidstrbuf",
            "\"%ld\"",
            "(long)pid"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"fork\""
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "platform_post_fork_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
          "lines": "69-78",
          "snippet": "void\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "_ssh_compat_fflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "314-326",
          "snippet": "int _ssh_compat_fflush(FILE *f)\n{\n\tint r1, r2;\n\n\tif (f == NULL) {\n\t\tr1 = fflush(stdout);\n\t\tr2 = fflush(stderr);\n\t\tif (r1 == -1 || r2 == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\treturn fflush(f);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint _ssh_compat_fflush(FILE *f)\n{\n\tint r1, r2;\n\n\tif (f == NULL) {\n\t\tr1 = fflush(stdout);\n\t\tr2 = fflush(stderr);\n\t\tif (r1 == -1 || r2 == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\treturn fflush(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "prev_mask"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unix_listener",
          "args": [
            "socket_name",
            "SSH_LISTEN_BACKLOG",
            "0"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "unix_listener",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1487-1532",
          "snippet": "int\nunix_listener(const char *path, int backlog, int unlink_first)\n{\n\tstruct sockaddr_un sunaddr;\n\tint saved_errno, sock;\n\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tif (strlcpy(sunaddr.sun_path, path,\n\t    sizeof(sunaddr.sun_path)) >= sizeof(sunaddr.sun_path)) {\n\t\terror(\"%s: path \\\"%s\\\" too long for Unix domain socket\",\n\t\t    __func__, path);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\n\tsock = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (sock < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"%s: socket: %.100s\", __func__, strerror(errno));\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (unlink_first == 1) {\n\t\tif (unlink(path) != 0 && errno != ENOENT)\n\t\t\terror(\"unlink(%s): %.100s\", path, strerror(errno));\n\t}\n\tif (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"%s: cannot bind to path %s: %s\",\n\t\t    __func__, path, strerror(errno));\n\t\tclose(sock);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (listen(sock, backlog) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"%s: cannot listen on path %s: %s\",\n\t\t    __func__, path, strerror(errno));\n\t\tclose(sock);\n\t\tunlink(path);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\treturn sock;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nunix_listener(const char *path, int backlog, int unlink_first)\n{\n\tstruct sockaddr_un sunaddr;\n\tint saved_errno, sock;\n\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tif (strlcpy(sunaddr.sun_path, path,\n\t    sizeof(sunaddr.sun_path)) >= sizeof(sunaddr.sun_path)) {\n\t\terror(\"%s: path \\\"%s\\\" too long for Unix domain socket\",\n\t\t    __func__, path);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\n\tsock = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (sock < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"%s: socket: %.100s\", __func__, strerror(errno));\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (unlink_first == 1) {\n\t\tif (unlink(path) != 0 && errno != ENOENT)\n\t\t\terror(\"unlink(%s): %.100s\", path, strerror(errno));\n\t}\n\tif (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"%s: cannot bind to path %s: %s\",\n\t\t    __func__, path, strerror(errno));\n\t\tclose(sock);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (listen(sock, backlog) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"%s: cannot listen on path %s: %s\",\n\t\t    __func__, path, strerror(errno));\n\t\tclose(sock);\n\t\tunlink(path);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\treturn sock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "0177"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "socket_name",
            "agentsocket",
            "sizeof socket_name"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"mkdtemp: private socket dir\""
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdtemp",
          "args": [
            "socket_dir"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "mkdtemp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/mktemp.c",
          "lines": "132-139",
          "snippet": "char *\nmkdtemp(char *path)\n{\n\tint error;\n\n\terror = mktemp_internal(path, 0, MKTEMP_DIR);\n\treturn(error ? NULL : path);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MKTEMP_DIR\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MKTEMP_DIR\t2\n\nchar *\nmkdtemp(char *path)\n{\n\tint error;\n\n\terror = mktemp_internal(path, 0, MKTEMP_DIR);\n\treturn(error ? NULL : path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mktemp_proto",
          "args": [
            "socket_dir",
            "sizeof(socket_dir)"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "mktemp_proto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1398-1412",
          "snippet": "void\nmktemp_proto(char *s, size_t len)\n{\n\tconst char *tmpdir;\n\tint r;\n\n\tif ((tmpdir = getenv(\"TMPDIR\")) != NULL) {\n\t\tr = snprintf(s, len, \"%s/ssh-XXXXXXXXXXXX\", tmpdir);\n\t\tif (r > 0 && (size_t)r < len)\n\t\t\treturn;\n\t}\n\tr = snprintf(s, len, \"/tmp/ssh-XXXXXXXXXXXX\");\n\tif (r < 0 || (size_t)r >= len)\n\t\tfatal(\"%s: template string too short\", __func__);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nmktemp_proto(char *s, size_t len)\n{\n\tconst char *tmpdir;\n\tint r;\n\n\tif ((tmpdir = getenv(\"TMPDIR\")) != NULL) {\n\t\tr = snprintf(s, len, \"%s/ssh-XXXXXXXXXXXX\", tmpdir);\n\t\tif (r > 0 && (size_t)r < len)\n\t\t\treturn;\n\t}\n\tr = snprintf(s, len, \"/tmp/ssh-XXXXXXXXXXXX\");\n\tif (r < 0 || (size_t)r >= len)\n\t\tfatal(\"%s: template string too short\", __func__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"kill\""
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "pid",
            "SIGTERM"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s=\\\"%s\\\", which is not a good PID: %s\\n\"",
            "SSH_AGENTPID_ENV_NAME",
            "pidstr",
            "errstr"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtonum",
          "args": [
            "pidstr",
            "2",
            "INT_MAX",
            "&errstr"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "strtonum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strtonum.c",
          "lines": "33-70",
          "snippet": "long long\nstrtonum(const char *numstr, long long minval, long long maxval,\n    const char **errstrp)\n{\n\tlong long ll = 0;\n\tchar *ep;\n\tint error = 0;\n\tstruct errval {\n\t\tconst char *errstr;\n\t\tint err;\n\t} ev[4] = {\n\t\t{ NULL,\t\t0 },\n\t\t{ \"invalid\",\tEINVAL },\n\t\t{ \"too small\",\tERANGE },\n\t\t{ \"too large\",\tERANGE },\n\t};\n\n\tev[0].err = errno;\n\terrno = 0;\n\tif (minval > maxval)\n\t\terror = INVALID;\n\telse {\n\t\tll = strtoll(numstr, &ep, 10);\n\t\tif (numstr == ep || *ep != '\\0')\n\t\t\terror = INVALID;\n\t\telse if ((ll == LLONG_MIN && errno == ERANGE) || ll < minval)\n\t\t\terror = TOOSMALL;\n\t\telse if ((ll == LLONG_MAX && errno == ERANGE) || ll > maxval)\n\t\t\terror = TOOLARGE;\n\t}\n\tif (errstrp != NULL)\n\t\t*errstrp = ev[error].errstr;\n\terrno = ev[error].err;\n\tif (error)\n\t\tll = 0;\n\n\treturn (ll);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define TOOLARGE \t3",
            "#define TOOSMALL \t2",
            "#define INVALID \t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\n#define TOOLARGE \t3\n#define TOOSMALL \t2\n#define INVALID \t1\n\nlong long\nstrtonum(const char *numstr, long long minval, long long maxval,\n    const char **errstrp)\n{\n\tlong long ll = 0;\n\tchar *ep;\n\tint error = 0;\n\tstruct errval {\n\t\tconst char *errstr;\n\t\tint err;\n\t} ev[4] = {\n\t\t{ NULL,\t\t0 },\n\t\t{ \"invalid\",\tEINVAL },\n\t\t{ \"too small\",\tERANGE },\n\t\t{ \"too large\",\tERANGE },\n\t};\n\n\tev[0].err = errno;\n\terrno = 0;\n\tif (minval > maxval)\n\t\terror = INVALID;\n\telse {\n\t\tll = strtoll(numstr, &ep, 10);\n\t\tif (numstr == ep || *ep != '\\0')\n\t\t\terror = INVALID;\n\t\telse if ((ll == LLONG_MIN && errno == ERANGE) || ll < minval)\n\t\t\terror = TOOSMALL;\n\t\telse if ((ll == LLONG_MAX && errno == ERANGE) || ll > maxval)\n\t\t\terror = TOOLARGE;\n\t}\n\tif (errstrp != NULL)\n\t\t*errstrp = ev[error].errstr;\n\terrno = ev[error].err;\n\tif (error)\n\t\tll = 0;\n\n\treturn (ll);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s not set, cannot kill agent\\n\"",
            "SSH_AGENTPID_ENV_NAME"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "SSH_AGENTPID_ENV_NAME"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "pam_getenvlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "254-263",
          "snippet": "static char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "shell + len - 3",
            "\"csh\"",
            "3"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "g_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "422-435",
          "snippet": "static int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "shell"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "DEFAULT_PKCS11_WHITELIST"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "1055-1063",
          "snippet": "static void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-P pkcs11_whitelist] [-t life] [command [arg ...]]\\n\"\n\t    \"       ssh-agent [-c | -s] -k\\n\");\n\texit(1);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *pkcs11_whitelist;",
            "static int fingerprint_hash = SSH_FP_HASH_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *pkcs11_whitelist;\nstatic int fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-P pkcs11_whitelist] [-t life] [command [arg ...]]\\n\"\n\t    \"       ssh-agent [-c | -s] -k\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Invalid lifetime\\n\""
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convtime",
          "args": [
            "optarg"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "convtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "406-465",
          "snippet": "long\nconvtime(const char *s)\n{\n\tlong total, secs, multiplier = 1;\n\tconst char *p;\n\tchar *endp;\n\n\terrno = 0;\n\ttotal = 0;\n\tp = s;\n\n\tif (p == NULL || *p == '\\0')\n\t\treturn -1;\n\n\twhile (*p) {\n\t\tsecs = strtol(p, &endp, 10);\n\t\tif (p == endp ||\n\t\t    (errno == ERANGE && (secs == LONG_MIN || secs == LONG_MAX)) ||\n\t\t    secs < 0)\n\t\t\treturn -1;\n\n\t\tswitch (*endp++) {\n\t\tcase '\\0':\n\t\t\tendp--;\n\t\t\tbreak;\n\t\tcase 's':\n\t\tcase 'S':\n\t\t\tbreak;\n\t\tcase 'm':\n\t\tcase 'M':\n\t\t\tmultiplier = MINUTES;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase 'H':\n\t\t\tmultiplier = HOURS;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\tcase 'D':\n\t\t\tmultiplier = DAYS;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\tcase 'W':\n\t\t\tmultiplier = WEEKS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\tif (secs >= LONG_MAX / multiplier)\n\t\t\treturn -1;\n\t\tsecs *= multiplier;\n\t\tif  (total >= LONG_MAX - secs)\n\t\t\treturn -1;\n\t\ttotal += secs;\n\t\tif (total < 0)\n\t\t\treturn -1;\n\t\tp = endp;\n\t}\n\n\treturn total;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define WEEKS\t\t(DAYS * 7)",
            "#define DAYS\t\t(HOURS * 24)",
            "#define HOURS\t\t(MINUTES * 60)",
            "#define MINUTES\t\t(SECONDS * 60)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define WEEKS\t\t(DAYS * 7)\n#define DAYS\t\t(HOURS * 24)\n#define HOURS\t\t(MINUTES * 60)\n#define MINUTES\t\t(SECONDS * 60)\n\nlong\nconvtime(const char *s)\n{\n\tlong total, secs, multiplier = 1;\n\tconst char *p;\n\tchar *endp;\n\n\terrno = 0;\n\ttotal = 0;\n\tp = s;\n\n\tif (p == NULL || *p == '\\0')\n\t\treturn -1;\n\n\twhile (*p) {\n\t\tsecs = strtol(p, &endp, 10);\n\t\tif (p == endp ||\n\t\t    (errno == ERANGE && (secs == LONG_MIN || secs == LONG_MAX)) ||\n\t\t    secs < 0)\n\t\t\treturn -1;\n\n\t\tswitch (*endp++) {\n\t\tcase '\\0':\n\t\t\tendp--;\n\t\t\tbreak;\n\t\tcase 's':\n\t\tcase 'S':\n\t\t\tbreak;\n\t\tcase 'm':\n\t\tcase 'M':\n\t\t\tmultiplier = MINUTES;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase 'H':\n\t\t\tmultiplier = HOURS;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\tcase 'D':\n\t\t\tmultiplier = DAYS;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\tcase 'W':\n\t\t\tmultiplier = WEEKS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\tif (secs >= LONG_MAX / multiplier)\n\t\t\treturn -1;\n\t\tsecs *= multiplier;\n\t\tif  (total >= LONG_MAX - secs)\n\t\t\treturn -1;\n\t\ttotal += secs;\n\t\tif (total < 0)\n\t\t\treturn -1;\n\t\tp = endp;\n\t}\n\n\treturn total;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_digest_alg_by_name",
          "args": [
            "optarg"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_digest_alg_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/digest-libc.c",
          "lines": "123-133",
          "snippet": "int\nssh_digest_alg_by_name(const char *name)\n{\n\tint alg;\n\n\tfor (alg = 0; alg < SSH_DIGEST_MAX; alg++) {\n\t\tif (strcasecmp(name, digests[alg].name) == 0)\n\t\t\treturn digests[alg].id;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <sha2.h>",
            "#include <sha1.h>",
            "#include <rmd160.h>",
            "#include <md5.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <sha2.h>\n#include <sha1.h>\n#include <rmd160.h>\n#include <md5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_digest_alg_by_name(const char *name)\n{\n\tint alg;\n\n\tfor (alg = 0; alg < SSH_DIGEST_MAX; alg++) {\n\t\tif (strcasecmp(name, digests[alg].name) == 0)\n\t\t\treturn digests[alg].id;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getopt",
          "args": [
            "ac",
            "av",
            "\"cDdksE:a:P:t:\""
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "getopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
          "lines": "489-502",
          "snippet": "int\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <getopt.h>",
            "#include <err.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\n#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */\n\nint\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "seed_rng",
          "args": [],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "seed_rng",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/entropy.c",
          "lines": "247-250",
          "snippet": "void\nseed_rng(void)\n{\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"xmalloc.h\"",
            "#include \"misc.h\"",
            "#include \"ssh.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/crypto.h>",
            "#include <openssl/rand.h>",
            "#include <stddef.h> /* for offsetof */",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"xmalloc.h\"\n#include \"misc.h\"\n#include \"ssh.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/err.h>\n#include <openssl/crypto.h>\n#include <openssl/rand.h>\n#include <stddef.h> /* for offsetof */\n#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nseed_rng(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_get_progname",
          "args": [
            "av[0]"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_get_progname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "43-64",
          "snippet": "char *ssh_get_progname(char *argv0)\n{\n\tchar *p, *q;\n#ifdef HAVE___PROGNAME\n\textern char *__progname;\n\n\tp = __progname;\n#else\n\tif (argv0 == NULL)\n\t\treturn (\"unknown\");\t/* XXX */\n\tp = strrchr(argv0, '/');\n\tif (p == NULL)\n\t\tp = argv0;\n\telse\n\t\tp++;\n#endif\n\tif ((q = strdup(p)) == NULL) {\n\t\tperror(\"strdup\");\n\t\texit(1);\n\t}\n\treturn q;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *ssh_get_progname(char *argv0)\n{\n\tchar *p, *q;\n#ifdef HAVE___PROGNAME\n\textern char *__progname;\n\n\tp = __progname;\n#else\n\tif (argv0 == NULL)\n\t\treturn (\"unknown\");\t/* XXX */\n\tp = strrchr(argv0, '/');\n\tif (p == NULL)\n\t\tp = argv0;\n\telse\n\t\tp++;\n#endif\n\tif ((q = strdup(p)) == NULL) {\n\t\tperror(\"strdup\");\n\t\texit(1);\n\t}\n\treturn q;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OpenSSL_add_all_algorithms",
          "args": [],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_OpenSSL_add_all_algorithms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/openssl-compat.c",
          "lines": "70-85",
          "snippet": "void\nssh_OpenSSL_add_all_algorithms(void)\n{\n\tOpenSSL_add_all_algorithms();\n\n\t/* Enable use of crypto hardware */\n\tENGINE_load_builtin_engines();\n\tENGINE_register_all_complete();\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tOPENSSL_config(NULL);\n#else\n\tOPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS |\n\t    OPENSSL_INIT_ADD_ALL_DIGESTS | OPENSSL_INIT_LOAD_CONFIG, NULL);\n#endif\n}",
          "includes": [
            "#include \"openssl-compat.h\"",
            "#include \"log.h\"",
            "# include <openssl/conf.h>",
            "# include <openssl/engine.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openssl-compat.h\"\n#include \"log.h\"\n# include <openssl/conf.h>\n# include <openssl/engine.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nssh_OpenSSL_add_all_algorithms(void)\n{\n\tOpenSSL_add_all_algorithms();\n\n\t/* Enable use of crypto hardware */\n\tENGINE_load_builtin_engines();\n\tENGINE_register_all_complete();\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tOPENSSL_config(NULL);\n#else\n\tOPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS |\n\t    OPENSSL_INIT_ADD_ALL_DIGESTS | OPENSSL_INIT_LOAD_CONFIG, NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "getrlimit",
          "args": [
            "RLIMIT_NOFILE",
            "&rlim"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "platform_disable_tracing",
          "args": [
            "0"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "platform_disable_tracing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform-tracing.c",
          "lines": "33-51",
          "snippet": "void\nplatform_disable_tracing(int strict)\n{\n#if defined(HAVE_PRCTL) && defined(PR_SET_DUMPABLE)\n\t/* Disable ptrace on Linux without sgid bit */\n\tif (prctl(PR_SET_DUMPABLE, 0) != 0 && strict)\n\t\tfatal(\"unable to make the process undumpable\");\n#endif\n#if defined(HAVE_SETPFLAGS) && defined(__PROC_PROTECT)\n\t/* On Solaris, we should make this process untraceable */\n\tif (setpflags(__PROC_PROTECT, 1) != 0 && strict)\n\t\tfatal(\"unable to make the process untraceable\");\n#endif\n#ifdef PT_DENY_ATTACH\n\t/* Mac OS X */\n\tif (ptrace(PT_DENY_ATTACH, 0, 0, 0) == -1 && strict)\n\t\tfatal(\"unable to set PT_DENY_ATTACH\");\n#endif\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <priv.h> /* For setpflags() and __PROC_PROTECT  */",
            "#include <sys/ptrace.h>",
            "#include <sys/prctl.h>\t/* For prctl() and PR_SET_DUMPABLE */",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <priv.h> /* For setpflags() and __PROC_PROTECT  */\n#include <sys/ptrace.h>\n#include <sys/prctl.h>\t/* For prctl() and PR_SET_DUMPABLE */\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nplatform_disable_tracing(int strict)\n{\n#if defined(HAVE_PRCTL) && defined(PR_SET_DUMPABLE)\n\t/* Disable ptrace on Linux without sgid bit */\n\tif (prctl(PR_SET_DUMPABLE, 0) != 0 && strict)\n\t\tfatal(\"unable to make the process undumpable\");\n#endif\n#if defined(HAVE_SETPFLAGS) && defined(__PROC_PROTECT)\n\t/* On Solaris, we should make this process untraceable */\n\tif (setpflags(__PROC_PROTECT, 1) != 0 && strict)\n\t\tfatal(\"unable to make the process untraceable\");\n#endif\n#ifdef PT_DENY_ATTACH\n\t/* Mac OS X */\n\tif (ptrace(PT_DENY_ATTACH, 0, 0, 0) == -1 && strict)\n\t\tfatal(\"unable to set PT_DENY_ATTACH\");\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "setgid",
          "args": [
            "getgid()"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setegid",
          "args": [
            "getgid()"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "setegid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "89-92",
          "snippet": "int setegid(uid_t egid)\n{\n\treturn(setresgid(-1, egid, -1));\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint setegid(uid_t egid)\n{\n\treturn(setresgid(-1, egid, -1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sanitise_stdfd",
          "args": [],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "sanitise_stdfd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1109-1130",
          "snippet": "void\nsanitise_stdfd(void)\n{\n\tint nullfd, dupfd;\n\n\tif ((nullfd = dupfd = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\tfprintf(stderr, \"Couldn't open /dev/null: %s\\n\",\n\t\t    strerror(errno));\n\t\texit(1);\n\t}\n\twhile (++dupfd <= STDERR_FILENO) {\n\t\t/* Only populate closed fds. */\n\t\tif (fcntl(dupfd, F_GETFL) == -1 && errno == EBADF) {\n\t\t\tif (dup2(nullfd, dupfd) == -1) {\n\t\t\t\tfprintf(stderr, \"dup2: %s\\n\", strerror(errno));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\tif (nullfd > STDERR_FILENO)\n\t\tclose(nullfd);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsanitise_stdfd(void)\n{\n\tint nullfd, dupfd;\n\n\tif ((nullfd = dupfd = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\tfprintf(stderr, \"Couldn't open /dev/null: %s\\n\",\n\t\t    strerror(errno));\n\t\texit(1);\n\t}\n\twhile (++dupfd <= STDERR_FILENO) {\n\t\t/* Only populate closed fds. */\n\t\tif (fcntl(dupfd, F_GETFL) == -1 && errno == EBADF) {\n\t\t\tif (dup2(nullfd, dupfd) == -1) {\n\t\t\t\tfprintf(stderr, \"dup2: %s\\n\", strerror(errno));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\tif (nullfd > STDERR_FILENO)\n\t\tclose(nullfd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_malloc_init",
          "args": [],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_malloc_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "29-37",
          "snippet": "void\nssh_malloc_init(void)\n{\n#if defined(__OpenBSD__)\n\textern char *malloc_options;\n\n\tmalloc_options = \"S\";\n#endif /* __OpenBSD__ */\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nssh_malloc_init(void)\n{\n#if defined(__OpenBSD__)\n\textern char *malloc_options;\n\n\tmalloc_options = \"S\";\n#endif /* __OpenBSD__ */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SSH_AGENT_MIN_FDS (3+1+1+1+4)\n\npid_t parent_pid = -1;\ntime_t parent_alive_interval = 0;\npid_t cleanup_pid = 0;\nchar socket_name[PATH_MAX];\nchar socket_dir[PATH_MAX];\nstatic char *pkcs11_whitelist;\nextern char *__progname;\nstatic long lifetime = 0;\nstatic int fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\nint\nmain(int ac, char **av)\n{\n\tint c_flag = 0, d_flag = 0, D_flag = 0, k_flag = 0, s_flag = 0;\n\tint sock, fd, ch, result, saved_errno;\n\tchar *shell, *format, *pidstr, *agentsocket = NULL;\n#ifdef HAVE_SETRLIMIT\n\tstruct rlimit rlim;\n#endif\n\textern int optind;\n\textern char *optarg;\n\tpid_t pid;\n\tchar pidstrbuf[1 + 3 * sizeof pid];\n\tsize_t len;\n\tmode_t prev_mask;\n\tint timeout = -1; /* INFTIM */\n\tstruct pollfd *pfd = NULL;\n\tsize_t npfd = 0;\n\tu_int maxfds;\n\n\tssh_malloc_init();\t/* must be called before any mallocs */\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\t/* drop */\n\tsetegid(getgid());\n\tsetgid(getgid());\n\n\tplatform_disable_tracing(0);\t/* strict=no */\n\n\tif (getrlimit(RLIMIT_NOFILE, &rlim) == -1)\n\t\tfatal(\"%s: getrlimit: %s\", __progname, strerror(errno));\n\n#ifdef WITH_OPENSSL\n\tOpenSSL_add_all_algorithms();\n#endif\n\n\t__progname = ssh_get_progname(av[0]);\n\tseed_rng();\n\n\twhile ((ch = getopt(ac, av, \"cDdksE:a:P:t:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'E':\n\t\t\tfingerprint_hash = ssh_digest_alg_by_name(optarg);\n\t\t\tif (fingerprint_hash == -1)\n\t\t\t\tfatal(\"Invalid hash algorithm \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tif (s_flag)\n\t\t\t\tusage();\n\t\t\tc_flag++;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tk_flag++;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (pkcs11_whitelist != NULL)\n\t\t\t\tfatal(\"-P option already specified\");\n\t\t\tpkcs11_whitelist = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (c_flag)\n\t\t\t\tusage();\n\t\t\ts_flag++;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\td_flag++;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\tD_flag++;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tagentsocket = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif ((lifetime = convtime(optarg)) == -1) {\n\t\t\t\tfprintf(stderr, \"Invalid lifetime\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\tac -= optind;\n\tav += optind;\n\n\tif (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))\n\t\tusage();\n\n\tif (pkcs11_whitelist == NULL)\n\t\tpkcs11_whitelist = xstrdup(DEFAULT_PKCS11_WHITELIST);\n\n\tif (ac == 0 && !c_flag && !s_flag) {\n\t\tshell = getenv(\"SHELL\");\n\t\tif (shell != NULL && (len = strlen(shell)) > 2 &&\n\t\t    strncmp(shell + len - 3, \"csh\", 3) == 0)\n\t\t\tc_flag = 1;\n\t}\n\tif (k_flag) {\n\t\tconst char *errstr = NULL;\n\n\t\tpidstr = getenv(SSH_AGENTPID_ENV_NAME);\n\t\tif (pidstr == NULL) {\n\t\t\tfprintf(stderr, \"%s not set, cannot kill agent\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\texit(1);\n\t\t}\n\t\tpid = (int)strtonum(pidstr, 2, INT_MAX, &errstr);\n\t\tif (errstr) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s=\\\"%s\\\", which is not a good PID: %s\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME, pidstr, errstr);\n\t\t\texit(1);\n\t\t}\n\t\tif (kill(pid, SIGTERM) == -1) {\n\t\t\tperror(\"kill\");\n\t\t\texit(1);\n\t\t}\n\t\tformat = c_flag ? \"unsetenv %s;\\n\" : \"unset %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(format, SSH_AGENTPID_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld killed;\\n\", (long)pid);\n\t\texit(0);\n\t}\n\n\t/*\n\t * Minimum file descriptors:\n\t * stdio (3) + listener (1) + syslog (1 maybe) + connection (1) +\n\t * a few spare for libc / stack protectors / sanitisers, etc.\n\t */\n#define SSH_AGENT_MIN_FDS (3+1+1+1+4)\n\tif (rlim.rlim_cur < SSH_AGENT_MIN_FDS)\n\t\tfatal(\"%s: file descriptor rlimit %lld too low (minimum %u)\",\n\t\t    __progname, (long long)rlim.rlim_cur, SSH_AGENT_MIN_FDS);\n\tmaxfds = rlim.rlim_cur - SSH_AGENT_MIN_FDS;\n\n\tparent_pid = getpid();\n\n\tif (agentsocket == NULL) {\n\t\t/* Create private directory for agent socket */\n\t\tmktemp_proto(socket_dir, sizeof(socket_dir));\n\t\tif (mkdtemp(socket_dir) == NULL) {\n\t\t\tperror(\"mkdtemp: private socket dir\");\n\t\t\texit(1);\n\t\t}\n\t\tsnprintf(socket_name, sizeof socket_name, \"%s/agent.%ld\", socket_dir,\n\t\t    (long)parent_pid);\n\t} else {\n\t\t/* Try to use specified agent socket */\n\t\tsocket_dir[0] = '\\0';\n\t\tstrlcpy(socket_name, agentsocket, sizeof socket_name);\n\t}\n\n\t/*\n\t * Create socket early so it will exist before command gets run from\n\t * the parent.\n\t */\n\tprev_mask = umask(0177);\n\tsock = unix_listener(socket_name, SSH_LISTEN_BACKLOG, 0);\n\tif (sock < 0) {\n\t\t/* XXX - unix_listener() calls error() not perror() */\n\t\t*socket_name = '\\0'; /* Don't unlink any existing file */\n\t\tcleanup_exit(1);\n\t}\n\tumask(prev_mask);\n\n\t/*\n\t * Fork, and have the parent execute the command, if any, or present\n\t * the socket data.  The child continues as the authentication agent.\n\t */\n\tif (D_flag || d_flag) {\n\t\tlog_init(__progname,\n\t\t    d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO,\n\t\t    SYSLOG_FACILITY_AUTH, 1);\n\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld;\\n\", (long)parent_pid);\n\t\tfflush(stdout);\n\t\tgoto skip;\n\t}\n\tpid = fork();\n\tif (pid == -1) {\n\t\tperror(\"fork\");\n\t\tcleanup_exit(1);\n\t}\n\tif (pid != 0) {\t\t/* Parent - execute the given command. */\n\t\tclose(sock);\n\t\tsnprintf(pidstrbuf, sizeof pidstrbuf, \"%ld\", (long)pid);\n\t\tif (ac == 0) {\n\t\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\t\tprintf(format, SSH_AGENTPID_ENV_NAME, pidstrbuf,\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\tprintf(\"echo Agent pid %ld;\\n\", (long)pid);\n\t\t\texit(0);\n\t\t}\n\t\tif (setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1) == -1 ||\n\t\t    setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1) == -1) {\n\t\t\tperror(\"setenv\");\n\t\t\texit(1);\n\t\t}\n\t\texecvp(av[0], av);\n\t\tperror(av[0]);\n\t\texit(1);\n\t}\n\t/* child */\n\tlog_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);\n\n\tif (setsid() == -1) {\n\t\terror(\"setsid: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n\n\t(void)chdir(\"/\");\n\tif ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {\n\t\t/* XXX might close listen socket */\n\t\t(void)dup2(fd, STDIN_FILENO);\n\t\t(void)dup2(fd, STDOUT_FILENO);\n\t\t(void)dup2(fd, STDERR_FILENO);\n\t\tif (fd > 2)\n\t\t\tclose(fd);\n\t}\n\n#ifdef HAVE_SETRLIMIT\n\t/* deny core dumps, since memory contains unencrypted private keys */\n\trlim.rlim_cur = rlim.rlim_max = 0;\n\tif (setrlimit(RLIMIT_CORE, &rlim) < 0) {\n\t\terror(\"setrlimit RLIMIT_CORE: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n#endif\n\nskip:\n\n\tcleanup_pid = getpid();\n\n#ifdef ENABLE_PKCS11\n\tpkcs11_init(0);\n#endif\n\tnew_socket(AUTH_SOCKET, sock);\n\tif (ac > 0)\n\t\tparent_alive_interval = 10;\n\tidtab_init();\n\tsignal(SIGPIPE, SIG_IGN);\n\tsignal(SIGINT, (d_flag | D_flag) ? cleanup_handler : SIG_IGN);\n\tsignal(SIGHUP, cleanup_handler);\n\tsignal(SIGTERM, cleanup_handler);\n\n\tif (pledge(\"stdio rpath cpath unix id proc exec\", NULL) == -1)\n\t\tfatal(\"%s: pledge: %s\", __progname, strerror(errno));\n\tplatform_pledge_agent();\n\n\twhile (1) {\n\t\tprepare_poll(&pfd, &npfd, &timeout, maxfds);\n\t\tresult = poll(pfd, npfd, timeout);\n\t\tsaved_errno = errno;\n\t\tif (parent_alive_interval != 0)\n\t\t\tcheck_parent_exists();\n\t\t(void) reaper();\t/* remove expired keys */\n\t\tif (result < 0) {\n\t\t\tif (saved_errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tfatal(\"poll: %s\", strerror(saved_errno));\n\t\t} else if (result > 0)\n\t\t\tafter_poll(pfd, npfd, maxfds);\n\t}\n\t/* NOTREACHED */\n}"
  },
  {
    "function_name": "usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "1055-1063",
    "snippet": "static void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-P pkcs11_whitelist] [-t life] [command [arg ...]]\\n\"\n\t    \"       ssh-agent [-c | -s] -k\\n\");\n\texit(1);\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *pkcs11_whitelist;",
      "static int fingerprint_hash = SSH_FP_HASH_DEFAULT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "1023-1028",
          "snippet": "void\ncleanup_exit(int i)\n{\n\tcleanup_socket();\n\t_exit(i);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ncleanup_exit(int i)\n{\n\tcleanup_socket();\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-P pkcs11_whitelist] [-t life] [command [arg ...]]\\n\"\n\t    \"       ssh-agent [-c | -s] -k\\n\""
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *pkcs11_whitelist;\nstatic int fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-P pkcs11_whitelist] [-t life] [command [arg ...]]\\n\"\n\t    \"       ssh-agent [-c | -s] -k\\n\");\n\texit(1);\n}"
  },
  {
    "function_name": "check_parent_exists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "1041-1053",
    "snippet": "static void\ncheck_parent_exists(void)\n{\n\t/*\n\t * If our parent has exited then getppid() will return (pid_t)1,\n\t * so testing for that should be safe.\n\t */\n\tif (parent_pid != -1 && getppid() != parent_pid) {\n\t\t/* printf(\"Parent has died - Authentication agent exiting.\\n\"); */\n\t\tcleanup_socket();\n\t\t_exit(2);\n\t}\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "pid_t parent_pid = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "2"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "1023-1028",
          "snippet": "void\ncleanup_exit(int i)\n{\n\tcleanup_socket();\n\t_exit(i);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ncleanup_exit(int i)\n{\n\tcleanup_socket();\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleanup_socket",
          "args": [],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "1011-1021",
          "snippet": "static void\ncleanup_socket(void)\n{\n\tif (cleanup_pid != 0 && getpid() != cleanup_pid)\n\t\treturn;\n\tdebug(\"%s: cleanup\", __func__);\n\tif (socket_name[0])\n\t\tunlink(socket_name);\n\tif (socket_dir[0])\n\t\trmdir(socket_dir);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "pid_t cleanup_pid = 0;",
            "char socket_name[PATH_MAX];",
            "char socket_dir[PATH_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\npid_t cleanup_pid = 0;\nchar socket_name[PATH_MAX];\nchar socket_dir[PATH_MAX];\n\nstatic void\ncleanup_socket(void)\n{\n\tif (cleanup_pid != 0 && getpid() != cleanup_pid)\n\t\treturn;\n\tdebug(\"%s: cleanup\", __func__);\n\tif (socket_name[0])\n\t\tunlink(socket_name);\n\tif (socket_dir[0])\n\t\trmdir(socket_dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getppid",
          "args": [],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\npid_t parent_pid = -1;\n\nstatic void\ncheck_parent_exists(void)\n{\n\t/*\n\t * If our parent has exited then getppid() will return (pid_t)1,\n\t * so testing for that should be safe.\n\t */\n\tif (parent_pid != -1 && getppid() != parent_pid) {\n\t\t/* printf(\"Parent has died - Authentication agent exiting.\\n\"); */\n\t\tcleanup_socket();\n\t\t_exit(2);\n\t}\n}"
  },
  {
    "function_name": "cleanup_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "1031-1039",
    "snippet": "static void\ncleanup_handler(int sig)\n{\n\tcleanup_socket();\n#ifdef ENABLE_PKCS11\n\tpkcs11_terminate();\n#endif\n\t_exit(2);\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "2"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "1023-1028",
          "snippet": "void\ncleanup_exit(int i)\n{\n\tcleanup_socket();\n\t_exit(i);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ncleanup_exit(int i)\n{\n\tcleanup_socket();\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pkcs11_terminate",
          "args": [],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "pkcs11_terminate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
          "lines": "108-113",
          "snippet": "void\npkcs11_terminate(void)\n{\n\tif (fd >= 0)\n\t\tclose(fd);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"pathnames.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rsa.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\npkcs11_terminate(void)\n{\n\tif (fd >= 0)\n\t\tclose(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleanup_socket",
          "args": [],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "1011-1021",
          "snippet": "static void\ncleanup_socket(void)\n{\n\tif (cleanup_pid != 0 && getpid() != cleanup_pid)\n\t\treturn;\n\tdebug(\"%s: cleanup\", __func__);\n\tif (socket_name[0])\n\t\tunlink(socket_name);\n\tif (socket_dir[0])\n\t\trmdir(socket_dir);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "pid_t cleanup_pid = 0;",
            "char socket_name[PATH_MAX];",
            "char socket_dir[PATH_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\npid_t cleanup_pid = 0;\nchar socket_name[PATH_MAX];\nchar socket_dir[PATH_MAX];\n\nstatic void\ncleanup_socket(void)\n{\n\tif (cleanup_pid != 0 && getpid() != cleanup_pid)\n\t\treturn;\n\tdebug(\"%s: cleanup\", __func__);\n\tif (socket_name[0])\n\t\tunlink(socket_name);\n\tif (socket_dir[0])\n\t\trmdir(socket_dir);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ncleanup_handler(int sig)\n{\n\tcleanup_socket();\n#ifdef ENABLE_PKCS11\n\tpkcs11_terminate();\n#endif\n\t_exit(2);\n}"
  },
  {
    "function_name": "cleanup_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "1023-1028",
    "snippet": "void\ncleanup_exit(int i)\n{\n\tcleanup_socket();\n\t_exit(i);\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "i"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "1023-1028",
          "snippet": "void\ncleanup_exit(int i)\n{\n\tcleanup_socket();\n\t_exit(i);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "cleanup_socket",
          "args": [],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "1011-1021",
          "snippet": "static void\ncleanup_socket(void)\n{\n\tif (cleanup_pid != 0 && getpid() != cleanup_pid)\n\t\treturn;\n\tdebug(\"%s: cleanup\", __func__);\n\tif (socket_name[0])\n\t\tunlink(socket_name);\n\tif (socket_dir[0])\n\t\trmdir(socket_dir);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "pid_t cleanup_pid = 0;",
            "char socket_name[PATH_MAX];",
            "char socket_dir[PATH_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\npid_t cleanup_pid = 0;\nchar socket_name[PATH_MAX];\nchar socket_dir[PATH_MAX];\n\nstatic void\ncleanup_socket(void)\n{\n\tif (cleanup_pid != 0 && getpid() != cleanup_pid)\n\t\treturn;\n\tdebug(\"%s: cleanup\", __func__);\n\tif (socket_name[0])\n\t\tunlink(socket_name);\n\tif (socket_dir[0])\n\t\trmdir(socket_dir);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ncleanup_exit(int i)\n{\n\tcleanup_socket();\n\t_exit(i);\n}"
  },
  {
    "function_name": "cleanup_socket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "1011-1021",
    "snippet": "static void\ncleanup_socket(void)\n{\n\tif (cleanup_pid != 0 && getpid() != cleanup_pid)\n\t\treturn;\n\tdebug(\"%s: cleanup\", __func__);\n\tif (socket_name[0])\n\t\tunlink(socket_name);\n\tif (socket_dir[0])\n\t\trmdir(socket_dir);\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "pid_t cleanup_pid = 0;",
      "char socket_name[PATH_MAX];",
      "char socket_dir[PATH_MAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "socket_dir"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "process_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1128-1143",
          "snippet": "static void\nprocess_rmdir(u_int32_t id)\n{\n\tchar *name;\n\tint r, status;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"request %u: rmdir\", id);\n\tlogit(\"rmdir name \\\"%s\\\"\", name);\n\tr = rmdir(name);\n\tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n\tsend_status(id, status);\n\tfree(name);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct sshbuf *iqueue;",
            "static void process_open(u_int32_t id);",
            "static void process_close(u_int32_t id);",
            "static void process_read(u_int32_t id);",
            "static void process_write(u_int32_t id);",
            "static void process_stat(u_int32_t id);",
            "static void process_lstat(u_int32_t id);",
            "static void process_fstat(u_int32_t id);",
            "static void process_setstat(u_int32_t id);",
            "static void process_fsetstat(u_int32_t id);",
            "static void process_opendir(u_int32_t id);",
            "static void process_readdir(u_int32_t id);",
            "static void process_remove(u_int32_t id);",
            "static void process_mkdir(u_int32_t id);",
            "static void process_rmdir(u_int32_t id);",
            "static void process_realpath(u_int32_t id);",
            "static void process_rename(u_int32_t id);",
            "static void process_readlink(u_int32_t id);",
            "static void process_symlink(u_int32_t id);",
            "static void process_extended_posix_rename(u_int32_t id);",
            "static void process_extended_statvfs(u_int32_t id);",
            "static void process_extended_fstatvfs(u_int32_t id);",
            "static void process_extended_hardlink(u_int32_t id);",
            "static void process_extended_fsync(u_int32_t id);",
            "static void process_extended(u_int32_t id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *iqueue;\nstatic void process_open(u_int32_t id);\nstatic void process_close(u_int32_t id);\nstatic void process_read(u_int32_t id);\nstatic void process_write(u_int32_t id);\nstatic void process_stat(u_int32_t id);\nstatic void process_lstat(u_int32_t id);\nstatic void process_fstat(u_int32_t id);\nstatic void process_setstat(u_int32_t id);\nstatic void process_fsetstat(u_int32_t id);\nstatic void process_opendir(u_int32_t id);\nstatic void process_readdir(u_int32_t id);\nstatic void process_remove(u_int32_t id);\nstatic void process_mkdir(u_int32_t id);\nstatic void process_rmdir(u_int32_t id);\nstatic void process_realpath(u_int32_t id);\nstatic void process_rename(u_int32_t id);\nstatic void process_readlink(u_int32_t id);\nstatic void process_symlink(u_int32_t id);\nstatic void process_extended_posix_rename(u_int32_t id);\nstatic void process_extended_statvfs(u_int32_t id);\nstatic void process_extended_fstatvfs(u_int32_t id);\nstatic void process_extended_hardlink(u_int32_t id);\nstatic void process_extended_fsync(u_int32_t id);\nstatic void process_extended(u_int32_t id);\n\nstatic void\nprocess_rmdir(u_int32_t id)\n{\n\tchar *name;\n\tint r, status;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"request %u: rmdir\", id);\n\tlogit(\"rmdir name \\\"%s\\\"\", name);\n\tr = rmdir(name);\n\tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n\tsend_status(id, status);\n\tfree(name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "socket_name"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: cleanup\"",
            "__func__"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\npid_t cleanup_pid = 0;\nchar socket_name[PATH_MAX];\nchar socket_dir[PATH_MAX];\n\nstatic void\ncleanup_socket(void)\n{\n\tif (cleanup_pid != 0 && getpid() != cleanup_pid)\n\t\treturn;\n\tdebug(\"%s: cleanup\", __func__);\n\tif (socket_name[0])\n\t\tunlink(socket_name);\n\tif (socket_dir[0])\n\t\trmdir(socket_dir);\n}"
  },
  {
    "function_name": "prepare_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "943-1009",
    "snippet": "static int\nprepare_poll(struct pollfd **pfdp, size_t *npfdp, int *timeoutp, u_int maxfds)\n{\n\tstruct pollfd *pfd = *pfdp;\n\tsize_t i, j, npfd = 0;\n\ttime_t deadline;\n\n\t/* Count active sockets */\n\tfor (i = 0; i < sockets_alloc; i++) {\n\t\tswitch (sockets[i].type) {\n\t\tcase AUTH_SOCKET:\n\t\tcase AUTH_CONNECTION:\n\t\t\tnpfd++;\n\t\t\tbreak;\n\t\tcase AUTH_UNUSED:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Unknown socket type %d\", sockets[i].type);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (npfd != *npfdp &&\n\t    (pfd = recallocarray(pfd, *npfdp, npfd, sizeof(*pfd))) == NULL)\n\t\tfatal(\"%s: recallocarray failed\", __func__);\n\t*pfdp = pfd;\n\t*npfdp = npfd;\n\n\tfor (i = j = 0; i < sockets_alloc; i++) {\n\t\tswitch (sockets[i].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %zu >= limit %u); \"\n\t\t\t\t    \"skipping arming listener\", npfd, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpfd[j].fd = sockets[i].fd;\n\t\t\tpfd[j].revents = 0;\n\t\t\tpfd[j].events = POLLIN;\n\t\t\tj++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tpfd[j].fd = sockets[i].fd;\n\t\t\tpfd[j].revents = 0;\n\t\t\t/* XXX backoff when input buffer full */\n\t\t\tpfd[j].events = POLLIN;\n\t\t\tif (sshbuf_len(sockets[i].output) > 0)\n\t\t\t\tpfd[j].events |= POLLOUT;\n\t\t\tj++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tdeadline = reaper();\n\tif (parent_alive_interval != 0)\n\t\tdeadline = (deadline == 0) ? parent_alive_interval :\n\t\t    MINIMUM(deadline, parent_alive_interval);\n\tif (deadline == 0) {\n\t\t*timeoutp = -1; /* INFTIM */\n\t} else {\n\t\tif (deadline > INT_MAX / 1000)\n\t\t\t*timeoutp = INT_MAX / 1000;\n\t\telse\n\t\t\t*timeoutp = deadline * 1000;\n\t}\n\treturn (1);\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int sockets_alloc = 0;",
      "SocketEntry *sockets = NULL;",
      "time_t parent_alive_interval = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MINIMUM",
          "args": [
            "deadline",
            "parent_alive_interval"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reaper",
          "args": [],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "reaper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "376-399",
          "snippet": "static time_t\nreaper(void)\n{\n\ttime_t deadline = 0, now = monotime();\n\tIdentity *id, *nxt;\n\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id; id = nxt) {\n\t\tnxt = TAILQ_NEXT(id, next);\n\t\tif (id->death == 0)\n\t\t\tcontinue;\n\t\tif (now >= id->death) {\n\t\t\tdebug(\"expiring key '%s'\", id->comment);\n\t\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\t\tfree_identity(id);\n\t\t\tidtab->nentries--;\n\t\t} else\n\t\t\tdeadline = (deadline == 0) ? id->death :\n\t\t\t    MINIMUM(deadline, id->death);\n\t}\n\tif (deadline == 0 || deadline <= now)\n\t\treturn 0;\n\telse\n\t\treturn (deadline - now);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct idtable *idtab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct idtable *idtab;\n\nstatic time_t\nreaper(void)\n{\n\ttime_t deadline = 0, now = monotime();\n\tIdentity *id, *nxt;\n\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id; id = nxt) {\n\t\tnxt = TAILQ_NEXT(id, next);\n\t\tif (id->death == 0)\n\t\t\tcontinue;\n\t\tif (now >= id->death) {\n\t\t\tdebug(\"expiring key '%s'\", id->comment);\n\t\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\t\tfree_identity(id);\n\t\t\tidtab->nentries--;\n\t\t} else\n\t\t\tdeadline = (deadline == 0) ? id->death :\n\t\t\t    MINIMUM(deadline, id->death);\n\t}\n\tif (deadline == 0 || deadline <= now)\n\t\treturn 0;\n\telse\n\t\treturn (deadline - now);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "sockets[i].output"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"out of fds (active %zu >= limit %u); \"\n\t\t\t\t    \"skipping arming listener\"",
            "npfd",
            "maxfds"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: recallocarray failed\"",
            "__func__"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recallocarray",
          "args": [
            "pfd",
            "*npfdp",
            "npfd",
            "sizeof(*pfd)"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "xrecallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "80-90",
          "snippet": "void *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int sockets_alloc = 0;\nSocketEntry *sockets = NULL;\ntime_t parent_alive_interval = 0;\n\nstatic int\nprepare_poll(struct pollfd **pfdp, size_t *npfdp, int *timeoutp, u_int maxfds)\n{\n\tstruct pollfd *pfd = *pfdp;\n\tsize_t i, j, npfd = 0;\n\ttime_t deadline;\n\n\t/* Count active sockets */\n\tfor (i = 0; i < sockets_alloc; i++) {\n\t\tswitch (sockets[i].type) {\n\t\tcase AUTH_SOCKET:\n\t\tcase AUTH_CONNECTION:\n\t\t\tnpfd++;\n\t\t\tbreak;\n\t\tcase AUTH_UNUSED:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Unknown socket type %d\", sockets[i].type);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (npfd != *npfdp &&\n\t    (pfd = recallocarray(pfd, *npfdp, npfd, sizeof(*pfd))) == NULL)\n\t\tfatal(\"%s: recallocarray failed\", __func__);\n\t*pfdp = pfd;\n\t*npfdp = npfd;\n\n\tfor (i = j = 0; i < sockets_alloc; i++) {\n\t\tswitch (sockets[i].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %zu >= limit %u); \"\n\t\t\t\t    \"skipping arming listener\", npfd, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpfd[j].fd = sockets[i].fd;\n\t\t\tpfd[j].revents = 0;\n\t\t\tpfd[j].events = POLLIN;\n\t\t\tj++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tpfd[j].fd = sockets[i].fd;\n\t\t\tpfd[j].revents = 0;\n\t\t\t/* XXX backoff when input buffer full */\n\t\t\tpfd[j].events = POLLIN;\n\t\t\tif (sshbuf_len(sockets[i].output) > 0)\n\t\t\t\tpfd[j].events |= POLLOUT;\n\t\t\tj++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tdeadline = reaper();\n\tif (parent_alive_interval != 0)\n\t\tdeadline = (deadline == 0) ? parent_alive_interval :\n\t\t    MINIMUM(deadline, parent_alive_interval);\n\tif (deadline == 0) {\n\t\t*timeoutp = -1; /* INFTIM */\n\t} else {\n\t\tif (deadline > INT_MAX / 1000)\n\t\t\t*timeoutp = INT_MAX / 1000;\n\t\telse\n\t\t\t*timeoutp = deadline * 1000;\n\t}\n\treturn (1);\n}"
  },
  {
    "function_name": "after_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "888-941",
    "snippet": "static void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t/* Find sockets entry */\n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror(\"%s: no socket for fd %d\", __func__, pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Process events */\n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0) {\n\t\t\t\tgoto close_sock;\n\t\t\t}\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int sockets_alloc = 0;",
      "SocketEntry *sockets = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close_socket",
          "args": [
            "&sockets[socknum]"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "close_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "165-174",
          "snippet": "static void\nclose_socket(SocketEntry *e)\n{\n\tclose(e->fd);\n\te->fd = -1;\n\te->type = AUTH_UNUSED;\n\tsshbuf_free(e->input);\n\tsshbuf_free(e->output);\n\tsshbuf_free(e->request);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nclose_socket(SocketEntry *e)\n{\n\tclose(e->fd);\n\te->fd = -1;\n\te->type = AUTH_UNUSED;\n\tsshbuf_free(e->input);\n\tsshbuf_free(e->output);\n\tsshbuf_free(e->request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"activefds == 0 at close_sock\""
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_conn_write",
          "args": [
            "socknum"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "handle_conn_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "863-886",
          "snippet": "static int\nhandle_conn_write(u_int socknum)\n{\n\tssize_t len;\n\tint r;\n\n\tif (sshbuf_len(sockets[socknum].output) == 0)\n\t\treturn 0; /* shouldn't happen */\n\tif ((len = write(sockets[socknum].fd,\n\t    sshbuf_ptr(sockets[socknum].output),\n\t    sshbuf_len(sockets[socknum].output))) <= 0) {\n\t\tif (len == -1) {\n\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\treturn 0;\n\t\t\terror(\"%s: read error on socket %u (fd %d): %s\",\n\t\t\t    __func__, socknum, sockets[socknum].fd,\n\t\t\t    strerror(errno));\n\t\t}\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_consume(sockets[socknum].output, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\treturn 0;\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "SocketEntry *sockets = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nSocketEntry *sockets = NULL;\n\nstatic int\nhandle_conn_write(u_int socknum)\n{\n\tssize_t len;\n\tint r;\n\n\tif (sshbuf_len(sockets[socknum].output) == 0)\n\t\treturn 0; /* shouldn't happen */\n\tif ((len = write(sockets[socknum].fd,\n\t    sshbuf_ptr(sockets[socknum].output),\n\t    sshbuf_len(sockets[socknum].output))) <= 0) {\n\t\tif (len == -1) {\n\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\treturn 0;\n\t\t\terror(\"%s: read error on socket %u (fd %d): %s\",\n\t\t\t    __func__, socknum, sockets[socknum].fd,\n\t\t\t    strerror(errno));\n\t\t}\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_consume(sockets[socknum].output, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_conn_read",
          "args": [
            "socknum"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "handle_conn_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "839-861",
          "snippet": "static int\nhandle_conn_read(u_int socknum)\n{\n\tchar buf[1024];\n\tssize_t len;\n\tint r;\n\n\tif ((len = read(sockets[socknum].fd, buf, sizeof(buf))) <= 0) {\n\t\tif (len == -1) {\n\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\treturn 0;\n\t\t\terror(\"%s: read error on socket %u (fd %d): %s\",\n\t\t\t    __func__, socknum, sockets[socknum].fd,\n\t\t\t    strerror(errno));\n\t\t}\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_put(sockets[socknum].input, buf, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\texplicit_bzero(buf, sizeof(buf));\n\tprocess_message(socknum);\n\treturn 0;\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "SocketEntry *sockets = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nSocketEntry *sockets = NULL;\n\nstatic int\nhandle_conn_read(u_int socknum)\n{\n\tchar buf[1024];\n\tssize_t len;\n\tint r;\n\n\tif ((len = read(sockets[socknum].fd, buf, sizeof(buf))) <= 0) {\n\t\tif (len == -1) {\n\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\treturn 0;\n\t\t\terror(\"%s: read error on socket %u (fd %d): %s\",\n\t\t\t    __func__, socknum, sockets[socknum].fd,\n\t\t\t    strerror(errno));\n\t\t}\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_put(sockets[socknum].input, buf, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\texplicit_bzero(buf, sizeof(buf));\n\tprocess_message(socknum);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_socket_read",
          "args": [
            "socknum"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "handle_socket_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "809-837",
          "snippet": "static int\nhandle_socket_read(u_int socknum)\n{\n\tstruct sockaddr_un sunaddr;\n\tsocklen_t slen;\n\tuid_t euid;\n\tgid_t egid;\n\tint fd;\n\n\tslen = sizeof(sunaddr);\n\tfd = accept(sockets[socknum].fd, (struct sockaddr *)&sunaddr, &slen);\n\tif (fd < 0) {\n\t\terror(\"accept from AUTH_SOCKET: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tif (getpeereid(fd, &euid, &egid) < 0) {\n\t\terror(\"getpeereid %d failed: %s\", fd, strerror(errno));\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif ((euid != 0) && (getuid() != euid)) {\n\t\terror(\"uid mismatch: peer euid %u != uid %u\",\n\t\t    (u_int) euid, (u_int) getuid());\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tnew_socket(AUTH_CONNECTION, fd);\n\treturn 0;\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "SocketEntry *sockets = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nSocketEntry *sockets = NULL;\n\nstatic int\nhandle_socket_read(u_int socknum)\n{\n\tstruct sockaddr_un sunaddr;\n\tsocklen_t slen;\n\tuid_t euid;\n\tgid_t egid;\n\tint fd;\n\n\tslen = sizeof(sunaddr);\n\tfd = accept(sockets[socknum].fd, (struct sockaddr *)&sunaddr, &slen);\n\tif (fd < 0) {\n\t\terror(\"accept from AUTH_SOCKET: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tif (getpeereid(fd, &euid, &egid) < 0) {\n\t\terror(\"getpeereid %d failed: %s\", fd, strerror(errno));\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif ((euid != 0) && (getuid() != euid)) {\n\t\terror(\"uid mismatch: peer euid %u != uid %u\",\n\t\t    (u_int) euid, (u_int) getuid());\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tnew_socket(AUTH_CONNECTION, fd);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\"",
            "activefds",
            "maxfds"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: no socket for fd %d\"",
            "__func__",
            "pfd[i].fd"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int sockets_alloc = 0;\nSocketEntry *sockets = NULL;\n\nstatic void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t/* Find sockets entry */\n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror(\"%s: no socket for fd %d\", __func__, pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Process events */\n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0) {\n\t\t\t\tgoto close_sock;\n\t\t\t}\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "handle_conn_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "863-886",
    "snippet": "static int\nhandle_conn_write(u_int socknum)\n{\n\tssize_t len;\n\tint r;\n\n\tif (sshbuf_len(sockets[socknum].output) == 0)\n\t\treturn 0; /* shouldn't happen */\n\tif ((len = write(sockets[socknum].fd,\n\t    sshbuf_ptr(sockets[socknum].output),\n\t    sshbuf_len(sockets[socknum].output))) <= 0) {\n\t\tif (len == -1) {\n\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\treturn 0;\n\t\t\terror(\"%s: read error on socket %u (fd %d): %s\",\n\t\t\t    __func__, socknum, sockets[socknum].fd,\n\t\t\t    strerror(errno));\n\t\t}\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_consume(sockets[socknum].output, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\treturn 0;\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "SocketEntry *sockets = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_consume",
          "args": [
            "sockets[socknum].output",
            "len"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_consume_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "383-398",
          "snippet": "int\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: read error on socket %u (fd %d): %s\"",
            "__func__",
            "socknum",
            "sockets[socknum].fd",
            "strerror(errno)"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "sockets[socknum].fd",
            "sshbuf_ptr(sockets[socknum].output)",
            "sshbuf_len(sockets[socknum].output)"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "sockets[socknum].output"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "sockets[socknum].output"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nSocketEntry *sockets = NULL;\n\nstatic int\nhandle_conn_write(u_int socknum)\n{\n\tssize_t len;\n\tint r;\n\n\tif (sshbuf_len(sockets[socknum].output) == 0)\n\t\treturn 0; /* shouldn't happen */\n\tif ((len = write(sockets[socknum].fd,\n\t    sshbuf_ptr(sockets[socknum].output),\n\t    sshbuf_len(sockets[socknum].output))) <= 0) {\n\t\tif (len == -1) {\n\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\treturn 0;\n\t\t\terror(\"%s: read error on socket %u (fd %d): %s\",\n\t\t\t    __func__, socknum, sockets[socknum].fd,\n\t\t\t    strerror(errno));\n\t\t}\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_consume(sockets[socknum].output, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\treturn 0;\n}"
  },
  {
    "function_name": "handle_conn_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "839-861",
    "snippet": "static int\nhandle_conn_read(u_int socknum)\n{\n\tchar buf[1024];\n\tssize_t len;\n\tint r;\n\n\tif ((len = read(sockets[socknum].fd, buf, sizeof(buf))) <= 0) {\n\t\tif (len == -1) {\n\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\treturn 0;\n\t\t\terror(\"%s: read error on socket %u (fd %d): %s\",\n\t\t\t    __func__, socknum, sockets[socknum].fd,\n\t\t\t    strerror(errno));\n\t\t}\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_put(sockets[socknum].input, buf, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\texplicit_bzero(buf, sizeof(buf));\n\tprocess_message(socknum);\n\treturn 0;\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "SocketEntry *sockets = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_message",
          "args": [
            "socknum"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "process_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "671-769",
          "snippet": "static int\nprocess_message(u_int socknum)\n{\n\tu_int msg_len;\n\tu_char type;\n\tconst u_char *cp;\n\tint r;\n\tSocketEntry *e;\n\n\tif (socknum >= sockets_alloc) {\n\t\tfatal(\"%s: socket number %u >= allocated %u\",\n\t\t    __func__, socknum, sockets_alloc);\n\t}\n\te = &sockets[socknum];\n\n\tif (sshbuf_len(e->input) < 5)\n\t\treturn 0;\t\t/* Incomplete message header. */\n\tcp = sshbuf_ptr(e->input);\n\tmsg_len = PEEK_U32(cp);\n\tif (msg_len > AGENT_MAX_LEN) {\n\t\tdebug(\"%s: socket %u (fd=%d) message too long %u > %u\",\n\t\t    __func__, socknum, e->fd, msg_len, AGENT_MAX_LEN);\n\t\treturn -1;\n\t}\n\tif (sshbuf_len(e->input) < msg_len + 4)\n\t\treturn 0;\t\t/* Incomplete message body. */\n\n\t/* move the current input to e->request */\n\tsshbuf_reset(e->request);\n\tif ((r = sshbuf_get_stringb(e->input, e->request)) != 0 ||\n\t    (r = sshbuf_get_u8(e->request, &type)) != 0) {\n\t\tif (r == SSH_ERR_MESSAGE_INCOMPLETE ||\n\t\t    r == SSH_ERR_STRING_TOO_LARGE) {\n\t\t\tdebug(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\t\treturn -1;\n\t\t}\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\n\tdebug(\"%s: socket %u (fd=%d) type %d\", __func__, socknum, e->fd, type);\n\n\t/* check whether agent is locked */\n\tif (locked && type != SSH_AGENTC_UNLOCK) {\n\t\tsshbuf_reset(e->request);\n\t\tswitch (type) {\n\t\tcase SSH2_AGENTC_REQUEST_IDENTITIES:\n\t\t\t/* send empty lists */\n\t\t\tno_identities(e);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* send a fail message for all other request types */\n\t\t\tsend_status(e, 0);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tswitch (type) {\n\tcase SSH_AGENTC_LOCK:\n\tcase SSH_AGENTC_UNLOCK:\n\t\tprocess_lock_agent(e, type == SSH_AGENTC_LOCK);\n\t\tbreak;\n\tcase SSH_AGENTC_REMOVE_ALL_RSA_IDENTITIES:\n\t\tprocess_remove_all_identities(e); /* safe for !WITH_SSH1 */\n\t\tbreak;\n\t/* ssh2 */\n\tcase SSH2_AGENTC_SIGN_REQUEST:\n\t\tprocess_sign_request2(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REQUEST_IDENTITIES:\n\t\tprocess_request_identities(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_ADD_IDENTITY:\n\tcase SSH2_AGENTC_ADD_ID_CONSTRAINED:\n\t\tprocess_add_identity(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REMOVE_IDENTITY:\n\t\tprocess_remove_identity(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REMOVE_ALL_IDENTITIES:\n\t\tprocess_remove_all_identities(e);\n\t\tbreak;\n#ifdef ENABLE_PKCS11\n\tcase SSH_AGENTC_ADD_SMARTCARD_KEY:\n\tcase SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED:\n\t\tprocess_add_smartcard_key(e);\n\t\tbreak;\n\tcase SSH_AGENTC_REMOVE_SMARTCARD_KEY:\n\t\tprocess_remove_smartcard_key(e);\n\t\tbreak;\n#endif /* ENABLE_PKCS11 */\n\tdefault:\n\t\t/* Unknown message.  Respond with failure. */\n\t\terror(\"Unknown message %d\", type);\n\t\tsshbuf_reset(e->request);\n\t\tsend_status(e, 0);\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define AGENT_MAX_LEN\t(256*1024)"
          ],
          "globals_used": [
            "u_int sockets_alloc = 0;",
            "SocketEntry *sockets = NULL;",
            "int locked = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define AGENT_MAX_LEN\t(256*1024)\n\nu_int sockets_alloc = 0;\nSocketEntry *sockets = NULL;\nint locked = 0;\n\nstatic int\nprocess_message(u_int socknum)\n{\n\tu_int msg_len;\n\tu_char type;\n\tconst u_char *cp;\n\tint r;\n\tSocketEntry *e;\n\n\tif (socknum >= sockets_alloc) {\n\t\tfatal(\"%s: socket number %u >= allocated %u\",\n\t\t    __func__, socknum, sockets_alloc);\n\t}\n\te = &sockets[socknum];\n\n\tif (sshbuf_len(e->input) < 5)\n\t\treturn 0;\t\t/* Incomplete message header. */\n\tcp = sshbuf_ptr(e->input);\n\tmsg_len = PEEK_U32(cp);\n\tif (msg_len > AGENT_MAX_LEN) {\n\t\tdebug(\"%s: socket %u (fd=%d) message too long %u > %u\",\n\t\t    __func__, socknum, e->fd, msg_len, AGENT_MAX_LEN);\n\t\treturn -1;\n\t}\n\tif (sshbuf_len(e->input) < msg_len + 4)\n\t\treturn 0;\t\t/* Incomplete message body. */\n\n\t/* move the current input to e->request */\n\tsshbuf_reset(e->request);\n\tif ((r = sshbuf_get_stringb(e->input, e->request)) != 0 ||\n\t    (r = sshbuf_get_u8(e->request, &type)) != 0) {\n\t\tif (r == SSH_ERR_MESSAGE_INCOMPLETE ||\n\t\t    r == SSH_ERR_STRING_TOO_LARGE) {\n\t\t\tdebug(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\t\treturn -1;\n\t\t}\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\n\tdebug(\"%s: socket %u (fd=%d) type %d\", __func__, socknum, e->fd, type);\n\n\t/* check whether agent is locked */\n\tif (locked && type != SSH_AGENTC_UNLOCK) {\n\t\tsshbuf_reset(e->request);\n\t\tswitch (type) {\n\t\tcase SSH2_AGENTC_REQUEST_IDENTITIES:\n\t\t\t/* send empty lists */\n\t\t\tno_identities(e);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* send a fail message for all other request types */\n\t\t\tsend_status(e, 0);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tswitch (type) {\n\tcase SSH_AGENTC_LOCK:\n\tcase SSH_AGENTC_UNLOCK:\n\t\tprocess_lock_agent(e, type == SSH_AGENTC_LOCK);\n\t\tbreak;\n\tcase SSH_AGENTC_REMOVE_ALL_RSA_IDENTITIES:\n\t\tprocess_remove_all_identities(e); /* safe for !WITH_SSH1 */\n\t\tbreak;\n\t/* ssh2 */\n\tcase SSH2_AGENTC_SIGN_REQUEST:\n\t\tprocess_sign_request2(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REQUEST_IDENTITIES:\n\t\tprocess_request_identities(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_ADD_IDENTITY:\n\tcase SSH2_AGENTC_ADD_ID_CONSTRAINED:\n\t\tprocess_add_identity(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REMOVE_IDENTITY:\n\t\tprocess_remove_identity(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REMOVE_ALL_IDENTITIES:\n\t\tprocess_remove_all_identities(e);\n\t\tbreak;\n#ifdef ENABLE_PKCS11\n\tcase SSH_AGENTC_ADD_SMARTCARD_KEY:\n\tcase SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED:\n\t\tprocess_add_smartcard_key(e);\n\t\tbreak;\n\tcase SSH_AGENTC_REMOVE_SMARTCARD_KEY:\n\t\tprocess_remove_smartcard_key(e);\n\t\tbreak;\n#endif /* ENABLE_PKCS11 */\n\tdefault:\n\t\t/* Unknown message.  Respond with failure. */\n\t\terror(\"Unknown message %d\", type);\n\t\tsshbuf_reset(e->request);\n\t\tsend_status(e, 0);\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "buf",
            "sizeof(buf)"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "sockets[socknum].input",
            "buf",
            "len"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: read error on socket %u (fd %d): %s\"",
            "__func__",
            "socknum",
            "sockets[socknum].fd",
            "strerror(errno)"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "sockets[socknum].fd",
            "buf",
            "sizeof(buf)"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "do_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "675-679",
          "snippet": "int\ndo_readdir(struct sftp_conn *conn, const char *path, SFTP_DIRENT ***dir)\n{\n\treturn(do_lsreaddir(conn, path, 0, dir));\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndo_readdir(struct sftp_conn *conn, const char *path, SFTP_DIRENT ***dir)\n{\n\treturn(do_lsreaddir(conn, path, 0, dir));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nSocketEntry *sockets = NULL;\n\nstatic int\nhandle_conn_read(u_int socknum)\n{\n\tchar buf[1024];\n\tssize_t len;\n\tint r;\n\n\tif ((len = read(sockets[socknum].fd, buf, sizeof(buf))) <= 0) {\n\t\tif (len == -1) {\n\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\treturn 0;\n\t\t\terror(\"%s: read error on socket %u (fd %d): %s\",\n\t\t\t    __func__, socknum, sockets[socknum].fd,\n\t\t\t    strerror(errno));\n\t\t}\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_put(sockets[socknum].input, buf, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\texplicit_bzero(buf, sizeof(buf));\n\tprocess_message(socknum);\n\treturn 0;\n}"
  },
  {
    "function_name": "handle_socket_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "809-837",
    "snippet": "static int\nhandle_socket_read(u_int socknum)\n{\n\tstruct sockaddr_un sunaddr;\n\tsocklen_t slen;\n\tuid_t euid;\n\tgid_t egid;\n\tint fd;\n\n\tslen = sizeof(sunaddr);\n\tfd = accept(sockets[socknum].fd, (struct sockaddr *)&sunaddr, &slen);\n\tif (fd < 0) {\n\t\terror(\"accept from AUTH_SOCKET: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tif (getpeereid(fd, &euid, &egid) < 0) {\n\t\terror(\"getpeereid %d failed: %s\", fd, strerror(errno));\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif ((euid != 0) && (getuid() != euid)) {\n\t\terror(\"uid mismatch: peer euid %u != uid %u\",\n\t\t    (u_int) euid, (u_int) getuid());\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tnew_socket(AUTH_CONNECTION, fd);\n\treturn 0;\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "SocketEntry *sockets = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "new_socket",
          "args": [
            "AUTH_CONNECTION",
            "fd"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "new_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "771-807",
          "snippet": "static void\nnew_socket(sock_type type, int fd)\n{\n\tu_int i, old_alloc, new_alloc;\n\n\tset_nonblock(fd);\n\n\tif (fd > max_fd)\n\t\tmax_fd = fd;\n\n\tfor (i = 0; i < sockets_alloc; i++)\n\t\tif (sockets[i].type == AUTH_UNUSED) {\n\t\t\tsockets[i].fd = fd;\n\t\t\tif ((sockets[i].input = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tif ((sockets[i].output = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tif ((sockets[i].request = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tsockets[i].type = type;\n\t\t\treturn;\n\t\t}\n\told_alloc = sockets_alloc;\n\tnew_alloc = sockets_alloc + 10;\n\tsockets = xreallocarray(sockets, new_alloc, sizeof(sockets[0]));\n\tfor (i = old_alloc; i < new_alloc; i++)\n\t\tsockets[i].type = AUTH_UNUSED;\n\tsockets_alloc = new_alloc;\n\tsockets[old_alloc].fd = fd;\n\tif ((sockets[old_alloc].input = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((sockets[old_alloc].output = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((sockets[old_alloc].request = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tsockets[old_alloc].type = type;\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int sockets_alloc = 0;",
            "SocketEntry *sockets = NULL;",
            "int max_fd = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int sockets_alloc = 0;\nSocketEntry *sockets = NULL;\nint max_fd = 0;\n\nstatic void\nnew_socket(sock_type type, int fd)\n{\n\tu_int i, old_alloc, new_alloc;\n\n\tset_nonblock(fd);\n\n\tif (fd > max_fd)\n\t\tmax_fd = fd;\n\n\tfor (i = 0; i < sockets_alloc; i++)\n\t\tif (sockets[i].type == AUTH_UNUSED) {\n\t\t\tsockets[i].fd = fd;\n\t\t\tif ((sockets[i].input = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tif ((sockets[i].output = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tif ((sockets[i].request = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tsockets[i].type = type;\n\t\t\treturn;\n\t\t}\n\told_alloc = sockets_alloc;\n\tnew_alloc = sockets_alloc + 10;\n\tsockets = xreallocarray(sockets, new_alloc, sizeof(sockets[0]));\n\tfor (i = old_alloc; i < new_alloc; i++)\n\t\tsockets[i].type = AUTH_UNUSED;\n\tsockets_alloc = new_alloc;\n\tsockets[old_alloc].fd = fd;\n\tif ((sockets[old_alloc].input = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((sockets[old_alloc].output = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((sockets[old_alloc].request = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tsockets[old_alloc].type = type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "close_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "165-174",
          "snippet": "static void\nclose_socket(SocketEntry *e)\n{\n\tclose(e->fd);\n\te->fd = -1;\n\te->type = AUTH_UNUSED;\n\tsshbuf_free(e->input);\n\tsshbuf_free(e->output);\n\tsshbuf_free(e->request);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nclose_socket(SocketEntry *e)\n{\n\tclose(e->fd);\n\te->fd = -1;\n\te->type = AUTH_UNUSED;\n\tsshbuf_free(e->input);\n\tsshbuf_free(e->output);\n\tsshbuf_free(e->request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"uid mismatch: peer euid %u != uid %u\"",
            "(u_int) euid",
            "(u_int) getuid()"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpeereid",
          "args": [
            "fd",
            "&euid",
            "&egid"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "getpeereid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-getpeereid.c",
          "lines": "63-70",
          "snippet": "int\ngetpeereid(int s, uid_t *euid, gid_t *gid)\n{\n\t*euid = geteuid();\n\t*gid = getgid();\n\n\treturn (0);\n}",
          "includes": [
            "# include <ucred.h>",
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <ucred.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ngetpeereid(int s, uid_t *euid, gid_t *gid)\n{\n\t*euid = geteuid();\n\t*gid = getgid();\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "sockets[socknum].fd",
            "(struct sockaddr *)&sunaddr",
            "&slen"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "input_userauth_service_accept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "419-449",
          "snippet": "int\ninput_userauth_service_accept(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tint r;\n\n\tif (ssh_packet_remaining(ssh) > 0) {\n\t\tchar *reply;\n\n\t\tif ((r = sshpkt_get_cstring(ssh, &reply, NULL)) != 0)\n\t\t\tgoto out;\n\t\tdebug2(\"service_accept: %s\", reply);\n\t\tfree(reply);\n\t} else {\n\t\tdebug2(\"buggy server: service_accept w/o service\");\n\t}\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto out;\n\tdebug(\"SSH2_MSG_SERVICE_ACCEPT received\");\n\n\t/* initial userauth request */\n\tuserauth_none(authctxt);\n\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &input_userauth_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_SUCCESS, &input_userauth_success);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_FAILURE, &input_userauth_failure);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_BANNER, &input_userauth_banner);\n\tr = 0;\n out:\n\treturn r;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
            "int\tuserauth_none(Authctxt *);",
            "int\tuserauth_pubkey(Authctxt *);",
            "int\tuserauth_passwd(Authctxt *);",
            "int\tuserauth_kbdint(Authctxt *);",
            "int\tuserauth_hostbased(Authctxt *);",
            "void\tuserauth(Authctxt *, char *);",
            "static void pubkey_prepare(Authctxt *);",
            "static void pubkey_cleanup(Authctxt *);",
            "static void pubkey_reset(Authctxt *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\n\nint\ninput_userauth_service_accept(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tint r;\n\n\tif (ssh_packet_remaining(ssh) > 0) {\n\t\tchar *reply;\n\n\t\tif ((r = sshpkt_get_cstring(ssh, &reply, NULL)) != 0)\n\t\t\tgoto out;\n\t\tdebug2(\"service_accept: %s\", reply);\n\t\tfree(reply);\n\t} else {\n\t\tdebug2(\"buggy server: service_accept w/o service\");\n\t}\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto out;\n\tdebug(\"SSH2_MSG_SERVICE_ACCEPT received\");\n\n\t/* initial userauth request */\n\tuserauth_none(authctxt);\n\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &input_userauth_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_SUCCESS, &input_userauth_success);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_FAILURE, &input_userauth_failure);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_BANNER, &input_userauth_banner);\n\tr = 0;\n out:\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nSocketEntry *sockets = NULL;\n\nstatic int\nhandle_socket_read(u_int socknum)\n{\n\tstruct sockaddr_un sunaddr;\n\tsocklen_t slen;\n\tuid_t euid;\n\tgid_t egid;\n\tint fd;\n\n\tslen = sizeof(sunaddr);\n\tfd = accept(sockets[socknum].fd, (struct sockaddr *)&sunaddr, &slen);\n\tif (fd < 0) {\n\t\terror(\"accept from AUTH_SOCKET: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tif (getpeereid(fd, &euid, &egid) < 0) {\n\t\terror(\"getpeereid %d failed: %s\", fd, strerror(errno));\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif ((euid != 0) && (getuid() != euid)) {\n\t\terror(\"uid mismatch: peer euid %u != uid %u\",\n\t\t    (u_int) euid, (u_int) getuid());\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tnew_socket(AUTH_CONNECTION, fd);\n\treturn 0;\n}"
  },
  {
    "function_name": "new_socket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "771-807",
    "snippet": "static void\nnew_socket(sock_type type, int fd)\n{\n\tu_int i, old_alloc, new_alloc;\n\n\tset_nonblock(fd);\n\n\tif (fd > max_fd)\n\t\tmax_fd = fd;\n\n\tfor (i = 0; i < sockets_alloc; i++)\n\t\tif (sockets[i].type == AUTH_UNUSED) {\n\t\t\tsockets[i].fd = fd;\n\t\t\tif ((sockets[i].input = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tif ((sockets[i].output = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tif ((sockets[i].request = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tsockets[i].type = type;\n\t\t\treturn;\n\t\t}\n\told_alloc = sockets_alloc;\n\tnew_alloc = sockets_alloc + 10;\n\tsockets = xreallocarray(sockets, new_alloc, sizeof(sockets[0]));\n\tfor (i = old_alloc; i < new_alloc; i++)\n\t\tsockets[i].type = AUTH_UNUSED;\n\tsockets_alloc = new_alloc;\n\tsockets[old_alloc].fd = fd;\n\tif ((sockets[old_alloc].input = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((sockets[old_alloc].output = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((sockets[old_alloc].request = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tsockets[old_alloc].type = type;\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int sockets_alloc = 0;",
      "SocketEntry *sockets = NULL;",
      "int max_fd = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xreallocarray",
          "args": [
            "sockets",
            "new_alloc",
            "sizeof(sockets[0])"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "xreallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "68-78",
          "snippet": "void *\nxreallocarray(void *ptr, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = reallocarray(ptr, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xreallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxreallocarray(void *ptr, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = reallocarray(ptr, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xreallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nonblock",
          "args": [
            "fd"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "unset_nonblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "116-138",
          "snippet": "int\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int sockets_alloc = 0;\nSocketEntry *sockets = NULL;\nint max_fd = 0;\n\nstatic void\nnew_socket(sock_type type, int fd)\n{\n\tu_int i, old_alloc, new_alloc;\n\n\tset_nonblock(fd);\n\n\tif (fd > max_fd)\n\t\tmax_fd = fd;\n\n\tfor (i = 0; i < sockets_alloc; i++)\n\t\tif (sockets[i].type == AUTH_UNUSED) {\n\t\t\tsockets[i].fd = fd;\n\t\t\tif ((sockets[i].input = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tif ((sockets[i].output = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tif ((sockets[i].request = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tsockets[i].type = type;\n\t\t\treturn;\n\t\t}\n\told_alloc = sockets_alloc;\n\tnew_alloc = sockets_alloc + 10;\n\tsockets = xreallocarray(sockets, new_alloc, sizeof(sockets[0]));\n\tfor (i = old_alloc; i < new_alloc; i++)\n\t\tsockets[i].type = AUTH_UNUSED;\n\tsockets_alloc = new_alloc;\n\tsockets[old_alloc].fd = fd;\n\tif ((sockets[old_alloc].input = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((sockets[old_alloc].output = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((sockets[old_alloc].request = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tsockets[old_alloc].type = type;\n}"
  },
  {
    "function_name": "process_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "671-769",
    "snippet": "static int\nprocess_message(u_int socknum)\n{\n\tu_int msg_len;\n\tu_char type;\n\tconst u_char *cp;\n\tint r;\n\tSocketEntry *e;\n\n\tif (socknum >= sockets_alloc) {\n\t\tfatal(\"%s: socket number %u >= allocated %u\",\n\t\t    __func__, socknum, sockets_alloc);\n\t}\n\te = &sockets[socknum];\n\n\tif (sshbuf_len(e->input) < 5)\n\t\treturn 0;\t\t/* Incomplete message header. */\n\tcp = sshbuf_ptr(e->input);\n\tmsg_len = PEEK_U32(cp);\n\tif (msg_len > AGENT_MAX_LEN) {\n\t\tdebug(\"%s: socket %u (fd=%d) message too long %u > %u\",\n\t\t    __func__, socknum, e->fd, msg_len, AGENT_MAX_LEN);\n\t\treturn -1;\n\t}\n\tif (sshbuf_len(e->input) < msg_len + 4)\n\t\treturn 0;\t\t/* Incomplete message body. */\n\n\t/* move the current input to e->request */\n\tsshbuf_reset(e->request);\n\tif ((r = sshbuf_get_stringb(e->input, e->request)) != 0 ||\n\t    (r = sshbuf_get_u8(e->request, &type)) != 0) {\n\t\tif (r == SSH_ERR_MESSAGE_INCOMPLETE ||\n\t\t    r == SSH_ERR_STRING_TOO_LARGE) {\n\t\t\tdebug(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\t\treturn -1;\n\t\t}\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\n\tdebug(\"%s: socket %u (fd=%d) type %d\", __func__, socknum, e->fd, type);\n\n\t/* check whether agent is locked */\n\tif (locked && type != SSH_AGENTC_UNLOCK) {\n\t\tsshbuf_reset(e->request);\n\t\tswitch (type) {\n\t\tcase SSH2_AGENTC_REQUEST_IDENTITIES:\n\t\t\t/* send empty lists */\n\t\t\tno_identities(e);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* send a fail message for all other request types */\n\t\t\tsend_status(e, 0);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tswitch (type) {\n\tcase SSH_AGENTC_LOCK:\n\tcase SSH_AGENTC_UNLOCK:\n\t\tprocess_lock_agent(e, type == SSH_AGENTC_LOCK);\n\t\tbreak;\n\tcase SSH_AGENTC_REMOVE_ALL_RSA_IDENTITIES:\n\t\tprocess_remove_all_identities(e); /* safe for !WITH_SSH1 */\n\t\tbreak;\n\t/* ssh2 */\n\tcase SSH2_AGENTC_SIGN_REQUEST:\n\t\tprocess_sign_request2(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REQUEST_IDENTITIES:\n\t\tprocess_request_identities(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_ADD_IDENTITY:\n\tcase SSH2_AGENTC_ADD_ID_CONSTRAINED:\n\t\tprocess_add_identity(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REMOVE_IDENTITY:\n\t\tprocess_remove_identity(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REMOVE_ALL_IDENTITIES:\n\t\tprocess_remove_all_identities(e);\n\t\tbreak;\n#ifdef ENABLE_PKCS11\n\tcase SSH_AGENTC_ADD_SMARTCARD_KEY:\n\tcase SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED:\n\t\tprocess_add_smartcard_key(e);\n\t\tbreak;\n\tcase SSH_AGENTC_REMOVE_SMARTCARD_KEY:\n\t\tprocess_remove_smartcard_key(e);\n\t\tbreak;\n#endif /* ENABLE_PKCS11 */\n\tdefault:\n\t\t/* Unknown message.  Respond with failure. */\n\t\terror(\"Unknown message %d\", type);\n\t\tsshbuf_reset(e->request);\n\t\tsend_status(e, 0);\n\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define AGENT_MAX_LEN\t(256*1024)"
    ],
    "globals_used": [
      "u_int sockets_alloc = 0;",
      "SocketEntry *sockets = NULL;",
      "int locked = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_status",
          "args": [
            "e",
            "0"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "send_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "223-232",
          "snippet": "static void\nsend_status(SocketEntry *e, int success)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(e->output, 1)) != 0 ||\n\t    (r = sshbuf_put_u8(e->output, success ?\n\t    SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_status(SocketEntry *e, int success)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(e->output, 1)) != 0 ||\n\t    (r = sshbuf_put_u8(e->output, success ?\n\t    SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "e->request"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Unknown message %d\"",
            "type"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_remove_smartcard_key",
          "args": [
            "e"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "process_remove_smartcard_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "627-666",
          "snippet": "static void\nprocess_remove_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX];\n\tint r, success = 0;\n\tIdentity *id, *nxt;\n\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tgoto send;\n\t}\n\tfree(pin);\n\n\tif (realpath(provider, canonical_provider) == NULL) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n\t\t    provider, strerror(errno));\n\t\tgoto send;\n\t}\n\n\tdebug(\"%s: remove %.100s\", __func__, canonical_provider);\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id; id = nxt) {\n\t\tnxt = TAILQ_NEXT(id, next);\n\t\t/* Skip file--based keys */\n\t\tif (id->provider == NULL)\n\t\t\tcontinue;\n\t\tif (!strcmp(canonical_provider, id->provider)) {\n\t\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\t\tfree_identity(id);\n\t\t\tidtab->nentries--;\n\t\t}\n\t}\n\tif (pkcs11_del_provider(canonical_provider) == 0)\n\t\tsuccess = 1;\n\telse\n\t\terror(\"%s: pkcs11_del_provider failed\", __func__);\nsend:\n\tfree(provider);\n\tsend_status(e, success);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct idtable *idtab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct idtable *idtab;\n\nstatic void\nprocess_remove_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX];\n\tint r, success = 0;\n\tIdentity *id, *nxt;\n\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tgoto send;\n\t}\n\tfree(pin);\n\n\tif (realpath(provider, canonical_provider) == NULL) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n\t\t    provider, strerror(errno));\n\t\tgoto send;\n\t}\n\n\tdebug(\"%s: remove %.100s\", __func__, canonical_provider);\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id; id = nxt) {\n\t\tnxt = TAILQ_NEXT(id, next);\n\t\t/* Skip file--based keys */\n\t\tif (id->provider == NULL)\n\t\t\tcontinue;\n\t\tif (!strcmp(canonical_provider, id->provider)) {\n\t\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\t\tfree_identity(id);\n\t\t\tidtab->nentries--;\n\t\t}\n\t}\n\tif (pkcs11_del_provider(canonical_provider) == 0)\n\t\tsuccess = 1;\n\telse\n\t\terror(\"%s: pkcs11_del_provider failed\", __func__);\nsend:\n\tfree(provider);\n\tsend_status(e, success);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_add_smartcard_key",
          "args": [
            "e"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "process_add_smartcard_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "549-625",
          "snippet": "static void\nprocess_add_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX];\n\tint r, i, count = 0, success = 0, confirm = 0;\n\tu_int seconds;\n\ttime_t death = 0;\n\tu_char type;\n\tstruct sshkey **keys = NULL, *k;\n\tIdentity *id;\n\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tgoto send;\n\t}\n\n\twhile (sshbuf_len(e->request)) {\n\t\tif ((r = sshbuf_get_u8(e->request, &type)) != 0) {\n\t\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\t\tgoto send;\n\t\t}\n\t\tswitch (type) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif ((r = sshbuf_get_u32(e->request, &seconds)) != 0) {\n\t\t\t\terror(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tgoto send;\n\t\t\t}\n\t\t\tdeath = monotime() + seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tconfirm = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Unknown constraint type %d\", __func__, type);\n\t\t\tgoto send;\n\t\t}\n\t}\n\tif (realpath(provider, canonical_provider) == NULL) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n\t\t    provider, strerror(errno));\n\t\tgoto send;\n\t}\n\tif (match_pattern_list(canonical_provider, pkcs11_whitelist, 0) != 1) {\n\t\tverbose(\"refusing PKCS#11 add of \\\"%.100s\\\": \"\n\t\t    \"provider not whitelisted\", canonical_provider);\n\t\tgoto send;\n\t}\n\tdebug(\"%s: add %.100s\", __func__, canonical_provider);\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\n\tcount = pkcs11_add_provider(canonical_provider, pin, &keys);\n\tfor (i = 0; i < count; i++) {\n\t\tk = keys[i];\n\t\tif (lookup_identity(k) == NULL) {\n\t\t\tid = xcalloc(1, sizeof(Identity));\n\t\t\tid->key = k;\n\t\t\tid->provider = xstrdup(canonical_provider);\n\t\t\tid->comment = xstrdup(canonical_provider); /* XXX */\n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t\tidtab->nentries++;\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\tsshkey_free(k);\n\t\t}\n\t\tkeys[i] = NULL;\n\t}\nsend:\n\tfree(pin);\n\tfree(provider);\n\tfree(keys);\n\tsend_status(e, success);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct idtable *idtab;",
            "static char *pkcs11_whitelist;",
            "static long lifetime = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct idtable *idtab;\nstatic char *pkcs11_whitelist;\nstatic long lifetime = 0;\n\nstatic void\nprocess_add_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX];\n\tint r, i, count = 0, success = 0, confirm = 0;\n\tu_int seconds;\n\ttime_t death = 0;\n\tu_char type;\n\tstruct sshkey **keys = NULL, *k;\n\tIdentity *id;\n\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tgoto send;\n\t}\n\n\twhile (sshbuf_len(e->request)) {\n\t\tif ((r = sshbuf_get_u8(e->request, &type)) != 0) {\n\t\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\t\tgoto send;\n\t\t}\n\t\tswitch (type) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif ((r = sshbuf_get_u32(e->request, &seconds)) != 0) {\n\t\t\t\terror(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tgoto send;\n\t\t\t}\n\t\t\tdeath = monotime() + seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tconfirm = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Unknown constraint type %d\", __func__, type);\n\t\t\tgoto send;\n\t\t}\n\t}\n\tif (realpath(provider, canonical_provider) == NULL) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n\t\t    provider, strerror(errno));\n\t\tgoto send;\n\t}\n\tif (match_pattern_list(canonical_provider, pkcs11_whitelist, 0) != 1) {\n\t\tverbose(\"refusing PKCS#11 add of \\\"%.100s\\\": \"\n\t\t    \"provider not whitelisted\", canonical_provider);\n\t\tgoto send;\n\t}\n\tdebug(\"%s: add %.100s\", __func__, canonical_provider);\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\n\tcount = pkcs11_add_provider(canonical_provider, pin, &keys);\n\tfor (i = 0; i < count; i++) {\n\t\tk = keys[i];\n\t\tif (lookup_identity(k) == NULL) {\n\t\t\tid = xcalloc(1, sizeof(Identity));\n\t\t\tid->key = k;\n\t\t\tid->provider = xstrdup(canonical_provider);\n\t\t\tid->comment = xstrdup(canonical_provider); /* XXX */\n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t\tidtab->nentries++;\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\tsshkey_free(k);\n\t\t}\n\t\tkeys[i] = NULL;\n\t}\nsend:\n\tfree(pin);\n\tfree(provider);\n\tfree(keys);\n\tsend_status(e, success);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_remove_all_identities",
          "args": [
            "e"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "process_remove_all_identities",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "356-373",
          "snippet": "static void\nprocess_remove_all_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\n\t/* Loop over all identities and clear the keys. */\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id;\n\t    id = TAILQ_FIRST(&idtab->idlist)) {\n\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\tfree_identity(id);\n\t}\n\n\t/* Mark that there are no identities. */\n\tidtab->nentries = 0;\n\n\t/* Send success. */\n\tsend_status(e, 1);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct idtable *idtab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct idtable *idtab;\n\nstatic void\nprocess_remove_all_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\n\t/* Loop over all identities and clear the keys. */\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id;\n\t    id = TAILQ_FIRST(&idtab->idlist)) {\n\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\tfree_identity(id);\n\t}\n\n\t/* Mark that there are no identities. */\n\tidtab->nentries = 0;\n\n\t/* Send success. */\n\tsend_status(e, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_remove_identity",
          "args": [
            "e"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "process_remove_identity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "328-354",
          "snippet": "static void\nprocess_remove_identity(SocketEntry *e)\n{\n\tint r, success = 0;\n\tstruct sshkey *key = NULL;\n\tIdentity *id;\n\n\tif ((r = sshkey_froms(e->request, &key)) != 0) {\n\t\terror(\"%s: get key: %s\", __func__, ssh_err(r));\n\t\tgoto done;\n\t}\n\tif ((id = lookup_identity(key)) == NULL) {\n\t\tdebug(\"%s: key not found\", __func__);\n\t\tgoto done;\n\t}\n\t/* We have this key, free it. */\n\tif (idtab->nentries < 1)\n\t\tfatal(\"%s: internal error: nentries %d\",\n\t\t    __func__, idtab->nentries);\n\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\tfree_identity(id);\n\tidtab->nentries--;\n\tsshkey_free(key);\n\tsuccess = 1;\n done:\n\tsend_status(e, success);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct idtable *idtab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct idtable *idtab;\n\nstatic void\nprocess_remove_identity(SocketEntry *e)\n{\n\tint r, success = 0;\n\tstruct sshkey *key = NULL;\n\tIdentity *id;\n\n\tif ((r = sshkey_froms(e->request, &key)) != 0) {\n\t\terror(\"%s: get key: %s\", __func__, ssh_err(r));\n\t\tgoto done;\n\t}\n\tif ((id = lookup_identity(key)) == NULL) {\n\t\tdebug(\"%s: key not found\", __func__);\n\t\tgoto done;\n\t}\n\t/* We have this key, free it. */\n\tif (idtab->nentries < 1)\n\t\tfatal(\"%s: internal error: nentries %d\",\n\t\t    __func__, idtab->nentries);\n\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\tfree_identity(id);\n\tidtab->nentries--;\n\tsshkey_free(key);\n\tsuccess = 1;\n done:\n\tsend_status(e, success);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_add_identity",
          "args": [
            "e"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "process_add_identity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "401-478",
          "snippet": "static void\nprocess_add_identity(SocketEntry *e)\n{\n\tIdentity *id;\n\tint success = 0, confirm = 0;\n\tu_int seconds, maxsign;\n\tchar *comment = NULL;\n\ttime_t death = 0;\n\tstruct sshkey *k = NULL;\n\tu_char ctype;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((r = sshkey_private_deserialize(e->request, &k)) != 0 ||\n\t    k == NULL ||\n\t    (r = sshbuf_get_cstring(e->request, &comment, NULL)) != 0) {\n\t\terror(\"%s: decode private key: %s\", __func__, ssh_err(r));\n\t\tgoto err;\n\t}\n\n\twhile (sshbuf_len(e->request)) {\n\t\tif ((r = sshbuf_get_u8(e->request, &ctype)) != 0) {\n\t\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\t\tgoto err;\n\t\t}\n\t\tswitch (ctype) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif ((r = sshbuf_get_u32(e->request, &seconds)) != 0) {\n\t\t\t\terror(\"%s: bad lifetime constraint: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tdeath = monotime() + seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tconfirm = 1;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_MAXSIGN:\n\t\t\tif ((r = sshbuf_get_u32(e->request, &maxsign)) != 0) {\n\t\t\t\terror(\"%s: bad maxsign constraint: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif ((r = sshkey_enable_maxsign(k, maxsign)) != 0) {\n\t\t\t\terror(\"%s: cannot enable maxsign: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Unknown constraint %d\", __func__, ctype);\n err:\n\t\t\tsshbuf_reset(e->request);\n\t\t\tfree(comment);\n\t\t\tsshkey_free(k);\n\t\t\tgoto send;\n\t\t}\n\t}\n\n\tsuccess = 1;\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\tif ((id = lookup_identity(k)) == NULL) {\n\t\tid = xcalloc(1, sizeof(Identity));\n\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t/* Increment the number of identities. */\n\t\tidtab->nentries++;\n\t} else {\n\t\t/* key state might have been updated */\n\t\tsshkey_free(id->key);\n\t\tfree(id->comment);\n\t}\n\tid->key = k;\n\tid->comment = comment;\n\tid->death = death;\n\tid->confirm = confirm;\nsend:\n\tsend_status(e, success);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct idtable *idtab;",
            "static long lifetime = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct idtable *idtab;\nstatic long lifetime = 0;\n\nstatic void\nprocess_add_identity(SocketEntry *e)\n{\n\tIdentity *id;\n\tint success = 0, confirm = 0;\n\tu_int seconds, maxsign;\n\tchar *comment = NULL;\n\ttime_t death = 0;\n\tstruct sshkey *k = NULL;\n\tu_char ctype;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((r = sshkey_private_deserialize(e->request, &k)) != 0 ||\n\t    k == NULL ||\n\t    (r = sshbuf_get_cstring(e->request, &comment, NULL)) != 0) {\n\t\terror(\"%s: decode private key: %s\", __func__, ssh_err(r));\n\t\tgoto err;\n\t}\n\n\twhile (sshbuf_len(e->request)) {\n\t\tif ((r = sshbuf_get_u8(e->request, &ctype)) != 0) {\n\t\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\t\tgoto err;\n\t\t}\n\t\tswitch (ctype) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif ((r = sshbuf_get_u32(e->request, &seconds)) != 0) {\n\t\t\t\terror(\"%s: bad lifetime constraint: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tdeath = monotime() + seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tconfirm = 1;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_MAXSIGN:\n\t\t\tif ((r = sshbuf_get_u32(e->request, &maxsign)) != 0) {\n\t\t\t\terror(\"%s: bad maxsign constraint: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif ((r = sshkey_enable_maxsign(k, maxsign)) != 0) {\n\t\t\t\terror(\"%s: cannot enable maxsign: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Unknown constraint %d\", __func__, ctype);\n err:\n\t\t\tsshbuf_reset(e->request);\n\t\t\tfree(comment);\n\t\t\tsshkey_free(k);\n\t\t\tgoto send;\n\t\t}\n\t}\n\n\tsuccess = 1;\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\tif ((id = lookup_identity(k)) == NULL) {\n\t\tid = xcalloc(1, sizeof(Identity));\n\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t/* Increment the number of identities. */\n\t\tidtab->nentries++;\n\t} else {\n\t\t/* key state might have been updated */\n\t\tsshkey_free(id->key);\n\t\tfree(id->comment);\n\t}\n\tid->key = k;\n\tid->comment = comment;\n\tid->death = death;\n\tid->confirm = confirm;\nsend:\n\tsend_status(e, success);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_request_identities",
          "args": [
            "e"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "process_request_identities",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "235-259",
          "snippet": "static void\nprocess_request_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, idtab->nentries)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif ((r = sshkey_puts_opts(id->key, msg, SSHKEY_SERIALIZE_INFO))\n\t\t     != 0 ||\n\t\t    (r = sshbuf_put_cstring(msg, id->comment)) != 0) {\n\t\t\terror(\"%s: put key/comment: %s\", __func__,\n\t\t\t    ssh_err(r));\n\t\t\tcontinue;\n\t\t}\n\t}\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct idtable *idtab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct idtable *idtab;\n\nstatic void\nprocess_request_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, idtab->nentries)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif ((r = sshkey_puts_opts(id->key, msg, SSHKEY_SERIALIZE_INFO))\n\t\t     != 0 ||\n\t\t    (r = sshbuf_put_cstring(msg, id->comment)) != 0) {\n\t\t\terror(\"%s: put key/comment: %s\", __func__,\n\t\t\t    ssh_err(r));\n\t\t\tcontinue;\n\t\t}\n\t}\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_sign_request2",
          "args": [
            "e"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "process_sign_request2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "275-325",
          "snippet": "static void\nprocess_sign_request2(SocketEntry *e)\n{\n\tconst u_char *data;\n\tu_char *signature = NULL;\n\tsize_t dlen, slen = 0;\n\tu_int compat = 0, flags;\n\tint r, ok = -1;\n\tstruct sshbuf *msg;\n\tstruct sshkey *key = NULL;\n\tstruct identity *id;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshkey_froms(e->request, &key)) != 0 ||\n\t    (r = sshbuf_get_string_direct(e->request, &data, &dlen)) != 0 ||\n\t    (r = sshbuf_get_u32(e->request, &flags)) != 0) {\n\t\terror(\"%s: couldn't parse request: %s\", __func__, ssh_err(r));\n\t\tgoto send;\n\t}\n\n\tif ((id = lookup_identity(key)) == NULL) {\n\t\tverbose(\"%s: %s key not found\", __func__, sshkey_type(key));\n\t\tgoto send;\n\t}\n\tif (id->confirm && confirm_key(id) != 0) {\n\t\tverbose(\"%s: user refused key\", __func__);\n\t\tgoto send;\n\t}\n\tif ((r = sshkey_sign(id->key, &signature, &slen,\n\t    data, dlen, agent_decode_alg(key, flags), compat)) != 0) {\n\t\terror(\"%s: sshkey_sign: %s\", __func__, ssh_err(r));\n\t\tgoto send;\n\t}\n\t/* Success */\n\tok = 0;\n send:\n\tsshkey_free(key);\n\tif (ok == 0) {\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_SIGN_RESPONSE)) != 0 ||\n\t\t    (r = sshbuf_put_string(msg, signature, slen)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t} else if ((r = sshbuf_put_u8(msg, SSH_AGENT_FAILURE)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tsshbuf_free(msg);\n\tfree(signature);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nprocess_sign_request2(SocketEntry *e)\n{\n\tconst u_char *data;\n\tu_char *signature = NULL;\n\tsize_t dlen, slen = 0;\n\tu_int compat = 0, flags;\n\tint r, ok = -1;\n\tstruct sshbuf *msg;\n\tstruct sshkey *key = NULL;\n\tstruct identity *id;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshkey_froms(e->request, &key)) != 0 ||\n\t    (r = sshbuf_get_string_direct(e->request, &data, &dlen)) != 0 ||\n\t    (r = sshbuf_get_u32(e->request, &flags)) != 0) {\n\t\terror(\"%s: couldn't parse request: %s\", __func__, ssh_err(r));\n\t\tgoto send;\n\t}\n\n\tif ((id = lookup_identity(key)) == NULL) {\n\t\tverbose(\"%s: %s key not found\", __func__, sshkey_type(key));\n\t\tgoto send;\n\t}\n\tif (id->confirm && confirm_key(id) != 0) {\n\t\tverbose(\"%s: user refused key\", __func__);\n\t\tgoto send;\n\t}\n\tif ((r = sshkey_sign(id->key, &signature, &slen,\n\t    data, dlen, agent_decode_alg(key, flags), compat)) != 0) {\n\t\terror(\"%s: sshkey_sign: %s\", __func__, ssh_err(r));\n\t\tgoto send;\n\t}\n\t/* Success */\n\tok = 0;\n send:\n\tsshkey_free(key);\n\tif (ok == 0) {\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_SIGN_RESPONSE)) != 0 ||\n\t\t    (r = sshbuf_put_string(msg, signature, slen)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t} else if ((r = sshbuf_put_u8(msg, SSH_AGENT_FAILURE)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tsshbuf_free(msg);\n\tfree(signature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_lock_agent",
          "args": [
            "e",
            "type == SSH_AGENTC_LOCK"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "process_lock_agent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "481-531",
          "snippet": "static void\nprocess_lock_agent(SocketEntry *e, int lock)\n{\n\tint r, success = 0, delay;\n\tchar *passwd;\n\tu_char passwdhash[LOCK_SIZE];\n\tstatic u_int fail_count = 0;\n\tsize_t pwlen;\n\n\t/*\n\t * This is deliberately fatal: the user has requested that we lock,\n\t * but we can't parse their request properly. The only safe thing to\n\t * do is abort.\n\t */\n\tif ((r = sshbuf_get_cstring(e->request, &passwd, &pwlen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (pwlen == 0) {\n\t\tdebug(\"empty password not supported\");\n\t} else if (locked && !lock) {\n\t\tif (bcrypt_pbkdf(passwd, pwlen, lock_salt, sizeof(lock_salt),\n\t\t    passwdhash, sizeof(passwdhash), LOCK_ROUNDS) < 0)\n\t\t\tfatal(\"bcrypt_pbkdf\");\n\t\tif (timingsafe_bcmp(passwdhash, lock_pwhash, LOCK_SIZE) == 0) {\n\t\t\tdebug(\"agent unlocked\");\n\t\t\tlocked = 0;\n\t\t\tfail_count = 0;\n\t\t\texplicit_bzero(lock_pwhash, sizeof(lock_pwhash));\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\t/* delay in 0.1s increments up to 10s */\n\t\t\tif (fail_count < 100)\n\t\t\t\tfail_count++;\n\t\t\tdelay = 100000 * fail_count;\n\t\t\tdebug(\"unlock failed, delaying %0.1lf seconds\",\n\t\t\t    (double)delay/1000000);\n\t\t\tusleep(delay);\n\t\t}\n\t\texplicit_bzero(passwdhash, sizeof(passwdhash));\n\t} else if (!locked && lock) {\n\t\tdebug(\"agent locked\");\n\t\tlocked = 1;\n\t\tarc4random_buf(lock_salt, sizeof(lock_salt));\n\t\tif (bcrypt_pbkdf(passwd, pwlen, lock_salt, sizeof(lock_salt),\n\t\t    lock_pwhash, sizeof(lock_pwhash), LOCK_ROUNDS) < 0)\n\t\t\tfatal(\"bcrypt_pbkdf\");\n\t\tsuccess = 1;\n\t}\n\texplicit_bzero(passwd, pwlen);\n\tfree(passwd);\n\tsend_status(e, success);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define LOCK_ROUNDS\t1",
            "#define LOCK_SIZE\t32"
          ],
          "globals_used": [
            "int locked = 0;",
            "u_char lock_pwhash[LOCK_SIZE];",
            "u_char lock_salt[LOCK_SALT_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define LOCK_ROUNDS\t1\n#define LOCK_SIZE\t32\n\nint locked = 0;\nu_char lock_pwhash[LOCK_SIZE];\nu_char lock_salt[LOCK_SALT_SIZE];\n\nstatic void\nprocess_lock_agent(SocketEntry *e, int lock)\n{\n\tint r, success = 0, delay;\n\tchar *passwd;\n\tu_char passwdhash[LOCK_SIZE];\n\tstatic u_int fail_count = 0;\n\tsize_t pwlen;\n\n\t/*\n\t * This is deliberately fatal: the user has requested that we lock,\n\t * but we can't parse their request properly. The only safe thing to\n\t * do is abort.\n\t */\n\tif ((r = sshbuf_get_cstring(e->request, &passwd, &pwlen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (pwlen == 0) {\n\t\tdebug(\"empty password not supported\");\n\t} else if (locked && !lock) {\n\t\tif (bcrypt_pbkdf(passwd, pwlen, lock_salt, sizeof(lock_salt),\n\t\t    passwdhash, sizeof(passwdhash), LOCK_ROUNDS) < 0)\n\t\t\tfatal(\"bcrypt_pbkdf\");\n\t\tif (timingsafe_bcmp(passwdhash, lock_pwhash, LOCK_SIZE) == 0) {\n\t\t\tdebug(\"agent unlocked\");\n\t\t\tlocked = 0;\n\t\t\tfail_count = 0;\n\t\t\texplicit_bzero(lock_pwhash, sizeof(lock_pwhash));\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\t/* delay in 0.1s increments up to 10s */\n\t\t\tif (fail_count < 100)\n\t\t\t\tfail_count++;\n\t\t\tdelay = 100000 * fail_count;\n\t\t\tdebug(\"unlock failed, delaying %0.1lf seconds\",\n\t\t\t    (double)delay/1000000);\n\t\t\tusleep(delay);\n\t\t}\n\t\texplicit_bzero(passwdhash, sizeof(passwdhash));\n\t} else if (!locked && lock) {\n\t\tdebug(\"agent locked\");\n\t\tlocked = 1;\n\t\tarc4random_buf(lock_salt, sizeof(lock_salt));\n\t\tif (bcrypt_pbkdf(passwd, pwlen, lock_salt, sizeof(lock_salt),\n\t\t    lock_pwhash, sizeof(lock_pwhash), LOCK_ROUNDS) < 0)\n\t\t\tfatal(\"bcrypt_pbkdf\");\n\t\tsuccess = 1;\n\t}\n\texplicit_bzero(passwd, pwlen);\n\tfree(passwd);\n\tsend_status(e, success);\n}"
        }
      },
      {
        "call_info": {
          "callee": "no_identities",
          "args": [
            "e"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "no_identities",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "533-546",
          "snippet": "static void\nno_identities(SocketEntry *e)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, 0)) != 0 ||\n\t    (r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nno_identities(SocketEntry *e)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, 0)) != 0 ||\n\t    (r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: socket %u (fd=%d) type %d\"",
            "__func__",
            "socknum",
            "e->fd",
            "type"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "e->request",
            "&type"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_stringb",
          "args": [
            "e->input",
            "e->request"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "215-233",
          "snippet": "int\nsshbuf_get_stringb(struct sshbuf *buf, struct sshbuf *v)\n{\n\tu_int32_t len;\n\tu_char *p;\n\tint r;\n\n\t/*\n\t * Use sshbuf_peek_string_direct() to figure out if there is\n\t * a complete string in 'buf' and copy the string directly\n\t * into 'v'.\n\t */\n\tif ((r = sshbuf_peek_string_direct(buf, NULL, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(buf, &len)) != 0 ||\n\t    (r = sshbuf_reserve(v, len, &p)) != 0 ||\n\t    (r = sshbuf_get(buf, p, len)) != 0)\n\t\treturn r;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_stringb(struct sshbuf *buf, struct sshbuf *v)\n{\n\tu_int32_t len;\n\tu_char *p;\n\tint r;\n\n\t/*\n\t * Use sshbuf_peek_string_direct() to figure out if there is\n\t * a complete string in 'buf' and copy the string directly\n\t * into 'v'.\n\t */\n\tif ((r = sshbuf_peek_string_direct(buf, NULL, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(buf, &len)) != 0 ||\n\t    (r = sshbuf_reserve(v, len, &p)) != 0 ||\n\t    (r = sshbuf_get(buf, p, len)) != 0)\n\t\treturn r;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "e->input"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PEEK_U32",
          "args": [
            "cp"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "e->input"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define AGENT_MAX_LEN\t(256*1024)\n\nu_int sockets_alloc = 0;\nSocketEntry *sockets = NULL;\nint locked = 0;\n\nstatic int\nprocess_message(u_int socknum)\n{\n\tu_int msg_len;\n\tu_char type;\n\tconst u_char *cp;\n\tint r;\n\tSocketEntry *e;\n\n\tif (socknum >= sockets_alloc) {\n\t\tfatal(\"%s: socket number %u >= allocated %u\",\n\t\t    __func__, socknum, sockets_alloc);\n\t}\n\te = &sockets[socknum];\n\n\tif (sshbuf_len(e->input) < 5)\n\t\treturn 0;\t\t/* Incomplete message header. */\n\tcp = sshbuf_ptr(e->input);\n\tmsg_len = PEEK_U32(cp);\n\tif (msg_len > AGENT_MAX_LEN) {\n\t\tdebug(\"%s: socket %u (fd=%d) message too long %u > %u\",\n\t\t    __func__, socknum, e->fd, msg_len, AGENT_MAX_LEN);\n\t\treturn -1;\n\t}\n\tif (sshbuf_len(e->input) < msg_len + 4)\n\t\treturn 0;\t\t/* Incomplete message body. */\n\n\t/* move the current input to e->request */\n\tsshbuf_reset(e->request);\n\tif ((r = sshbuf_get_stringb(e->input, e->request)) != 0 ||\n\t    (r = sshbuf_get_u8(e->request, &type)) != 0) {\n\t\tif (r == SSH_ERR_MESSAGE_INCOMPLETE ||\n\t\t    r == SSH_ERR_STRING_TOO_LARGE) {\n\t\t\tdebug(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\t\treturn -1;\n\t\t}\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\n\tdebug(\"%s: socket %u (fd=%d) type %d\", __func__, socknum, e->fd, type);\n\n\t/* check whether agent is locked */\n\tif (locked && type != SSH_AGENTC_UNLOCK) {\n\t\tsshbuf_reset(e->request);\n\t\tswitch (type) {\n\t\tcase SSH2_AGENTC_REQUEST_IDENTITIES:\n\t\t\t/* send empty lists */\n\t\t\tno_identities(e);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* send a fail message for all other request types */\n\t\t\tsend_status(e, 0);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tswitch (type) {\n\tcase SSH_AGENTC_LOCK:\n\tcase SSH_AGENTC_UNLOCK:\n\t\tprocess_lock_agent(e, type == SSH_AGENTC_LOCK);\n\t\tbreak;\n\tcase SSH_AGENTC_REMOVE_ALL_RSA_IDENTITIES:\n\t\tprocess_remove_all_identities(e); /* safe for !WITH_SSH1 */\n\t\tbreak;\n\t/* ssh2 */\n\tcase SSH2_AGENTC_SIGN_REQUEST:\n\t\tprocess_sign_request2(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REQUEST_IDENTITIES:\n\t\tprocess_request_identities(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_ADD_IDENTITY:\n\tcase SSH2_AGENTC_ADD_ID_CONSTRAINED:\n\t\tprocess_add_identity(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REMOVE_IDENTITY:\n\t\tprocess_remove_identity(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REMOVE_ALL_IDENTITIES:\n\t\tprocess_remove_all_identities(e);\n\t\tbreak;\n#ifdef ENABLE_PKCS11\n\tcase SSH_AGENTC_ADD_SMARTCARD_KEY:\n\tcase SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED:\n\t\tprocess_add_smartcard_key(e);\n\t\tbreak;\n\tcase SSH_AGENTC_REMOVE_SMARTCARD_KEY:\n\t\tprocess_remove_smartcard_key(e);\n\t\tbreak;\n#endif /* ENABLE_PKCS11 */\n\tdefault:\n\t\t/* Unknown message.  Respond with failure. */\n\t\terror(\"Unknown message %d\", type);\n\t\tsshbuf_reset(e->request);\n\t\tsend_status(e, 0);\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "process_remove_smartcard_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "627-666",
    "snippet": "static void\nprocess_remove_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX];\n\tint r, success = 0;\n\tIdentity *id, *nxt;\n\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tgoto send;\n\t}\n\tfree(pin);\n\n\tif (realpath(provider, canonical_provider) == NULL) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n\t\t    provider, strerror(errno));\n\t\tgoto send;\n\t}\n\n\tdebug(\"%s: remove %.100s\", __func__, canonical_provider);\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id; id = nxt) {\n\t\tnxt = TAILQ_NEXT(id, next);\n\t\t/* Skip file--based keys */\n\t\tif (id->provider == NULL)\n\t\t\tcontinue;\n\t\tif (!strcmp(canonical_provider, id->provider)) {\n\t\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\t\tfree_identity(id);\n\t\t\tidtab->nentries--;\n\t\t}\n\t}\n\tif (pkcs11_del_provider(canonical_provider) == 0)\n\t\tsuccess = 1;\n\telse\n\t\terror(\"%s: pkcs11_del_provider failed\", __func__);\nsend:\n\tfree(provider);\n\tsend_status(e, success);\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct idtable *idtab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_status",
          "args": [
            "e",
            "success"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "send_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "223-232",
          "snippet": "static void\nsend_status(SocketEntry *e, int success)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(e->output, 1)) != 0 ||\n\t    (r = sshbuf_put_u8(e->output, success ?\n\t    SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_status(SocketEntry *e, int success)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(e->output, 1)) != 0 ||\n\t    (r = sshbuf_put_u8(e->output, success ?\n\t    SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "provider"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "free_identity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "184-191",
          "snippet": "static void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: pkcs11_del_provider failed\"",
            "__func__"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pkcs11_del_provider",
          "args": [
            "canonical_provider"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "pkcs11_del_provider",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
          "lines": "248-267",
          "snippet": "int\npkcs11_del_provider(char *name)\n{\n\tint r, ret = -1;\n\tstruct sshbuf *msg;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH_AGENTC_REMOVE_SMARTCARD_KEY)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, name)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, \"\")) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(msg);\n\tsshbuf_reset(msg);\n\n\tif (recv_msg(msg) == SSH_AGENT_SUCCESS)\n\t\tret = 0;\n\tsshbuf_free(msg);\n\treturn (ret);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"pathnames.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rsa.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\npkcs11_del_provider(char *name)\n{\n\tint r, ret = -1;\n\tstruct sshbuf *msg;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH_AGENTC_REMOVE_SMARTCARD_KEY)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, name)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, \"\")) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(msg);\n\tsshbuf_reset(msg);\n\n\tif (recv_msg(msg) == SSH_AGENT_SUCCESS)\n\t\tret = 0;\n\tsshbuf_free(msg);\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&idtab->idlist",
            "id",
            "next"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "canonical_provider",
            "id->provider"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_NEXT",
          "args": [
            "id",
            "next"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&idtab->idlist"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: remove %.100s\"",
            "__func__",
            "canonical_provider"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\"",
            "provider",
            "strerror(errno)"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "210-218",
          "snippet": "void\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "realpath",
          "args": [
            "provider",
            "canonical_provider"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "do_realpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "825-880",
          "snippet": "char *\ndo_realpath(struct sftp_conn *conn, const char *path)\n{\n\tstruct sshbuf *msg;\n\tu_int expected_id, count, id;\n\tchar *filename, *longname;\n\tAttrib a;\n\tu_char type;\n\tint r;\n\n\texpected_id = id = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_REALPATH, path,\n\t    strlen(path));\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\terror(\"Couldn't canonicalize: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn NULL;\n\t} else if (type != SSH2_FXP_NAME)\n\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t    SSH2_FXP_NAME, type);\n\n\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (count != 1)\n\t\tfatal(\"Got multiple names (%d) from SSH_FXP_REALPATH\", count);\n\n\tif ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||\n\t    (r = decode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"SSH_FXP_REALPATH %s -> %s size %lu\", path, filename,\n\t    (unsigned long)a.size);\n\n\tfree(longname);\n\n\tsshbuf_free(msg);\n\n\treturn(filename);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ndo_realpath(struct sftp_conn *conn, const char *path)\n{\n\tstruct sshbuf *msg;\n\tu_int expected_id, count, id;\n\tchar *filename, *longname;\n\tAttrib a;\n\tu_char type;\n\tint r;\n\n\texpected_id = id = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_REALPATH, path,\n\t    strlen(path));\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\terror(\"Couldn't canonicalize: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn NULL;\n\t} else if (type != SSH2_FXP_NAME)\n\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t    SSH2_FXP_NAME, type);\n\n\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (count != 1)\n\t\tfatal(\"Got multiple names (%d) from SSH_FXP_REALPATH\", count);\n\n\tif ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||\n\t    (r = decode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"SSH_FXP_REALPATH %s -> %s size %lu\", path, filename,\n\t    (unsigned long)a.size);\n\n\tfree(longname);\n\n\tsshbuf_free(msg);\n\n\treturn(filename);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "e->request",
            "&pin",
            "NULL"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct idtable *idtab;\n\nstatic void\nprocess_remove_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX];\n\tint r, success = 0;\n\tIdentity *id, *nxt;\n\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tgoto send;\n\t}\n\tfree(pin);\n\n\tif (realpath(provider, canonical_provider) == NULL) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n\t\t    provider, strerror(errno));\n\t\tgoto send;\n\t}\n\n\tdebug(\"%s: remove %.100s\", __func__, canonical_provider);\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id; id = nxt) {\n\t\tnxt = TAILQ_NEXT(id, next);\n\t\t/* Skip file--based keys */\n\t\tif (id->provider == NULL)\n\t\t\tcontinue;\n\t\tif (!strcmp(canonical_provider, id->provider)) {\n\t\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\t\tfree_identity(id);\n\t\t\tidtab->nentries--;\n\t\t}\n\t}\n\tif (pkcs11_del_provider(canonical_provider) == 0)\n\t\tsuccess = 1;\n\telse\n\t\terror(\"%s: pkcs11_del_provider failed\", __func__);\nsend:\n\tfree(provider);\n\tsend_status(e, success);\n}"
  },
  {
    "function_name": "process_add_smartcard_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "549-625",
    "snippet": "static void\nprocess_add_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX];\n\tint r, i, count = 0, success = 0, confirm = 0;\n\tu_int seconds;\n\ttime_t death = 0;\n\tu_char type;\n\tstruct sshkey **keys = NULL, *k;\n\tIdentity *id;\n\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tgoto send;\n\t}\n\n\twhile (sshbuf_len(e->request)) {\n\t\tif ((r = sshbuf_get_u8(e->request, &type)) != 0) {\n\t\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\t\tgoto send;\n\t\t}\n\t\tswitch (type) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif ((r = sshbuf_get_u32(e->request, &seconds)) != 0) {\n\t\t\t\terror(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tgoto send;\n\t\t\t}\n\t\t\tdeath = monotime() + seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tconfirm = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Unknown constraint type %d\", __func__, type);\n\t\t\tgoto send;\n\t\t}\n\t}\n\tif (realpath(provider, canonical_provider) == NULL) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n\t\t    provider, strerror(errno));\n\t\tgoto send;\n\t}\n\tif (match_pattern_list(canonical_provider, pkcs11_whitelist, 0) != 1) {\n\t\tverbose(\"refusing PKCS#11 add of \\\"%.100s\\\": \"\n\t\t    \"provider not whitelisted\", canonical_provider);\n\t\tgoto send;\n\t}\n\tdebug(\"%s: add %.100s\", __func__, canonical_provider);\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\n\tcount = pkcs11_add_provider(canonical_provider, pin, &keys);\n\tfor (i = 0; i < count; i++) {\n\t\tk = keys[i];\n\t\tif (lookup_identity(k) == NULL) {\n\t\t\tid = xcalloc(1, sizeof(Identity));\n\t\t\tid->key = k;\n\t\t\tid->provider = xstrdup(canonical_provider);\n\t\t\tid->comment = xstrdup(canonical_provider); /* XXX */\n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t\tidtab->nentries++;\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\tsshkey_free(k);\n\t\t}\n\t\tkeys[i] = NULL;\n\t}\nsend:\n\tfree(pin);\n\tfree(provider);\n\tfree(keys);\n\tsend_status(e, success);\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct idtable *idtab;",
      "static char *pkcs11_whitelist;",
      "static long lifetime = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_status",
          "args": [
            "e",
            "success"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "send_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "223-232",
          "snippet": "static void\nsend_status(SocketEntry *e, int success)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(e->output, 1)) != 0 ||\n\t    (r = sshbuf_put_u8(e->output, success ?\n\t    SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_status(SocketEntry *e, int success)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(e->output, 1)) != 0 ||\n\t    (r = sshbuf_put_u8(e->output, success ?\n\t    SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "keys"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "free_identity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "184-191",
          "snippet": "static void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "k"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&idtab->idlist",
            "id",
            "next"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "canonical_provider"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "1",
            "sizeof(Identity)"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_identity",
          "args": [
            "k"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_identity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "194-204",
          "snippet": "static Identity *\nlookup_identity(struct sshkey *key)\n{\n\tIdentity *id;\n\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif (sshkey_equal(key, id->key))\n\t\t\treturn (id);\n\t}\n\treturn (NULL);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct idtable *idtab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct idtable *idtab;\n\nstatic Identity *\nlookup_identity(struct sshkey *key)\n{\n\tIdentity *id;\n\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif (sshkey_equal(key, id->key))\n\t\t\treturn (id);\n\t}\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pkcs11_add_provider",
          "args": [
            "canonical_provider",
            "pin",
            "&keys"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "pkcs11_add_provider",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
          "lines": "203-246",
          "snippet": "int\npkcs11_add_provider(char *name, char *pin, struct sshkey ***keysp)\n{\n\tstruct sshkey *k;\n\tint r;\n\tu_char *blob;\n\tsize_t blen;\n\tu_int nkeys, i;\n\tstruct sshbuf *msg;\n\n\tif (fd < 0 && pkcs11_start_helper() < 0)\n\t\treturn (-1);\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH_AGENTC_ADD_SMARTCARD_KEY)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, name)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, pin)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(msg);\n\tsshbuf_reset(msg);\n\n\tif (recv_msg(msg) == SSH2_AGENT_IDENTITIES_ANSWER) {\n\t\tif ((r = sshbuf_get_u32(msg, &nkeys)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\t*keysp = xcalloc(nkeys, sizeof(struct sshkey *));\n\t\tfor (i = 0; i < nkeys; i++) {\n\t\t\t/* XXX clean up properly instead of fatal() */\n\t\t\tif ((r = sshbuf_get_string(msg, &blob, &blen)) != 0 ||\n\t\t\t    (r = sshbuf_skip_string(msg)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif ((r = sshkey_from_blob(blob, blen, &k)) != 0)\n\t\t\t\tfatal(\"%s: bad key: %s\", __func__, ssh_err(r));\n\t\t\twrap_key(k->rsa);\n\t\t\t(*keysp)[i] = k;\n\t\t\tfree(blob);\n\t\t}\n\t} else {\n\t\tnkeys = -1;\n\t}\n\tsshbuf_free(msg);\n\treturn (nkeys);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"pathnames.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rsa.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\npkcs11_add_provider(char *name, char *pin, struct sshkey ***keysp)\n{\n\tstruct sshkey *k;\n\tint r;\n\tu_char *blob;\n\tsize_t blen;\n\tu_int nkeys, i;\n\tstruct sshbuf *msg;\n\n\tif (fd < 0 && pkcs11_start_helper() < 0)\n\t\treturn (-1);\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH_AGENTC_ADD_SMARTCARD_KEY)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, name)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, pin)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(msg);\n\tsshbuf_reset(msg);\n\n\tif (recv_msg(msg) == SSH2_AGENT_IDENTITIES_ANSWER) {\n\t\tif ((r = sshbuf_get_u32(msg, &nkeys)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\t*keysp = xcalloc(nkeys, sizeof(struct sshkey *));\n\t\tfor (i = 0; i < nkeys; i++) {\n\t\t\t/* XXX clean up properly instead of fatal() */\n\t\t\tif ((r = sshbuf_get_string(msg, &blob, &blen)) != 0 ||\n\t\t\t    (r = sshbuf_skip_string(msg)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif ((r = sshkey_from_blob(blob, blen, &k)) != 0)\n\t\t\t\tfatal(\"%s: bad key: %s\", __func__, ssh_err(r));\n\t\t\twrap_key(k->rsa);\n\t\t\t(*keysp)[i] = k;\n\t\t\tfree(blob);\n\t\t}\n\t} else {\n\t\tnkeys = -1;\n\t}\n\tsshbuf_free(msg);\n\treturn (nkeys);\n}"
        }
      },
      {
        "call_info": {
          "callee": "monotime",
          "args": [],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "monotime_double",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1324-1331",
          "snippet": "double\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\ndouble\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: add %.100s\"",
            "__func__",
            "canonical_provider"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"refusing PKCS#11 add of \\\"%.100s\\\": \"\n\t\t    \"provider not whitelisted\"",
            "canonical_provider"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "210-218",
          "snippet": "void\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_pattern_list",
          "args": [
            "canonical_provider",
            "pkcs11_whitelist",
            "0"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "match_pattern_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "120-171",
          "snippet": "int\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "realpath",
          "args": [
            "provider",
            "canonical_provider"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "do_realpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "825-880",
          "snippet": "char *\ndo_realpath(struct sftp_conn *conn, const char *path)\n{\n\tstruct sshbuf *msg;\n\tu_int expected_id, count, id;\n\tchar *filename, *longname;\n\tAttrib a;\n\tu_char type;\n\tint r;\n\n\texpected_id = id = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_REALPATH, path,\n\t    strlen(path));\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\terror(\"Couldn't canonicalize: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn NULL;\n\t} else if (type != SSH2_FXP_NAME)\n\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t    SSH2_FXP_NAME, type);\n\n\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (count != 1)\n\t\tfatal(\"Got multiple names (%d) from SSH_FXP_REALPATH\", count);\n\n\tif ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||\n\t    (r = decode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"SSH_FXP_REALPATH %s -> %s size %lu\", path, filename,\n\t    (unsigned long)a.size);\n\n\tfree(longname);\n\n\tsshbuf_free(msg);\n\n\treturn(filename);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ndo_realpath(struct sftp_conn *conn, const char *path)\n{\n\tstruct sshbuf *msg;\n\tu_int expected_id, count, id;\n\tchar *filename, *longname;\n\tAttrib a;\n\tu_char type;\n\tint r;\n\n\texpected_id = id = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_REALPATH, path,\n\t    strlen(path));\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\terror(\"Couldn't canonicalize: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn NULL;\n\t} else if (type != SSH2_FXP_NAME)\n\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t    SSH2_FXP_NAME, type);\n\n\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (count != 1)\n\t\tfatal(\"Got multiple names (%d) from SSH_FXP_REALPATH\", count);\n\n\tif ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||\n\t    (r = decode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"SSH_FXP_REALPATH %s -> %s size %lu\", path, filename,\n\t    (unsigned long)a.size);\n\n\tfree(longname);\n\n\tsshbuf_free(msg);\n\n\treturn(filename);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: Unknown constraint type %d\"",
            "__func__",
            "type"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "e->request",
            "&seconds"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "e->request",
            "&type"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "e->request"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "e->request",
            "&pin",
            "NULL"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct idtable *idtab;\nstatic char *pkcs11_whitelist;\nstatic long lifetime = 0;\n\nstatic void\nprocess_add_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX];\n\tint r, i, count = 0, success = 0, confirm = 0;\n\tu_int seconds;\n\ttime_t death = 0;\n\tu_char type;\n\tstruct sshkey **keys = NULL, *k;\n\tIdentity *id;\n\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tgoto send;\n\t}\n\n\twhile (sshbuf_len(e->request)) {\n\t\tif ((r = sshbuf_get_u8(e->request, &type)) != 0) {\n\t\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\t\tgoto send;\n\t\t}\n\t\tswitch (type) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif ((r = sshbuf_get_u32(e->request, &seconds)) != 0) {\n\t\t\t\terror(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tgoto send;\n\t\t\t}\n\t\t\tdeath = monotime() + seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tconfirm = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Unknown constraint type %d\", __func__, type);\n\t\t\tgoto send;\n\t\t}\n\t}\n\tif (realpath(provider, canonical_provider) == NULL) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n\t\t    provider, strerror(errno));\n\t\tgoto send;\n\t}\n\tif (match_pattern_list(canonical_provider, pkcs11_whitelist, 0) != 1) {\n\t\tverbose(\"refusing PKCS#11 add of \\\"%.100s\\\": \"\n\t\t    \"provider not whitelisted\", canonical_provider);\n\t\tgoto send;\n\t}\n\tdebug(\"%s: add %.100s\", __func__, canonical_provider);\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\n\tcount = pkcs11_add_provider(canonical_provider, pin, &keys);\n\tfor (i = 0; i < count; i++) {\n\t\tk = keys[i];\n\t\tif (lookup_identity(k) == NULL) {\n\t\t\tid = xcalloc(1, sizeof(Identity));\n\t\t\tid->key = k;\n\t\t\tid->provider = xstrdup(canonical_provider);\n\t\t\tid->comment = xstrdup(canonical_provider); /* XXX */\n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t\tidtab->nentries++;\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\tsshkey_free(k);\n\t\t}\n\t\tkeys[i] = NULL;\n\t}\nsend:\n\tfree(pin);\n\tfree(provider);\n\tfree(keys);\n\tsend_status(e, success);\n}"
  },
  {
    "function_name": "no_identities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "533-546",
    "snippet": "static void\nno_identities(SocketEntry *e)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, 0)) != 0 ||\n\t    (r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_stringb",
          "args": [
            "e->output",
            "msg"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "371-375",
          "snippet": "int\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "msg",
            "0"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "SSH2_AGENT_IDENTITIES_ANSWER"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nno_identities(SocketEntry *e)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, 0)) != 0 ||\n\t    (r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n}"
  },
  {
    "function_name": "process_lock_agent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "481-531",
    "snippet": "static void\nprocess_lock_agent(SocketEntry *e, int lock)\n{\n\tint r, success = 0, delay;\n\tchar *passwd;\n\tu_char passwdhash[LOCK_SIZE];\n\tstatic u_int fail_count = 0;\n\tsize_t pwlen;\n\n\t/*\n\t * This is deliberately fatal: the user has requested that we lock,\n\t * but we can't parse their request properly. The only safe thing to\n\t * do is abort.\n\t */\n\tif ((r = sshbuf_get_cstring(e->request, &passwd, &pwlen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (pwlen == 0) {\n\t\tdebug(\"empty password not supported\");\n\t} else if (locked && !lock) {\n\t\tif (bcrypt_pbkdf(passwd, pwlen, lock_salt, sizeof(lock_salt),\n\t\t    passwdhash, sizeof(passwdhash), LOCK_ROUNDS) < 0)\n\t\t\tfatal(\"bcrypt_pbkdf\");\n\t\tif (timingsafe_bcmp(passwdhash, lock_pwhash, LOCK_SIZE) == 0) {\n\t\t\tdebug(\"agent unlocked\");\n\t\t\tlocked = 0;\n\t\t\tfail_count = 0;\n\t\t\texplicit_bzero(lock_pwhash, sizeof(lock_pwhash));\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\t/* delay in 0.1s increments up to 10s */\n\t\t\tif (fail_count < 100)\n\t\t\t\tfail_count++;\n\t\t\tdelay = 100000 * fail_count;\n\t\t\tdebug(\"unlock failed, delaying %0.1lf seconds\",\n\t\t\t    (double)delay/1000000);\n\t\t\tusleep(delay);\n\t\t}\n\t\texplicit_bzero(passwdhash, sizeof(passwdhash));\n\t} else if (!locked && lock) {\n\t\tdebug(\"agent locked\");\n\t\tlocked = 1;\n\t\tarc4random_buf(lock_salt, sizeof(lock_salt));\n\t\tif (bcrypt_pbkdf(passwd, pwlen, lock_salt, sizeof(lock_salt),\n\t\t    lock_pwhash, sizeof(lock_pwhash), LOCK_ROUNDS) < 0)\n\t\t\tfatal(\"bcrypt_pbkdf\");\n\t\tsuccess = 1;\n\t}\n\texplicit_bzero(passwd, pwlen);\n\tfree(passwd);\n\tsend_status(e, success);\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define LOCK_ROUNDS\t1",
      "#define LOCK_SIZE\t32"
    ],
    "globals_used": [
      "int locked = 0;",
      "u_char lock_pwhash[LOCK_SIZE];",
      "u_char lock_salt[LOCK_SALT_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_status",
          "args": [
            "e",
            "success"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "send_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "223-232",
          "snippet": "static void\nsend_status(SocketEntry *e, int success)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(e->output, 1)) != 0 ||\n\t    (r = sshbuf_put_u8(e->output, success ?\n\t    SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_status(SocketEntry *e, int success)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(e->output, 1)) != 0 ||\n\t    (r = sshbuf_put_u8(e->output, success ?\n\t    SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "passwd"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "free_identity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "184-191",
          "snippet": "static void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "passwd",
            "pwlen"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"bcrypt_pbkdf\""
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcrypt_pbkdf",
          "args": [
            "passwd",
            "pwlen",
            "lock_salt",
            "sizeof(lock_salt)",
            "lock_pwhash",
            "sizeof(lock_pwhash)",
            "LOCK_ROUNDS"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "bcrypt_pbkdf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bcrypt_pbkdf.c",
          "lines": "110-178",
          "snippet": "int\nbcrypt_pbkdf(const char *pass, size_t passlen, const u_int8_t *salt, size_t saltlen,\n    u_int8_t *key, size_t keylen, unsigned int rounds)\n{\n\tu_int8_t sha2pass[SHA512_DIGEST_LENGTH];\n\tu_int8_t sha2salt[SHA512_DIGEST_LENGTH];\n\tu_int8_t out[BCRYPT_HASHSIZE];\n\tu_int8_t tmpout[BCRYPT_HASHSIZE];\n\tu_int8_t *countsalt;\n\tsize_t i, j, amt, stride;\n\tuint32_t count;\n\tsize_t origkeylen = keylen;\n\n\t/* nothing crazy */\n\tif (rounds < 1)\n\t\treturn -1;\n\tif (passlen == 0 || saltlen == 0 || keylen == 0 ||\n\t    keylen > sizeof(out) * sizeof(out) || saltlen > 1<<20)\n\t\treturn -1;\n\tif ((countsalt = calloc(1, saltlen + 4)) == NULL)\n\t\treturn -1;\n\tstride = (keylen + sizeof(out) - 1) / sizeof(out);\n\tamt = (keylen + stride - 1) / stride;\n\n\tmemcpy(countsalt, salt, saltlen);\n\n\t/* collapse password */\n\tcrypto_hash_sha512(sha2pass, pass, passlen);\n\n\t/* generate key, sizeof(out) at a time */\n\tfor (count = 1; keylen > 0; count++) {\n\t\tcountsalt[saltlen + 0] = (count >> 24) & 0xff;\n\t\tcountsalt[saltlen + 1] = (count >> 16) & 0xff;\n\t\tcountsalt[saltlen + 2] = (count >> 8) & 0xff;\n\t\tcountsalt[saltlen + 3] = count & 0xff;\n\n\t\t/* first round, salt is salt */\n\t\tcrypto_hash_sha512(sha2salt, countsalt, saltlen + 4);\n\n\t\tbcrypt_hash(sha2pass, sha2salt, tmpout);\n\t\tmemcpy(out, tmpout, sizeof(out));\n\n\t\tfor (i = 1; i < rounds; i++) {\n\t\t\t/* subsequent rounds, salt is previous output */\n\t\t\tcrypto_hash_sha512(sha2salt, tmpout, sizeof(tmpout));\n\t\t\tbcrypt_hash(sha2pass, sha2salt, tmpout);\n\t\t\tfor (j = 0; j < sizeof(out); j++)\n\t\t\t\tout[j] ^= tmpout[j];\n\t\t}\n\n\t\t/*\n\t\t * pbkdf2 deviation: output the key material non-linearly.\n\t\t */\n\t\tamt = MINIMUM(amt, keylen);\n\t\tfor (i = 0; i < amt; i++) {\n\t\t\tsize_t dest = i * stride + (count - 1);\n\t\t\tif (dest >= origkeylen)\n\t\t\t\tbreak;\n\t\t\tkey[dest] = out[i];\n\t\t}\n\t\tkeylen -= i;\n\t}\n\n\t/* zap */\n\texplicit_bzero(out, sizeof(out));\n\tfree(countsalt);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"crypto_api.h\"",
            "# include <blf.h>",
            "#include <string.h>",
            "# include <stdlib.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define BCRYPT_HASHSIZE (BCRYPT_WORDS * 4)",
            "#define SHA512_DIGEST_LENGTH crypto_hash_sha512_BYTES"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"crypto_api.h\"\n# include <blf.h>\n#include <string.h>\n# include <stdlib.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define BCRYPT_HASHSIZE (BCRYPT_WORDS * 4)\n#define SHA512_DIGEST_LENGTH crypto_hash_sha512_BYTES\n\nint\nbcrypt_pbkdf(const char *pass, size_t passlen, const u_int8_t *salt, size_t saltlen,\n    u_int8_t *key, size_t keylen, unsigned int rounds)\n{\n\tu_int8_t sha2pass[SHA512_DIGEST_LENGTH];\n\tu_int8_t sha2salt[SHA512_DIGEST_LENGTH];\n\tu_int8_t out[BCRYPT_HASHSIZE];\n\tu_int8_t tmpout[BCRYPT_HASHSIZE];\n\tu_int8_t *countsalt;\n\tsize_t i, j, amt, stride;\n\tuint32_t count;\n\tsize_t origkeylen = keylen;\n\n\t/* nothing crazy */\n\tif (rounds < 1)\n\t\treturn -1;\n\tif (passlen == 0 || saltlen == 0 || keylen == 0 ||\n\t    keylen > sizeof(out) * sizeof(out) || saltlen > 1<<20)\n\t\treturn -1;\n\tif ((countsalt = calloc(1, saltlen + 4)) == NULL)\n\t\treturn -1;\n\tstride = (keylen + sizeof(out) - 1) / sizeof(out);\n\tamt = (keylen + stride - 1) / stride;\n\n\tmemcpy(countsalt, salt, saltlen);\n\n\t/* collapse password */\n\tcrypto_hash_sha512(sha2pass, pass, passlen);\n\n\t/* generate key, sizeof(out) at a time */\n\tfor (count = 1; keylen > 0; count++) {\n\t\tcountsalt[saltlen + 0] = (count >> 24) & 0xff;\n\t\tcountsalt[saltlen + 1] = (count >> 16) & 0xff;\n\t\tcountsalt[saltlen + 2] = (count >> 8) & 0xff;\n\t\tcountsalt[saltlen + 3] = count & 0xff;\n\n\t\t/* first round, salt is salt */\n\t\tcrypto_hash_sha512(sha2salt, countsalt, saltlen + 4);\n\n\t\tbcrypt_hash(sha2pass, sha2salt, tmpout);\n\t\tmemcpy(out, tmpout, sizeof(out));\n\n\t\tfor (i = 1; i < rounds; i++) {\n\t\t\t/* subsequent rounds, salt is previous output */\n\t\t\tcrypto_hash_sha512(sha2salt, tmpout, sizeof(tmpout));\n\t\t\tbcrypt_hash(sha2pass, sha2salt, tmpout);\n\t\t\tfor (j = 0; j < sizeof(out); j++)\n\t\t\t\tout[j] ^= tmpout[j];\n\t\t}\n\n\t\t/*\n\t\t * pbkdf2 deviation: output the key material non-linearly.\n\t\t */\n\t\tamt = MINIMUM(amt, keylen);\n\t\tfor (i = 0; i < amt; i++) {\n\t\t\tsize_t dest = i * stride + (count - 1);\n\t\t\tif (dest >= origkeylen)\n\t\t\t\tbreak;\n\t\t\tkey[dest] = out[i];\n\t\t}\n\t\tkeylen -= i;\n\t}\n\n\t/* zap */\n\texplicit_bzero(out, sizeof(out));\n\tfree(countsalt);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arc4random_buf",
          "args": [
            "lock_salt",
            "sizeof(lock_salt)"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "arc4random_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "263-277",
          "snippet": "void\narc4random_buf(void *_buf, size_t n)\n{\n\tsize_t i;\n\tu_int32_t r = 0;\n\tchar *buf = (char *)_buf;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (i % 4 == 0)\n\t\t\tr = arc4random();\n\t\tbuf[i] = r & 0xff;\n\t\tr >>= 8;\n\t}\n\texplicit_bzero(&r, sizeof(r));\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\narc4random_buf(void *_buf, size_t n)\n{\n\tsize_t i;\n\tu_int32_t r = 0;\n\tchar *buf = (char *)_buf;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (i % 4 == 0)\n\t\t\tr = arc4random();\n\t\tbuf[i] = r & 0xff;\n\t\tr >>= 8;\n\t}\n\texplicit_bzero(&r, sizeof(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"agent locked\""
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "delay"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "usleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "171-178",
          "snippet": "int usleep(unsigned int useconds)\n{\n\tstruct timespec ts;\n\n\tts.tv_sec = useconds / 1000000;\n\tts.tv_nsec = (useconds % 1000000) * 1000;\n\treturn nanosleep(&ts, NULL);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint usleep(unsigned int useconds)\n{\n\tstruct timespec ts;\n\n\tts.tv_sec = useconds / 1000000;\n\tts.tv_nsec = (useconds % 1000000) * 1000;\n\treturn nanosleep(&ts, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timingsafe_bcmp",
          "args": [
            "passwdhash",
            "lock_pwhash",
            "LOCK_SIZE"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "timingsafe_bcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/timingsafe_bcmp.c",
          "lines": "23-32",
          "snippet": "int\ntimingsafe_bcmp(const void *b1, const void *b2, size_t n)\n{\n\tconst unsigned char *p1 = b1, *p2 = b2;\n\tint ret = 0;\n\n\tfor (; n > 0; n--)\n\t\tret |= *p1++ ^ *p2++;\n\treturn (ret != 0);\n}",
          "includes": [
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"includes.h\"\n\nint\ntimingsafe_bcmp(const void *b1, const void *b2, size_t n)\n{\n\tconst unsigned char *p1 = b1, *p2 = b2;\n\tint ret = 0;\n\n\tfor (; n > 0; n--)\n\t\tret |= *p1++ ^ *p2++;\n\treturn (ret != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "e->request",
            "&passwd",
            "&pwlen"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define LOCK_ROUNDS\t1\n#define LOCK_SIZE\t32\n\nint locked = 0;\nu_char lock_pwhash[LOCK_SIZE];\nu_char lock_salt[LOCK_SALT_SIZE];\n\nstatic void\nprocess_lock_agent(SocketEntry *e, int lock)\n{\n\tint r, success = 0, delay;\n\tchar *passwd;\n\tu_char passwdhash[LOCK_SIZE];\n\tstatic u_int fail_count = 0;\n\tsize_t pwlen;\n\n\t/*\n\t * This is deliberately fatal: the user has requested that we lock,\n\t * but we can't parse their request properly. The only safe thing to\n\t * do is abort.\n\t */\n\tif ((r = sshbuf_get_cstring(e->request, &passwd, &pwlen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (pwlen == 0) {\n\t\tdebug(\"empty password not supported\");\n\t} else if (locked && !lock) {\n\t\tif (bcrypt_pbkdf(passwd, pwlen, lock_salt, sizeof(lock_salt),\n\t\t    passwdhash, sizeof(passwdhash), LOCK_ROUNDS) < 0)\n\t\t\tfatal(\"bcrypt_pbkdf\");\n\t\tif (timingsafe_bcmp(passwdhash, lock_pwhash, LOCK_SIZE) == 0) {\n\t\t\tdebug(\"agent unlocked\");\n\t\t\tlocked = 0;\n\t\t\tfail_count = 0;\n\t\t\texplicit_bzero(lock_pwhash, sizeof(lock_pwhash));\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\t/* delay in 0.1s increments up to 10s */\n\t\t\tif (fail_count < 100)\n\t\t\t\tfail_count++;\n\t\t\tdelay = 100000 * fail_count;\n\t\t\tdebug(\"unlock failed, delaying %0.1lf seconds\",\n\t\t\t    (double)delay/1000000);\n\t\t\tusleep(delay);\n\t\t}\n\t\texplicit_bzero(passwdhash, sizeof(passwdhash));\n\t} else if (!locked && lock) {\n\t\tdebug(\"agent locked\");\n\t\tlocked = 1;\n\t\tarc4random_buf(lock_salt, sizeof(lock_salt));\n\t\tif (bcrypt_pbkdf(passwd, pwlen, lock_salt, sizeof(lock_salt),\n\t\t    lock_pwhash, sizeof(lock_pwhash), LOCK_ROUNDS) < 0)\n\t\t\tfatal(\"bcrypt_pbkdf\");\n\t\tsuccess = 1;\n\t}\n\texplicit_bzero(passwd, pwlen);\n\tfree(passwd);\n\tsend_status(e, success);\n}"
  },
  {
    "function_name": "process_add_identity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "401-478",
    "snippet": "static void\nprocess_add_identity(SocketEntry *e)\n{\n\tIdentity *id;\n\tint success = 0, confirm = 0;\n\tu_int seconds, maxsign;\n\tchar *comment = NULL;\n\ttime_t death = 0;\n\tstruct sshkey *k = NULL;\n\tu_char ctype;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((r = sshkey_private_deserialize(e->request, &k)) != 0 ||\n\t    k == NULL ||\n\t    (r = sshbuf_get_cstring(e->request, &comment, NULL)) != 0) {\n\t\terror(\"%s: decode private key: %s\", __func__, ssh_err(r));\n\t\tgoto err;\n\t}\n\n\twhile (sshbuf_len(e->request)) {\n\t\tif ((r = sshbuf_get_u8(e->request, &ctype)) != 0) {\n\t\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\t\tgoto err;\n\t\t}\n\t\tswitch (ctype) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif ((r = sshbuf_get_u32(e->request, &seconds)) != 0) {\n\t\t\t\terror(\"%s: bad lifetime constraint: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tdeath = monotime() + seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tconfirm = 1;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_MAXSIGN:\n\t\t\tif ((r = sshbuf_get_u32(e->request, &maxsign)) != 0) {\n\t\t\t\terror(\"%s: bad maxsign constraint: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif ((r = sshkey_enable_maxsign(k, maxsign)) != 0) {\n\t\t\t\terror(\"%s: cannot enable maxsign: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Unknown constraint %d\", __func__, ctype);\n err:\n\t\t\tsshbuf_reset(e->request);\n\t\t\tfree(comment);\n\t\t\tsshkey_free(k);\n\t\t\tgoto send;\n\t\t}\n\t}\n\n\tsuccess = 1;\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\tif ((id = lookup_identity(k)) == NULL) {\n\t\tid = xcalloc(1, sizeof(Identity));\n\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t/* Increment the number of identities. */\n\t\tidtab->nentries++;\n\t} else {\n\t\t/* key state might have been updated */\n\t\tsshkey_free(id->key);\n\t\tfree(id->comment);\n\t}\n\tid->key = k;\n\tid->comment = comment;\n\tid->death = death;\n\tid->confirm = confirm;\nsend:\n\tsend_status(e, success);\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct idtable *idtab;",
      "static long lifetime = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_status",
          "args": [
            "e",
            "success"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "send_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "223-232",
          "snippet": "static void\nsend_status(SocketEntry *e, int success)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(e->output, 1)) != 0 ||\n\t    (r = sshbuf_put_u8(e->output, success ?\n\t    SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_status(SocketEntry *e, int success)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(e->output, 1)) != 0 ||\n\t    (r = sshbuf_put_u8(e->output, success ?\n\t    SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "id->comment"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "free_identity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "184-191",
          "snippet": "static void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "id->key"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&idtab->idlist",
            "id",
            "next"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "1",
            "sizeof(Identity)"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_identity",
          "args": [
            "k"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_identity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "194-204",
          "snippet": "static Identity *\nlookup_identity(struct sshkey *key)\n{\n\tIdentity *id;\n\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif (sshkey_equal(key, id->key))\n\t\t\treturn (id);\n\t}\n\treturn (NULL);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct idtable *idtab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct idtable *idtab;\n\nstatic Identity *\nlookup_identity(struct sshkey *key)\n{\n\tIdentity *id;\n\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif (sshkey_equal(key, id->key))\n\t\t\treturn (id);\n\t}\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "monotime",
          "args": [],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "monotime_double",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1324-1331",
          "snippet": "double\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\ndouble\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "e->request"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: Unknown constraint %d\"",
            "__func__",
            "ctype"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_enable_maxsign",
          "args": [
            "k",
            "maxsign"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_enable_maxsign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "4152-4156",
          "snippet": "int\nsshkey_enable_maxsign(struct sshkey *k, u_int32_t maxsign)\n{\n\treturn SSH_ERR_INVALID_ARGUMENT;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_enable_maxsign(struct sshkey *k, u_int32_t maxsign)\n{\n\treturn SSH_ERR_INVALID_ARGUMENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "e->request",
            "&maxsign"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "e->request",
            "&ctype"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "e->request"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "e->request",
            "&comment",
            "NULL"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_private_deserialize",
          "args": [
            "e->request",
            "&k"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_private_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2915-3221",
          "snippet": "int\nsshkey_private_deserialize(struct sshbuf *buf, struct sshkey **kp)\n{\n\tchar *tname = NULL, *curve = NULL, *xmss_name = NULL;\n\tstruct sshkey *k = NULL;\n\tsize_t pklen = 0, sklen = 0;\n\tint type, r = SSH_ERR_INTERNAL_ERROR;\n\tu_char *ed25519_pk = NULL, *ed25519_sk = NULL;\n\tu_char *xmss_pk = NULL, *xmss_sk = NULL;\n#ifdef WITH_OPENSSL\n\tBIGNUM *exponent = NULL;\n\tBIGNUM *rsa_n = NULL, *rsa_e = NULL, *rsa_d = NULL;\n\tBIGNUM *rsa_iqmp = NULL, *rsa_p = NULL, *rsa_q = NULL;\n\tBIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL;\n\tBIGNUM *dsa_pub_key = NULL, *dsa_priv_key = NULL;\n#endif /* WITH_OPENSSL */\n\n\tif (kp != NULL)\n\t\t*kp = NULL;\n\tif ((r = sshbuf_get_cstring(buf, &tname, NULL)) != 0)\n\t\tgoto out;\n\ttype = sshkey_type_from_name(tname);\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((dsa_p = BN_new()) == NULL ||\n\t\t    (dsa_q = BN_new()) == NULL ||\n\t\t    (dsa_g = BN_new()) == NULL ||\n\t\t    (dsa_pub_key = BN_new()) == NULL ||\n\t\t    (dsa_priv_key = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_bignum2(buf, dsa_p)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_q)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_g)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_pub_key)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tif (!DSA_set0_pqg(k->dsa, dsa_p, dsa_q, dsa_g)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p = dsa_q = dsa_g = NULL; /* transferred */\n\t\tif (!DSA_set0_key(k->dsa, dsa_pub_key, dsa_priv_key)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key = dsa_priv_key = NULL; /* transferred */\n\t\tbreak;\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa_priv_key = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tif (!DSA_set0_key(k->dsa, NULL, dsa_priv_key)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_priv_key = NULL; /* transferred */\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((k->ecdsa_nid = sshkey_ecdsa_nid_from_name(tname)) == -1) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_cstring(buf, &curve, NULL)) != 0)\n\t\t\tgoto out;\n\t\tif (k->ecdsa_nid != sshkey_curve_name_to_nid(curve)) {\n\t\t\tr = SSH_ERR_EC_CURVE_MISMATCH;\n\t\t\tgoto out;\n\t\t}\n\t\tk->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (k->ecdsa  == NULL || (exponent = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_eckey(buf, k->ecdsa)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, exponent)))\n\t\t\tgoto out;\n\t\tif (EC_KEY_set_private_key(k->ecdsa, exponent) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_ec_validate_public(EC_KEY_get0_group(k->ecdsa),\n\t\t    EC_KEY_get0_public_key(k->ecdsa))) != 0 ||\n\t\t    (r = sshkey_ec_validate_private(k->ecdsa)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_ECDSA_CERT:\n\t\tif ((exponent = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, exponent)) != 0)\n\t\t\tgoto out;\n\t\tif (EC_KEY_set_private_key(k->ecdsa, exponent) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_ec_validate_public(EC_KEY_get0_group(k->ecdsa),\n\t\t    EC_KEY_get0_public_key(k->ecdsa))) != 0 ||\n\t\t    (r = sshkey_ec_validate_private(k->ecdsa)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((rsa_n = BN_new()) == NULL ||\n\t\t    (rsa_e = BN_new()) == NULL ||\n\t\t    (rsa_d = BN_new()) == NULL ||\n\t\t    (rsa_iqmp = BN_new()) == NULL ||\n\t\t    (rsa_p = BN_new()) == NULL ||\n\t\t    (rsa_q = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_bignum2(buf, rsa_n)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_e)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tif (!RSA_set0_key(k->rsa, rsa_n, rsa_e, rsa_d)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n = rsa_e = rsa_d = NULL; /* transferred */\n\t\tif (!RSA_set0_factors(k->rsa, rsa_p, rsa_q)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_p = rsa_q = NULL; /* transferred */\n\t\tif ((r = check_rsa_length(k->rsa)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = ssh_rsa_complete_crt_parameters(k, rsa_iqmp)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa_d = BN_new()) == NULL ||\n\t\t    (rsa_iqmp = BN_new()) == NULL ||\n\t\t    (rsa_p = BN_new()) == NULL ||\n\t\t    (rsa_q = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tif (!RSA_set0_key(k->rsa, NULL, NULL, rsa_d)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_d = NULL; /* transferred */\n\t\tif (!RSA_set0_factors(k->rsa, rsa_p, rsa_q)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_p = rsa_q = NULL; /* transferred */\n\t\tif ((r = check_rsa_length(k->rsa)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = ssh_rsa_complete_crt_parameters(k, rsa_iqmp)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_string(buf, &ed25519_pk, &pklen)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &ed25519_sk, &sklen)) != 0)\n\t\t\tgoto out;\n\t\tif (pklen != ED25519_PK_SZ || sklen != ED25519_SK_SZ) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tk->ed25519_pk = ed25519_pk;\n\t\tk->ed25519_sk = ed25519_sk;\n\t\ted25519_pk = ed25519_sk = NULL;\n\t\tbreak;\n\tcase KEY_ED25519_CERT:\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &ed25519_pk, &pklen)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &ed25519_sk, &sklen)) != 0)\n\t\t\tgoto out;\n\t\tif (pklen != ED25519_PK_SZ || sklen != ED25519_SK_SZ) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tk->ed25519_pk = ed25519_pk;\n\t\tk->ed25519_sk = ed25519_sk;\n\t\ted25519_pk = ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_cstring(buf, &xmss_name, NULL)) != 0 ||\n\t\t    (r = sshkey_xmss_init(k, xmss_name)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &xmss_pk, &pklen)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &xmss_sk, &sklen)) != 0)\n\t\t\tgoto out;\n\t\tif (pklen != sshkey_xmss_pklen(k) ||\n\t\t    sklen != sshkey_xmss_sklen(k)) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tk->xmss_pk = xmss_pk;\n\t\tk->xmss_sk = xmss_sk;\n\t\txmss_pk = xmss_sk = NULL;\n\t\t/* optional internal state */\n\t\tif ((r = sshkey_xmss_deserialize_state_opt(k, buf)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_XMSS_CERT:\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_cstring(buf, &xmss_name, NULL)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &xmss_pk, &pklen)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &xmss_sk, &sklen)) != 0)\n\t\t\tgoto out;\n\t\tif (strcmp(xmss_name, k->xmss_name)) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (pklen != sshkey_xmss_pklen(k) ||\n\t\t    sklen != sshkey_xmss_sklen(k)) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tk->xmss_pk = xmss_pk;\n\t\tk->xmss_sk = xmss_sk;\n\t\txmss_pk = xmss_sk = NULL;\n\t\t/* optional internal state */\n\t\tif ((r = sshkey_xmss_deserialize_state_opt(k, buf)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n#ifdef WITH_OPENSSL\n\t/* enable blinding */\n\tswitch (k->type) {\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif (RSA_blinding_on(k->rsa, NULL) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n#endif /* WITH_OPENSSL */\n\t/* success */\n\tr = 0;\n\tif (kp != NULL) {\n\t\t*kp = k;\n\t\tk = NULL;\n\t}\n out:\n\tfree(tname);\n\tfree(curve);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(exponent);\n\tBN_clear_free(dsa_p);\n\tBN_clear_free(dsa_q);\n\tBN_clear_free(dsa_g);\n\tBN_clear_free(dsa_pub_key);\n\tBN_clear_free(dsa_priv_key);\n\tBN_clear_free(rsa_n);\n\tBN_clear_free(rsa_e);\n\tBN_clear_free(rsa_d);\n\tBN_clear_free(rsa_p);\n\tBN_clear_free(rsa_q);\n\tBN_clear_free(rsa_iqmp);\n#endif /* WITH_OPENSSL */\n\tsshkey_free(k);\n\tfreezero(ed25519_pk, pklen);\n\tfreezero(ed25519_sk, sklen);\n\tfree(xmss_name);\n\tfreezero(xmss_pk, pklen);\n\tfreezero(xmss_sk, sklen);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_private_deserialize(struct sshbuf *buf, struct sshkey **kp)\n{\n\tchar *tname = NULL, *curve = NULL, *xmss_name = NULL;\n\tstruct sshkey *k = NULL;\n\tsize_t pklen = 0, sklen = 0;\n\tint type, r = SSH_ERR_INTERNAL_ERROR;\n\tu_char *ed25519_pk = NULL, *ed25519_sk = NULL;\n\tu_char *xmss_pk = NULL, *xmss_sk = NULL;\n#ifdef WITH_OPENSSL\n\tBIGNUM *exponent = NULL;\n\tBIGNUM *rsa_n = NULL, *rsa_e = NULL, *rsa_d = NULL;\n\tBIGNUM *rsa_iqmp = NULL, *rsa_p = NULL, *rsa_q = NULL;\n\tBIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL;\n\tBIGNUM *dsa_pub_key = NULL, *dsa_priv_key = NULL;\n#endif /* WITH_OPENSSL */\n\n\tif (kp != NULL)\n\t\t*kp = NULL;\n\tif ((r = sshbuf_get_cstring(buf, &tname, NULL)) != 0)\n\t\tgoto out;\n\ttype = sshkey_type_from_name(tname);\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((dsa_p = BN_new()) == NULL ||\n\t\t    (dsa_q = BN_new()) == NULL ||\n\t\t    (dsa_g = BN_new()) == NULL ||\n\t\t    (dsa_pub_key = BN_new()) == NULL ||\n\t\t    (dsa_priv_key = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_bignum2(buf, dsa_p)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_q)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_g)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_pub_key)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tif (!DSA_set0_pqg(k->dsa, dsa_p, dsa_q, dsa_g)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p = dsa_q = dsa_g = NULL; /* transferred */\n\t\tif (!DSA_set0_key(k->dsa, dsa_pub_key, dsa_priv_key)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key = dsa_priv_key = NULL; /* transferred */\n\t\tbreak;\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa_priv_key = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, dsa_priv_key)) != 0)\n\t\t\tgoto out;\n\t\tif (!DSA_set0_key(k->dsa, NULL, dsa_priv_key)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_priv_key = NULL; /* transferred */\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((k->ecdsa_nid = sshkey_ecdsa_nid_from_name(tname)) == -1) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_cstring(buf, &curve, NULL)) != 0)\n\t\t\tgoto out;\n\t\tif (k->ecdsa_nid != sshkey_curve_name_to_nid(curve)) {\n\t\t\tr = SSH_ERR_EC_CURVE_MISMATCH;\n\t\t\tgoto out;\n\t\t}\n\t\tk->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (k->ecdsa  == NULL || (exponent = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_eckey(buf, k->ecdsa)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, exponent)))\n\t\t\tgoto out;\n\t\tif (EC_KEY_set_private_key(k->ecdsa, exponent) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_ec_validate_public(EC_KEY_get0_group(k->ecdsa),\n\t\t    EC_KEY_get0_public_key(k->ecdsa))) != 0 ||\n\t\t    (r = sshkey_ec_validate_private(k->ecdsa)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_ECDSA_CERT:\n\t\tif ((exponent = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, exponent)) != 0)\n\t\t\tgoto out;\n\t\tif (EC_KEY_set_private_key(k->ecdsa, exponent) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_ec_validate_public(EC_KEY_get0_group(k->ecdsa),\n\t\t    EC_KEY_get0_public_key(k->ecdsa))) != 0 ||\n\t\t    (r = sshkey_ec_validate_private(k->ecdsa)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((rsa_n = BN_new()) == NULL ||\n\t\t    (rsa_e = BN_new()) == NULL ||\n\t\t    (rsa_d = BN_new()) == NULL ||\n\t\t    (rsa_iqmp = BN_new()) == NULL ||\n\t\t    (rsa_p = BN_new()) == NULL ||\n\t\t    (rsa_q = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_bignum2(buf, rsa_n)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_e)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tif (!RSA_set0_key(k->rsa, rsa_n, rsa_e, rsa_d)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n = rsa_e = rsa_d = NULL; /* transferred */\n\t\tif (!RSA_set0_factors(k->rsa, rsa_p, rsa_q)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_p = rsa_q = NULL; /* transferred */\n\t\tif ((r = check_rsa_length(k->rsa)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = ssh_rsa_complete_crt_parameters(k, rsa_iqmp)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa_d = BN_new()) == NULL ||\n\t\t    (rsa_iqmp = BN_new()) == NULL ||\n\t\t    (rsa_p = BN_new()) == NULL ||\n\t\t    (rsa_q = BN_new()) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_d)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_iqmp)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_p)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(buf, rsa_q)) != 0)\n\t\t\tgoto out;\n\t\tif (!RSA_set0_key(k->rsa, NULL, NULL, rsa_d)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_d = NULL; /* transferred */\n\t\tif (!RSA_set0_factors(k->rsa, rsa_p, rsa_q)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_p = rsa_q = NULL; /* transferred */\n\t\tif ((r = check_rsa_length(k->rsa)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = ssh_rsa_complete_crt_parameters(k, rsa_iqmp)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_string(buf, &ed25519_pk, &pklen)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &ed25519_sk, &sklen)) != 0)\n\t\t\tgoto out;\n\t\tif (pklen != ED25519_PK_SZ || sklen != ED25519_SK_SZ) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tk->ed25519_pk = ed25519_pk;\n\t\tk->ed25519_sk = ed25519_sk;\n\t\ted25519_pk = ed25519_sk = NULL;\n\t\tbreak;\n\tcase KEY_ED25519_CERT:\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &ed25519_pk, &pklen)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &ed25519_sk, &sklen)) != 0)\n\t\t\tgoto out;\n\t\tif (pklen != ED25519_PK_SZ || sklen != ED25519_SK_SZ) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tk->ed25519_pk = ed25519_pk;\n\t\tk->ed25519_sk = ed25519_sk;\n\t\ted25519_pk = ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_cstring(buf, &xmss_name, NULL)) != 0 ||\n\t\t    (r = sshkey_xmss_init(k, xmss_name)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &xmss_pk, &pklen)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &xmss_sk, &sklen)) != 0)\n\t\t\tgoto out;\n\t\tif (pklen != sshkey_xmss_pklen(k) ||\n\t\t    sklen != sshkey_xmss_sklen(k)) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tk->xmss_pk = xmss_pk;\n\t\tk->xmss_sk = xmss_sk;\n\t\txmss_pk = xmss_sk = NULL;\n\t\t/* optional internal state */\n\t\tif ((r = sshkey_xmss_deserialize_state_opt(k, buf)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KEY_XMSS_CERT:\n\t\tif ((r = sshkey_froms(buf, &k)) != 0 ||\n\t\t    (r = sshbuf_get_cstring(buf, &xmss_name, NULL)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &xmss_pk, &pklen)) != 0 ||\n\t\t    (r = sshbuf_get_string(buf, &xmss_sk, &sklen)) != 0)\n\t\t\tgoto out;\n\t\tif (strcmp(xmss_name, k->xmss_name)) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (pklen != sshkey_xmss_pklen(k) ||\n\t\t    sklen != sshkey_xmss_sklen(k)) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tk->xmss_pk = xmss_pk;\n\t\tk->xmss_sk = xmss_sk;\n\t\txmss_pk = xmss_sk = NULL;\n\t\t/* optional internal state */\n\t\tif ((r = sshkey_xmss_deserialize_state_opt(k, buf)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n#ifdef WITH_OPENSSL\n\t/* enable blinding */\n\tswitch (k->type) {\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif (RSA_blinding_on(k->rsa, NULL) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n#endif /* WITH_OPENSSL */\n\t/* success */\n\tr = 0;\n\tif (kp != NULL) {\n\t\t*kp = k;\n\t\tk = NULL;\n\t}\n out:\n\tfree(tname);\n\tfree(curve);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(exponent);\n\tBN_clear_free(dsa_p);\n\tBN_clear_free(dsa_q);\n\tBN_clear_free(dsa_g);\n\tBN_clear_free(dsa_pub_key);\n\tBN_clear_free(dsa_priv_key);\n\tBN_clear_free(rsa_n);\n\tBN_clear_free(rsa_e);\n\tBN_clear_free(rsa_d);\n\tBN_clear_free(rsa_p);\n\tBN_clear_free(rsa_q);\n\tBN_clear_free(rsa_iqmp);\n#endif /* WITH_OPENSSL */\n\tsshkey_free(k);\n\tfreezero(ed25519_pk, pklen);\n\tfreezero(ed25519_sk, sklen);\n\tfree(xmss_name);\n\tfreezero(xmss_pk, pklen);\n\tfreezero(xmss_sk, sklen);\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct idtable *idtab;\nstatic long lifetime = 0;\n\nstatic void\nprocess_add_identity(SocketEntry *e)\n{\n\tIdentity *id;\n\tint success = 0, confirm = 0;\n\tu_int seconds, maxsign;\n\tchar *comment = NULL;\n\ttime_t death = 0;\n\tstruct sshkey *k = NULL;\n\tu_char ctype;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((r = sshkey_private_deserialize(e->request, &k)) != 0 ||\n\t    k == NULL ||\n\t    (r = sshbuf_get_cstring(e->request, &comment, NULL)) != 0) {\n\t\terror(\"%s: decode private key: %s\", __func__, ssh_err(r));\n\t\tgoto err;\n\t}\n\n\twhile (sshbuf_len(e->request)) {\n\t\tif ((r = sshbuf_get_u8(e->request, &ctype)) != 0) {\n\t\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\t\tgoto err;\n\t\t}\n\t\tswitch (ctype) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif ((r = sshbuf_get_u32(e->request, &seconds)) != 0) {\n\t\t\t\terror(\"%s: bad lifetime constraint: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tdeath = monotime() + seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tconfirm = 1;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_MAXSIGN:\n\t\t\tif ((r = sshbuf_get_u32(e->request, &maxsign)) != 0) {\n\t\t\t\terror(\"%s: bad maxsign constraint: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif ((r = sshkey_enable_maxsign(k, maxsign)) != 0) {\n\t\t\t\terror(\"%s: cannot enable maxsign: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Unknown constraint %d\", __func__, ctype);\n err:\n\t\t\tsshbuf_reset(e->request);\n\t\t\tfree(comment);\n\t\t\tsshkey_free(k);\n\t\t\tgoto send;\n\t\t}\n\t}\n\n\tsuccess = 1;\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\tif ((id = lookup_identity(k)) == NULL) {\n\t\tid = xcalloc(1, sizeof(Identity));\n\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t/* Increment the number of identities. */\n\t\tidtab->nentries++;\n\t} else {\n\t\t/* key state might have been updated */\n\t\tsshkey_free(id->key);\n\t\tfree(id->comment);\n\t}\n\tid->key = k;\n\tid->comment = comment;\n\tid->death = death;\n\tid->confirm = confirm;\nsend:\n\tsend_status(e, success);\n}"
  },
  {
    "function_name": "reaper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "376-399",
    "snippet": "static time_t\nreaper(void)\n{\n\ttime_t deadline = 0, now = monotime();\n\tIdentity *id, *nxt;\n\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id; id = nxt) {\n\t\tnxt = TAILQ_NEXT(id, next);\n\t\tif (id->death == 0)\n\t\t\tcontinue;\n\t\tif (now >= id->death) {\n\t\t\tdebug(\"expiring key '%s'\", id->comment);\n\t\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\t\tfree_identity(id);\n\t\t\tidtab->nentries--;\n\t\t} else\n\t\t\tdeadline = (deadline == 0) ? id->death :\n\t\t\t    MINIMUM(deadline, id->death);\n\t}\n\tif (deadline == 0 || deadline <= now)\n\t\treturn 0;\n\telse\n\t\treturn (deadline - now);\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct idtable *idtab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MINIMUM",
          "args": [
            "deadline",
            "id->death"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_identity",
          "args": [
            "id"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "free_identity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "184-191",
          "snippet": "static void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&idtab->idlist",
            "id",
            "next"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"expiring key '%s'\"",
            "id->comment"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_NEXT",
          "args": [
            "id",
            "next"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&idtab->idlist"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "monotime",
          "args": [],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "monotime_double",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1324-1331",
          "snippet": "double\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\ndouble\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct idtable *idtab;\n\nstatic time_t\nreaper(void)\n{\n\ttime_t deadline = 0, now = monotime();\n\tIdentity *id, *nxt;\n\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id; id = nxt) {\n\t\tnxt = TAILQ_NEXT(id, next);\n\t\tif (id->death == 0)\n\t\t\tcontinue;\n\t\tif (now >= id->death) {\n\t\t\tdebug(\"expiring key '%s'\", id->comment);\n\t\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\t\tfree_identity(id);\n\t\t\tidtab->nentries--;\n\t\t} else\n\t\t\tdeadline = (deadline == 0) ? id->death :\n\t\t\t    MINIMUM(deadline, id->death);\n\t}\n\tif (deadline == 0 || deadline <= now)\n\t\treturn 0;\n\telse\n\t\treturn (deadline - now);\n}"
  },
  {
    "function_name": "process_remove_all_identities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "356-373",
    "snippet": "static void\nprocess_remove_all_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\n\t/* Loop over all identities and clear the keys. */\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id;\n\t    id = TAILQ_FIRST(&idtab->idlist)) {\n\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\tfree_identity(id);\n\t}\n\n\t/* Mark that there are no identities. */\n\tidtab->nentries = 0;\n\n\t/* Send success. */\n\tsend_status(e, 1);\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct idtable *idtab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_status",
          "args": [
            "e",
            "1"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "send_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "223-232",
          "snippet": "static void\nsend_status(SocketEntry *e, int success)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(e->output, 1)) != 0 ||\n\t    (r = sshbuf_put_u8(e->output, success ?\n\t    SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_status(SocketEntry *e, int success)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(e->output, 1)) != 0 ||\n\t    (r = sshbuf_put_u8(e->output, success ?\n\t    SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_identity",
          "args": [
            "id"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "free_identity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "184-191",
          "snippet": "static void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&idtab->idlist",
            "id",
            "next"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&idtab->idlist"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&idtab->idlist"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct idtable *idtab;\n\nstatic void\nprocess_remove_all_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\n\t/* Loop over all identities and clear the keys. */\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id;\n\t    id = TAILQ_FIRST(&idtab->idlist)) {\n\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\tfree_identity(id);\n\t}\n\n\t/* Mark that there are no identities. */\n\tidtab->nentries = 0;\n\n\t/* Send success. */\n\tsend_status(e, 1);\n}"
  },
  {
    "function_name": "process_remove_identity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "328-354",
    "snippet": "static void\nprocess_remove_identity(SocketEntry *e)\n{\n\tint r, success = 0;\n\tstruct sshkey *key = NULL;\n\tIdentity *id;\n\n\tif ((r = sshkey_froms(e->request, &key)) != 0) {\n\t\terror(\"%s: get key: %s\", __func__, ssh_err(r));\n\t\tgoto done;\n\t}\n\tif ((id = lookup_identity(key)) == NULL) {\n\t\tdebug(\"%s: key not found\", __func__);\n\t\tgoto done;\n\t}\n\t/* We have this key, free it. */\n\tif (idtab->nentries < 1)\n\t\tfatal(\"%s: internal error: nentries %d\",\n\t\t    __func__, idtab->nentries);\n\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\tfree_identity(id);\n\tidtab->nentries--;\n\tsshkey_free(key);\n\tsuccess = 1;\n done:\n\tsend_status(e, success);\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct idtable *idtab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_status",
          "args": [
            "e",
            "success"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "send_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "223-232",
          "snippet": "static void\nsend_status(SocketEntry *e, int success)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(e->output, 1)) != 0 ||\n\t    (r = sshbuf_put_u8(e->output, success ?\n\t    SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_status(SocketEntry *e, int success)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(e->output, 1)) != 0 ||\n\t    (r = sshbuf_put_u8(e->output, success ?\n\t    SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "key"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_identity",
          "args": [
            "id"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "free_identity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "184-191",
          "snippet": "static void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&idtab->idlist",
            "id",
            "next"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: internal error: nentries %d\"",
            "__func__",
            "idtab->nentries"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: key not found\"",
            "__func__"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_identity",
          "args": [
            "key"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_identity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "194-204",
          "snippet": "static Identity *\nlookup_identity(struct sshkey *key)\n{\n\tIdentity *id;\n\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif (sshkey_equal(key, id->key))\n\t\t\treturn (id);\n\t}\n\treturn (NULL);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct idtable *idtab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct idtable *idtab;\n\nstatic Identity *\nlookup_identity(struct sshkey *key)\n{\n\tIdentity *id;\n\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif (sshkey_equal(key, id->key))\n\t\t\treturn (id);\n\t}\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: get key: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_froms",
          "args": [
            "e->request",
            "&key"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_froms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2282-2293",
          "snippet": "int\nsshkey_froms(struct sshbuf *buf, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((r = sshbuf_froms(buf, &b)) != 0)\n\t\treturn r;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_froms(struct sshbuf *buf, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((r = sshbuf_froms(buf, &b)) != 0)\n\t\treturn r;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct idtable *idtab;\n\nstatic void\nprocess_remove_identity(SocketEntry *e)\n{\n\tint r, success = 0;\n\tstruct sshkey *key = NULL;\n\tIdentity *id;\n\n\tif ((r = sshkey_froms(e->request, &key)) != 0) {\n\t\terror(\"%s: get key: %s\", __func__, ssh_err(r));\n\t\tgoto done;\n\t}\n\tif ((id = lookup_identity(key)) == NULL) {\n\t\tdebug(\"%s: key not found\", __func__);\n\t\tgoto done;\n\t}\n\t/* We have this key, free it. */\n\tif (idtab->nentries < 1)\n\t\tfatal(\"%s: internal error: nentries %d\",\n\t\t    __func__, idtab->nentries);\n\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\tfree_identity(id);\n\tidtab->nentries--;\n\tsshkey_free(key);\n\tsuccess = 1;\n done:\n\tsend_status(e, success);\n}"
  },
  {
    "function_name": "process_sign_request2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "275-325",
    "snippet": "static void\nprocess_sign_request2(SocketEntry *e)\n{\n\tconst u_char *data;\n\tu_char *signature = NULL;\n\tsize_t dlen, slen = 0;\n\tu_int compat = 0, flags;\n\tint r, ok = -1;\n\tstruct sshbuf *msg;\n\tstruct sshkey *key = NULL;\n\tstruct identity *id;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshkey_froms(e->request, &key)) != 0 ||\n\t    (r = sshbuf_get_string_direct(e->request, &data, &dlen)) != 0 ||\n\t    (r = sshbuf_get_u32(e->request, &flags)) != 0) {\n\t\terror(\"%s: couldn't parse request: %s\", __func__, ssh_err(r));\n\t\tgoto send;\n\t}\n\n\tif ((id = lookup_identity(key)) == NULL) {\n\t\tverbose(\"%s: %s key not found\", __func__, sshkey_type(key));\n\t\tgoto send;\n\t}\n\tif (id->confirm && confirm_key(id) != 0) {\n\t\tverbose(\"%s: user refused key\", __func__);\n\t\tgoto send;\n\t}\n\tif ((r = sshkey_sign(id->key, &signature, &slen,\n\t    data, dlen, agent_decode_alg(key, flags), compat)) != 0) {\n\t\terror(\"%s: sshkey_sign: %s\", __func__, ssh_err(r));\n\t\tgoto send;\n\t}\n\t/* Success */\n\tok = 0;\n send:\n\tsshkey_free(key);\n\tif (ok == 0) {\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_SIGN_RESPONSE)) != 0 ||\n\t\t    (r = sshbuf_put_string(msg, signature, slen)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t} else if ((r = sshbuf_put_u8(msg, SSH_AGENT_FAILURE)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tsshbuf_free(msg);\n\tfree(signature);\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "signature"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "free_identity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "184-191",
          "snippet": "static void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_stringb",
          "args": [
            "e->output",
            "msg"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "371-375",
          "snippet": "int\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "SSH_AGENT_FAILURE"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "msg",
            "signature",
            "slen"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "key"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: sshkey_sign: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_sign",
          "args": [
            "id->key",
            "&signature",
            "&slen",
            "data",
            "dlen",
            "agent_decode_alg(key, flags)",
            "compat"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2385-2421",
          "snippet": "int\nsshkey_sign(const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_sign(key, sigp, lenp, data, datalen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_sign(key, sigp, lenp, data, datalen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_sign(key, sigp, lenp, data, datalen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_sign(key, sigp, lenp, data, datalen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_sign(key, sigp, lenp, data, datalen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_sign(const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_sign(key, sigp, lenp, data, datalen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_sign(key, sigp, lenp, data, datalen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_sign(key, sigp, lenp, data, datalen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_sign(key, sigp, lenp, data, datalen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_sign(key, sigp, lenp, data, datalen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "agent_decode_alg",
          "args": [
            "key",
            "flags"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "agent_decode_alg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "262-272",
          "snippet": "static char *\nagent_decode_alg(struct sshkey *key, u_int flags)\n{\n\tif (key->type == KEY_RSA) {\n\t\tif (flags & SSH_AGENT_RSA_SHA2_256)\n\t\t\treturn \"rsa-sha2-256\";\n\t\telse if (flags & SSH_AGENT_RSA_SHA2_512)\n\t\t\treturn \"rsa-sha2-512\";\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nagent_decode_alg(struct sshkey *key, u_int flags)\n{\n\tif (key->type == KEY_RSA) {\n\t\tif (flags & SSH_AGENT_RSA_SHA2_256)\n\t\t\treturn \"rsa-sha2-256\";\n\t\telse if (flags & SSH_AGENT_RSA_SHA2_512)\n\t\t\treturn \"rsa-sha2-512\";\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"%s: user refused key\"",
            "__func__"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "210-218",
          "snippet": "void\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "confirm_key",
          "args": [
            "id"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "confirm_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "207-221",
          "snippet": "static int\nconfirm_key(Identity *id)\n{\n\tchar *p;\n\tint ret = -1;\n\n\tp = sshkey_fingerprint(id->key, fingerprint_hash, SSH_FP_DEFAULT);\n\tif (p != NULL &&\n\t    ask_permission(\"Allow use of key %s?\\nKey fingerprint %s.\",\n\t    id->comment, p))\n\t\tret = 0;\n\tfree(p);\n\n\treturn (ret);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fingerprint_hash = SSH_FP_HASH_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\nstatic int\nconfirm_key(Identity *id)\n{\n\tchar *p;\n\tint ret = -1;\n\n\tp = sshkey_fingerprint(id->key, fingerprint_hash, SSH_FP_DEFAULT);\n\tif (p != NULL &&\n\t    ask_permission(\"Allow use of key %s?\\nKey fingerprint %s.\",\n\t    id->comment, p))\n\t\tret = 0;\n\tfree(p);\n\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "key"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_identity",
          "args": [
            "key"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_identity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "194-204",
          "snippet": "static Identity *\nlookup_identity(struct sshkey *key)\n{\n\tIdentity *id;\n\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif (sshkey_equal(key, id->key))\n\t\t\treturn (id);\n\t}\n\treturn (NULL);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct idtable *idtab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct idtable *idtab;\n\nstatic Identity *\nlookup_identity(struct sshkey *key)\n{\n\tIdentity *id;\n\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif (sshkey_equal(key, id->key))\n\t\t\treturn (id);\n\t}\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "e->request",
            "&flags"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string_direct",
          "args": [
            "e->request",
            "&data",
            "&dlen"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_froms",
          "args": [
            "e->request",
            "&key"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_froms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2282-2293",
          "snippet": "int\nsshkey_froms(struct sshbuf *buf, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((r = sshbuf_froms(buf, &b)) != 0)\n\t\treturn r;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_froms(struct sshbuf *buf, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((r = sshbuf_froms(buf, &b)) != 0)\n\t\treturn r;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nprocess_sign_request2(SocketEntry *e)\n{\n\tconst u_char *data;\n\tu_char *signature = NULL;\n\tsize_t dlen, slen = 0;\n\tu_int compat = 0, flags;\n\tint r, ok = -1;\n\tstruct sshbuf *msg;\n\tstruct sshkey *key = NULL;\n\tstruct identity *id;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshkey_froms(e->request, &key)) != 0 ||\n\t    (r = sshbuf_get_string_direct(e->request, &data, &dlen)) != 0 ||\n\t    (r = sshbuf_get_u32(e->request, &flags)) != 0) {\n\t\terror(\"%s: couldn't parse request: %s\", __func__, ssh_err(r));\n\t\tgoto send;\n\t}\n\n\tif ((id = lookup_identity(key)) == NULL) {\n\t\tverbose(\"%s: %s key not found\", __func__, sshkey_type(key));\n\t\tgoto send;\n\t}\n\tif (id->confirm && confirm_key(id) != 0) {\n\t\tverbose(\"%s: user refused key\", __func__);\n\t\tgoto send;\n\t}\n\tif ((r = sshkey_sign(id->key, &signature, &slen,\n\t    data, dlen, agent_decode_alg(key, flags), compat)) != 0) {\n\t\terror(\"%s: sshkey_sign: %s\", __func__, ssh_err(r));\n\t\tgoto send;\n\t}\n\t/* Success */\n\tok = 0;\n send:\n\tsshkey_free(key);\n\tif (ok == 0) {\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_SIGN_RESPONSE)) != 0 ||\n\t\t    (r = sshbuf_put_string(msg, signature, slen)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t} else if ((r = sshbuf_put_u8(msg, SSH_AGENT_FAILURE)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tsshbuf_free(msg);\n\tfree(signature);\n}"
  },
  {
    "function_name": "agent_decode_alg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "262-272",
    "snippet": "static char *\nagent_decode_alg(struct sshkey *key, u_int flags)\n{\n\tif (key->type == KEY_RSA) {\n\t\tif (flags & SSH_AGENT_RSA_SHA2_256)\n\t\t\treturn \"rsa-sha2-256\";\n\t\telse if (flags & SSH_AGENT_RSA_SHA2_512)\n\t\t\treturn \"rsa-sha2-512\";\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nagent_decode_alg(struct sshkey *key, u_int flags)\n{\n\tif (key->type == KEY_RSA) {\n\t\tif (flags & SSH_AGENT_RSA_SHA2_256)\n\t\t\treturn \"rsa-sha2-256\";\n\t\telse if (flags & SSH_AGENT_RSA_SHA2_512)\n\t\t\treturn \"rsa-sha2-512\";\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "process_request_identities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "235-259",
    "snippet": "static void\nprocess_request_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, idtab->nentries)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif ((r = sshkey_puts_opts(id->key, msg, SSHKEY_SERIALIZE_INFO))\n\t\t     != 0 ||\n\t\t    (r = sshbuf_put_cstring(msg, id->comment)) != 0) {\n\t\t\terror(\"%s: put key/comment: %s\", __func__,\n\t\t\t    ssh_err(r));\n\t\t\tcontinue;\n\t\t}\n\t}\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct idtable *idtab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_stringb",
          "args": [
            "e->output",
            "msg"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "371-375",
          "snippet": "int\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: put key/comment: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "msg",
            "id->comment"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_puts_opts",
          "args": [
            "id->key",
            "msg",
            "SSHKEY_SERIALIZE_INFO"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_puts_opts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "820-834",
          "snippet": "int\nsshkey_puts_opts(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tstruct sshbuf *tmp;\n\tint r;\n\n\tif ((tmp = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = to_blob_buf(key, tmp, 0, opts);\n\tif (r == 0)\n\t\tr = sshbuf_put_stringb(b, tmp);\n\tsshbuf_free(tmp);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tsshkey_private_serialize_opt(const struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);\n\nint\nsshkey_puts_opts(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tstruct sshbuf *tmp;\n\tint r;\n\n\tif ((tmp = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = to_blob_buf(key, tmp, 0, opts);\n\tif (r == 0)\n\t\tr = sshbuf_put_stringb(b, tmp);\n\tsshbuf_free(tmp);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_FOREACH",
          "args": [
            "id",
            "&idtab->idlist",
            "next"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "msg",
            "idtab->nentries"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "SSH2_AGENT_IDENTITIES_ANSWER"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct idtable *idtab;\n\nstatic void\nprocess_request_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, idtab->nentries)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif ((r = sshkey_puts_opts(id->key, msg, SSHKEY_SERIALIZE_INFO))\n\t\t     != 0 ||\n\t\t    (r = sshbuf_put_cstring(msg, id->comment)) != 0) {\n\t\t\terror(\"%s: put key/comment: %s\", __func__,\n\t\t\t    ssh_err(r));\n\t\t\tcontinue;\n\t\t}\n\t}\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n}"
  },
  {
    "function_name": "send_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "223-232",
    "snippet": "static void\nsend_status(SocketEntry *e, int success)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(e->output, 1)) != 0 ||\n\t    (r = sshbuf_put_u8(e->output, success ?\n\t    SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "e->output",
            "success ?\n\t    SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "e->output",
            "1"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_status(SocketEntry *e, int success)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(e->output, 1)) != 0 ||\n\t    (r = sshbuf_put_u8(e->output, success ?\n\t    SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}"
  },
  {
    "function_name": "confirm_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "207-221",
    "snippet": "static int\nconfirm_key(Identity *id)\n{\n\tchar *p;\n\tint ret = -1;\n\n\tp = sshkey_fingerprint(id->key, fingerprint_hash, SSH_FP_DEFAULT);\n\tif (p != NULL &&\n\t    ask_permission(\"Allow use of key %s?\\nKey fingerprint %s.\",\n\t    id->comment, p))\n\t\tret = 0;\n\tfree(p);\n\n\treturn (ret);\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fingerprint_hash = SSH_FP_HASH_DEFAULT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "p"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "free_identity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "184-191",
          "snippet": "static void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id);\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ask_permission",
          "args": [
            "\"Allow use of key %s?\\nKey fingerprint %s.\"",
            "id->comment",
            "p"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "ask_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readpass.c",
          "lines": "168-192",
          "snippet": "int\nask_permission(const char *fmt, ...)\n{\n\tva_list args;\n\tchar *p, prompt[1024];\n\tint allowed = 0;\n\n\tva_start(args, fmt);\n\tvsnprintf(prompt, sizeof(prompt), fmt, args);\n\tva_end(args);\n\n\tp = read_passphrase(prompt, RP_USE_ASKPASS|RP_ALLOW_EOF);\n\tif (p != NULL) {\n\t\t/*\n\t\t * Accept empty responses and responses consisting\n\t\t * of the word \"yes\" as affirmative.\n\t\t */\n\t\tif (*p == '\\0' || *p == '\\n' ||\n\t\t    strcasecmp(p, \"yes\") == 0)\n\t\t\tallowed = 1;\n\t\tfree(p);\n\t}\n\n\treturn (allowed);\n}",
          "includes": [
            "#include \"uidswap.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uidswap.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nask_permission(const char *fmt, ...)\n{\n\tva_list args;\n\tchar *p, prompt[1024];\n\tint allowed = 0;\n\n\tva_start(args, fmt);\n\tvsnprintf(prompt, sizeof(prompt), fmt, args);\n\tva_end(args);\n\n\tp = read_passphrase(prompt, RP_USE_ASKPASS|RP_ALLOW_EOF);\n\tif (p != NULL) {\n\t\t/*\n\t\t * Accept empty responses and responses consisting\n\t\t * of the word \"yes\" as affirmative.\n\t\t */\n\t\tif (*p == '\\0' || *p == '\\n' ||\n\t\t    strcasecmp(p, \"yes\") == 0)\n\t\t\tallowed = 1;\n\t\tfree(p);\n\t}\n\n\treturn (allowed);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "id->key",
            "fingerprint_hash",
            "SSH_FP_DEFAULT"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\nstatic int\nconfirm_key(Identity *id)\n{\n\tchar *p;\n\tint ret = -1;\n\n\tp = sshkey_fingerprint(id->key, fingerprint_hash, SSH_FP_DEFAULT);\n\tif (p != NULL &&\n\t    ask_permission(\"Allow use of key %s?\\nKey fingerprint %s.\",\n\t    id->comment, p))\n\t\tret = 0;\n\tfree(p);\n\n\treturn (ret);\n}"
  },
  {
    "function_name": "lookup_identity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "194-204",
    "snippet": "static Identity *\nlookup_identity(struct sshkey *key)\n{\n\tIdentity *id;\n\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif (sshkey_equal(key, id->key))\n\t\t\treturn (id);\n\t}\n\treturn (NULL);\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct idtable *idtab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_equal",
          "args": [
            "key",
            "id->key"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "704-714",
          "snippet": "int\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_FOREACH",
          "args": [
            "id",
            "&idtab->idlist",
            "next"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct idtable *idtab;\n\nstatic Identity *\nlookup_identity(struct sshkey *key)\n{\n\tIdentity *id;\n\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif (sshkey_equal(key, id->key))\n\t\t\treturn (id);\n\t}\n\treturn (NULL);\n}"
  },
  {
    "function_name": "free_identity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "184-191",
    "snippet": "static void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id);\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "id"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "free_identity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "184-191",
          "snippet": "static void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "id->key"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id);\n}"
  },
  {
    "function_name": "idtab_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "176-182",
    "snippet": "static void\nidtab_init(void)\n{\n\tidtab = xcalloc(1, sizeof(*idtab));\n\tTAILQ_INIT(&idtab->idlist);\n\tidtab->nentries = 0;\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct idtable *idtab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&idtab->idlist"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "1",
            "sizeof(*idtab)"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct idtable *idtab;\n\nstatic void\nidtab_init(void)\n{\n\tidtab = xcalloc(1, sizeof(*idtab));\n\tTAILQ_INIT(&idtab->idlist);\n\tidtab->nentries = 0;\n}"
  },
  {
    "function_name": "close_socket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
    "lines": "165-174",
    "snippet": "static void\nclose_socket(SocketEntry *e)\n{\n\tclose(e->fd);\n\te->fd = -1;\n\te->type = AUTH_UNUSED;\n\tsshbuf_free(e->input);\n\tsshbuf_free(e->output);\n\tsshbuf_free(e->request);\n}",
    "includes": [
      "#include \"ssh-pkcs11.h\"",
      "#include \"match.h\"",
      "#include \"ssherr.h\"",
      "#include \"digest.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"compat.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "# include <util.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "# include <paths.h>",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/evp.h>",
      "#include \"openbsd-compat/sys-queue.h\"",
      "# include <sys/un.h>",
      "# include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "e->request"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "e->fd"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "close_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "165-174",
          "snippet": "static void\nclose_socket(SocketEntry *e)\n{\n\tclose(e->fd);\n\te->fd = -1;\n\te->type = AUTH_UNUSED;\n\tsshbuf_free(e->input);\n\tsshbuf_free(e->output);\n\tsshbuf_free(e->request);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nclose_socket(SocketEntry *e)\n{\n\tclose(e->fd);\n\te->fd = -1;\n\te->type = AUTH_UNUSED;\n\tsshbuf_free(e->input);\n\tsshbuf_free(e->output);\n\tsshbuf_free(e->request);\n}"
  }
]