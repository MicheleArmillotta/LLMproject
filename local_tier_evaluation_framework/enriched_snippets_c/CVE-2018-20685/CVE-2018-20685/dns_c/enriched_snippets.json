[
  {
    "function_name": "export_dns_rr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dns.c",
    "lines": "319-356",
    "snippet": "int\nexport_dns_rr(const char *hostname, struct sshkey *key, FILE *f, int generic)\n{\n\tu_int8_t rdata_pubkey_algorithm = 0;\n\tu_int8_t rdata_digest_type = SSHFP_HASH_RESERVED;\n\tu_int8_t dtype;\n\tu_char *rdata_digest;\n\tsize_t i, rdata_digest_len;\n\tint success = 0;\n\n\tfor (dtype = SSHFP_HASH_SHA1; dtype < SSHFP_HASH_MAX; dtype++) {\n\t\trdata_digest_type = dtype;\n\t\tif (dns_read_key(&rdata_pubkey_algorithm, &rdata_digest_type,\n\t\t    &rdata_digest, &rdata_digest_len, key)) {\n\t\t\tif (generic) {\n\t\t\t\tfprintf(f, \"%s IN TYPE%d \\\\# %zu %02x %02x \",\n\t\t\t\t    hostname, DNS_RDATATYPE_SSHFP,\n\t\t\t\t    2 + rdata_digest_len,\n\t\t\t\t    rdata_pubkey_algorithm, rdata_digest_type);\n\t\t\t} else {\n\t\t\t\tfprintf(f, \"%s IN SSHFP %d %d \", hostname,\n\t\t\t\t    rdata_pubkey_algorithm, rdata_digest_type);\n\t\t\t}\n\t\t\tfor (i = 0; i < rdata_digest_len; i++)\n\t\t\t\tfprintf(f, \"%02x\", rdata_digest[i]);\n\t\t\tfprintf(f, \"\\n\");\n\t\t\tfree(rdata_digest); /* from sshkey_fingerprint_raw() */\n\t\t\tsuccess = 1;\n\t\t}\n\t}\n\n\t/* No SSHFP record was generated at all */\n\tif (success == 0) {\n\t\terror(\"%s: unsupported algorithm and/or digest_type\", __func__);\n\t}\n\n\treturn success;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"dns.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: unsupported algorithm and/or digest_type\"",
            "__func__"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "rdata_digest"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"\\n\""
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"%02x\"",
            "rdata_digest[i]"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"%s IN SSHFP %d %d \"",
            "hostname",
            "rdata_pubkey_algorithm",
            "rdata_digest_type"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"%s IN TYPE%d \\\\# %zu %02x %02x \"",
            "hostname",
            "DNS_RDATATYPE_SSHFP",
            "2 + rdata_digest_len",
            "rdata_pubkey_algorithm",
            "rdata_digest_type"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dns_read_key",
          "args": [
            "&rdata_pubkey_algorithm",
            "&rdata_digest_type",
            "&rdata_digest",
            "&rdata_digest_len",
            "key"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "dns_read_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dns.c",
          "lines": "80-142",
          "snippet": "static int\ndns_read_key(u_int8_t *algorithm, u_int8_t *digest_type,\n    u_char **digest, size_t *digest_len, struct sshkey *key)\n{\n\tint r, success = 0;\n\tint fp_alg = -1;\n\n\tswitch (key->type) {\n\tcase KEY_RSA:\n\t\t*algorithm = SSHFP_KEY_RSA;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA1;\n\t\tbreak;\n\tcase KEY_DSA:\n\t\t*algorithm = SSHFP_KEY_DSA;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA1;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\t\t*algorithm = SSHFP_KEY_ECDSA;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA256;\n\t\tbreak;\n\tcase KEY_ED25519:\n\t\t*algorithm = SSHFP_KEY_ED25519;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA256;\n\t\tbreak;\n\tcase KEY_XMSS:\n\t\t*algorithm = SSHFP_KEY_XMSS;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA256;\n\t\tbreak;\n\tdefault:\n\t\t*algorithm = SSHFP_KEY_RESERVED; /* 0 */\n\t\t*digest_type = SSHFP_HASH_RESERVED; /* 0 */\n\t}\n\n\tswitch (*digest_type) {\n\tcase SSHFP_HASH_SHA1:\n\t\tfp_alg = SSH_DIGEST_SHA1;\n\t\tbreak;\n\tcase SSHFP_HASH_SHA256:\n\t\tfp_alg = SSH_DIGEST_SHA256;\n\t\tbreak;\n\tdefault:\n\t\t*digest_type = SSHFP_HASH_RESERVED; /* 0 */\n\t}\n\n\tif (*algorithm && *digest_type) {\n\t\tif ((r = sshkey_fingerprint_raw(key, fp_alg, digest,\n\t\t    digest_len)) != 0)\n\t\t\tfatal(\"%s: sshkey_fingerprint_raw: %s\", __func__,\n\t\t\t   ssh_err(r));\n\t\tsuccess = 1;\n\t} else {\n\t\t*digest = NULL;\n\t\t*digest_len = 0;\n\t\tsuccess = 0;\n\t}\n\n\treturn success;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"dns.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"log.h\"\n#include \"dns.h\"\n#include \"ssherr.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndns_read_key(u_int8_t *algorithm, u_int8_t *digest_type,\n    u_char **digest, size_t *digest_len, struct sshkey *key)\n{\n\tint r, success = 0;\n\tint fp_alg = -1;\n\n\tswitch (key->type) {\n\tcase KEY_RSA:\n\t\t*algorithm = SSHFP_KEY_RSA;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA1;\n\t\tbreak;\n\tcase KEY_DSA:\n\t\t*algorithm = SSHFP_KEY_DSA;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA1;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\t\t*algorithm = SSHFP_KEY_ECDSA;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA256;\n\t\tbreak;\n\tcase KEY_ED25519:\n\t\t*algorithm = SSHFP_KEY_ED25519;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA256;\n\t\tbreak;\n\tcase KEY_XMSS:\n\t\t*algorithm = SSHFP_KEY_XMSS;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA256;\n\t\tbreak;\n\tdefault:\n\t\t*algorithm = SSHFP_KEY_RESERVED; /* 0 */\n\t\t*digest_type = SSHFP_HASH_RESERVED; /* 0 */\n\t}\n\n\tswitch (*digest_type) {\n\tcase SSHFP_HASH_SHA1:\n\t\tfp_alg = SSH_DIGEST_SHA1;\n\t\tbreak;\n\tcase SSHFP_HASH_SHA256:\n\t\tfp_alg = SSH_DIGEST_SHA256;\n\t\tbreak;\n\tdefault:\n\t\t*digest_type = SSHFP_HASH_RESERVED; /* 0 */\n\t}\n\n\tif (*algorithm && *digest_type) {\n\t\tif ((r = sshkey_fingerprint_raw(key, fp_alg, digest,\n\t\t    digest_len)) != 0)\n\t\t\tfatal(\"%s: sshkey_fingerprint_raw: %s\", __func__,\n\t\t\t   ssh_err(r));\n\t\tsuccess = 1;\n\t} else {\n\t\t*digest = NULL;\n\t\t*digest_len = 0;\n\t\tsuccess = 0;\n\t}\n\n\treturn success;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"log.h\"\n#include \"dns.h\"\n#include \"ssherr.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nexport_dns_rr(const char *hostname, struct sshkey *key, FILE *f, int generic)\n{\n\tu_int8_t rdata_pubkey_algorithm = 0;\n\tu_int8_t rdata_digest_type = SSHFP_HASH_RESERVED;\n\tu_int8_t dtype;\n\tu_char *rdata_digest;\n\tsize_t i, rdata_digest_len;\n\tint success = 0;\n\n\tfor (dtype = SSHFP_HASH_SHA1; dtype < SSHFP_HASH_MAX; dtype++) {\n\t\trdata_digest_type = dtype;\n\t\tif (dns_read_key(&rdata_pubkey_algorithm, &rdata_digest_type,\n\t\t    &rdata_digest, &rdata_digest_len, key)) {\n\t\t\tif (generic) {\n\t\t\t\tfprintf(f, \"%s IN TYPE%d \\\\# %zu %02x %02x \",\n\t\t\t\t    hostname, DNS_RDATATYPE_SSHFP,\n\t\t\t\t    2 + rdata_digest_len,\n\t\t\t\t    rdata_pubkey_algorithm, rdata_digest_type);\n\t\t\t} else {\n\t\t\t\tfprintf(f, \"%s IN SSHFP %d %d \", hostname,\n\t\t\t\t    rdata_pubkey_algorithm, rdata_digest_type);\n\t\t\t}\n\t\t\tfor (i = 0; i < rdata_digest_len; i++)\n\t\t\t\tfprintf(f, \"%02x\", rdata_digest[i]);\n\t\t\tfprintf(f, \"\\n\");\n\t\t\tfree(rdata_digest); /* from sshkey_fingerprint_raw() */\n\t\t\tsuccess = 1;\n\t\t}\n\t}\n\n\t/* No SSHFP record was generated at all */\n\tif (success == 0) {\n\t\terror(\"%s: unsupported algorithm and/or digest_type\", __func__);\n\t}\n\n\treturn success;\n}"
  },
  {
    "function_name": "verify_host_key_dns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dns.c",
    "lines": "208-314",
    "snippet": "int\nverify_host_key_dns(const char *hostname, struct sockaddr *address,\n    struct sshkey *hostkey, int *flags)\n{\n\tu_int counter;\n\tint result;\n\tstruct rrsetinfo *fingerprints = NULL;\n\n\tu_int8_t hostkey_algorithm;\n\tu_int8_t hostkey_digest_type = SSHFP_HASH_RESERVED;\n\tu_char *hostkey_digest;\n\tsize_t hostkey_digest_len;\n\n\tu_int8_t dnskey_algorithm;\n\tu_int8_t dnskey_digest_type;\n\tu_char *dnskey_digest;\n\tsize_t dnskey_digest_len;\n\n\t*flags = 0;\n\n\tdebug3(\"verify_host_key_dns\");\n\tif (hostkey == NULL)\n\t\tfatal(\"No key to look up!\");\n\n\tif (is_numeric_hostname(hostname)) {\n\t\tdebug(\"skipped DNS lookup for numerical hostname\");\n\t\treturn -1;\n\t}\n\n\tresult = getrrsetbyname(hostname, DNS_RDATACLASS_IN,\n\t    DNS_RDATATYPE_SSHFP, 0, &fingerprints);\n\tif (result) {\n\t\tverbose(\"DNS lookup error: %s\", dns_result_totext(result));\n\t\treturn -1;\n\t}\n\n\tif (fingerprints->rri_flags & RRSET_VALIDATED) {\n\t\t*flags |= DNS_VERIFY_SECURE;\n\t\tdebug(\"found %d secure fingerprints in DNS\",\n\t\t    fingerprints->rri_nrdatas);\n\t} else {\n\t\tdebug(\"found %d insecure fingerprints in DNS\",\n\t\t    fingerprints->rri_nrdatas);\n\t}\n\n\t/* Initialize default host key parameters */\n\tif (!dns_read_key(&hostkey_algorithm, &hostkey_digest_type,\n\t    &hostkey_digest, &hostkey_digest_len, hostkey)) {\n\t\terror(\"Error calculating host key fingerprint.\");\n\t\tfreerrset(fingerprints);\n\t\treturn -1;\n\t}\n\n\tif (fingerprints->rri_nrdatas)\n\t\t*flags |= DNS_VERIFY_FOUND;\n\n\tfor (counter = 0; counter < fingerprints->rri_nrdatas; counter++) {\n\t\t/*\n\t\t * Extract the key from the answer. Ignore any badly\n\t\t * formatted fingerprints.\n\t\t */\n\t\tif (!dns_read_rdata(&dnskey_algorithm, &dnskey_digest_type,\n\t\t    &dnskey_digest, &dnskey_digest_len,\n\t\t    fingerprints->rri_rdatas[counter].rdi_data,\n\t\t    fingerprints->rri_rdatas[counter].rdi_length)) {\n\t\t\tverbose(\"Error parsing fingerprint from DNS.\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (hostkey_digest_type != dnskey_digest_type) {\n\t\t\thostkey_digest_type = dnskey_digest_type;\n\t\t\tfree(hostkey_digest);\n\n\t\t\t/* Initialize host key parameters */\n\t\t\tif (!dns_read_key(&hostkey_algorithm,\n\t\t\t    &hostkey_digest_type, &hostkey_digest,\n\t\t\t    &hostkey_digest_len, hostkey)) {\n\t\t\t\terror(\"Error calculating key fingerprint.\");\n\t\t\t\tfreerrset(fingerprints);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\t/* Check if the current key is the same as the given key */\n\t\tif (hostkey_algorithm == dnskey_algorithm &&\n\t\t    hostkey_digest_type == dnskey_digest_type) {\n\t\t\tif (hostkey_digest_len == dnskey_digest_len &&\n\t\t\t    timingsafe_bcmp(hostkey_digest, dnskey_digest,\n\t\t\t    hostkey_digest_len) == 0)\n\t\t\t\t*flags |= DNS_VERIFY_MATCH;\n\t\t}\n\t\tfree(dnskey_digest);\n\t}\n\n\tfree(hostkey_digest); /* from sshkey_fingerprint_raw() */\n\tfreerrset(fingerprints);\n\n\tif (*flags & DNS_VERIFY_FOUND)\n\t\tif (*flags & DNS_VERIFY_MATCH)\n\t\t\tdebug(\"matching host key fingerprint found in DNS\");\n\t\telse\n\t\t\tdebug(\"mismatching host key fingerprint found in DNS\");\n\telse\n\t\tdebug(\"no host key fingerprint found in DNS\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"dns.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"no host key fingerprint found in DNS\""
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freerrset",
          "args": [
            "fingerprints"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "freerrset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname-ldns.c",
          "lines": "252-281",
          "snippet": "void\nfreerrset(struct rrsetinfo *rrset)\n{\n\tu_int16_t i;\n\n\tif (rrset == NULL)\n\t\treturn;\n\n\tif (rrset->rri_rdatas) {\n\t\tfor (i = 0; i < rrset->rri_nrdatas; i++) {\n\t\t\tif (rrset->rri_rdatas[i].rdi_data == NULL)\n\t\t\t\tbreak;\n\t\t\tfree(rrset->rri_rdatas[i].rdi_data);\n\t\t}\n\t\tfree(rrset->rri_rdatas);\n\t}\n\n\tif (rrset->rri_sigs) {\n\t\tfor (i = 0; i < rrset->rri_nsigs; i++) {\n\t\t\tif (rrset->rri_sigs[i].rdi_data == NULL)\n\t\t\t\tbreak;\n\t\t\tfree(rrset->rri_sigs[i].rdi_data);\n\t\t}\n\t\tfree(rrset->rri_sigs);\n\t}\n\n\tif (rrset->rri_name)\n\t\tfree(rrset->rri_name);\n\tfree(rrset);\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"log.h\"",
            "#include \"getrrsetbyname.h\"",
            "#include <ldns/ldns.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"log.h\"\n#include \"getrrsetbyname.h\"\n#include <ldns/ldns.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreerrset(struct rrsetinfo *rrset)\n{\n\tu_int16_t i;\n\n\tif (rrset == NULL)\n\t\treturn;\n\n\tif (rrset->rri_rdatas) {\n\t\tfor (i = 0; i < rrset->rri_nrdatas; i++) {\n\t\t\tif (rrset->rri_rdatas[i].rdi_data == NULL)\n\t\t\t\tbreak;\n\t\t\tfree(rrset->rri_rdatas[i].rdi_data);\n\t\t}\n\t\tfree(rrset->rri_rdatas);\n\t}\n\n\tif (rrset->rri_sigs) {\n\t\tfor (i = 0; i < rrset->rri_nsigs; i++) {\n\t\t\tif (rrset->rri_sigs[i].rdi_data == NULL)\n\t\t\t\tbreak;\n\t\t\tfree(rrset->rri_sigs[i].rdi_data);\n\t\t}\n\t\tfree(rrset->rri_sigs);\n\t}\n\n\tif (rrset->rri_name)\n\t\tfree(rrset->rri_name);\n\tfree(rrset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "hostkey_digest"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timingsafe_bcmp",
          "args": [
            "hostkey_digest",
            "dnskey_digest",
            "hostkey_digest_len"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "timingsafe_bcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/timingsafe_bcmp.c",
          "lines": "23-32",
          "snippet": "int\ntimingsafe_bcmp(const void *b1, const void *b2, size_t n)\n{\n\tconst unsigned char *p1 = b1, *p2 = b2;\n\tint ret = 0;\n\n\tfor (; n > 0; n--)\n\t\tret |= *p1++ ^ *p2++;\n\treturn (ret != 0);\n}",
          "includes": [
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"includes.h\"\n\nint\ntimingsafe_bcmp(const void *b1, const void *b2, size_t n)\n{\n\tconst unsigned char *p1 = b1, *p2 = b2;\n\tint ret = 0;\n\n\tfor (; n > 0; n--)\n\t\tret |= *p1++ ^ *p2++;\n\treturn (ret != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Error calculating key fingerprint.\""
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dns_read_key",
          "args": [
            "&hostkey_algorithm",
            "&hostkey_digest_type",
            "&hostkey_digest",
            "&hostkey_digest_len",
            "hostkey"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "dns_read_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dns.c",
          "lines": "80-142",
          "snippet": "static int\ndns_read_key(u_int8_t *algorithm, u_int8_t *digest_type,\n    u_char **digest, size_t *digest_len, struct sshkey *key)\n{\n\tint r, success = 0;\n\tint fp_alg = -1;\n\n\tswitch (key->type) {\n\tcase KEY_RSA:\n\t\t*algorithm = SSHFP_KEY_RSA;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA1;\n\t\tbreak;\n\tcase KEY_DSA:\n\t\t*algorithm = SSHFP_KEY_DSA;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA1;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\t\t*algorithm = SSHFP_KEY_ECDSA;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA256;\n\t\tbreak;\n\tcase KEY_ED25519:\n\t\t*algorithm = SSHFP_KEY_ED25519;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA256;\n\t\tbreak;\n\tcase KEY_XMSS:\n\t\t*algorithm = SSHFP_KEY_XMSS;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA256;\n\t\tbreak;\n\tdefault:\n\t\t*algorithm = SSHFP_KEY_RESERVED; /* 0 */\n\t\t*digest_type = SSHFP_HASH_RESERVED; /* 0 */\n\t}\n\n\tswitch (*digest_type) {\n\tcase SSHFP_HASH_SHA1:\n\t\tfp_alg = SSH_DIGEST_SHA1;\n\t\tbreak;\n\tcase SSHFP_HASH_SHA256:\n\t\tfp_alg = SSH_DIGEST_SHA256;\n\t\tbreak;\n\tdefault:\n\t\t*digest_type = SSHFP_HASH_RESERVED; /* 0 */\n\t}\n\n\tif (*algorithm && *digest_type) {\n\t\tif ((r = sshkey_fingerprint_raw(key, fp_alg, digest,\n\t\t    digest_len)) != 0)\n\t\t\tfatal(\"%s: sshkey_fingerprint_raw: %s\", __func__,\n\t\t\t   ssh_err(r));\n\t\tsuccess = 1;\n\t} else {\n\t\t*digest = NULL;\n\t\t*digest_len = 0;\n\t\tsuccess = 0;\n\t}\n\n\treturn success;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"dns.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"log.h\"\n#include \"dns.h\"\n#include \"ssherr.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndns_read_key(u_int8_t *algorithm, u_int8_t *digest_type,\n    u_char **digest, size_t *digest_len, struct sshkey *key)\n{\n\tint r, success = 0;\n\tint fp_alg = -1;\n\n\tswitch (key->type) {\n\tcase KEY_RSA:\n\t\t*algorithm = SSHFP_KEY_RSA;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA1;\n\t\tbreak;\n\tcase KEY_DSA:\n\t\t*algorithm = SSHFP_KEY_DSA;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA1;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\t\t*algorithm = SSHFP_KEY_ECDSA;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA256;\n\t\tbreak;\n\tcase KEY_ED25519:\n\t\t*algorithm = SSHFP_KEY_ED25519;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA256;\n\t\tbreak;\n\tcase KEY_XMSS:\n\t\t*algorithm = SSHFP_KEY_XMSS;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA256;\n\t\tbreak;\n\tdefault:\n\t\t*algorithm = SSHFP_KEY_RESERVED; /* 0 */\n\t\t*digest_type = SSHFP_HASH_RESERVED; /* 0 */\n\t}\n\n\tswitch (*digest_type) {\n\tcase SSHFP_HASH_SHA1:\n\t\tfp_alg = SSH_DIGEST_SHA1;\n\t\tbreak;\n\tcase SSHFP_HASH_SHA256:\n\t\tfp_alg = SSH_DIGEST_SHA256;\n\t\tbreak;\n\tdefault:\n\t\t*digest_type = SSHFP_HASH_RESERVED; /* 0 */\n\t}\n\n\tif (*algorithm && *digest_type) {\n\t\tif ((r = sshkey_fingerprint_raw(key, fp_alg, digest,\n\t\t    digest_len)) != 0)\n\t\t\tfatal(\"%s: sshkey_fingerprint_raw: %s\", __func__,\n\t\t\t   ssh_err(r));\n\t\tsuccess = 1;\n\t} else {\n\t\t*digest = NULL;\n\t\t*digest_len = 0;\n\t\tsuccess = 0;\n\t}\n\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Error parsing fingerprint from DNS.\""
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "210-218",
          "snippet": "void\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dns_read_rdata",
          "args": [
            "&dnskey_algorithm",
            "&dnskey_digest_type",
            "&dnskey_digest",
            "&dnskey_digest_len",
            "fingerprints->rri_rdatas[counter].rdi_data",
            "fingerprints->rri_rdatas[counter].rdi_length"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "dns_read_rdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dns.c",
          "lines": "147-172",
          "snippet": "static int\ndns_read_rdata(u_int8_t *algorithm, u_int8_t *digest_type,\n    u_char **digest, size_t *digest_len, u_char *rdata, int rdata_len)\n{\n\tint success = 0;\n\n\t*algorithm = SSHFP_KEY_RESERVED;\n\t*digest_type = SSHFP_HASH_RESERVED;\n\n\tif (rdata_len >= 2) {\n\t\t*algorithm = rdata[0];\n\t\t*digest_type = rdata[1];\n\t\t*digest_len = rdata_len - 2;\n\n\t\tif (*digest_len > 0) {\n\t\t\t*digest = xmalloc(*digest_len);\n\t\t\tmemcpy(*digest, rdata + 2, *digest_len);\n\t\t} else {\n\t\t\t*digest = (u_char *)xstrdup(\"\");\n\t\t}\n\n\t\tsuccess = 1;\n\t}\n\n\treturn success;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"dns.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"log.h\"\n#include \"dns.h\"\n#include \"ssherr.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndns_read_rdata(u_int8_t *algorithm, u_int8_t *digest_type,\n    u_char **digest, size_t *digest_len, u_char *rdata, int rdata_len)\n{\n\tint success = 0;\n\n\t*algorithm = SSHFP_KEY_RESERVED;\n\t*digest_type = SSHFP_HASH_RESERVED;\n\n\tif (rdata_len >= 2) {\n\t\t*algorithm = rdata[0];\n\t\t*digest_type = rdata[1];\n\t\t*digest_len = rdata_len - 2;\n\n\t\tif (*digest_len > 0) {\n\t\t\t*digest = xmalloc(*digest_len);\n\t\t\tmemcpy(*digest, rdata + 2, *digest_len);\n\t\t} else {\n\t\t\t*digest = (u_char *)xstrdup(\"\");\n\t\t}\n\n\t\tsuccess = 1;\n\t}\n\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dns_result_totext",
          "args": [
            "result"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "dns_result_totext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dns.c",
          "lines": "56-75",
          "snippet": "static const char *\ndns_result_totext(unsigned int res)\n{\n\tswitch (res) {\n\tcase ERRSET_SUCCESS:\n\t\treturn errset_text[ERRSET_SUCCESS];\n\tcase ERRSET_NOMEMORY:\n\t\treturn errset_text[ERRSET_NOMEMORY];\n\tcase ERRSET_FAIL:\n\t\treturn errset_text[ERRSET_FAIL];\n\tcase ERRSET_INVAL:\n\t\treturn errset_text[ERRSET_INVAL];\n\tcase ERRSET_NONAME:\n\t\treturn errset_text[ERRSET_NONAME];\n\tcase ERRSET_NODATA:\n\t\treturn errset_text[ERRSET_NODATA];\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"dns.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *errset_text[] = {\n\t\"success\",\t\t/* 0 ERRSET_SUCCESS */\n\t\"out of memory\",\t/* 1 ERRSET_NOMEMORY */\n\t\"general failure\",\t/* 2 ERRSET_FAIL */\n\t\"invalid parameter\",\t/* 3 ERRSET_INVAL */\n\t\"name does not exist\",\t/* 4 ERRSET_NONAME */\n\t\"data does not exist\",\t/* 5 ERRSET_NODATA */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"log.h\"\n#include \"dns.h\"\n#include \"ssherr.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *errset_text[] = {\n\t\"success\",\t\t/* 0 ERRSET_SUCCESS */\n\t\"out of memory\",\t/* 1 ERRSET_NOMEMORY */\n\t\"general failure\",\t/* 2 ERRSET_FAIL */\n\t\"invalid parameter\",\t/* 3 ERRSET_INVAL */\n\t\"name does not exist\",\t/* 4 ERRSET_NONAME */\n\t\"data does not exist\",\t/* 5 ERRSET_NODATA */\n};\n\nstatic const char *\ndns_result_totext(unsigned int res)\n{\n\tswitch (res) {\n\tcase ERRSET_SUCCESS:\n\t\treturn errset_text[ERRSET_SUCCESS];\n\tcase ERRSET_NOMEMORY:\n\t\treturn errset_text[ERRSET_NOMEMORY];\n\tcase ERRSET_FAIL:\n\t\treturn errset_text[ERRSET_FAIL];\n\tcase ERRSET_INVAL:\n\t\treturn errset_text[ERRSET_INVAL];\n\tcase ERRSET_NONAME:\n\t\treturn errset_text[ERRSET_NONAME];\n\tcase ERRSET_NODATA:\n\t\treturn errset_text[ERRSET_NODATA];\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getrrsetbyname",
          "args": [
            "hostname",
            "DNS_RDATACLASS_IN",
            "DNS_RDATATYPE_SSHFP",
            "0",
            "&fingerprints"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "getrrsetbyname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname-ldns.c",
          "lines": "62-249",
          "snippet": "int\ngetrrsetbyname(const char *hostname, unsigned int rdclass,\n\t       unsigned int rdtype, unsigned int flags,\n\t       struct rrsetinfo **res)\n{\n\tint result;\n\tunsigned int i, j, index_ans, index_sig;\n\tstruct rrsetinfo *rrset = NULL;\n\tstruct rdatainfo *rdata;\n\tsize_t len;\n\tldns_resolver *ldns_res = NULL;\n\tldns_rdf *domain = NULL;\n\tldns_pkt *pkt = NULL;\n\tldns_rr_list *rrsigs = NULL, *rrdata = NULL;\n\tldns_status err;\n\tldns_rr *rr;\n\n\t/* check for invalid class and type */\n\tif (rdclass > 0xffff || rdtype > 0xffff) {\n\t\tresult = ERRSET_INVAL;\n\t\tgoto fail;\n\t}\n\n\t/* don't allow queries of class or type ANY */\n\tif (rdclass == 0xff || rdtype == 0xff) {\n\t\tresult = ERRSET_INVAL;\n\t\tgoto fail;\n\t}\n\n\t/* don't allow flags yet, unimplemented */\n\tif (flags) {\n\t\tresult = ERRSET_INVAL;\n\t\tgoto fail;\n\t}\n\n\t/* Initialize resolver from resolv.conf */\n\tdomain = ldns_dname_new_frm_str(hostname);\n\tif ((err = ldns_resolver_new_frm_file(&ldns_res, NULL)) != \\\n\t    LDNS_STATUS_OK) {\n\t\tresult = ERRSET_FAIL;\n\t\tgoto fail;\n\t}\n\n#ifdef LDNS_DEBUG\n\tldns_resolver_set_debug(ldns_res, true);\n#endif /* LDNS_DEBUG */\n\n\tldns_resolver_set_dnssec(ldns_res, true); /* Use DNSSEC */\n\n\t/* make query */\n\tpkt = ldns_resolver_query(ldns_res, domain, rdtype, rdclass, LDNS_RD);\n\n\t/*** TODO: finer errcodes -- see original **/\n\tif (!pkt || ldns_pkt_ancount(pkt) < 1) {\n\t\tresult = ERRSET_FAIL;\n\t\tgoto fail;\n\t}\n\n\t/* initialize rrset */\n\trrset = calloc(1, sizeof(struct rrsetinfo));\n\tif (rrset == NULL) {\n\t\tresult = ERRSET_NOMEMORY;\n\t\tgoto fail;\n\t}\n\n\trrdata = ldns_pkt_rr_list_by_type(pkt, rdtype, LDNS_SECTION_ANSWER);\n\trrset->rri_nrdatas = ldns_rr_list_rr_count(rrdata);\n\tif (!rrset->rri_nrdatas) {\n\t\tresult = ERRSET_NODATA;\n\t\tgoto fail;\n\t}\n\n\t/* copy name from answer section */\n\tlen = ldns_rdf_size(ldns_rr_owner(ldns_rr_list_rr(rrdata, 0)));\n\tif ((rrset->rri_name = malloc(len)) == NULL) {\n\t\tresult = ERRSET_NOMEMORY;\n\t\tgoto fail;\n\t}\n\tmemcpy(rrset->rri_name,\n\t    ldns_rdf_data(ldns_rr_owner(ldns_rr_list_rr(rrdata, 0))), len);\n\n\trrset->rri_rdclass = ldns_rr_get_class(ldns_rr_list_rr(rrdata, 0));\n\trrset->rri_rdtype = ldns_rr_get_type(ldns_rr_list_rr(rrdata, 0));\n\trrset->rri_ttl = ldns_rr_ttl(ldns_rr_list_rr(rrdata, 0));\n\n\tdebug2(\"ldns: got %u answers from DNS\", rrset->rri_nrdatas);\n\n\t/* Check for authenticated data */\n\tif (ldns_pkt_ad(pkt)) {\n\t\trrset->rri_flags |= RRSET_VALIDATED;\n\t} else { /* AD is not set, try autonomous validation */\n\t\tldns_rr_list * trusted_keys = ldns_rr_list_new();\n\n\t\tdebug2(\"ldns: trying to validate RRset\");\n\t\t/* Get eventual sigs */\n\t\trrsigs = ldns_pkt_rr_list_by_type(pkt, LDNS_RR_TYPE_RRSIG,\n\t\t    LDNS_SECTION_ANSWER);\n\n\t\trrset->rri_nsigs = ldns_rr_list_rr_count(rrsigs);\n\t\tdebug2(\"ldns: got %u signature(s) (RRTYPE %u) from DNS\",\n\t\t       rrset->rri_nsigs, LDNS_RR_TYPE_RRSIG);\n\n\t\tif ((err = ldns_verify_trusted(ldns_res, rrdata, rrsigs,\n\t\t     trusted_keys)) == LDNS_STATUS_OK) {\n\t\t\trrset->rri_flags |= RRSET_VALIDATED;\n\t\t\tdebug2(\"ldns: RRset is signed with a valid key\");\n\t\t} else {\n\t\t\tdebug2(\"ldns: RRset validation failed: %s\",\n\t\t\t    ldns_get_errorstr_by_id(err));\n\t\t}\n\n\t\tldns_rr_list_deep_free(trusted_keys);\n\t}\n\n\t/* allocate memory for answers */\n\trrset->rri_rdatas = calloc(rrset->rri_nrdatas,\n\t   sizeof(struct rdatainfo));\n\n\tif (rrset->rri_rdatas == NULL) {\n\t\tresult = ERRSET_NOMEMORY;\n\t\tgoto fail;\n\t}\n\n\t/* allocate memory for signatures */\n\tif (rrset->rri_nsigs > 0) {\n\t\trrset->rri_sigs = calloc(rrset->rri_nsigs,\n\t\t    sizeof(struct rdatainfo));\n\n\t\tif (rrset->rri_sigs == NULL) {\n\t\t\tresult = ERRSET_NOMEMORY;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* copy answers & signatures */\n\tfor (i=0, index_ans=0, index_sig=0; i< pkt->_header->_ancount; i++) {\n\t\trdata = NULL;\n\t\trr = ldns_rr_list_rr(ldns_pkt_answer(pkt), i);\n\n\t\tif (ldns_rr_get_class(rr) == rrset->rri_rdclass &&\n\t\t    ldns_rr_get_type(rr) == rrset->rri_rdtype) {\n\t\t\trdata = &rrset->rri_rdatas[index_ans++];\n\t\t}\n\n\t\tif (rr->_rr_class == rrset->rri_rdclass &&\n\t\t    rr->_rr_type == LDNS_RR_TYPE_RRSIG &&\n\t\t    rrset->rri_sigs) {\n\t\t\trdata = &rrset->rri_sigs[index_sig++];\n\t\t}\n\n\t\tif (rdata) {\n\t\t\tsize_t rdata_offset = 0;\n\n\t\t\trdata->rdi_length = 0;\n\t\t\tfor (j=0; j< rr->_rd_count; j++) {\n\t\t\t\trdata->rdi_length +=\n\t\t\t\t    ldns_rdf_size(ldns_rr_rdf(rr, j));\n\t\t\t}\n\n\t\t\trdata->rdi_data = malloc(rdata->rdi_length);\n\t\t\tif (rdata->rdi_data == NULL) {\n\t\t\t\tresult = ERRSET_NOMEMORY;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\t/* Re-create the raw DNS RDATA */\n\t\t\tfor (j=0; j< rr->_rd_count; j++) {\n\t\t\t\tlen = ldns_rdf_size(ldns_rr_rdf(rr, j));\n\t\t\t\tmemcpy(rdata->rdi_data + rdata_offset,\n\t\t\t\t       ldns_rdf_data(ldns_rr_rdf(rr, j)), len);\n\t\t\t\trdata_offset += len;\n\t\t\t}\n\t\t}\n\t}\n\n\t*res = rrset;\n\tresult = ERRSET_SUCCESS;\n\nfail:\n\t/* freerrset(rrset); */\n\tldns_rdf_deep_free(domain);\n\tldns_pkt_free(pkt);\n\tldns_rr_list_deep_free(rrsigs);\n\tldns_rr_list_deep_free(rrdata);\n\tldns_resolver_deep_free(ldns_res);\n\n\treturn result;\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"log.h\"",
            "#include \"getrrsetbyname.h\"",
            "#include <ldns/ldns.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"log.h\"\n#include \"getrrsetbyname.h\"\n#include <ldns/ldns.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint\ngetrrsetbyname(const char *hostname, unsigned int rdclass,\n\t       unsigned int rdtype, unsigned int flags,\n\t       struct rrsetinfo **res)\n{\n\tint result;\n\tunsigned int i, j, index_ans, index_sig;\n\tstruct rrsetinfo *rrset = NULL;\n\tstruct rdatainfo *rdata;\n\tsize_t len;\n\tldns_resolver *ldns_res = NULL;\n\tldns_rdf *domain = NULL;\n\tldns_pkt *pkt = NULL;\n\tldns_rr_list *rrsigs = NULL, *rrdata = NULL;\n\tldns_status err;\n\tldns_rr *rr;\n\n\t/* check for invalid class and type */\n\tif (rdclass > 0xffff || rdtype > 0xffff) {\n\t\tresult = ERRSET_INVAL;\n\t\tgoto fail;\n\t}\n\n\t/* don't allow queries of class or type ANY */\n\tif (rdclass == 0xff || rdtype == 0xff) {\n\t\tresult = ERRSET_INVAL;\n\t\tgoto fail;\n\t}\n\n\t/* don't allow flags yet, unimplemented */\n\tif (flags) {\n\t\tresult = ERRSET_INVAL;\n\t\tgoto fail;\n\t}\n\n\t/* Initialize resolver from resolv.conf */\n\tdomain = ldns_dname_new_frm_str(hostname);\n\tif ((err = ldns_resolver_new_frm_file(&ldns_res, NULL)) != \\\n\t    LDNS_STATUS_OK) {\n\t\tresult = ERRSET_FAIL;\n\t\tgoto fail;\n\t}\n\n#ifdef LDNS_DEBUG\n\tldns_resolver_set_debug(ldns_res, true);\n#endif /* LDNS_DEBUG */\n\n\tldns_resolver_set_dnssec(ldns_res, true); /* Use DNSSEC */\n\n\t/* make query */\n\tpkt = ldns_resolver_query(ldns_res, domain, rdtype, rdclass, LDNS_RD);\n\n\t/*** TODO: finer errcodes -- see original **/\n\tif (!pkt || ldns_pkt_ancount(pkt) < 1) {\n\t\tresult = ERRSET_FAIL;\n\t\tgoto fail;\n\t}\n\n\t/* initialize rrset */\n\trrset = calloc(1, sizeof(struct rrsetinfo));\n\tif (rrset == NULL) {\n\t\tresult = ERRSET_NOMEMORY;\n\t\tgoto fail;\n\t}\n\n\trrdata = ldns_pkt_rr_list_by_type(pkt, rdtype, LDNS_SECTION_ANSWER);\n\trrset->rri_nrdatas = ldns_rr_list_rr_count(rrdata);\n\tif (!rrset->rri_nrdatas) {\n\t\tresult = ERRSET_NODATA;\n\t\tgoto fail;\n\t}\n\n\t/* copy name from answer section */\n\tlen = ldns_rdf_size(ldns_rr_owner(ldns_rr_list_rr(rrdata, 0)));\n\tif ((rrset->rri_name = malloc(len)) == NULL) {\n\t\tresult = ERRSET_NOMEMORY;\n\t\tgoto fail;\n\t}\n\tmemcpy(rrset->rri_name,\n\t    ldns_rdf_data(ldns_rr_owner(ldns_rr_list_rr(rrdata, 0))), len);\n\n\trrset->rri_rdclass = ldns_rr_get_class(ldns_rr_list_rr(rrdata, 0));\n\trrset->rri_rdtype = ldns_rr_get_type(ldns_rr_list_rr(rrdata, 0));\n\trrset->rri_ttl = ldns_rr_ttl(ldns_rr_list_rr(rrdata, 0));\n\n\tdebug2(\"ldns: got %u answers from DNS\", rrset->rri_nrdatas);\n\n\t/* Check for authenticated data */\n\tif (ldns_pkt_ad(pkt)) {\n\t\trrset->rri_flags |= RRSET_VALIDATED;\n\t} else { /* AD is not set, try autonomous validation */\n\t\tldns_rr_list * trusted_keys = ldns_rr_list_new();\n\n\t\tdebug2(\"ldns: trying to validate RRset\");\n\t\t/* Get eventual sigs */\n\t\trrsigs = ldns_pkt_rr_list_by_type(pkt, LDNS_RR_TYPE_RRSIG,\n\t\t    LDNS_SECTION_ANSWER);\n\n\t\trrset->rri_nsigs = ldns_rr_list_rr_count(rrsigs);\n\t\tdebug2(\"ldns: got %u signature(s) (RRTYPE %u) from DNS\",\n\t\t       rrset->rri_nsigs, LDNS_RR_TYPE_RRSIG);\n\n\t\tif ((err = ldns_verify_trusted(ldns_res, rrdata, rrsigs,\n\t\t     trusted_keys)) == LDNS_STATUS_OK) {\n\t\t\trrset->rri_flags |= RRSET_VALIDATED;\n\t\t\tdebug2(\"ldns: RRset is signed with a valid key\");\n\t\t} else {\n\t\t\tdebug2(\"ldns: RRset validation failed: %s\",\n\t\t\t    ldns_get_errorstr_by_id(err));\n\t\t}\n\n\t\tldns_rr_list_deep_free(trusted_keys);\n\t}\n\n\t/* allocate memory for answers */\n\trrset->rri_rdatas = calloc(rrset->rri_nrdatas,\n\t   sizeof(struct rdatainfo));\n\n\tif (rrset->rri_rdatas == NULL) {\n\t\tresult = ERRSET_NOMEMORY;\n\t\tgoto fail;\n\t}\n\n\t/* allocate memory for signatures */\n\tif (rrset->rri_nsigs > 0) {\n\t\trrset->rri_sigs = calloc(rrset->rri_nsigs,\n\t\t    sizeof(struct rdatainfo));\n\n\t\tif (rrset->rri_sigs == NULL) {\n\t\t\tresult = ERRSET_NOMEMORY;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* copy answers & signatures */\n\tfor (i=0, index_ans=0, index_sig=0; i< pkt->_header->_ancount; i++) {\n\t\trdata = NULL;\n\t\trr = ldns_rr_list_rr(ldns_pkt_answer(pkt), i);\n\n\t\tif (ldns_rr_get_class(rr) == rrset->rri_rdclass &&\n\t\t    ldns_rr_get_type(rr) == rrset->rri_rdtype) {\n\t\t\trdata = &rrset->rri_rdatas[index_ans++];\n\t\t}\n\n\t\tif (rr->_rr_class == rrset->rri_rdclass &&\n\t\t    rr->_rr_type == LDNS_RR_TYPE_RRSIG &&\n\t\t    rrset->rri_sigs) {\n\t\t\trdata = &rrset->rri_sigs[index_sig++];\n\t\t}\n\n\t\tif (rdata) {\n\t\t\tsize_t rdata_offset = 0;\n\n\t\t\trdata->rdi_length = 0;\n\t\t\tfor (j=0; j< rr->_rd_count; j++) {\n\t\t\t\trdata->rdi_length +=\n\t\t\t\t    ldns_rdf_size(ldns_rr_rdf(rr, j));\n\t\t\t}\n\n\t\t\trdata->rdi_data = malloc(rdata->rdi_length);\n\t\t\tif (rdata->rdi_data == NULL) {\n\t\t\t\tresult = ERRSET_NOMEMORY;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\t/* Re-create the raw DNS RDATA */\n\t\t\tfor (j=0; j< rr->_rd_count; j++) {\n\t\t\t\tlen = ldns_rdf_size(ldns_rr_rdf(rr, j));\n\t\t\t\tmemcpy(rdata->rdi_data + rdata_offset,\n\t\t\t\t       ldns_rdf_data(ldns_rr_rdf(rr, j)), len);\n\t\t\t\trdata_offset += len;\n\t\t\t}\n\t\t}\n\t}\n\n\t*res = rrset;\n\tresult = ERRSET_SUCCESS;\n\nfail:\n\t/* freerrset(rrset); */\n\tldns_rdf_deep_free(domain);\n\tldns_pkt_free(pkt);\n\tldns_rr_list_deep_free(rrsigs);\n\tldns_rr_list_deep_free(rrdata);\n\tldns_resolver_deep_free(ldns_res);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_numeric_hostname",
          "args": [
            "hostname"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "is_numeric_hostname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dns.c",
          "lines": "178-202",
          "snippet": "static int\nis_numeric_hostname(const char *hostname)\n{\n\tstruct addrinfo hints, *ai;\n\n\t/*\n\t * We shouldn't ever get a null host but if we do then log an error\n\t * and return -1 which stops DNS key fingerprint processing.\n\t */\n\tif (hostname == NULL) {\n\t\terror(\"is_numeric_hostname called with NULL hostname\");\n\t\treturn -1;\n\t}\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_socktype = SOCK_DGRAM;\n\thints.ai_flags = AI_NUMERICHOST;\n\n\tif (getaddrinfo(hostname, NULL, &hints, &ai) == 0) {\n\t\tfreeaddrinfo(ai);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"log.h\"",
            "#include \"dns.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"log.h\"\n#include \"dns.h\"\n#include \"ssherr.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nis_numeric_hostname(const char *hostname)\n{\n\tstruct addrinfo hints, *ai;\n\n\t/*\n\t * We shouldn't ever get a null host but if we do then log an error\n\t * and return -1 which stops DNS key fingerprint processing.\n\t */\n\tif (hostname == NULL) {\n\t\terror(\"is_numeric_hostname called with NULL hostname\");\n\t\treturn -1;\n\t}\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_socktype = SOCK_DGRAM;\n\thints.ai_flags = AI_NUMERICHOST;\n\n\tif (getaddrinfo(hostname, NULL, &hints, &ai) == 0) {\n\t\tfreeaddrinfo(ai);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"No key to look up!\""
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"log.h\"\n#include \"dns.h\"\n#include \"ssherr.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nverify_host_key_dns(const char *hostname, struct sockaddr *address,\n    struct sshkey *hostkey, int *flags)\n{\n\tu_int counter;\n\tint result;\n\tstruct rrsetinfo *fingerprints = NULL;\n\n\tu_int8_t hostkey_algorithm;\n\tu_int8_t hostkey_digest_type = SSHFP_HASH_RESERVED;\n\tu_char *hostkey_digest;\n\tsize_t hostkey_digest_len;\n\n\tu_int8_t dnskey_algorithm;\n\tu_int8_t dnskey_digest_type;\n\tu_char *dnskey_digest;\n\tsize_t dnskey_digest_len;\n\n\t*flags = 0;\n\n\tdebug3(\"verify_host_key_dns\");\n\tif (hostkey == NULL)\n\t\tfatal(\"No key to look up!\");\n\n\tif (is_numeric_hostname(hostname)) {\n\t\tdebug(\"skipped DNS lookup for numerical hostname\");\n\t\treturn -1;\n\t}\n\n\tresult = getrrsetbyname(hostname, DNS_RDATACLASS_IN,\n\t    DNS_RDATATYPE_SSHFP, 0, &fingerprints);\n\tif (result) {\n\t\tverbose(\"DNS lookup error: %s\", dns_result_totext(result));\n\t\treturn -1;\n\t}\n\n\tif (fingerprints->rri_flags & RRSET_VALIDATED) {\n\t\t*flags |= DNS_VERIFY_SECURE;\n\t\tdebug(\"found %d secure fingerprints in DNS\",\n\t\t    fingerprints->rri_nrdatas);\n\t} else {\n\t\tdebug(\"found %d insecure fingerprints in DNS\",\n\t\t    fingerprints->rri_nrdatas);\n\t}\n\n\t/* Initialize default host key parameters */\n\tif (!dns_read_key(&hostkey_algorithm, &hostkey_digest_type,\n\t    &hostkey_digest, &hostkey_digest_len, hostkey)) {\n\t\terror(\"Error calculating host key fingerprint.\");\n\t\tfreerrset(fingerprints);\n\t\treturn -1;\n\t}\n\n\tif (fingerprints->rri_nrdatas)\n\t\t*flags |= DNS_VERIFY_FOUND;\n\n\tfor (counter = 0; counter < fingerprints->rri_nrdatas; counter++) {\n\t\t/*\n\t\t * Extract the key from the answer. Ignore any badly\n\t\t * formatted fingerprints.\n\t\t */\n\t\tif (!dns_read_rdata(&dnskey_algorithm, &dnskey_digest_type,\n\t\t    &dnskey_digest, &dnskey_digest_len,\n\t\t    fingerprints->rri_rdatas[counter].rdi_data,\n\t\t    fingerprints->rri_rdatas[counter].rdi_length)) {\n\t\t\tverbose(\"Error parsing fingerprint from DNS.\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (hostkey_digest_type != dnskey_digest_type) {\n\t\t\thostkey_digest_type = dnskey_digest_type;\n\t\t\tfree(hostkey_digest);\n\n\t\t\t/* Initialize host key parameters */\n\t\t\tif (!dns_read_key(&hostkey_algorithm,\n\t\t\t    &hostkey_digest_type, &hostkey_digest,\n\t\t\t    &hostkey_digest_len, hostkey)) {\n\t\t\t\terror(\"Error calculating key fingerprint.\");\n\t\t\t\tfreerrset(fingerprints);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\t/* Check if the current key is the same as the given key */\n\t\tif (hostkey_algorithm == dnskey_algorithm &&\n\t\t    hostkey_digest_type == dnskey_digest_type) {\n\t\t\tif (hostkey_digest_len == dnskey_digest_len &&\n\t\t\t    timingsafe_bcmp(hostkey_digest, dnskey_digest,\n\t\t\t    hostkey_digest_len) == 0)\n\t\t\t\t*flags |= DNS_VERIFY_MATCH;\n\t\t}\n\t\tfree(dnskey_digest);\n\t}\n\n\tfree(hostkey_digest); /* from sshkey_fingerprint_raw() */\n\tfreerrset(fingerprints);\n\n\tif (*flags & DNS_VERIFY_FOUND)\n\t\tif (*flags & DNS_VERIFY_MATCH)\n\t\t\tdebug(\"matching host key fingerprint found in DNS\");\n\t\telse\n\t\t\tdebug(\"mismatching host key fingerprint found in DNS\");\n\telse\n\t\tdebug(\"no host key fingerprint found in DNS\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "is_numeric_hostname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dns.c",
    "lines": "178-202",
    "snippet": "static int\nis_numeric_hostname(const char *hostname)\n{\n\tstruct addrinfo hints, *ai;\n\n\t/*\n\t * We shouldn't ever get a null host but if we do then log an error\n\t * and return -1 which stops DNS key fingerprint processing.\n\t */\n\tif (hostname == NULL) {\n\t\terror(\"is_numeric_hostname called with NULL hostname\");\n\t\treturn -1;\n\t}\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_socktype = SOCK_DGRAM;\n\thints.ai_flags = AI_NUMERICHOST;\n\n\tif (getaddrinfo(hostname, NULL, &hints, &ai) == 0) {\n\t\tfreeaddrinfo(ai);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"dns.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "ai"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "hostname",
            "NULL",
            "&hints",
            "&ai"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "getaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "154-234",
          "snippet": "int\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hints",
            "0",
            "sizeof(hints)"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"is_numeric_hostname called with NULL hostname\""
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"log.h\"\n#include \"dns.h\"\n#include \"ssherr.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nis_numeric_hostname(const char *hostname)\n{\n\tstruct addrinfo hints, *ai;\n\n\t/*\n\t * We shouldn't ever get a null host but if we do then log an error\n\t * and return -1 which stops DNS key fingerprint processing.\n\t */\n\tif (hostname == NULL) {\n\t\terror(\"is_numeric_hostname called with NULL hostname\");\n\t\treturn -1;\n\t}\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_socktype = SOCK_DGRAM;\n\thints.ai_flags = AI_NUMERICHOST;\n\n\tif (getaddrinfo(hostname, NULL, &hints, &ai) == 0) {\n\t\tfreeaddrinfo(ai);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dns_read_rdata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dns.c",
    "lines": "147-172",
    "snippet": "static int\ndns_read_rdata(u_int8_t *algorithm, u_int8_t *digest_type,\n    u_char **digest, size_t *digest_len, u_char *rdata, int rdata_len)\n{\n\tint success = 0;\n\n\t*algorithm = SSHFP_KEY_RESERVED;\n\t*digest_type = SSHFP_HASH_RESERVED;\n\n\tif (rdata_len >= 2) {\n\t\t*algorithm = rdata[0];\n\t\t*digest_type = rdata[1];\n\t\t*digest_len = rdata_len - 2;\n\n\t\tif (*digest_len > 0) {\n\t\t\t*digest = xmalloc(*digest_len);\n\t\t\tmemcpy(*digest, rdata + 2, *digest_len);\n\t\t} else {\n\t\t\t*digest = (u_char *)xstrdup(\"\");\n\t\t}\n\n\t\tsuccess = 1;\n\t}\n\n\treturn success;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"dns.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "\"\""
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*digest",
            "rdata + 2",
            "*digest_len"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "*digest_len"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"log.h\"\n#include \"dns.h\"\n#include \"ssherr.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndns_read_rdata(u_int8_t *algorithm, u_int8_t *digest_type,\n    u_char **digest, size_t *digest_len, u_char *rdata, int rdata_len)\n{\n\tint success = 0;\n\n\t*algorithm = SSHFP_KEY_RESERVED;\n\t*digest_type = SSHFP_HASH_RESERVED;\n\n\tif (rdata_len >= 2) {\n\t\t*algorithm = rdata[0];\n\t\t*digest_type = rdata[1];\n\t\t*digest_len = rdata_len - 2;\n\n\t\tif (*digest_len > 0) {\n\t\t\t*digest = xmalloc(*digest_len);\n\t\t\tmemcpy(*digest, rdata + 2, *digest_len);\n\t\t} else {\n\t\t\t*digest = (u_char *)xstrdup(\"\");\n\t\t}\n\n\t\tsuccess = 1;\n\t}\n\n\treturn success;\n}"
  },
  {
    "function_name": "dns_read_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dns.c",
    "lines": "80-142",
    "snippet": "static int\ndns_read_key(u_int8_t *algorithm, u_int8_t *digest_type,\n    u_char **digest, size_t *digest_len, struct sshkey *key)\n{\n\tint r, success = 0;\n\tint fp_alg = -1;\n\n\tswitch (key->type) {\n\tcase KEY_RSA:\n\t\t*algorithm = SSHFP_KEY_RSA;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA1;\n\t\tbreak;\n\tcase KEY_DSA:\n\t\t*algorithm = SSHFP_KEY_DSA;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA1;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\t\t*algorithm = SSHFP_KEY_ECDSA;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA256;\n\t\tbreak;\n\tcase KEY_ED25519:\n\t\t*algorithm = SSHFP_KEY_ED25519;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA256;\n\t\tbreak;\n\tcase KEY_XMSS:\n\t\t*algorithm = SSHFP_KEY_XMSS;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA256;\n\t\tbreak;\n\tdefault:\n\t\t*algorithm = SSHFP_KEY_RESERVED; /* 0 */\n\t\t*digest_type = SSHFP_HASH_RESERVED; /* 0 */\n\t}\n\n\tswitch (*digest_type) {\n\tcase SSHFP_HASH_SHA1:\n\t\tfp_alg = SSH_DIGEST_SHA1;\n\t\tbreak;\n\tcase SSHFP_HASH_SHA256:\n\t\tfp_alg = SSH_DIGEST_SHA256;\n\t\tbreak;\n\tdefault:\n\t\t*digest_type = SSHFP_HASH_RESERVED; /* 0 */\n\t}\n\n\tif (*algorithm && *digest_type) {\n\t\tif ((r = sshkey_fingerprint_raw(key, fp_alg, digest,\n\t\t    digest_len)) != 0)\n\t\t\tfatal(\"%s: sshkey_fingerprint_raw: %s\", __func__,\n\t\t\t   ssh_err(r));\n\t\tsuccess = 1;\n\t} else {\n\t\t*digest = NULL;\n\t\t*digest_len = 0;\n\t\tsuccess = 0;\n\t}\n\n\treturn success;\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"dns.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshkey_fingerprint_raw: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint_raw",
          "args": [
            "key",
            "fp_alg",
            "digest",
            "digest_len"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "892-933",
          "snippet": "int\nsshkey_fingerprint_raw(const struct sshkey *k, int dgst_alg,\n    u_char **retp, size_t *lenp)\n{\n\tu_char *blob = NULL, *ret = NULL;\n\tsize_t blob_len = 0;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (retp != NULL)\n\t\t*retp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (ssh_digest_bytes(dgst_alg) == 0) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif ((r = to_blob(k, &blob, &blob_len, 1, SSHKEY_SERIALIZE_DEFAULT))\n\t    != 0)\n\t\tgoto out;\n\tif ((ret = calloc(1, SSH_DIGEST_MAX_LENGTH)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = ssh_digest_memory(dgst_alg, blob, blob_len,\n\t    ret, SSH_DIGEST_MAX_LENGTH)) != 0)\n\t\tgoto out;\n\t/* success */\n\tif (retp != NULL) {\n\t\t*retp = ret;\n\t\tret = NULL;\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = ssh_digest_bytes(dgst_alg);\n\tr = 0;\n out:\n\tfree(ret);\n\tif (blob != NULL) {\n\t\texplicit_bzero(blob, blob_len);\n\t\tfree(blob);\n\t}\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_fingerprint_raw(const struct sshkey *k, int dgst_alg,\n    u_char **retp, size_t *lenp)\n{\n\tu_char *blob = NULL, *ret = NULL;\n\tsize_t blob_len = 0;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (retp != NULL)\n\t\t*retp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (ssh_digest_bytes(dgst_alg) == 0) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif ((r = to_blob(k, &blob, &blob_len, 1, SSHKEY_SERIALIZE_DEFAULT))\n\t    != 0)\n\t\tgoto out;\n\tif ((ret = calloc(1, SSH_DIGEST_MAX_LENGTH)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = ssh_digest_memory(dgst_alg, blob, blob_len,\n\t    ret, SSH_DIGEST_MAX_LENGTH)) != 0)\n\t\tgoto out;\n\t/* success */\n\tif (retp != NULL) {\n\t\t*retp = ret;\n\t\tret = NULL;\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = ssh_digest_bytes(dgst_alg);\n\tr = 0;\n out:\n\tfree(ret);\n\tif (blob != NULL) {\n\t\texplicit_bzero(blob, blob_len);\n\t\tfree(blob);\n\t}\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"digest.h\"\n#include \"log.h\"\n#include \"dns.h\"\n#include \"ssherr.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndns_read_key(u_int8_t *algorithm, u_int8_t *digest_type,\n    u_char **digest, size_t *digest_len, struct sshkey *key)\n{\n\tint r, success = 0;\n\tint fp_alg = -1;\n\n\tswitch (key->type) {\n\tcase KEY_RSA:\n\t\t*algorithm = SSHFP_KEY_RSA;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA1;\n\t\tbreak;\n\tcase KEY_DSA:\n\t\t*algorithm = SSHFP_KEY_DSA;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA1;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\t\t*algorithm = SSHFP_KEY_ECDSA;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA256;\n\t\tbreak;\n\tcase KEY_ED25519:\n\t\t*algorithm = SSHFP_KEY_ED25519;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA256;\n\t\tbreak;\n\tcase KEY_XMSS:\n\t\t*algorithm = SSHFP_KEY_XMSS;\n\t\tif (!*digest_type)\n\t\t\t*digest_type = SSHFP_HASH_SHA256;\n\t\tbreak;\n\tdefault:\n\t\t*algorithm = SSHFP_KEY_RESERVED; /* 0 */\n\t\t*digest_type = SSHFP_HASH_RESERVED; /* 0 */\n\t}\n\n\tswitch (*digest_type) {\n\tcase SSHFP_HASH_SHA1:\n\t\tfp_alg = SSH_DIGEST_SHA1;\n\t\tbreak;\n\tcase SSHFP_HASH_SHA256:\n\t\tfp_alg = SSH_DIGEST_SHA256;\n\t\tbreak;\n\tdefault:\n\t\t*digest_type = SSHFP_HASH_RESERVED; /* 0 */\n\t}\n\n\tif (*algorithm && *digest_type) {\n\t\tif ((r = sshkey_fingerprint_raw(key, fp_alg, digest,\n\t\t    digest_len)) != 0)\n\t\t\tfatal(\"%s: sshkey_fingerprint_raw: %s\", __func__,\n\t\t\t   ssh_err(r));\n\t\tsuccess = 1;\n\t} else {\n\t\t*digest = NULL;\n\t\t*digest_len = 0;\n\t\tsuccess = 0;\n\t}\n\n\treturn success;\n}"
  },
  {
    "function_name": "dns_result_totext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dns.c",
    "lines": "56-75",
    "snippet": "static const char *\ndns_result_totext(unsigned int res)\n{\n\tswitch (res) {\n\tcase ERRSET_SUCCESS:\n\t\treturn errset_text[ERRSET_SUCCESS];\n\tcase ERRSET_NOMEMORY:\n\t\treturn errset_text[ERRSET_NOMEMORY];\n\tcase ERRSET_FAIL:\n\t\treturn errset_text[ERRSET_FAIL];\n\tcase ERRSET_INVAL:\n\t\treturn errset_text[ERRSET_INVAL];\n\tcase ERRSET_NONAME:\n\t\treturn errset_text[ERRSET_NONAME];\n\tcase ERRSET_NODATA:\n\t\treturn errset_text[ERRSET_NODATA];\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
    "includes": [
      "#include \"digest.h\"",
      "#include \"log.h\"",
      "#include \"dns.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshkey.h\"",
      "#include \"xmalloc.h\"",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *errset_text[] = {\n\t\"success\",\t\t/* 0 ERRSET_SUCCESS */\n\t\"out of memory\",\t/* 1 ERRSET_NOMEMORY */\n\t\"general failure\",\t/* 2 ERRSET_FAIL */\n\t\"invalid parameter\",\t/* 3 ERRSET_INVAL */\n\t\"name does not exist\",\t/* 4 ERRSET_NONAME */\n\t\"data does not exist\",\t/* 5 ERRSET_NODATA */\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"digest.h\"\n#include \"log.h\"\n#include \"dns.h\"\n#include \"ssherr.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *errset_text[] = {\n\t\"success\",\t\t/* 0 ERRSET_SUCCESS */\n\t\"out of memory\",\t/* 1 ERRSET_NOMEMORY */\n\t\"general failure\",\t/* 2 ERRSET_FAIL */\n\t\"invalid parameter\",\t/* 3 ERRSET_INVAL */\n\t\"name does not exist\",\t/* 4 ERRSET_NONAME */\n\t\"data does not exist\",\t/* 5 ERRSET_NODATA */\n};\n\nstatic const char *\ndns_result_totext(unsigned int res)\n{\n\tswitch (res) {\n\tcase ERRSET_SUCCESS:\n\t\treturn errset_text[ERRSET_SUCCESS];\n\tcase ERRSET_NOMEMORY:\n\t\treturn errset_text[ERRSET_NOMEMORY];\n\tcase ERRSET_FAIL:\n\t\treturn errset_text[ERRSET_FAIL];\n\tcase ERRSET_INVAL:\n\t\treturn errset_text[ERRSET_INVAL];\n\tcase ERRSET_NONAME:\n\t\treturn errset_text[ERRSET_NONAME];\n\tcase ERRSET_NODATA:\n\t\treturn errset_text[ERRSET_NODATA];\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
  }
]