[
  {
    "function_name": "auth_authorise_keyopts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
    "lines": "1109-1202",
    "snippet": "int\nauth_authorise_keyopts(struct ssh *ssh, struct passwd *pw,\n    struct sshauthopt *opts, int allow_cert_authority, const char *loc)\n{\n\tconst char *remote_ip = ssh_remote_ipaddr(ssh);\n\tconst char *remote_host = auth_get_canonical_hostname(ssh,\n\t    options.use_dns);\n\ttime_t now = time(NULL);\n\tchar buf[64];\n\n\t/*\n\t * Check keys/principals file expiry time.\n\t * NB. validity interval in certificate is handled elsewhere.\n\t */\n\tif (opts->valid_before && now > 0 &&\n\t    opts->valid_before < (uint64_t)now) {\n\t\tformat_absolute_time(opts->valid_before, buf, sizeof(buf));\n\t\tdebug(\"%s: entry expired at %s\", loc, buf);\n\t\tauth_debug_add(\"%s: entry expired at %s\", loc, buf);\n\t\treturn -1;\n\t}\n\t/* Consistency checks */\n\tif (opts->cert_principals != NULL && !opts->cert_authority) {\n\t\tdebug(\"%s: principals on non-CA key\", loc);\n\t\tauth_debug_add(\"%s: principals on non-CA key\", loc);\n\t\t/* deny access */\n\t\treturn -1;\n\t}\n\t/* cert-authority flag isn't valid in authorized_principals files */\n\tif (!allow_cert_authority && opts->cert_authority) {\n\t\tdebug(\"%s: cert-authority flag invalid here\", loc);\n\t\tauth_debug_add(\"%s: cert-authority flag invalid here\", loc);\n\t\t/* deny access */\n\t\treturn -1;\n\t}\n\n\t/* Perform from= checks */\n\tif (opts->required_from_host_keys != NULL) {\n\t\tswitch (match_host_and_ip(remote_host, remote_ip,\n\t\t    opts->required_from_host_keys )) {\n\t\tcase 1:\n\t\t\t/* Host name matches. */\n\t\t\tbreak;\n\t\tcase -1:\n\t\tdefault:\n\t\t\tdebug(\"%s: invalid from criteria\", loc);\n\t\t\tauth_debug_add(\"%s: invalid from criteria\", loc);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 0:\n\t\t\tlogit(\"%s: Authentication tried for %.100s with \"\n\t\t\t    \"correct key but not from a permitted \"\n\t\t\t    \"host (host=%.200s, ip=%.200s, required=%.200s).\",\n\t\t\t    loc, pw->pw_name, remote_host, remote_ip,\n\t\t\t    opts->required_from_host_keys);\n\t\t\tauth_debug_add(\"%s: Your host '%.200s' is not \"\n\t\t\t    \"permitted to use this key for login.\",\n\t\t\t    loc, remote_host);\n\t\t\t/* deny access */\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* Check source-address restriction from certificate */\n\tif (opts->required_from_host_cert != NULL) {\n\t\tswitch (addr_match_cidr_list(remote_ip,\n\t\t    opts->required_from_host_cert)) {\n\t\tcase 1:\n\t\t\t/* accepted */\n\t\t\tbreak;\n\t\tcase -1:\n\t\tdefault:\n\t\t\t/* invalid */\n\t\t\terror(\"%s: Certificate source-address invalid\",\n\t\t\t    loc);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 0:\n\t\t\tlogit(\"%s: Authentication tried for %.100s with valid \"\n\t\t\t    \"certificate but not from a permitted source \"\n\t\t\t    \"address (%.200s).\", loc, pw->pw_name, remote_ip);\n\t\t\tauth_debug_add(\"%s: Your address '%.200s' is not \"\n\t\t\t    \"permitted to use this certificate for login.\",\n\t\t\t    loc, remote_ip);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/*\n\t *\n\t * XXX this is spammy. We should report remotely only for keys\n\t *     that are successful in actual auth attempts, and not PK_OK\n\t *     tests.\n\t */\n\tauth_log_authopts(loc, opts, 1);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"authfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"loginrec.h\"",
      "#include \"packet.h\"",
      "#include \"uidswap.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"groupaccess.h\"",
      "#include \"match.h\"",
      "#include \"xmalloc.h\"",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <shadow.h>",
      "#include <login.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "auth_log_authopts",
          "args": [
            "loc",
            "opts",
            "1"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "auth_log_authopts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "1009-1074",
          "snippet": "void\nauth_log_authopts(const char *loc, const struct sshauthopt *opts, int do_remote)\n{\n\tint do_env = options.permit_user_env && opts->nenv > 0;\n\tint do_permitopen = opts->npermitopen > 0 &&\n\t    (options.allow_tcp_forwarding & FORWARD_LOCAL) != 0;\n\tint do_permitlisten = opts->npermitlisten > 0 &&\n\t    (options.allow_tcp_forwarding & FORWARD_REMOTE) != 0;\n\tsize_t i;\n\tchar msg[1024], buf[64];\n\n\tsnprintf(buf, sizeof(buf), \"%d\", opts->force_tun_device);\n\t/* Try to keep this alphabetically sorted */\n\tsnprintf(msg, sizeof(msg), \"key options:%s%s%s%s%s%s%s%s%s%s%s%s%s\",\n\t    opts->permit_agent_forwarding_flag ? \" agent-forwarding\" : \"\",\n\t    opts->force_command == NULL ? \"\" : \" command\",\n\t    do_env ?  \" environment\" : \"\",\n\t    opts->valid_before == 0 ? \"\" : \"expires\",\n\t    do_permitopen ?  \" permitopen\" : \"\",\n\t    do_permitlisten ?  \" permitlisten\" : \"\",\n\t    opts->permit_port_forwarding_flag ? \" port-forwarding\" : \"\",\n\t    opts->cert_principals == NULL ? \"\" : \" principals\",\n\t    opts->permit_pty_flag ? \" pty\" : \"\",\n\t    opts->force_tun_device == -1 ? \"\" : \" tun=\",\n\t    opts->force_tun_device == -1 ? \"\" : buf,\n\t    opts->permit_user_rc ? \" user-rc\" : \"\",\n\t    opts->permit_x11_forwarding_flag ? \" x11-forwarding\" : \"\");\n\n\tdebug(\"%s: %s\", loc, msg);\n\tif (do_remote)\n\t\tauth_debug_add(\"%s: %s\", loc, msg);\n\n\tif (options.permit_user_env) {\n\t\tfor (i = 0; i < opts->nenv; i++) {\n\t\t\tdebug(\"%s: environment: %s\", loc, opts->env[i]);\n\t\t\tif (do_remote) {\n\t\t\t\tauth_debug_add(\"%s: environment: %s\",\n\t\t\t\t    loc, opts->env[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Go into a little more details for the local logs. */\n\tif (opts->valid_before != 0) {\n\t\tformat_absolute_time(opts->valid_before, buf, sizeof(buf));\n\t\tdebug(\"%s: expires at %s\", loc, buf);\n\t}\n\tif (opts->cert_principals != NULL) {\n\t\tdebug(\"%s: authorized principals: \\\"%s\\\"\",\n\t\t    loc, opts->cert_principals);\n\t}\n\tif (opts->force_command != NULL)\n\t\tdebug(\"%s: forced command: \\\"%s\\\"\", loc, opts->force_command);\n\tif (do_permitopen) {\n\t\tfor (i = 0; i < opts->npermitopen; i++) {\n\t\t\tdebug(\"%s: permitted open: %s\",\n\t\t\t    loc, opts->permitopen[i]);\n\t\t}\n\t}\n\tif (do_permitlisten) {\n\t\tfor (i = 0; i < opts->npermitlisten; i++) {\n\t\t\tdebug(\"%s: permitted listen: %s\",\n\t\t\t    loc, opts->permitlisten[i]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nvoid\nauth_log_authopts(const char *loc, const struct sshauthopt *opts, int do_remote)\n{\n\tint do_env = options.permit_user_env && opts->nenv > 0;\n\tint do_permitopen = opts->npermitopen > 0 &&\n\t    (options.allow_tcp_forwarding & FORWARD_LOCAL) != 0;\n\tint do_permitlisten = opts->npermitlisten > 0 &&\n\t    (options.allow_tcp_forwarding & FORWARD_REMOTE) != 0;\n\tsize_t i;\n\tchar msg[1024], buf[64];\n\n\tsnprintf(buf, sizeof(buf), \"%d\", opts->force_tun_device);\n\t/* Try to keep this alphabetically sorted */\n\tsnprintf(msg, sizeof(msg), \"key options:%s%s%s%s%s%s%s%s%s%s%s%s%s\",\n\t    opts->permit_agent_forwarding_flag ? \" agent-forwarding\" : \"\",\n\t    opts->force_command == NULL ? \"\" : \" command\",\n\t    do_env ?  \" environment\" : \"\",\n\t    opts->valid_before == 0 ? \"\" : \"expires\",\n\t    do_permitopen ?  \" permitopen\" : \"\",\n\t    do_permitlisten ?  \" permitlisten\" : \"\",\n\t    opts->permit_port_forwarding_flag ? \" port-forwarding\" : \"\",\n\t    opts->cert_principals == NULL ? \"\" : \" principals\",\n\t    opts->permit_pty_flag ? \" pty\" : \"\",\n\t    opts->force_tun_device == -1 ? \"\" : \" tun=\",\n\t    opts->force_tun_device == -1 ? \"\" : buf,\n\t    opts->permit_user_rc ? \" user-rc\" : \"\",\n\t    opts->permit_x11_forwarding_flag ? \" x11-forwarding\" : \"\");\n\n\tdebug(\"%s: %s\", loc, msg);\n\tif (do_remote)\n\t\tauth_debug_add(\"%s: %s\", loc, msg);\n\n\tif (options.permit_user_env) {\n\t\tfor (i = 0; i < opts->nenv; i++) {\n\t\t\tdebug(\"%s: environment: %s\", loc, opts->env[i]);\n\t\t\tif (do_remote) {\n\t\t\t\tauth_debug_add(\"%s: environment: %s\",\n\t\t\t\t    loc, opts->env[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Go into a little more details for the local logs. */\n\tif (opts->valid_before != 0) {\n\t\tformat_absolute_time(opts->valid_before, buf, sizeof(buf));\n\t\tdebug(\"%s: expires at %s\", loc, buf);\n\t}\n\tif (opts->cert_principals != NULL) {\n\t\tdebug(\"%s: authorized principals: \\\"%s\\\"\",\n\t\t    loc, opts->cert_principals);\n\t}\n\tif (opts->force_command != NULL)\n\t\tdebug(\"%s: forced command: \\\"%s\\\"\", loc, opts->force_command);\n\tif (do_permitopen) {\n\t\tfor (i = 0; i < opts->npermitopen; i++) {\n\t\t\tdebug(\"%s: permitted open: %s\",\n\t\t\t    loc, opts->permitopen[i]);\n\t\t}\n\t}\n\tif (do_permitlisten) {\n\t\tfor (i = 0; i < opts->npermitlisten; i++) {\n\t\t\tdebug(\"%s: permitted listen: %s\",\n\t\t\t    loc, opts->permitlisten[i]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_debug_add",
          "args": [
            "\"%s: Your address '%.200s' is not \"\n\t\t\t    \"permitted to use this certificate for login.\"",
            "loc",
            "remote_ip"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "auth_debug_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "673-688",
          "snippet": "void\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sshbuf *auth_debug;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshbuf *auth_debug;\n\nvoid\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"%s: Authentication tried for %.100s with valid \"\n\t\t\t    \"certificate but not from a permitted source \"\n\t\t\t    \"address (%.200s).\"",
            "loc",
            "pw->pw_name",
            "remote_ip"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: Certificate source-address invalid\"",
            "loc"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr_match_cidr_list",
          "args": [
            "remote_ip",
            "opts->required_from_host_cert"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "addr_match_cidr_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
          "lines": "435-498",
          "snippet": "int\naddr_match_cidr_list(const char *addr, const char *_list)\n{\n\tchar *list, *cp, *o;\n\tstruct xaddr try_addr, match_addr;\n\tu_int masklen;\n\tint ret = 0, r;\n\n\tif (addr != NULL && addr_pton(addr, &try_addr) != 0) {\n\t\tdebug2(\"%s: couldn't parse address %.100s\", __func__, addr);\n\t\treturn 0;\n\t}\n\tif ((o = list = strdup(_list)) == NULL)\n\t\treturn -1;\n\twhile ((cp = strsep(&list, \",\")) != NULL) {\n\t\tif (*cp == '\\0') {\n\t\t\terror(\"%s: empty entry in list \\\"%.100s\\\"\",\n\t\t\t    __func__, o);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * NB. This function is called in pre-auth with untrusted data,\n\t\t * so be extra paranoid about junk reaching getaddrino (via\n\t\t * addr_pton_cidr).\n\t\t */\n\n\t\t/* Stop junk from reaching getaddrinfo. +3 is for masklen */\n\t\tif (strlen(cp) > INET6_ADDRSTRLEN + 3) {\n\t\t\terror(\"%s: list entry \\\"%.100s\\\" too long\",\n\t\t\t    __func__, cp);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n#define VALID_CIDR_CHARS \"0123456789abcdefABCDEF.:/\"\n\t\tif (strspn(cp, VALID_CIDR_CHARS) != strlen(cp)) {\n\t\t\terror(\"%s: list entry \\\"%.100s\\\" contains invalid \"\n\t\t\t    \"characters\", __func__, cp);\n\t\t\tret = -1;\n\t\t}\n\n\t\t/* Prefer CIDR address matching */\n\t\tr = addr_pton_cidr(cp, &match_addr, &masklen);\n\t\tif (r == -1) {\n\t\t\terror(\"Invalid network entry \\\"%.100s\\\"\", cp);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t} else if (r == -2) {\n\t\t\terror(\"Inconsistent mask length for \"\n\t\t\t    \"network \\\"%.100s\\\"\", cp);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t} else if (r == 0 && addr != NULL) {\n\t\t\tif (addr_netmatch(&try_addr, &match_addr,\n\t\t\t    masklen) == 0)\n\t\t\t\tret = 1;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tfree(o);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define VALID_CIDR_CHARS \"0123456789abcdefABCDEF.:/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define VALID_CIDR_CHARS \"0123456789abcdefABCDEF.:/\"\n\nint\naddr_match_cidr_list(const char *addr, const char *_list)\n{\n\tchar *list, *cp, *o;\n\tstruct xaddr try_addr, match_addr;\n\tu_int masklen;\n\tint ret = 0, r;\n\n\tif (addr != NULL && addr_pton(addr, &try_addr) != 0) {\n\t\tdebug2(\"%s: couldn't parse address %.100s\", __func__, addr);\n\t\treturn 0;\n\t}\n\tif ((o = list = strdup(_list)) == NULL)\n\t\treturn -1;\n\twhile ((cp = strsep(&list, \",\")) != NULL) {\n\t\tif (*cp == '\\0') {\n\t\t\terror(\"%s: empty entry in list \\\"%.100s\\\"\",\n\t\t\t    __func__, o);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * NB. This function is called in pre-auth with untrusted data,\n\t\t * so be extra paranoid about junk reaching getaddrino (via\n\t\t * addr_pton_cidr).\n\t\t */\n\n\t\t/* Stop junk from reaching getaddrinfo. +3 is for masklen */\n\t\tif (strlen(cp) > INET6_ADDRSTRLEN + 3) {\n\t\t\terror(\"%s: list entry \\\"%.100s\\\" too long\",\n\t\t\t    __func__, cp);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n#define VALID_CIDR_CHARS \"0123456789abcdefABCDEF.:/\"\n\t\tif (strspn(cp, VALID_CIDR_CHARS) != strlen(cp)) {\n\t\t\terror(\"%s: list entry \\\"%.100s\\\" contains invalid \"\n\t\t\t    \"characters\", __func__, cp);\n\t\t\tret = -1;\n\t\t}\n\n\t\t/* Prefer CIDR address matching */\n\t\tr = addr_pton_cidr(cp, &match_addr, &masklen);\n\t\tif (r == -1) {\n\t\t\terror(\"Invalid network entry \\\"%.100s\\\"\", cp);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t} else if (r == -2) {\n\t\t\terror(\"Inconsistent mask length for \"\n\t\t\t    \"network \\\"%.100s\\\"\", cp);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t} else if (r == 0 && addr != NULL) {\n\t\t\tif (addr_netmatch(&try_addr, &match_addr,\n\t\t\t    masklen) == 0)\n\t\t\t\tret = 1;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tfree(o);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_host_and_ip",
          "args": [
            "remote_host",
            "remote_ip",
            "opts->required_from_host_keys"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "match_host_and_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "196-214",
          "snippet": "int\nmatch_host_and_ip(const char *host, const char *ipaddr,\n    const char *patterns)\n{\n\tint mhost, mip;\n\n\tif ((mip = addr_match_list(ipaddr, patterns)) == -2)\n\t\treturn -1; /* error in ipaddr match */\n\telse if (host == NULL || ipaddr == NULL || mip == -1)\n\t\treturn 0; /* negative ip address match, or testing pattern */\n\n\t/* negative hostname match */\n\tif ((mhost = match_hostname(host, patterns)) == -1)\n\t\treturn 0;\n\t/* no match at all */\n\tif (mhost == 0 && mip == 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_host_and_ip(const char *host, const char *ipaddr,\n    const char *patterns)\n{\n\tint mhost, mip;\n\n\tif ((mip = addr_match_list(ipaddr, patterns)) == -2)\n\t\treturn -1; /* error in ipaddr match */\n\telse if (host == NULL || ipaddr == NULL || mip == -1)\n\t\treturn 0; /* negative ip address match, or testing pattern */\n\n\t/* negative hostname match */\n\tif ((mhost = match_hostname(host, patterns)) == -1)\n\t\treturn 0;\n\t/* no match at all */\n\tif (mhost == 0 && mip == 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_absolute_time",
          "args": [
            "opts->valid_before",
            "buf",
            "sizeof(buf)"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "format_absolute_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "2031-2039",
          "snippet": "void\nformat_absolute_time(uint64_t t, char *buf, size_t len)\n{\n\ttime_t tt = t > INT_MAX ? INT_MAX : t; /* XXX revisit in 2038 :P */\n\tstruct tm tm;\n\n\tlocaltime_r(&tt, &tm);\n\tstrftime(buf, len, \"%Y-%m-%dT%H:%M:%S\", &tm);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nformat_absolute_time(uint64_t t, char *buf, size_t len)\n{\n\ttime_t tt = t > INT_MAX ? INT_MAX : t; /* XXX revisit in 2038 :P */\n\tstruct tm tm;\n\n\tlocaltime_r(&tt, &tm);\n\tstrftime(buf, len, \"%Y-%m-%dT%H:%M:%S\", &tm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "parse_cert_times",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keygen.c",
          "lines": "1840-1888",
          "snippet": "static void\nparse_cert_times(char *timespec)\n{\n\tchar *from, *to;\n\ttime_t now = time(NULL);\n\tint64_t secs;\n\n\t/* +timespec relative to now */\n\tif (*timespec == '+' && strchr(timespec, ':') == NULL) {\n\t\tif ((secs = convtime(timespec + 1)) == -1)\n\t\t\tfatal(\"Invalid relative certificate life %s\", timespec);\n\t\tcert_valid_to = now + secs;\n\t\t/*\n\t\t * Backdate certificate one minute to avoid problems on hosts\n\t\t * with poorly-synchronised clocks.\n\t\t */\n\t\tcert_valid_from = ((now - 59)/ 60) * 60;\n\t\treturn;\n\t}\n\n\t/*\n\t * from:to, where\n\t * from := [+-]timespec | YYYYMMDD | YYYYMMDDHHMMSS | \"always\"\n\t *   to := [+-]timespec | YYYYMMDD | YYYYMMDDHHMMSS | \"forever\"\n\t */\n\tfrom = xstrdup(timespec);\n\tto = strchr(from, ':');\n\tif (to == NULL || from == to || *(to + 1) == '\\0')\n\t\tfatal(\"Invalid certificate life specification %s\", timespec);\n\t*to++ = '\\0';\n\n\tif (*from == '-' || *from == '+')\n\t\tcert_valid_from = parse_relative_time(from, now);\n\telse if (strcmp(from, \"always\") == 0)\n\t\tcert_valid_from = 0;\n\telse if (parse_absolute_time(from, &cert_valid_from) != 0)\n\t\tfatal(\"Invalid from time \\\"%s\\\"\", from);\n\n\tif (*to == '-' || *to == '+')\n\t\tcert_valid_to = parse_relative_time(to, now);\n\telse if (strcmp(to, \"forever\") == 0)\n\t\tcert_valid_to = ~(u_int64_t)0;\n\telse if (parse_absolute_time(to, &cert_valid_to) != 0)\n\t\tfatal(\"Invalid to time \\\"%s\\\"\", to);\n\n\tif (cert_valid_to <= cert_valid_from)\n\t\tfatal(\"Empty certificate validity interval\");\n\tfree(from);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"utf8.h\"",
            "#include \"digest.h\"",
            "#include \"krl.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"dns.h\"",
            "#include \"hostfile.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"sshbuf.h\"",
            "#include \"uuencode.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <time.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/evp.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int64_t cert_valid_from = 0;",
            "u_int64_t cert_valid_to = ~0ULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"utf8.h\"\n#include \"digest.h\"\n#include \"krl.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"dns.h\"\n#include \"hostfile.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"sshbuf.h\"\n#include \"uuencode.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <time.h>\n#include <locale.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int64_t cert_valid_from = 0;\nu_int64_t cert_valid_to = ~0ULL;\n\nstatic void\nparse_cert_times(char *timespec)\n{\n\tchar *from, *to;\n\ttime_t now = time(NULL);\n\tint64_t secs;\n\n\t/* +timespec relative to now */\n\tif (*timespec == '+' && strchr(timespec, ':') == NULL) {\n\t\tif ((secs = convtime(timespec + 1)) == -1)\n\t\t\tfatal(\"Invalid relative certificate life %s\", timespec);\n\t\tcert_valid_to = now + secs;\n\t\t/*\n\t\t * Backdate certificate one minute to avoid problems on hosts\n\t\t * with poorly-synchronised clocks.\n\t\t */\n\t\tcert_valid_from = ((now - 59)/ 60) * 60;\n\t\treturn;\n\t}\n\n\t/*\n\t * from:to, where\n\t * from := [+-]timespec | YYYYMMDD | YYYYMMDDHHMMSS | \"always\"\n\t *   to := [+-]timespec | YYYYMMDD | YYYYMMDDHHMMSS | \"forever\"\n\t */\n\tfrom = xstrdup(timespec);\n\tto = strchr(from, ':');\n\tif (to == NULL || from == to || *(to + 1) == '\\0')\n\t\tfatal(\"Invalid certificate life specification %s\", timespec);\n\t*to++ = '\\0';\n\n\tif (*from == '-' || *from == '+')\n\t\tcert_valid_from = parse_relative_time(from, now);\n\telse if (strcmp(from, \"always\") == 0)\n\t\tcert_valid_from = 0;\n\telse if (parse_absolute_time(from, &cert_valid_from) != 0)\n\t\tfatal(\"Invalid from time \\\"%s\\\"\", from);\n\n\tif (*to == '-' || *to == '+')\n\t\tcert_valid_to = parse_relative_time(to, now);\n\telse if (strcmp(to, \"forever\") == 0)\n\t\tcert_valid_to = ~(u_int64_t)0;\n\telse if (parse_absolute_time(to, &cert_valid_to) != 0)\n\t\tfatal(\"Invalid to time \\\"%s\\\"\", to);\n\n\tif (cert_valid_to <= cert_valid_from)\n\t\tfatal(\"Empty certificate validity interval\");\n\tfree(from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_get_canonical_hostname",
          "args": [
            "ssh",
            "options.use_dns"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "auth_get_canonical_hostname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "839-852",
          "snippet": "const char *\nauth_get_canonical_hostname(struct ssh *ssh, int use_dns)\n{\n\tstatic char *dnsname;\n\n\tif (!use_dns)\n\t\treturn ssh_remote_ipaddr(ssh);\n\telse if (dnsname != NULL)\n\t\treturn dnsname;\n\telse {\n\t\tdnsname = remote_hostname(ssh);\n\t\treturn dnsname;\n\t}\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nauth_get_canonical_hostname(struct ssh *ssh, int use_dns)\n{\n\tstatic char *dnsname;\n\n\tif (!use_dns)\n\t\treturn ssh_remote_ipaddr(ssh);\n\telse if (dnsname != NULL)\n\t\treturn dnsname;\n\telse {\n\t\tdnsname = remote_hostname(ssh);\n\t\treturn dnsname;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_ipaddr",
          "args": [
            "ssh"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "514-535",
          "snippet": "const char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nint\nauth_authorise_keyopts(struct ssh *ssh, struct passwd *pw,\n    struct sshauthopt *opts, int allow_cert_authority, const char *loc)\n{\n\tconst char *remote_ip = ssh_remote_ipaddr(ssh);\n\tconst char *remote_host = auth_get_canonical_hostname(ssh,\n\t    options.use_dns);\n\ttime_t now = time(NULL);\n\tchar buf[64];\n\n\t/*\n\t * Check keys/principals file expiry time.\n\t * NB. validity interval in certificate is handled elsewhere.\n\t */\n\tif (opts->valid_before && now > 0 &&\n\t    opts->valid_before < (uint64_t)now) {\n\t\tformat_absolute_time(opts->valid_before, buf, sizeof(buf));\n\t\tdebug(\"%s: entry expired at %s\", loc, buf);\n\t\tauth_debug_add(\"%s: entry expired at %s\", loc, buf);\n\t\treturn -1;\n\t}\n\t/* Consistency checks */\n\tif (opts->cert_principals != NULL && !opts->cert_authority) {\n\t\tdebug(\"%s: principals on non-CA key\", loc);\n\t\tauth_debug_add(\"%s: principals on non-CA key\", loc);\n\t\t/* deny access */\n\t\treturn -1;\n\t}\n\t/* cert-authority flag isn't valid in authorized_principals files */\n\tif (!allow_cert_authority && opts->cert_authority) {\n\t\tdebug(\"%s: cert-authority flag invalid here\", loc);\n\t\tauth_debug_add(\"%s: cert-authority flag invalid here\", loc);\n\t\t/* deny access */\n\t\treturn -1;\n\t}\n\n\t/* Perform from= checks */\n\tif (opts->required_from_host_keys != NULL) {\n\t\tswitch (match_host_and_ip(remote_host, remote_ip,\n\t\t    opts->required_from_host_keys )) {\n\t\tcase 1:\n\t\t\t/* Host name matches. */\n\t\t\tbreak;\n\t\tcase -1:\n\t\tdefault:\n\t\t\tdebug(\"%s: invalid from criteria\", loc);\n\t\t\tauth_debug_add(\"%s: invalid from criteria\", loc);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 0:\n\t\t\tlogit(\"%s: Authentication tried for %.100s with \"\n\t\t\t    \"correct key but not from a permitted \"\n\t\t\t    \"host (host=%.200s, ip=%.200s, required=%.200s).\",\n\t\t\t    loc, pw->pw_name, remote_host, remote_ip,\n\t\t\t    opts->required_from_host_keys);\n\t\t\tauth_debug_add(\"%s: Your host '%.200s' is not \"\n\t\t\t    \"permitted to use this key for login.\",\n\t\t\t    loc, remote_host);\n\t\t\t/* deny access */\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* Check source-address restriction from certificate */\n\tif (opts->required_from_host_cert != NULL) {\n\t\tswitch (addr_match_cidr_list(remote_ip,\n\t\t    opts->required_from_host_cert)) {\n\t\tcase 1:\n\t\t\t/* accepted */\n\t\t\tbreak;\n\t\tcase -1:\n\t\tdefault:\n\t\t\t/* invalid */\n\t\t\terror(\"%s: Certificate source-address invalid\",\n\t\t\t    loc);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 0:\n\t\t\tlogit(\"%s: Authentication tried for %.100s with valid \"\n\t\t\t    \"certificate but not from a permitted source \"\n\t\t\t    \"address (%.200s).\", loc, pw->pw_name, remote_ip);\n\t\t\tauth_debug_add(\"%s: Your address '%.200s' is not \"\n\t\t\t    \"permitted to use this certificate for login.\",\n\t\t\t    loc, remote_ip);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/*\n\t *\n\t * XXX this is spammy. We should report remotely only for keys\n\t *     that are successful in actual auth attempts, and not PK_OK\n\t *     tests.\n\t */\n\tauth_log_authopts(loc, opts, 1);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "auth_restrict_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
    "lines": "1092-1107",
    "snippet": "void\nauth_restrict_session(struct ssh *ssh)\n{\n\tstruct sshauthopt *restricted;\n\n\tdebug(\"%s: restricting session\", __func__);\n\n\t/* A blank sshauthopt defaults to permitting nothing */\n\trestricted = sshauthopt_new();\n\trestricted->permit_pty_flag = 1;\n\trestricted->restricted = 1;\n\n\tif (auth_activate_options(ssh, restricted) != 0)\n\t\tfatal(\"%s: failed to restrict session\", __func__);\n\tsshauthopt_free(restricted);\n}",
    "includes": [
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"authfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"loginrec.h\"",
      "#include \"packet.h\"",
      "#include \"uidswap.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"groupaccess.h\"",
      "#include \"match.h\"",
      "#include \"xmalloc.h\"",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <shadow.h>",
      "#include <login.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshauthopt_free",
          "args": [
            "restricted"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "265-292",
          "snippet": "void\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: failed to restrict session\"",
            "__func__"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_activate_options",
          "args": [
            "ssh",
            "restricted"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "auth_activate_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "1077-1089",
          "snippet": "int\nauth_activate_options(struct ssh *ssh, struct sshauthopt *opts)\n{\n\tstruct sshauthopt *old = auth_opts;\n\tconst char *emsg = NULL;\n\n\tdebug(\"%s: setting new authentication options\", __func__);\n\tif ((auth_opts = sshauthopt_merge(old, opts, &emsg)) == NULL) {\n\t\terror(\"Inconsistent authentication options: %s\", emsg);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "extern struct sshauthopt *auth_opts;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern struct sshauthopt *auth_opts;\n\nint\nauth_activate_options(struct ssh *ssh, struct sshauthopt *opts)\n{\n\tstruct sshauthopt *old = auth_opts;\n\tconst char *emsg = NULL;\n\n\tdebug(\"%s: setting new authentication options\", __func__);\n\tif ((auth_opts = sshauthopt_merge(old, opts, &emsg)) == NULL) {\n\t\terror(\"Inconsistent authentication options: %s\", emsg);\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshauthopt_new",
          "args": [],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_new_with_keys_defaults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "294-309",
          "snippet": "struct sshauthopt *\nsshauthopt_new_with_keys_defaults(void)\n{\n\tstruct sshauthopt *ret = NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\treturn NULL;\n\n\t/* Defaults for authorized_keys flags */\n\tret->permit_port_forwarding_flag = 1;\n\tret->permit_agent_forwarding_flag = 1;\n\tret->permit_x11_forwarding_flag = 1;\n\tret->permit_pty_flag = 1;\n\tret->permit_user_rc = 1;\n\treturn ret;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshauthopt *\nsshauthopt_new_with_keys_defaults(void)\n{\n\tstruct sshauthopt *ret = NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\treturn NULL;\n\n\t/* Defaults for authorized_keys flags */\n\tret->permit_port_forwarding_flag = 1;\n\tret->permit_agent_forwarding_flag = 1;\n\tret->permit_x11_forwarding_flag = 1;\n\tret->permit_pty_flag = 1;\n\tret->permit_user_rc = 1;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: restricting session\"",
            "__func__"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "auth_debug_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "673-688",
          "snippet": "void\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sshbuf *auth_debug;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshbuf *auth_debug;\n\nvoid\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nauth_restrict_session(struct ssh *ssh)\n{\n\tstruct sshauthopt *restricted;\n\n\tdebug(\"%s: restricting session\", __func__);\n\n\t/* A blank sshauthopt defaults to permitting nothing */\n\trestricted = sshauthopt_new();\n\trestricted->permit_pty_flag = 1;\n\trestricted->restricted = 1;\n\n\tif (auth_activate_options(ssh, restricted) != 0)\n\t\tfatal(\"%s: failed to restrict session\", __func__);\n\tsshauthopt_free(restricted);\n}"
  },
  {
    "function_name": "auth_activate_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
    "lines": "1077-1089",
    "snippet": "int\nauth_activate_options(struct ssh *ssh, struct sshauthopt *opts)\n{\n\tstruct sshauthopt *old = auth_opts;\n\tconst char *emsg = NULL;\n\n\tdebug(\"%s: setting new authentication options\", __func__);\n\tif ((auth_opts = sshauthopt_merge(old, opts, &emsg)) == NULL) {\n\t\terror(\"Inconsistent authentication options: %s\", emsg);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"authfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"loginrec.h\"",
      "#include \"packet.h\"",
      "#include \"uidswap.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"groupaccess.h\"",
      "#include \"match.h\"",
      "#include \"xmalloc.h\"",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <shadow.h>",
      "#include <login.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "extern struct sshauthopt *auth_opts;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Inconsistent authentication options: %s\"",
            "emsg"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshauthopt_merge",
          "args": [
            "old",
            "opts",
            "&emsg"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "572-690",
          "snippet": "struct sshauthopt *\nsshauthopt_merge(const struct sshauthopt *primary,\n    const struct sshauthopt *additional, const char **errstrp)\n{\n\tstruct sshauthopt *ret;\n\tconst char *errstr = \"internal error\";\n\tconst char *tmp;\n\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\tgoto alloc_fail;\n\n\t/* cert_authority and cert_principals are cleared in result */\n\n\t/* Prefer access lists from primary. */\n\t/* XXX err is both set and mismatch? */\n\ttmp = primary->required_from_host_cert;\n\tif (tmp == NULL)\n\t\ttmp = additional->required_from_host_cert;\n\tif (tmp != NULL && (ret->required_from_host_cert = strdup(tmp)) == NULL)\n\t\tgoto alloc_fail;\n\ttmp = primary->required_from_host_keys;\n\tif (tmp == NULL)\n\t\ttmp = additional->required_from_host_keys;\n\tif (tmp != NULL && (ret->required_from_host_keys = strdup(tmp)) == NULL)\n\t\tgoto alloc_fail;\n\n\t/*\n\t * force_tun_device, permitopen/permitlisten and environment all\n\t * prefer the primary.\n\t */\n\tret->force_tun_device = primary->force_tun_device;\n\tif (ret->force_tun_device == -1)\n\t\tret->force_tun_device = additional->force_tun_device;\n\tif (primary->nenv > 0) {\n\t\tif (dup_strings(&ret->env, &ret->nenv,\n\t\t    primary->env, primary->nenv) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->nenv) {\n\t\tif (dup_strings(&ret->env, &ret->nenv,\n\t\t    additional->env, additional->nenv) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\tif (primary->npermitopen > 0) {\n\t\tif (dup_strings(&ret->permitopen, &ret->npermitopen,\n\t\t    primary->permitopen, primary->npermitopen) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->npermitopen > 0) {\n\t\tif (dup_strings(&ret->permitopen, &ret->npermitopen,\n\t\t    additional->permitopen, additional->npermitopen) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\n\tif (primary->npermitlisten > 0) {\n\t\tif (dup_strings(&ret->permitlisten, &ret->npermitlisten,\n\t\t    primary->permitlisten, primary->npermitlisten) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->npermitlisten > 0) {\n\t\tif (dup_strings(&ret->permitlisten, &ret->npermitlisten,\n\t\t    additional->permitlisten, additional->npermitlisten) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\n\t/* Flags are logical-AND (i.e. must be set in both for permission) */\n#define OPTFLAG(x) ret->x = (primary->x == 1) && (additional->x == 1)\n\tOPTFLAG(permit_port_forwarding_flag);\n\tOPTFLAG(permit_agent_forwarding_flag);\n\tOPTFLAG(permit_x11_forwarding_flag);\n\tOPTFLAG(permit_pty_flag);\n\tOPTFLAG(permit_user_rc);\n#undef OPTFLAG\n\n\t/* Earliest expiry time should win */\n\tif (primary->valid_before != 0)\n\t\tret->valid_before = primary->valid_before;\n\tif (additional->valid_before != 0 &&\n\t    additional->valid_before < ret->valid_before)\n\t\tret->valid_before = additional->valid_before;\n\n\t/*\n\t * When both multiple forced-command are specified, only\n\t * proceed if they are identical, otherwise fail.\n\t */\n\tif (primary->force_command != NULL &&\n\t    additional->force_command != NULL) {\n\t\tif (strcmp(primary->force_command,\n\t\t    additional->force_command) == 0) {\n\t\t\t/* ok */\n\t\t\tret->force_command = strdup(primary->force_command);\n\t\t\tif (ret->force_command == NULL)\n\t\t\t\tgoto alloc_fail;\n\t\t} else {\n\t\t\terrstr = \"forced command options do not match\";\n\t\t\tgoto fail;\n\t\t}\n\t} else if (primary->force_command != NULL) {\n\t\tif ((ret->force_command = strdup(\n\t\t    primary->force_command)) == NULL)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->force_command != NULL) {\n\t\tif ((ret->force_command = strdup(\n\t\t    additional->force_command)) == NULL)\n\t\t\tgoto alloc_fail;\n\t}\n\t/* success */\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\treturn ret;\n\n alloc_fail:\n\terrstr = \"memory allocation failed\";\n fail:\n\tif (errstrp != NULL)\n\t\t*errstrp = errstr;\n\tsshauthopt_free(ret);\n\treturn NULL;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshauthopt *\nsshauthopt_merge(const struct sshauthopt *primary,\n    const struct sshauthopt *additional, const char **errstrp)\n{\n\tstruct sshauthopt *ret;\n\tconst char *errstr = \"internal error\";\n\tconst char *tmp;\n\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\tgoto alloc_fail;\n\n\t/* cert_authority and cert_principals are cleared in result */\n\n\t/* Prefer access lists from primary. */\n\t/* XXX err is both set and mismatch? */\n\ttmp = primary->required_from_host_cert;\n\tif (tmp == NULL)\n\t\ttmp = additional->required_from_host_cert;\n\tif (tmp != NULL && (ret->required_from_host_cert = strdup(tmp)) == NULL)\n\t\tgoto alloc_fail;\n\ttmp = primary->required_from_host_keys;\n\tif (tmp == NULL)\n\t\ttmp = additional->required_from_host_keys;\n\tif (tmp != NULL && (ret->required_from_host_keys = strdup(tmp)) == NULL)\n\t\tgoto alloc_fail;\n\n\t/*\n\t * force_tun_device, permitopen/permitlisten and environment all\n\t * prefer the primary.\n\t */\n\tret->force_tun_device = primary->force_tun_device;\n\tif (ret->force_tun_device == -1)\n\t\tret->force_tun_device = additional->force_tun_device;\n\tif (primary->nenv > 0) {\n\t\tif (dup_strings(&ret->env, &ret->nenv,\n\t\t    primary->env, primary->nenv) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->nenv) {\n\t\tif (dup_strings(&ret->env, &ret->nenv,\n\t\t    additional->env, additional->nenv) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\tif (primary->npermitopen > 0) {\n\t\tif (dup_strings(&ret->permitopen, &ret->npermitopen,\n\t\t    primary->permitopen, primary->npermitopen) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->npermitopen > 0) {\n\t\tif (dup_strings(&ret->permitopen, &ret->npermitopen,\n\t\t    additional->permitopen, additional->npermitopen) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\n\tif (primary->npermitlisten > 0) {\n\t\tif (dup_strings(&ret->permitlisten, &ret->npermitlisten,\n\t\t    primary->permitlisten, primary->npermitlisten) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->npermitlisten > 0) {\n\t\tif (dup_strings(&ret->permitlisten, &ret->npermitlisten,\n\t\t    additional->permitlisten, additional->npermitlisten) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\n\t/* Flags are logical-AND (i.e. must be set in both for permission) */\n#define OPTFLAG(x) ret->x = (primary->x == 1) && (additional->x == 1)\n\tOPTFLAG(permit_port_forwarding_flag);\n\tOPTFLAG(permit_agent_forwarding_flag);\n\tOPTFLAG(permit_x11_forwarding_flag);\n\tOPTFLAG(permit_pty_flag);\n\tOPTFLAG(permit_user_rc);\n#undef OPTFLAG\n\n\t/* Earliest expiry time should win */\n\tif (primary->valid_before != 0)\n\t\tret->valid_before = primary->valid_before;\n\tif (additional->valid_before != 0 &&\n\t    additional->valid_before < ret->valid_before)\n\t\tret->valid_before = additional->valid_before;\n\n\t/*\n\t * When both multiple forced-command are specified, only\n\t * proceed if they are identical, otherwise fail.\n\t */\n\tif (primary->force_command != NULL &&\n\t    additional->force_command != NULL) {\n\t\tif (strcmp(primary->force_command,\n\t\t    additional->force_command) == 0) {\n\t\t\t/* ok */\n\t\t\tret->force_command = strdup(primary->force_command);\n\t\t\tif (ret->force_command == NULL)\n\t\t\t\tgoto alloc_fail;\n\t\t} else {\n\t\t\terrstr = \"forced command options do not match\";\n\t\t\tgoto fail;\n\t\t}\n\t} else if (primary->force_command != NULL) {\n\t\tif ((ret->force_command = strdup(\n\t\t    primary->force_command)) == NULL)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->force_command != NULL) {\n\t\tif ((ret->force_command = strdup(\n\t\t    additional->force_command)) == NULL)\n\t\t\tgoto alloc_fail;\n\t}\n\t/* success */\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\treturn ret;\n\n alloc_fail:\n\terrstr = \"memory allocation failed\";\n fail:\n\tif (errstrp != NULL)\n\t\t*errstrp = errstr;\n\tsshauthopt_free(ret);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: setting new authentication options\"",
            "__func__"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "auth_debug_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "673-688",
          "snippet": "void\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sshbuf *auth_debug;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshbuf *auth_debug;\n\nvoid\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern struct sshauthopt *auth_opts;\n\nint\nauth_activate_options(struct ssh *ssh, struct sshauthopt *opts)\n{\n\tstruct sshauthopt *old = auth_opts;\n\tconst char *emsg = NULL;\n\n\tdebug(\"%s: setting new authentication options\", __func__);\n\tif ((auth_opts = sshauthopt_merge(old, opts, &emsg)) == NULL) {\n\t\terror(\"Inconsistent authentication options: %s\", emsg);\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "auth_log_authopts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
    "lines": "1009-1074",
    "snippet": "void\nauth_log_authopts(const char *loc, const struct sshauthopt *opts, int do_remote)\n{\n\tint do_env = options.permit_user_env && opts->nenv > 0;\n\tint do_permitopen = opts->npermitopen > 0 &&\n\t    (options.allow_tcp_forwarding & FORWARD_LOCAL) != 0;\n\tint do_permitlisten = opts->npermitlisten > 0 &&\n\t    (options.allow_tcp_forwarding & FORWARD_REMOTE) != 0;\n\tsize_t i;\n\tchar msg[1024], buf[64];\n\n\tsnprintf(buf, sizeof(buf), \"%d\", opts->force_tun_device);\n\t/* Try to keep this alphabetically sorted */\n\tsnprintf(msg, sizeof(msg), \"key options:%s%s%s%s%s%s%s%s%s%s%s%s%s\",\n\t    opts->permit_agent_forwarding_flag ? \" agent-forwarding\" : \"\",\n\t    opts->force_command == NULL ? \"\" : \" command\",\n\t    do_env ?  \" environment\" : \"\",\n\t    opts->valid_before == 0 ? \"\" : \"expires\",\n\t    do_permitopen ?  \" permitopen\" : \"\",\n\t    do_permitlisten ?  \" permitlisten\" : \"\",\n\t    opts->permit_port_forwarding_flag ? \" port-forwarding\" : \"\",\n\t    opts->cert_principals == NULL ? \"\" : \" principals\",\n\t    opts->permit_pty_flag ? \" pty\" : \"\",\n\t    opts->force_tun_device == -1 ? \"\" : \" tun=\",\n\t    opts->force_tun_device == -1 ? \"\" : buf,\n\t    opts->permit_user_rc ? \" user-rc\" : \"\",\n\t    opts->permit_x11_forwarding_flag ? \" x11-forwarding\" : \"\");\n\n\tdebug(\"%s: %s\", loc, msg);\n\tif (do_remote)\n\t\tauth_debug_add(\"%s: %s\", loc, msg);\n\n\tif (options.permit_user_env) {\n\t\tfor (i = 0; i < opts->nenv; i++) {\n\t\t\tdebug(\"%s: environment: %s\", loc, opts->env[i]);\n\t\t\tif (do_remote) {\n\t\t\t\tauth_debug_add(\"%s: environment: %s\",\n\t\t\t\t    loc, opts->env[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Go into a little more details for the local logs. */\n\tif (opts->valid_before != 0) {\n\t\tformat_absolute_time(opts->valid_before, buf, sizeof(buf));\n\t\tdebug(\"%s: expires at %s\", loc, buf);\n\t}\n\tif (opts->cert_principals != NULL) {\n\t\tdebug(\"%s: authorized principals: \\\"%s\\\"\",\n\t\t    loc, opts->cert_principals);\n\t}\n\tif (opts->force_command != NULL)\n\t\tdebug(\"%s: forced command: \\\"%s\\\"\", loc, opts->force_command);\n\tif (do_permitopen) {\n\t\tfor (i = 0; i < opts->npermitopen; i++) {\n\t\t\tdebug(\"%s: permitted open: %s\",\n\t\t\t    loc, opts->permitopen[i]);\n\t\t}\n\t}\n\tif (do_permitlisten) {\n\t\tfor (i = 0; i < opts->npermitlisten; i++) {\n\t\t\tdebug(\"%s: permitted listen: %s\",\n\t\t\t    loc, opts->permitlisten[i]);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"authfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"loginrec.h\"",
      "#include \"packet.h\"",
      "#include \"uidswap.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"groupaccess.h\"",
      "#include \"match.h\"",
      "#include \"xmalloc.h\"",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <shadow.h>",
      "#include <login.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: permitted listen: %s\"",
            "loc",
            "opts->permitlisten[i]"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "auth_debug_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "673-688",
          "snippet": "void\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sshbuf *auth_debug;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshbuf *auth_debug;\n\nvoid\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_absolute_time",
          "args": [
            "opts->valid_before",
            "buf",
            "sizeof(buf)"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "format_absolute_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "2031-2039",
          "snippet": "void\nformat_absolute_time(uint64_t t, char *buf, size_t len)\n{\n\ttime_t tt = t > INT_MAX ? INT_MAX : t; /* XXX revisit in 2038 :P */\n\tstruct tm tm;\n\n\tlocaltime_r(&tt, &tm);\n\tstrftime(buf, len, \"%Y-%m-%dT%H:%M:%S\", &tm);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nformat_absolute_time(uint64_t t, char *buf, size_t len)\n{\n\ttime_t tt = t > INT_MAX ? INT_MAX : t; /* XXX revisit in 2038 :P */\n\tstruct tm tm;\n\n\tlocaltime_r(&tt, &tm);\n\tstrftime(buf, len, \"%Y-%m-%dT%H:%M:%S\", &tm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "msg",
            "sizeof(msg)",
            "\"key options:%s%s%s%s%s%s%s%s%s%s%s%s%s\"",
            "opts->permit_agent_forwarding_flag ? \" agent-forwarding\" : \"\"",
            "opts->force_command == NULL ? \"\" : \" command\"",
            "do_env ?  \" environment\" : \"\"",
            "opts->valid_before == 0 ? \"\" : \"expires\"",
            "do_permitopen ?  \" permitopen\" : \"\"",
            "do_permitlisten ?  \" permitlisten\" : \"\"",
            "opts->permit_port_forwarding_flag ? \" port-forwarding\" : \"\"",
            "opts->cert_principals == NULL ? \"\" : \" principals\"",
            "opts->permit_pty_flag ? \" pty\" : \"\"",
            "opts->force_tun_device == -1 ? \"\" : \" tun=\"",
            "opts->force_tun_device == -1 ? \"\" : buf",
            "opts->permit_user_rc ? \" user-rc\" : \"\"",
            "opts->permit_x11_forwarding_flag ? \" x11-forwarding\" : \"\""
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nvoid\nauth_log_authopts(const char *loc, const struct sshauthopt *opts, int do_remote)\n{\n\tint do_env = options.permit_user_env && opts->nenv > 0;\n\tint do_permitopen = opts->npermitopen > 0 &&\n\t    (options.allow_tcp_forwarding & FORWARD_LOCAL) != 0;\n\tint do_permitlisten = opts->npermitlisten > 0 &&\n\t    (options.allow_tcp_forwarding & FORWARD_REMOTE) != 0;\n\tsize_t i;\n\tchar msg[1024], buf[64];\n\n\tsnprintf(buf, sizeof(buf), \"%d\", opts->force_tun_device);\n\t/* Try to keep this alphabetically sorted */\n\tsnprintf(msg, sizeof(msg), \"key options:%s%s%s%s%s%s%s%s%s%s%s%s%s\",\n\t    opts->permit_agent_forwarding_flag ? \" agent-forwarding\" : \"\",\n\t    opts->force_command == NULL ? \"\" : \" command\",\n\t    do_env ?  \" environment\" : \"\",\n\t    opts->valid_before == 0 ? \"\" : \"expires\",\n\t    do_permitopen ?  \" permitopen\" : \"\",\n\t    do_permitlisten ?  \" permitlisten\" : \"\",\n\t    opts->permit_port_forwarding_flag ? \" port-forwarding\" : \"\",\n\t    opts->cert_principals == NULL ? \"\" : \" principals\",\n\t    opts->permit_pty_flag ? \" pty\" : \"\",\n\t    opts->force_tun_device == -1 ? \"\" : \" tun=\",\n\t    opts->force_tun_device == -1 ? \"\" : buf,\n\t    opts->permit_user_rc ? \" user-rc\" : \"\",\n\t    opts->permit_x11_forwarding_flag ? \" x11-forwarding\" : \"\");\n\n\tdebug(\"%s: %s\", loc, msg);\n\tif (do_remote)\n\t\tauth_debug_add(\"%s: %s\", loc, msg);\n\n\tif (options.permit_user_env) {\n\t\tfor (i = 0; i < opts->nenv; i++) {\n\t\t\tdebug(\"%s: environment: %s\", loc, opts->env[i]);\n\t\t\tif (do_remote) {\n\t\t\t\tauth_debug_add(\"%s: environment: %s\",\n\t\t\t\t    loc, opts->env[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Go into a little more details for the local logs. */\n\tif (opts->valid_before != 0) {\n\t\tformat_absolute_time(opts->valid_before, buf, sizeof(buf));\n\t\tdebug(\"%s: expires at %s\", loc, buf);\n\t}\n\tif (opts->cert_principals != NULL) {\n\t\tdebug(\"%s: authorized principals: \\\"%s\\\"\",\n\t\t    loc, opts->cert_principals);\n\t}\n\tif (opts->force_command != NULL)\n\t\tdebug(\"%s: forced command: \\\"%s\\\"\", loc, opts->force_command);\n\tif (do_permitopen) {\n\t\tfor (i = 0; i < opts->npermitopen; i++) {\n\t\t\tdebug(\"%s: permitted open: %s\",\n\t\t\t    loc, opts->permitopen[i]);\n\t\t}\n\t}\n\tif (do_permitlisten) {\n\t\tfor (i = 0; i < opts->npermitlisten; i++) {\n\t\t\tdebug(\"%s: permitted listen: %s\",\n\t\t\t    loc, opts->permitlisten[i]);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "subprocess",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
    "lines": "863-1004",
    "snippet": "pid_t\nsubprocess(const char *tag, struct passwd *pw, const char *command,\n    int ac, char **av, FILE **child, u_int flags)\n{\n\tFILE *f = NULL;\n\tstruct stat st;\n\tint fd, devnull, p[2], i;\n\tpid_t pid;\n\tchar *cp, errmsg[512];\n\tu_int envsize;\n\tchar **child_env;\n\n\tif (child != NULL)\n\t\t*child = NULL;\n\n\tdebug3(\"%s: %s command \\\"%s\\\" running as %s (flags 0x%x)\", __func__,\n\t    tag, command, pw->pw_name, flags);\n\n\t/* Check consistency */\n\tif ((flags & SSH_SUBPROCESS_STDOUT_DISCARD) != 0 &&\n\t    (flags & SSH_SUBPROCESS_STDOUT_CAPTURE) != 0) {\n\t\terror(\"%s: inconsistent flags\", __func__);\n\t\treturn 0;\n\t}\n\tif (((flags & SSH_SUBPROCESS_STDOUT_CAPTURE) == 0) != (child == NULL)) {\n\t\terror(\"%s: inconsistent flags/output\", __func__);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If executing an explicit binary, then verify the it exists\n\t * and appears safe-ish to execute\n\t */\n\tif (*av[0] != '/') {\n\t\terror(\"%s path is not absolute\", tag);\n\t\treturn 0;\n\t}\n\ttemporarily_use_uid(pw);\n\tif (stat(av[0], &st) < 0) {\n\t\terror(\"Could not stat %s \\\"%s\\\": %s\", tag,\n\t\t    av[0], strerror(errno));\n\t\trestore_uid();\n\t\treturn 0;\n\t}\n\tif (safe_path(av[0], &st, NULL, 0, errmsg, sizeof(errmsg)) != 0) {\n\t\terror(\"Unsafe %s \\\"%s\\\": %s\", tag, av[0], errmsg);\n\t\trestore_uid();\n\t\treturn 0;\n\t}\n\t/* Prepare to keep the child's stdout if requested */\n\tif (pipe(p) != 0) {\n\t\terror(\"%s: pipe: %s\", tag, strerror(errno));\n\t\trestore_uid();\n\t\treturn 0;\n\t}\n\trestore_uid();\n\n\tswitch ((pid = fork())) {\n\tcase -1: /* error */\n\t\terror(\"%s: fork: %s\", tag, strerror(errno));\n\t\tclose(p[0]);\n\t\tclose(p[1]);\n\t\treturn 0;\n\tcase 0: /* child */\n\t\t/* Prepare a minimal environment for the child. */\n\t\tenvsize = 5;\n\t\tchild_env = xcalloc(sizeof(*child_env), envsize);\n\t\tchild_set_env(&child_env, &envsize, \"PATH\", _PATH_STDPATH);\n\t\tchild_set_env(&child_env, &envsize, \"USER\", pw->pw_name);\n\t\tchild_set_env(&child_env, &envsize, \"LOGNAME\", pw->pw_name);\n\t\tchild_set_env(&child_env, &envsize, \"HOME\", pw->pw_dir);\n\t\tif ((cp = getenv(\"LANG\")) != NULL)\n\t\t\tchild_set_env(&child_env, &envsize, \"LANG\", cp);\n\n\t\tfor (i = 0; i < NSIG; i++)\n\t\t\tsignal(i, SIG_DFL);\n\n\t\tif ((devnull = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\t\terror(\"%s: open %s: %s\", tag, _PATH_DEVNULL,\n\t\t\t    strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tif (dup2(devnull, STDIN_FILENO) == -1) {\n\t\t\terror(\"%s: dup2: %s\", tag, strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\n\t\t/* Set up stdout as requested; leave stderr in place for now. */\n\t\tfd = -1;\n\t\tif ((flags & SSH_SUBPROCESS_STDOUT_CAPTURE) != 0)\n\t\t\tfd = p[1];\n\t\telse if ((flags & SSH_SUBPROCESS_STDOUT_DISCARD) != 0)\n\t\t\tfd = devnull;\n\t\tif (fd != -1 && dup2(fd, STDOUT_FILENO) == -1) {\n\t\t\terror(\"%s: dup2: %s\", tag, strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tclosefrom(STDERR_FILENO + 1);\n\n\t\t/* Don't use permanently_set_uid() here to avoid fatal() */\n\t\tif (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) != 0) {\n\t\t\terror(\"%s: setresgid %u: %s\", tag, (u_int)pw->pw_gid,\n\t\t\t    strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tif (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) != 0) {\n\t\t\terror(\"%s: setresuid %u: %s\", tag, (u_int)pw->pw_uid,\n\t\t\t    strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\t/* stdin is pointed to /dev/null at this point */\n\t\tif ((flags & SSH_SUBPROCESS_STDOUT_DISCARD) != 0 &&\n\t\t    dup2(STDIN_FILENO, STDERR_FILENO) == -1) {\n\t\t\terror(\"%s: dup2: %s\", tag, strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\n\t\texecve(av[0], av, child_env);\n\t\terror(\"%s exec \\\"%s\\\": %s\", tag, command, strerror(errno));\n\t\t_exit(127);\n\tdefault: /* parent */\n\t\tbreak;\n\t}\n\n\tclose(p[1]);\n\tif ((flags & SSH_SUBPROCESS_STDOUT_CAPTURE) == 0)\n\t\tclose(p[0]);\n\telse if ((f = fdopen(p[0], \"r\")) == NULL) {\n\t\terror(\"%s: fdopen: %s\", tag, strerror(errno));\n\t\tclose(p[0]);\n\t\t/* Don't leave zombie child */\n\t\tkill(pid, SIGTERM);\n\t\twhile (waitpid(pid, NULL, 0) == -1 && errno == EINTR)\n\t\t\t;\n\t\treturn 0;\n\t}\n\t/* Success */\n\tdebug3(\"%s: %s pid %ld\", __func__, tag, (long)pid);\n\tif (child != NULL)\n\t\t*child = f;\n\treturn pid;\n}",
    "includes": [
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"authfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"loginrec.h\"",
      "#include \"packet.h\"",
      "#include \"uidswap.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"groupaccess.h\"",
      "#include \"match.h\"",
      "#include \"xmalloc.h\"",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <shadow.h>",
      "#include <login.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: %s pid %ld\"",
            "__func__",
            "tag",
            "(long)pid"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "NULL",
            "0"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "waitpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-waitpid.c",
          "lines": "32-51",
          "snippet": "pid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}",
          "includes": [
            "#include \"bsd-waitpid.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-waitpid.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\npid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "pid",
            "SIGTERM"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "p[0]"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: fdopen: %s\"",
            "tag",
            "strerror(errno)"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "p[0]",
            "\"r\""
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "127"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "execve",
          "args": [
            "av[0]",
            "av",
            "child_env"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "STDIN_FILENO",
            "STDERR_FILENO"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setresuid",
          "args": [
            "pw->pw_uid",
            "pw->pw_uid",
            "pw->pw_uid"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "setresuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-setres_id.c",
          "lines": "63-97",
          "snippet": "int\nsetresuid(uid_t ruid, uid_t euid, uid_t suid)\n{\n\tint ret = 0, saved_errno;\n\n\tif (ruid != suid) {\n\t\terrno = ENOSYS;\n\t\treturn -1;\n\t}\n#if defined(HAVE_SETREUID) && !defined(BROKEN_SETREUID)\n\tif (setreuid(ruid, euid) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"setreuid %u: %.100s\", ruid, strerror(errno));\n\t\terrno = saved_errno;\n\t\tret = -1;\n\t}\n#else\n\n# ifndef SETEUID_BREAKS_SETUID\n\tif (seteuid(euid) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"seteuid %u: %.100s\", euid, strerror(errno));\n\t\terrno = saved_errno;\n\t\tret = -1;\n\t}\n# endif\n\tif (setuid(ruid) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"setuid %u: %.100s\", ruid, strerror(errno));\n\t\terrno = saved_errno;\n\t\tret = -1;\n\t}\n#endif\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsetresuid(uid_t ruid, uid_t euid, uid_t suid)\n{\n\tint ret = 0, saved_errno;\n\n\tif (ruid != suid) {\n\t\terrno = ENOSYS;\n\t\treturn -1;\n\t}\n#if defined(HAVE_SETREUID) && !defined(BROKEN_SETREUID)\n\tif (setreuid(ruid, euid) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"setreuid %u: %.100s\", ruid, strerror(errno));\n\t\terrno = saved_errno;\n\t\tret = -1;\n\t}\n#else\n\n# ifndef SETEUID_BREAKS_SETUID\n\tif (seteuid(euid) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"seteuid %u: %.100s\", euid, strerror(errno));\n\t\terrno = saved_errno;\n\t\tret = -1;\n\t}\n# endif\n\tif (setuid(ruid) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"setuid %u: %.100s\", ruid, strerror(errno));\n\t\terrno = saved_errno;\n\t\tret = -1;\n\t}\n#endif\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setresgid",
          "args": [
            "pw->pw_gid",
            "pw->pw_gid",
            "pw->pw_gid"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "setresgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-setres_id.c",
          "lines": "28-59",
          "snippet": "int\nsetresgid(gid_t rgid, gid_t egid, gid_t sgid)\n{\n\tint ret = 0, saved_errno;\n\n\tif (rgid != sgid) {\n\t\terrno = ENOSYS;\n\t\treturn -1;\n\t}\n#if defined(HAVE_SETREGID) && !defined(BROKEN_SETREGID)\n\tif (setregid(rgid, egid) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"setregid %u: %.100s\", rgid, strerror(errno));\n\t\terrno = saved_errno;\n\t\tret = -1;\n\t}\n#else\n\tif (setegid(egid) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"setegid %u: %.100s\", (u_int)egid, strerror(errno));\n\t\terrno = saved_errno;\n\t\tret = -1;\n\t}\n\tif (setgid(rgid) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"setgid %u: %.100s\", rgid, strerror(errno));\n\t\terrno = saved_errno;\n\t\tret = -1;\n\t}\n#endif\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsetresgid(gid_t rgid, gid_t egid, gid_t sgid)\n{\n\tint ret = 0, saved_errno;\n\n\tif (rgid != sgid) {\n\t\terrno = ENOSYS;\n\t\treturn -1;\n\t}\n#if defined(HAVE_SETREGID) && !defined(BROKEN_SETREGID)\n\tif (setregid(rgid, egid) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"setregid %u: %.100s\", rgid, strerror(errno));\n\t\terrno = saved_errno;\n\t\tret = -1;\n\t}\n#else\n\tif (setegid(egid) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"setegid %u: %.100s\", (u_int)egid, strerror(errno));\n\t\terrno = saved_errno;\n\t\tret = -1;\n\t}\n\tif (setgid(rgid) < 0) {\n\t\tsaved_errno = errno;\n\t\terror(\"setgid %u: %.100s\", rgid, strerror(errno));\n\t\terrno = saved_errno;\n\t\tret = -1;\n\t}\n#endif\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "closefrom",
          "args": [
            "STDERR_FILENO + 1"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "closefrom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-closefrom.c",
          "lines": "68-107",
          "snippet": "void\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}",
          "includes": [
            "#  include <ndir.h>",
            "#  include <sys/dir.h>",
            "#  include <sys/ndir.h>",
            "# include <dirent.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "# include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <ndir.h>\n#  include <sys/dir.h>\n#  include <sys/ndir.h>\n# include <dirent.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <limits.h>\n# include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd",
            "STDOUT_FILENO"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "devnull",
            "STDIN_FILENO"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "_PATH_DEVNULL",
            "O_RDWR"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "process_permitopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "901-909",
          "snippet": "void\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "i",
            "SIG_DFL"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "child_set_env",
          "args": [
            "&child_env",
            "&envsize",
            "\"LANG\"",
            "cp"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "child_set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1851-1905",
          "snippet": "void\nchild_set_env(char ***envp, u_int *envsizep, const char *name,\n\tconst char *value)\n{\n\tchar **env;\n\tu_int envsize;\n\tu_int i, namelen;\n\n\tif (strchr(name, '=') != NULL) {\n\t\terror(\"Invalid environment variable \\\"%.100s\\\"\", name);\n\t\treturn;\n\t}\n\n\t/*\n\t * If we're passed an uninitialized list, allocate a single null\n\t * entry before continuing.\n\t */\n\tif (*envp == NULL && *envsizep == 0) {\n\t\t*envp = xmalloc(sizeof(char *));\n\t\t*envp[0] = NULL;\n\t\t*envsizep = 1;\n\t}\n\n\t/*\n\t * Find the slot where the value should be stored.  If the variable\n\t * already exists, we reuse the slot; otherwise we append a new slot\n\t * at the end of the array, expanding if necessary.\n\t */\n\tenv = *envp;\n\tnamelen = strlen(name);\n\tfor (i = 0; env[i]; i++)\n\t\tif (strncmp(env[i], name, namelen) == 0 && env[i][namelen] == '=')\n\t\t\tbreak;\n\tif (env[i]) {\n\t\t/* Reuse the slot. */\n\t\tfree(env[i]);\n\t} else {\n\t\t/* New variable.  Expand if necessary. */\n\t\tenvsize = *envsizep;\n\t\tif (i >= envsize - 1) {\n\t\t\tif (envsize >= 1000)\n\t\t\t\tfatal(\"child_set_env: too many env vars\");\n\t\t\tenvsize += 50;\n\t\t\tenv = (*envp) = xreallocarray(env, envsize, sizeof(char *));\n\t\t\t*envsizep = envsize;\n\t\t}\n\t\t/* Need to set the NULL pointer at end of array beyond the new slot. */\n\t\tenv[i + 1] = NULL;\n\t}\n\n\t/* Allocate space and format the variable in the appropriate slot. */\n\t/* XXX xasprintf */\n\tenv[i] = xmalloc(strlen(name) + 1 + strlen(value) + 1);\n\tsnprintf(env[i], strlen(name) + 1 + strlen(value) + 1, \"%s=%s\", name, value);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nchild_set_env(char ***envp, u_int *envsizep, const char *name,\n\tconst char *value)\n{\n\tchar **env;\n\tu_int envsize;\n\tu_int i, namelen;\n\n\tif (strchr(name, '=') != NULL) {\n\t\terror(\"Invalid environment variable \\\"%.100s\\\"\", name);\n\t\treturn;\n\t}\n\n\t/*\n\t * If we're passed an uninitialized list, allocate a single null\n\t * entry before continuing.\n\t */\n\tif (*envp == NULL && *envsizep == 0) {\n\t\t*envp = xmalloc(sizeof(char *));\n\t\t*envp[0] = NULL;\n\t\t*envsizep = 1;\n\t}\n\n\t/*\n\t * Find the slot where the value should be stored.  If the variable\n\t * already exists, we reuse the slot; otherwise we append a new slot\n\t * at the end of the array, expanding if necessary.\n\t */\n\tenv = *envp;\n\tnamelen = strlen(name);\n\tfor (i = 0; env[i]; i++)\n\t\tif (strncmp(env[i], name, namelen) == 0 && env[i][namelen] == '=')\n\t\t\tbreak;\n\tif (env[i]) {\n\t\t/* Reuse the slot. */\n\t\tfree(env[i]);\n\t} else {\n\t\t/* New variable.  Expand if necessary. */\n\t\tenvsize = *envsizep;\n\t\tif (i >= envsize - 1) {\n\t\t\tif (envsize >= 1000)\n\t\t\t\tfatal(\"child_set_env: too many env vars\");\n\t\t\tenvsize += 50;\n\t\t\tenv = (*envp) = xreallocarray(env, envsize, sizeof(char *));\n\t\t\t*envsizep = envsize;\n\t\t}\n\t\t/* Need to set the NULL pointer at end of array beyond the new slot. */\n\t\tenv[i + 1] = NULL;\n\t}\n\n\t/* Allocate space and format the variable in the appropriate slot. */\n\t/* XXX xasprintf */\n\tenv[i] = xmalloc(strlen(name) + 1 + strlen(value) + 1);\n\tsnprintf(env[i], strlen(name) + 1 + strlen(value) + 1, \"%s=%s\", name, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LANG\""
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "pam_getenvlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-pam.c",
          "lines": "254-263",
          "snippet": "static char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}",
          "includes": [
            "#include <pthread.h>",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"log.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <pam/pam_appl.h>",
            "#include <security/pam_appl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <pam/pam_appl.h>\n#include <security/pam_appl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t/*\n\t * XXX - If necessary, we can still support envrionment passing\n\t * for platforms without pam_getenvlist by searching for known\n\t * env vars (e.g. KRB5CCNAME) from the PAM environment.\n\t */\n\t return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "sizeof(*child_env)",
            "envsize"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "platform_post_fork_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
          "lines": "69-78",
          "snippet": "void\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_uid",
          "args": [],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "restore_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "141-172",
          "snippet": "void\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "p"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_path",
          "args": [
            "av[0]",
            "&st",
            "NULL",
            "0",
            "errmsg",
            "sizeof(errmsg)"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "safe_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1768-1824",
          "snippet": "int\nsafe_path(const char *name, struct stat *stp, const char *pw_dir,\n    uid_t uid, char *err, size_t errlen)\n{\n\tchar buf[PATH_MAX], homedir[PATH_MAX];\n\tchar *cp;\n\tint comparehome = 0;\n\tstruct stat st;\n\n\tif (realpath(name, buf) == NULL) {\n\t\tsnprintf(err, errlen, \"realpath %s failed: %s\", name,\n\t\t    strerror(errno));\n\t\treturn -1;\n\t}\n\tif (pw_dir != NULL && realpath(pw_dir, homedir) != NULL)\n\t\tcomparehome = 1;\n\n\tif (!S_ISREG(stp->st_mode)) {\n\t\tsnprintf(err, errlen, \"%s is not a regular file\", buf);\n\t\treturn -1;\n\t}\n\tif ((!platform_sys_dir_uid(stp->st_uid) && stp->st_uid != uid) ||\n\t    (stp->st_mode & 022) != 0) {\n\t\tsnprintf(err, errlen, \"bad ownership or modes for file %s\",\n\t\t    buf);\n\t\treturn -1;\n\t}\n\n\t/* for each component of the canonical path, walking upwards */\n\tfor (;;) {\n\t\tif ((cp = dirname(buf)) == NULL) {\n\t\t\tsnprintf(err, errlen, \"dirname() failed\");\n\t\t\treturn -1;\n\t\t}\n\t\tstrlcpy(buf, cp, sizeof(buf));\n\n\t\tif (stat(buf, &st) < 0 ||\n\t\t    (!platform_sys_dir_uid(st.st_uid) && st.st_uid != uid) ||\n\t\t    (st.st_mode & 022) != 0) {\n\t\t\tsnprintf(err, errlen,\n\t\t\t    \"bad ownership or modes for directory %s\", buf);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* If are past the homedir then we can stop */\n\t\tif (comparehome && strcmp(homedir, buf) == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * dirname should always complete with a \"/\" path,\n\t\t * but we can be paranoid and check for \".\" too\n\t\t */\n\t\tif ((strcmp(\"/\", buf) == 0) || (strcmp(\".\", buf) == 0))\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsafe_path(const char *name, struct stat *stp, const char *pw_dir,\n    uid_t uid, char *err, size_t errlen)\n{\n\tchar buf[PATH_MAX], homedir[PATH_MAX];\n\tchar *cp;\n\tint comparehome = 0;\n\tstruct stat st;\n\n\tif (realpath(name, buf) == NULL) {\n\t\tsnprintf(err, errlen, \"realpath %s failed: %s\", name,\n\t\t    strerror(errno));\n\t\treturn -1;\n\t}\n\tif (pw_dir != NULL && realpath(pw_dir, homedir) != NULL)\n\t\tcomparehome = 1;\n\n\tif (!S_ISREG(stp->st_mode)) {\n\t\tsnprintf(err, errlen, \"%s is not a regular file\", buf);\n\t\treturn -1;\n\t}\n\tif ((!platform_sys_dir_uid(stp->st_uid) && stp->st_uid != uid) ||\n\t    (stp->st_mode & 022) != 0) {\n\t\tsnprintf(err, errlen, \"bad ownership or modes for file %s\",\n\t\t    buf);\n\t\treturn -1;\n\t}\n\n\t/* for each component of the canonical path, walking upwards */\n\tfor (;;) {\n\t\tif ((cp = dirname(buf)) == NULL) {\n\t\t\tsnprintf(err, errlen, \"dirname() failed\");\n\t\t\treturn -1;\n\t\t}\n\t\tstrlcpy(buf, cp, sizeof(buf));\n\n\t\tif (stat(buf, &st) < 0 ||\n\t\t    (!platform_sys_dir_uid(st.st_uid) && st.st_uid != uid) ||\n\t\t    (st.st_mode & 022) != 0) {\n\t\t\tsnprintf(err, errlen,\n\t\t\t    \"bad ownership or modes for directory %s\", buf);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* If are past the homedir then we can stop */\n\t\tif (comparehome && strcmp(homedir, buf) == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * dirname should always complete with a \"/\" path,\n\t\t * but we can be paranoid and check for \".\" too\n\t\t */\n\t\tif ((strcmp(\"/\", buf) == 0) || (strcmp(\".\", buf) == 0))\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "av[0]",
            "&st"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "temporarily_use_uid",
          "args": [
            "pw"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "temporarily_use_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "60-136",
          "snippet": "void\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static uid_t\tuser_groups_uid;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic uid_t\tuser_groups_uid;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\npid_t\nsubprocess(const char *tag, struct passwd *pw, const char *command,\n    int ac, char **av, FILE **child, u_int flags)\n{\n\tFILE *f = NULL;\n\tstruct stat st;\n\tint fd, devnull, p[2], i;\n\tpid_t pid;\n\tchar *cp, errmsg[512];\n\tu_int envsize;\n\tchar **child_env;\n\n\tif (child != NULL)\n\t\t*child = NULL;\n\n\tdebug3(\"%s: %s command \\\"%s\\\" running as %s (flags 0x%x)\", __func__,\n\t    tag, command, pw->pw_name, flags);\n\n\t/* Check consistency */\n\tif ((flags & SSH_SUBPROCESS_STDOUT_DISCARD) != 0 &&\n\t    (flags & SSH_SUBPROCESS_STDOUT_CAPTURE) != 0) {\n\t\terror(\"%s: inconsistent flags\", __func__);\n\t\treturn 0;\n\t}\n\tif (((flags & SSH_SUBPROCESS_STDOUT_CAPTURE) == 0) != (child == NULL)) {\n\t\terror(\"%s: inconsistent flags/output\", __func__);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If executing an explicit binary, then verify the it exists\n\t * and appears safe-ish to execute\n\t */\n\tif (*av[0] != '/') {\n\t\terror(\"%s path is not absolute\", tag);\n\t\treturn 0;\n\t}\n\ttemporarily_use_uid(pw);\n\tif (stat(av[0], &st) < 0) {\n\t\terror(\"Could not stat %s \\\"%s\\\": %s\", tag,\n\t\t    av[0], strerror(errno));\n\t\trestore_uid();\n\t\treturn 0;\n\t}\n\tif (safe_path(av[0], &st, NULL, 0, errmsg, sizeof(errmsg)) != 0) {\n\t\terror(\"Unsafe %s \\\"%s\\\": %s\", tag, av[0], errmsg);\n\t\trestore_uid();\n\t\treturn 0;\n\t}\n\t/* Prepare to keep the child's stdout if requested */\n\tif (pipe(p) != 0) {\n\t\terror(\"%s: pipe: %s\", tag, strerror(errno));\n\t\trestore_uid();\n\t\treturn 0;\n\t}\n\trestore_uid();\n\n\tswitch ((pid = fork())) {\n\tcase -1: /* error */\n\t\terror(\"%s: fork: %s\", tag, strerror(errno));\n\t\tclose(p[0]);\n\t\tclose(p[1]);\n\t\treturn 0;\n\tcase 0: /* child */\n\t\t/* Prepare a minimal environment for the child. */\n\t\tenvsize = 5;\n\t\tchild_env = xcalloc(sizeof(*child_env), envsize);\n\t\tchild_set_env(&child_env, &envsize, \"PATH\", _PATH_STDPATH);\n\t\tchild_set_env(&child_env, &envsize, \"USER\", pw->pw_name);\n\t\tchild_set_env(&child_env, &envsize, \"LOGNAME\", pw->pw_name);\n\t\tchild_set_env(&child_env, &envsize, \"HOME\", pw->pw_dir);\n\t\tif ((cp = getenv(\"LANG\")) != NULL)\n\t\t\tchild_set_env(&child_env, &envsize, \"LANG\", cp);\n\n\t\tfor (i = 0; i < NSIG; i++)\n\t\t\tsignal(i, SIG_DFL);\n\n\t\tif ((devnull = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\t\terror(\"%s: open %s: %s\", tag, _PATH_DEVNULL,\n\t\t\t    strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tif (dup2(devnull, STDIN_FILENO) == -1) {\n\t\t\terror(\"%s: dup2: %s\", tag, strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\n\t\t/* Set up stdout as requested; leave stderr in place for now. */\n\t\tfd = -1;\n\t\tif ((flags & SSH_SUBPROCESS_STDOUT_CAPTURE) != 0)\n\t\t\tfd = p[1];\n\t\telse if ((flags & SSH_SUBPROCESS_STDOUT_DISCARD) != 0)\n\t\t\tfd = devnull;\n\t\tif (fd != -1 && dup2(fd, STDOUT_FILENO) == -1) {\n\t\t\terror(\"%s: dup2: %s\", tag, strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tclosefrom(STDERR_FILENO + 1);\n\n\t\t/* Don't use permanently_set_uid() here to avoid fatal() */\n\t\tif (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) != 0) {\n\t\t\terror(\"%s: setresgid %u: %s\", tag, (u_int)pw->pw_gid,\n\t\t\t    strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tif (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) != 0) {\n\t\t\terror(\"%s: setresuid %u: %s\", tag, (u_int)pw->pw_uid,\n\t\t\t    strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\t/* stdin is pointed to /dev/null at this point */\n\t\tif ((flags & SSH_SUBPROCESS_STDOUT_DISCARD) != 0 &&\n\t\t    dup2(STDIN_FILENO, STDERR_FILENO) == -1) {\n\t\t\terror(\"%s: dup2: %s\", tag, strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\n\t\texecve(av[0], av, child_env);\n\t\terror(\"%s exec \\\"%s\\\": %s\", tag, command, strerror(errno));\n\t\t_exit(127);\n\tdefault: /* parent */\n\t\tbreak;\n\t}\n\n\tclose(p[1]);\n\tif ((flags & SSH_SUBPROCESS_STDOUT_CAPTURE) == 0)\n\t\tclose(p[0]);\n\telse if ((f = fdopen(p[0], \"r\")) == NULL) {\n\t\terror(\"%s: fdopen: %s\", tag, strerror(errno));\n\t\tclose(p[0]);\n\t\t/* Don't leave zombie child */\n\t\tkill(pid, SIGTERM);\n\t\twhile (waitpid(pid, NULL, 0) == -1 && errno == EINTR)\n\t\t\t;\n\t\treturn 0;\n\t}\n\t/* Success */\n\tdebug3(\"%s: %s pid %ld\", __func__, tag, (long)pid);\n\tif (child != NULL)\n\t\t*child = f;\n\treturn pid;\n}"
  },
  {
    "function_name": "auth_get_canonical_hostname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
    "lines": "839-852",
    "snippet": "const char *\nauth_get_canonical_hostname(struct ssh *ssh, int use_dns)\n{\n\tstatic char *dnsname;\n\n\tif (!use_dns)\n\t\treturn ssh_remote_ipaddr(ssh);\n\telse if (dnsname != NULL)\n\t\treturn dnsname;\n\telse {\n\t\tdnsname = remote_hostname(ssh);\n\t\treturn dnsname;\n\t}\n}",
    "includes": [
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"authfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"loginrec.h\"",
      "#include \"packet.h\"",
      "#include \"uidswap.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"groupaccess.h\"",
      "#include \"match.h\"",
      "#include \"xmalloc.h\"",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <shadow.h>",
      "#include <login.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remote_hostname",
          "args": [
            "ssh"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "remote_hostname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "750-831",
          "snippet": "static char *\nremote_hostname(struct ssh *ssh)\n{\n\tstruct sockaddr_storage from;\n\tsocklen_t fromlen;\n\tstruct addrinfo hints, *ai, *aitop;\n\tchar name[NI_MAXHOST], ntop2[NI_MAXHOST];\n\tconst char *ntop = ssh_remote_ipaddr(ssh);\n\n\t/* Get IP address of client. */\n\tfromlen = sizeof(from);\n\tmemset(&from, 0, sizeof(from));\n\tif (getpeername(ssh_packet_get_connection_in(ssh),\n\t    (struct sockaddr *)&from, &fromlen) < 0) {\n\t\tdebug(\"getpeername failed: %.100s\", strerror(errno));\n\t\treturn strdup(ntop);\n\t}\n\n\tipv64_normalise_mapped(&from, &fromlen);\n\tif (from.ss_family == AF_INET6)\n\t\tfromlen = sizeof(struct sockaddr_in6);\n\n\tdebug3(\"Trying to reverse map address %.100s.\", ntop);\n\t/* Map the IP address to a host name. */\n\tif (getnameinfo((struct sockaddr *)&from, fromlen, name, sizeof(name),\n\t    NULL, 0, NI_NAMEREQD) != 0) {\n\t\t/* Host name not found.  Use ip address. */\n\t\treturn strdup(ntop);\n\t}\n\n\t/*\n\t * if reverse lookup result looks like a numeric hostname,\n\t * someone is trying to trick us by PTR record like following:\n\t *\t1.1.1.10.in-addr.arpa.\tIN PTR\t2.3.4.5\n\t */\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_socktype = SOCK_DGRAM;\t/*dummy*/\n\thints.ai_flags = AI_NUMERICHOST;\n\tif (getaddrinfo(name, NULL, &hints, &ai) == 0) {\n\t\tlogit(\"Nasty PTR record \\\"%s\\\" is set up for %s, ignoring\",\n\t\t    name, ntop);\n\t\tfreeaddrinfo(ai);\n\t\treturn strdup(ntop);\n\t}\n\n\t/* Names are stored in lowercase. */\n\tlowercase(name);\n\n\t/*\n\t * Map it back to an IP address and check that the given\n\t * address actually is an address of this host.  This is\n\t * necessary because anyone with access to a name server can\n\t * define arbitrary names for an IP address. Mapping from\n\t * name to IP address can be trusted better (but can still be\n\t * fooled if the intruder has access to the name server of\n\t * the domain).\n\t */\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = from.ss_family;\n\thints.ai_socktype = SOCK_STREAM;\n\tif (getaddrinfo(name, NULL, &hints, &aitop) != 0) {\n\t\tlogit(\"reverse mapping checking getaddrinfo for %.700s \"\n\t\t    \"[%s] failed.\", name, ntop);\n\t\treturn strdup(ntop);\n\t}\n\t/* Look for the address from the list of addresses. */\n\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\tif (getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop2,\n\t\t    sizeof(ntop2), NULL, 0, NI_NUMERICHOST) == 0 &&\n\t\t    (strcmp(ntop, ntop2) == 0))\n\t\t\t\tbreak;\n\t}\n\tfreeaddrinfo(aitop);\n\t/* If we reached the end of the list, the address was not there. */\n\tif (ai == NULL) {\n\t\t/* Address not found for the host name. */\n\t\tlogit(\"Address %.100s maps to %.600s, but this does not \"\n\t\t    \"map back to the address.\", ntop, name);\n\t\treturn strdup(ntop);\n\t}\n\treturn strdup(name);\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nremote_hostname(struct ssh *ssh)\n{\n\tstruct sockaddr_storage from;\n\tsocklen_t fromlen;\n\tstruct addrinfo hints, *ai, *aitop;\n\tchar name[NI_MAXHOST], ntop2[NI_MAXHOST];\n\tconst char *ntop = ssh_remote_ipaddr(ssh);\n\n\t/* Get IP address of client. */\n\tfromlen = sizeof(from);\n\tmemset(&from, 0, sizeof(from));\n\tif (getpeername(ssh_packet_get_connection_in(ssh),\n\t    (struct sockaddr *)&from, &fromlen) < 0) {\n\t\tdebug(\"getpeername failed: %.100s\", strerror(errno));\n\t\treturn strdup(ntop);\n\t}\n\n\tipv64_normalise_mapped(&from, &fromlen);\n\tif (from.ss_family == AF_INET6)\n\t\tfromlen = sizeof(struct sockaddr_in6);\n\n\tdebug3(\"Trying to reverse map address %.100s.\", ntop);\n\t/* Map the IP address to a host name. */\n\tif (getnameinfo((struct sockaddr *)&from, fromlen, name, sizeof(name),\n\t    NULL, 0, NI_NAMEREQD) != 0) {\n\t\t/* Host name not found.  Use ip address. */\n\t\treturn strdup(ntop);\n\t}\n\n\t/*\n\t * if reverse lookup result looks like a numeric hostname,\n\t * someone is trying to trick us by PTR record like following:\n\t *\t1.1.1.10.in-addr.arpa.\tIN PTR\t2.3.4.5\n\t */\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_socktype = SOCK_DGRAM;\t/*dummy*/\n\thints.ai_flags = AI_NUMERICHOST;\n\tif (getaddrinfo(name, NULL, &hints, &ai) == 0) {\n\t\tlogit(\"Nasty PTR record \\\"%s\\\" is set up for %s, ignoring\",\n\t\t    name, ntop);\n\t\tfreeaddrinfo(ai);\n\t\treturn strdup(ntop);\n\t}\n\n\t/* Names are stored in lowercase. */\n\tlowercase(name);\n\n\t/*\n\t * Map it back to an IP address and check that the given\n\t * address actually is an address of this host.  This is\n\t * necessary because anyone with access to a name server can\n\t * define arbitrary names for an IP address. Mapping from\n\t * name to IP address can be trusted better (but can still be\n\t * fooled if the intruder has access to the name server of\n\t * the domain).\n\t */\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = from.ss_family;\n\thints.ai_socktype = SOCK_STREAM;\n\tif (getaddrinfo(name, NULL, &hints, &aitop) != 0) {\n\t\tlogit(\"reverse mapping checking getaddrinfo for %.700s \"\n\t\t    \"[%s] failed.\", name, ntop);\n\t\treturn strdup(ntop);\n\t}\n\t/* Look for the address from the list of addresses. */\n\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\tif (getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop2,\n\t\t    sizeof(ntop2), NULL, 0, NI_NUMERICHOST) == 0 &&\n\t\t    (strcmp(ntop, ntop2) == 0))\n\t\t\t\tbreak;\n\t}\n\tfreeaddrinfo(aitop);\n\t/* If we reached the end of the list, the address was not there. */\n\tif (ai == NULL) {\n\t\t/* Address not found for the host name. */\n\t\tlogit(\"Address %.100s maps to %.600s, but this does not \"\n\t\t    \"map back to the address.\", ntop, name);\n\t\treturn strdup(ntop);\n\t}\n\treturn strdup(name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_ipaddr",
          "args": [
            "ssh"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "514-535",
          "snippet": "const char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nauth_get_canonical_hostname(struct ssh *ssh, int use_dns)\n{\n\tstatic char *dnsname;\n\n\tif (!use_dns)\n\t\treturn ssh_remote_ipaddr(ssh);\n\telse if (dnsname != NULL)\n\t\treturn dnsname;\n\telse {\n\t\tdnsname = remote_hostname(ssh);\n\t\treturn dnsname;\n\t}\n}"
  },
  {
    "function_name": "remote_hostname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
    "lines": "750-831",
    "snippet": "static char *\nremote_hostname(struct ssh *ssh)\n{\n\tstruct sockaddr_storage from;\n\tsocklen_t fromlen;\n\tstruct addrinfo hints, *ai, *aitop;\n\tchar name[NI_MAXHOST], ntop2[NI_MAXHOST];\n\tconst char *ntop = ssh_remote_ipaddr(ssh);\n\n\t/* Get IP address of client. */\n\tfromlen = sizeof(from);\n\tmemset(&from, 0, sizeof(from));\n\tif (getpeername(ssh_packet_get_connection_in(ssh),\n\t    (struct sockaddr *)&from, &fromlen) < 0) {\n\t\tdebug(\"getpeername failed: %.100s\", strerror(errno));\n\t\treturn strdup(ntop);\n\t}\n\n\tipv64_normalise_mapped(&from, &fromlen);\n\tif (from.ss_family == AF_INET6)\n\t\tfromlen = sizeof(struct sockaddr_in6);\n\n\tdebug3(\"Trying to reverse map address %.100s.\", ntop);\n\t/* Map the IP address to a host name. */\n\tif (getnameinfo((struct sockaddr *)&from, fromlen, name, sizeof(name),\n\t    NULL, 0, NI_NAMEREQD) != 0) {\n\t\t/* Host name not found.  Use ip address. */\n\t\treturn strdup(ntop);\n\t}\n\n\t/*\n\t * if reverse lookup result looks like a numeric hostname,\n\t * someone is trying to trick us by PTR record like following:\n\t *\t1.1.1.10.in-addr.arpa.\tIN PTR\t2.3.4.5\n\t */\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_socktype = SOCK_DGRAM;\t/*dummy*/\n\thints.ai_flags = AI_NUMERICHOST;\n\tif (getaddrinfo(name, NULL, &hints, &ai) == 0) {\n\t\tlogit(\"Nasty PTR record \\\"%s\\\" is set up for %s, ignoring\",\n\t\t    name, ntop);\n\t\tfreeaddrinfo(ai);\n\t\treturn strdup(ntop);\n\t}\n\n\t/* Names are stored in lowercase. */\n\tlowercase(name);\n\n\t/*\n\t * Map it back to an IP address and check that the given\n\t * address actually is an address of this host.  This is\n\t * necessary because anyone with access to a name server can\n\t * define arbitrary names for an IP address. Mapping from\n\t * name to IP address can be trusted better (but can still be\n\t * fooled if the intruder has access to the name server of\n\t * the domain).\n\t */\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = from.ss_family;\n\thints.ai_socktype = SOCK_STREAM;\n\tif (getaddrinfo(name, NULL, &hints, &aitop) != 0) {\n\t\tlogit(\"reverse mapping checking getaddrinfo for %.700s \"\n\t\t    \"[%s] failed.\", name, ntop);\n\t\treturn strdup(ntop);\n\t}\n\t/* Look for the address from the list of addresses. */\n\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\tif (getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop2,\n\t\t    sizeof(ntop2), NULL, 0, NI_NUMERICHOST) == 0 &&\n\t\t    (strcmp(ntop, ntop2) == 0))\n\t\t\t\tbreak;\n\t}\n\tfreeaddrinfo(aitop);\n\t/* If we reached the end of the list, the address was not there. */\n\tif (ai == NULL) {\n\t\t/* Address not found for the host name. */\n\t\tlogit(\"Address %.100s maps to %.600s, but this does not \"\n\t\t    \"map back to the address.\", ntop, name);\n\t\treturn strdup(ntop);\n\t}\n\treturn strdup(name);\n}",
    "includes": [
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"authfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"loginrec.h\"",
      "#include \"packet.h\"",
      "#include \"uidswap.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"groupaccess.h\"",
      "#include \"match.h\"",
      "#include \"xmalloc.h\"",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <shadow.h>",
      "#include <login.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "name"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Address %.100s maps to %.600s, but this does not \"\n\t\t    \"map back to the address.\"",
            "ntop",
            "name"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "aitop"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ntop",
            "ntop2"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getnameinfo",
          "args": [
            "ai->ai_addr",
            "ai->ai_addrlen",
            "ntop2",
            "sizeof(ntop2)",
            "NULL",
            "0",
            "NI_NUMERICHOST"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "sshaix_getnameinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "415-434",
          "snippet": "int\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nint\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "name",
            "NULL",
            "&hints",
            "&aitop"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "getaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "154-234",
          "snippet": "int\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hints",
            "0",
            "sizeof(hints)"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lowercase",
          "args": [
            "name"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "lowercase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1480-1485",
          "snippet": "void\nlowercase(char *s)\n{\n\tfor (; *s; s++)\n\t\t*s = tolower((u_char)*s);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlowercase(char *s)\n{\n\tfor (; *s; s++)\n\t\t*s = tolower((u_char)*s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hints",
            "0",
            "sizeof(hints)"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Trying to reverse map address %.100s.\"",
            "ntop"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ipv64_normalise_mapped",
          "args": [
            "&from",
            "&fromlen"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "ipv64_normalise_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "38-61",
          "snippet": "void\nipv64_normalise_mapped(struct sockaddr_storage *addr, socklen_t *len)\n{\n\tstruct sockaddr_in6 *a6 = (struct sockaddr_in6 *)addr;\n\tstruct sockaddr_in *a4 = (struct sockaddr_in *)addr;\n\tstruct in_addr inaddr;\n\tu_int16_t port;\n\n\tif (addr->ss_family != AF_INET6 ||\n\t    !IN6_IS_ADDR_V4MAPPED(&a6->sin6_addr))\n\t\treturn;\n\n\tdebug3(\"Normalising mapped IPv4 in IPv6 address\");\n\n\tmemcpy(&inaddr, ((char *)&a6->sin6_addr) + 12, sizeof(inaddr));\n\tport = a6->sin6_port;\n\n\tmemset(a4, 0, sizeof(*a4));\n\n\ta4->sin_family = AF_INET;\n\t*len = sizeof(*a4);\n\tmemcpy(&a4->sin_addr, &inaddr, sizeof(inaddr));\n\ta4->sin_port = port;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nipv64_normalise_mapped(struct sockaddr_storage *addr, socklen_t *len)\n{\n\tstruct sockaddr_in6 *a6 = (struct sockaddr_in6 *)addr;\n\tstruct sockaddr_in *a4 = (struct sockaddr_in *)addr;\n\tstruct in_addr inaddr;\n\tu_int16_t port;\n\n\tif (addr->ss_family != AF_INET6 ||\n\t    !IN6_IS_ADDR_V4MAPPED(&a6->sin6_addr))\n\t\treturn;\n\n\tdebug3(\"Normalising mapped IPv4 in IPv6 address\");\n\n\tmemcpy(&inaddr, ((char *)&a6->sin6_addr) + 12, sizeof(inaddr));\n\tport = a6->sin6_port;\n\n\tmemset(a4, 0, sizeof(*a4));\n\n\ta4->sin_family = AF_INET;\n\t*len = sizeof(*a4);\n\tmemcpy(&a4->sin_addr, &inaddr, sizeof(inaddr));\n\ta4->sin_port = port;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"getpeername failed: %.100s\"",
            "strerror(errno)"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "auth_debug_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "673-688",
          "snippet": "void\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sshbuf *auth_debug;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshbuf *auth_debug;\n\nvoid\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpeername",
          "args": [
            "ssh_packet_get_connection_in(ssh)",
            "(struct sockaddr *)&from",
            "&fromlen"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_packet_get_connection_in",
          "args": [
            "ssh"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_get_connection_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "495-499",
          "snippet": "int\nssh_packet_get_connection_in(struct ssh *ssh)\n{\n\treturn ssh->state->connection_in;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_packet_get_connection_in(struct ssh *ssh)\n{\n\treturn ssh->state->connection_in;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&from",
            "0",
            "sizeof(from)"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_remote_ipaddr",
          "args": [
            "ssh"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "514-535",
          "snippet": "const char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nremote_hostname(struct ssh *ssh)\n{\n\tstruct sockaddr_storage from;\n\tsocklen_t fromlen;\n\tstruct addrinfo hints, *ai, *aitop;\n\tchar name[NI_MAXHOST], ntop2[NI_MAXHOST];\n\tconst char *ntop = ssh_remote_ipaddr(ssh);\n\n\t/* Get IP address of client. */\n\tfromlen = sizeof(from);\n\tmemset(&from, 0, sizeof(from));\n\tif (getpeername(ssh_packet_get_connection_in(ssh),\n\t    (struct sockaddr *)&from, &fromlen) < 0) {\n\t\tdebug(\"getpeername failed: %.100s\", strerror(errno));\n\t\treturn strdup(ntop);\n\t}\n\n\tipv64_normalise_mapped(&from, &fromlen);\n\tif (from.ss_family == AF_INET6)\n\t\tfromlen = sizeof(struct sockaddr_in6);\n\n\tdebug3(\"Trying to reverse map address %.100s.\", ntop);\n\t/* Map the IP address to a host name. */\n\tif (getnameinfo((struct sockaddr *)&from, fromlen, name, sizeof(name),\n\t    NULL, 0, NI_NAMEREQD) != 0) {\n\t\t/* Host name not found.  Use ip address. */\n\t\treturn strdup(ntop);\n\t}\n\n\t/*\n\t * if reverse lookup result looks like a numeric hostname,\n\t * someone is trying to trick us by PTR record like following:\n\t *\t1.1.1.10.in-addr.arpa.\tIN PTR\t2.3.4.5\n\t */\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_socktype = SOCK_DGRAM;\t/*dummy*/\n\thints.ai_flags = AI_NUMERICHOST;\n\tif (getaddrinfo(name, NULL, &hints, &ai) == 0) {\n\t\tlogit(\"Nasty PTR record \\\"%s\\\" is set up for %s, ignoring\",\n\t\t    name, ntop);\n\t\tfreeaddrinfo(ai);\n\t\treturn strdup(ntop);\n\t}\n\n\t/* Names are stored in lowercase. */\n\tlowercase(name);\n\n\t/*\n\t * Map it back to an IP address and check that the given\n\t * address actually is an address of this host.  This is\n\t * necessary because anyone with access to a name server can\n\t * define arbitrary names for an IP address. Mapping from\n\t * name to IP address can be trusted better (but can still be\n\t * fooled if the intruder has access to the name server of\n\t * the domain).\n\t */\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = from.ss_family;\n\thints.ai_socktype = SOCK_STREAM;\n\tif (getaddrinfo(name, NULL, &hints, &aitop) != 0) {\n\t\tlogit(\"reverse mapping checking getaddrinfo for %.700s \"\n\t\t    \"[%s] failed.\", name, ntop);\n\t\treturn strdup(ntop);\n\t}\n\t/* Look for the address from the list of addresses. */\n\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\tif (getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop2,\n\t\t    sizeof(ntop2), NULL, 0, NI_NUMERICHOST) == 0 &&\n\t\t    (strcmp(ntop, ntop2) == 0))\n\t\t\t\tbreak;\n\t}\n\tfreeaddrinfo(aitop);\n\t/* If we reached the end of the list, the address was not there. */\n\tif (ai == NULL) {\n\t\t/* Address not found for the host name. */\n\t\tlogit(\"Address %.100s maps to %.600s, but this does not \"\n\t\t    \"map back to the address.\", ntop, name);\n\t\treturn strdup(ntop);\n\t}\n\treturn strdup(name);\n}"
  },
  {
    "function_name": "fakepw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
    "lines": "717-738",
    "snippet": "struct passwd *\nfakepw(void)\n{\n\tstatic struct passwd fake;\n\n\tmemset(&fake, 0, sizeof(fake));\n\tfake.pw_name = \"NOUSER\";\n\tfake.pw_passwd =\n\t    \"$2a$06$r3.juUaHZDlIbQaO2dS9FuYxL1W9M81R1Tc92PoSNmzvpEqLkLGrK\";\n#ifdef HAVE_STRUCT_PASSWD_PW_GECOS\n\tfake.pw_gecos = \"NOUSER\";\n#endif\n\tfake.pw_uid = privsep_pw == NULL ? (uid_t)-1 : privsep_pw->pw_uid;\n\tfake.pw_gid = privsep_pw == NULL ? (gid_t)-1 : privsep_pw->pw_gid;\n#ifdef HAVE_STRUCT_PASSWD_PW_CLASS\n\tfake.pw_class = \"\";\n#endif\n\tfake.pw_dir = \"/nonexist\";\n\tfake.pw_shell = \"/nonexist\";\n\n\treturn (&fake);\n}",
    "includes": [
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"authfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"loginrec.h\"",
      "#include \"packet.h\"",
      "#include \"uidswap.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"groupaccess.h\"",
      "#include \"match.h\"",
      "#include \"xmalloc.h\"",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <shadow.h>",
      "#include <login.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct passwd *privsep_pw;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&fake",
            "0",
            "sizeof(fake)"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern struct passwd *privsep_pw;\n\nstruct passwd *\nfakepw(void)\n{\n\tstatic struct passwd fake;\n\n\tmemset(&fake, 0, sizeof(fake));\n\tfake.pw_name = \"NOUSER\";\n\tfake.pw_passwd =\n\t    \"$2a$06$r3.juUaHZDlIbQaO2dS9FuYxL1W9M81R1Tc92PoSNmzvpEqLkLGrK\";\n#ifdef HAVE_STRUCT_PASSWD_PW_GECOS\n\tfake.pw_gecos = \"NOUSER\";\n#endif\n\tfake.pw_uid = privsep_pw == NULL ? (uid_t)-1 : privsep_pw->pw_uid;\n\tfake.pw_gid = privsep_pw == NULL ? (gid_t)-1 : privsep_pw->pw_gid;\n#ifdef HAVE_STRUCT_PASSWD_PW_CLASS\n\tfake.pw_class = \"\";\n#endif\n\tfake.pw_dir = \"/nonexist\";\n\tfake.pw_shell = \"/nonexist\";\n\n\treturn (&fake);\n}"
  },
  {
    "function_name": "auth_debug_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
    "lines": "708-715",
    "snippet": "void\nauth_debug_reset(void)\n{\n\tif (auth_debug != NULL)\n\t\tsshbuf_reset(auth_debug);\n\telse if ((auth_debug = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n}",
    "includes": [
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"authfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"loginrec.h\"",
      "#include \"packet.h\"",
      "#include \"uidswap.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"groupaccess.h\"",
      "#include \"match.h\"",
      "#include \"xmalloc.h\"",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <shadow.h>",
      "#include <login.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sshbuf *auth_debug;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "auth_debug"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshbuf *auth_debug;\n\nvoid\nauth_debug_reset(void)\n{\n\tif (auth_debug != NULL)\n\t\tsshbuf_reset(auth_debug);\n\telse if ((auth_debug = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n}"
  },
  {
    "function_name": "auth_debug_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
    "lines": "690-706",
    "snippet": "void\nauth_debug_send(void)\n{\n\tstruct ssh *ssh = active_state;\t\t/* XXX */\n\tchar *msg;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\twhile (sshbuf_len(auth_debug) != 0) {\n\t\tif ((r = sshbuf_get_cstring(auth_debug, &msg, NULL)) != 0)\n\t\t\tfatal(\"%s: sshbuf_get_cstring: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\tssh_packet_send_debug(ssh, \"%s\", msg);\n\t\tfree(msg);\n\t}\n}",
    "includes": [
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"authfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"loginrec.h\"",
      "#include \"packet.h\"",
      "#include \"uidswap.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"groupaccess.h\"",
      "#include \"match.h\"",
      "#include \"xmalloc.h\"",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <shadow.h>",
      "#include <login.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sshbuf *auth_debug;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "msg"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_send_debug",
          "args": [
            "ssh",
            "\"%s\"",
            "msg"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_send_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "1771-1794",
          "snippet": "void\nssh_packet_send_debug(struct ssh *ssh, const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif ((ssh->compat & SSH_BUG_DEBUG))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tdebug3(\"sending debug message: %s\", buf);\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_DEBUG)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 0)) != 0 || /* always display */\n\t    (r = sshpkt_put_cstring(ssh, buf)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"\")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_packet_send_debug(struct ssh *ssh, const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif ((ssh->compat & SSH_BUG_DEBUG))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tdebug3(\"sending debug message: %s\", buf);\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_DEBUG)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 0)) != 0 || /* always display */\n\t    (r = sshpkt_put_cstring(ssh, buf)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"\")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_get_cstring: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "auth_debug",
            "&msg",
            "NULL"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "auth_debug"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshbuf *auth_debug;\n\nvoid\nauth_debug_send(void)\n{\n\tstruct ssh *ssh = active_state;\t\t/* XXX */\n\tchar *msg;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\twhile (sshbuf_len(auth_debug) != 0) {\n\t\tif ((r = sshbuf_get_cstring(auth_debug, &msg, NULL)) != 0)\n\t\t\tfatal(\"%s: sshbuf_get_cstring: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\tssh_packet_send_debug(ssh, \"%s\", msg);\n\t\tfree(msg);\n\t}\n}"
  },
  {
    "function_name": "auth_debug_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
    "lines": "673-688",
    "snippet": "void\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}",
    "includes": [
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"authfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"loginrec.h\"",
      "#include \"packet.h\"",
      "#include \"uidswap.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"groupaccess.h\"",
      "#include \"match.h\"",
      "#include \"xmalloc.h\"",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <shadow.h>",
      "#include <login.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sshbuf *auth_debug;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_put_cstring: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "auth_debug",
            "buf"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "fmt",
            "args"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "vsnprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "861-865",
          "snippet": "int\nvsnprintf (char *str, size_t count, const char *fmt, va_list args)\n{\n\treturn dopr(str, count, fmt, args);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nvsnprintf (char *str, size_t count, const char *fmt, va_list args)\n{\n\treturn dopr(str, count, fmt, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshbuf *auth_debug;\n\nvoid\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}"
  },
  {
    "function_name": "auth_key_is_revoked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
    "lines": "635-671",
    "snippet": "int\nauth_key_is_revoked(struct sshkey *key)\n{\n\tchar *fp = NULL;\n\tint r;\n\n\tif (options.revoked_keys_file == NULL)\n\t\treturn 0;\n\tif ((fp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\terror(\"%s: fingerprint key: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\n\tr = sshkey_check_revoked(key, options.revoked_keys_file);\n\tswitch (r) {\n\tcase 0:\n\t\tbreak; /* not revoked */\n\tcase SSH_ERR_KEY_REVOKED:\n\t\terror(\"Authentication key %s %s revoked by file %s\",\n\t\t    sshkey_type(key), fp, options.revoked_keys_file);\n\t\tgoto out;\n\tdefault:\n\t\terror(\"Error checking authentication key %s %s in \"\n\t\t    \"revoked keys file %s: %s\", sshkey_type(key), fp,\n\t\t    options.revoked_keys_file, ssh_err(r));\n\t\tgoto out;\n\t}\n\n\t/* Success */\n\tr = 0;\n\n out:\n\tfree(fp);\n\treturn r == 0 ? 0 : 1;\n}",
    "includes": [
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"authfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"loginrec.h\"",
      "#include \"packet.h\"",
      "#include \"uidswap.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"groupaccess.h\"",
      "#include \"match.h\"",
      "#include \"xmalloc.h\"",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <shadow.h>",
      "#include <login.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fp"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Error checking authentication key %s %s in \"\n\t\t    \"revoked keys file %s: %s\"",
            "sshkey_type(key)",
            "fp",
            "options.revoked_keys_file",
            "ssh_err(r)"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "key"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_check_revoked",
          "args": [
            "key",
            "options.revoked_keys_file"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_check_revoked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "512-537",
          "snippet": "int\nsshkey_check_revoked(struct sshkey *key, const char *revoked_keys_file)\n{\n\tint r;\n\n\tr = ssh_krl_file_contains_key(revoked_keys_file, key);\n\t/* If this was not a KRL to begin with then continue below */\n\tif (r != SSH_ERR_KRL_BAD_MAGIC)\n\t\treturn r;\n\n\t/*\n\t * If the file is not a KRL or we can't handle KRLs then attempt to\n\t * parse the file as a flat list of keys.\n\t */\n\tswitch ((r = sshkey_in_file(key, revoked_keys_file, 0, 1))) {\n\tcase 0:\n\t\t/* Key found => revoked */\n\t\treturn SSH_ERR_KEY_REVOKED;\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\t/* Key not found => not revoked */\n\t\treturn 0;\n\tdefault:\n\t\t/* Some other error occurred */\n\t\treturn r;\n\t}\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_check_revoked(struct sshkey *key, const char *revoked_keys_file)\n{\n\tint r;\n\n\tr = ssh_krl_file_contains_key(revoked_keys_file, key);\n\t/* If this was not a KRL to begin with then continue below */\n\tif (r != SSH_ERR_KRL_BAD_MAGIC)\n\t\treturn r;\n\n\t/*\n\t * If the file is not a KRL or we can't handle KRLs then attempt to\n\t * parse the file as a flat list of keys.\n\t */\n\tswitch ((r = sshkey_in_file(key, revoked_keys_file, 0, 1))) {\n\tcase 0:\n\t\t/* Key found => revoked */\n\t\treturn SSH_ERR_KEY_REVOKED;\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\t/* Key not found => not revoked */\n\t\treturn 0;\n\tdefault:\n\t\t/* Some other error occurred */\n\t\treturn r;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "key",
            "options.fingerprint_hash",
            "SSH_FP_DEFAULT"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nint\nauth_key_is_revoked(struct sshkey *key)\n{\n\tchar *fp = NULL;\n\tint r;\n\n\tif (options.revoked_keys_file == NULL)\n\t\treturn 0;\n\tif ((fp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\terror(\"%s: fingerprint key: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\n\tr = sshkey_check_revoked(key, options.revoked_keys_file);\n\tswitch (r) {\n\tcase 0:\n\t\tbreak; /* not revoked */\n\tcase SSH_ERR_KEY_REVOKED:\n\t\terror(\"Authentication key %s %s revoked by file %s\",\n\t\t    sshkey_type(key), fp, options.revoked_keys_file);\n\t\tgoto out;\n\tdefault:\n\t\terror(\"Error checking authentication key %s %s in \"\n\t\t    \"revoked keys file %s: %s\", sshkey_type(key), fp,\n\t\t    options.revoked_keys_file, ssh_err(r));\n\t\tgoto out;\n\t}\n\n\t/* Success */\n\tr = 0;\n\n out:\n\tfree(fp);\n\treturn r == 0 ? 0 : 1;\n}"
  },
  {
    "function_name": "getpwnamallow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
    "lines": "560-632",
    "snippet": "struct passwd *\ngetpwnamallow(const char *user)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n#ifdef HAVE_LOGIN_CAP\n\textern login_cap_t *lc;\n#ifdef BSD_AUTH\n\tauth_session_t *as;\n#endif\n#endif\n\tstruct passwd *pw;\n\tstruct connection_info *ci = get_connection_info(1, options.use_dns);\n\n\tci->user = user;\n\tparse_server_match_config(&options, ci);\n\tlog_change_level(options.log_level);\n\tprocess_permitopen(ssh, &options);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_setauthdb(user);\n#endif\n\n\tpw = getpwnam(user);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_restoreauthdb();\n#endif\n#ifdef HAVE_CYGWIN\n\t/*\n\t * Windows usernames are case-insensitive.  To avoid later problems\n\t * when trying to match the username, the user is only allowed to\n\t * login if the username is given in the same case as stored in the\n\t * user database.\n\t */\n\tif (pw != NULL && strcmp(user, pw->pw_name) != 0) {\n\t\tlogit(\"Login name %.100s does not match stored username %.100s\",\n\t\t    user, pw->pw_name);\n\t\tpw = NULL;\n\t}\n#endif\n\tif (pw == NULL) {\n\t\tlogit(\"Invalid user %.100s from %.100s port %d\",\n\t\t    user, ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n#ifdef CUSTOM_FAILED_LOGIN\n\t\trecord_failed_login(user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\");\n#endif\n#ifdef SSH_AUDIT_EVENTS\n\t\taudit_event(SSH_INVALID_USER);\n#endif /* SSH_AUDIT_EVENTS */\n\t\treturn (NULL);\n\t}\n\tif (!allowed_user(pw))\n\t\treturn (NULL);\n#ifdef HAVE_LOGIN_CAP\n\tif ((lc = login_getclass(pw->pw_class)) == NULL) {\n\t\tdebug(\"unable to get login class: %s\", user);\n\t\treturn (NULL);\n\t}\n#ifdef BSD_AUTH\n\tif ((as = auth_open()) == NULL || auth_setpwd(as, pw) != 0 ||\n\t    auth_approval(as, lc, pw->pw_name, \"ssh\") <= 0) {\n\t\tdebug(\"Approval failure for %s\", user);\n\t\tpw = NULL;\n\t}\n\tif (as != NULL)\n\t\tauth_close(as);\n#endif\n#endif\n\tif (pw != NULL)\n\t\treturn (pwcopy(pw));\n\treturn (NULL);\n}",
    "includes": [
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"authfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"loginrec.h\"",
      "#include \"packet.h\"",
      "#include \"uidswap.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"groupaccess.h\"",
      "#include \"match.h\"",
      "#include \"xmalloc.h\"",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <shadow.h>",
      "#include <login.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pwcopy",
          "args": [
            "pw"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "pwcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "302-326",
          "snippet": "struct passwd *\npwcopy(struct passwd *pw)\n{\n\tstruct passwd *copy = xcalloc(1, sizeof(*copy));\n\n\tcopy->pw_name = xstrdup(pw->pw_name);\n\tcopy->pw_passwd = xstrdup(pw->pw_passwd);\n#ifdef HAVE_STRUCT_PASSWD_PW_GECOS\n\tcopy->pw_gecos = xstrdup(pw->pw_gecos);\n#endif\n\tcopy->pw_uid = pw->pw_uid;\n\tcopy->pw_gid = pw->pw_gid;\n#ifdef HAVE_STRUCT_PASSWD_PW_EXPIRE\n\tcopy->pw_expire = pw->pw_expire;\n#endif\n#ifdef HAVE_STRUCT_PASSWD_PW_CHANGE\n\tcopy->pw_change = pw->pw_change;\n#endif\n#ifdef HAVE_STRUCT_PASSWD_PW_CLASS\n\tcopy->pw_class = xstrdup(pw->pw_class);\n#endif\n\tcopy->pw_dir = xstrdup(pw->pw_dir);\n\tcopy->pw_shell = xstrdup(pw->pw_shell);\n\treturn copy;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct passwd *\npwcopy(struct passwd *pw)\n{\n\tstruct passwd *copy = xcalloc(1, sizeof(*copy));\n\n\tcopy->pw_name = xstrdup(pw->pw_name);\n\tcopy->pw_passwd = xstrdup(pw->pw_passwd);\n#ifdef HAVE_STRUCT_PASSWD_PW_GECOS\n\tcopy->pw_gecos = xstrdup(pw->pw_gecos);\n#endif\n\tcopy->pw_uid = pw->pw_uid;\n\tcopy->pw_gid = pw->pw_gid;\n#ifdef HAVE_STRUCT_PASSWD_PW_EXPIRE\n\tcopy->pw_expire = pw->pw_expire;\n#endif\n#ifdef HAVE_STRUCT_PASSWD_PW_CHANGE\n\tcopy->pw_change = pw->pw_change;\n#endif\n#ifdef HAVE_STRUCT_PASSWD_PW_CLASS\n\tcopy->pw_class = xstrdup(pw->pw_class);\n#endif\n\tcopy->pw_dir = xstrdup(pw->pw_dir);\n\tcopy->pw_shell = xstrdup(pw->pw_shell);\n\treturn copy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_close",
          "args": [
            "as"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Approval failure for %s\"",
            "user"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "auth_debug_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "673-688",
          "snippet": "void\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sshbuf *auth_debug;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshbuf *auth_debug;\n\nvoid\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_approval",
          "args": [
            "as",
            "lc",
            "pw->pw_name",
            "\"ssh\""
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth_setpwd",
          "args": [
            "as",
            "pw"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth_open",
          "args": [],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "login_getclass",
          "args": [
            "pw->pw_class"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allowed_user",
          "args": [
            "pw"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "allowed_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "98-267",
          "snippet": "int\nallowed_user(struct passwd * pw)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tstruct stat st;\n\tconst char *hostname = NULL, *ipaddr = NULL, *passwd = NULL;\n\tu_int i;\n\tint r;\n#ifdef USE_SHADOW\n\tstruct spwd *spw = NULL;\n#endif\n\n\t/* Shouldn't be called if pw is NULL, but better safe than sorry... */\n\tif (!pw || !pw->pw_name)\n\t\treturn 0;\n\n#ifdef USE_SHADOW\n\tif (!options.use_pam)\n\t\tspw = getspnam(pw->pw_name);\n#ifdef HAS_SHADOW_EXPIRE\n\tif (!options.use_pam && spw != NULL && auth_shadow_acctexpired(spw))\n\t\treturn 0;\n#endif /* HAS_SHADOW_EXPIRE */\n#endif /* USE_SHADOW */\n\n\t/* grab passwd field for locked account check */\n\tpasswd = pw->pw_passwd;\n#ifdef USE_SHADOW\n\tif (spw != NULL)\n#ifdef USE_LIBIAF\n\t\tpasswd = get_iaf_password(pw);\n#else\n\t\tpasswd = spw->sp_pwdp;\n#endif /* USE_LIBIAF */\n#endif\n\n\t/* check for locked account */\n\tif (!options.use_pam && passwd && *passwd) {\n\t\tint locked = 0;\n\n#ifdef LOCKED_PASSWD_STRING\n\t\tif (strcmp(passwd, LOCKED_PASSWD_STRING) == 0)\n\t\t\t locked = 1;\n#endif\n#ifdef LOCKED_PASSWD_PREFIX\n\t\tif (strncmp(passwd, LOCKED_PASSWD_PREFIX,\n\t\t    strlen(LOCKED_PASSWD_PREFIX)) == 0)\n\t\t\t locked = 1;\n#endif\n#ifdef LOCKED_PASSWD_SUBSTR\n\t\tif (strstr(passwd, LOCKED_PASSWD_SUBSTR))\n\t\t\tlocked = 1;\n#endif\n#ifdef USE_LIBIAF\n\t\tfree((void *) passwd);\n#endif /* USE_LIBIAF */\n\t\tif (locked) {\n\t\t\tlogit(\"User %.100s not allowed because account is locked\",\n\t\t\t    pw->pw_name);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Deny if shell does not exist or is not executable unless we\n\t * are chrooting.\n\t */\n\tif (options.chroot_directory == NULL ||\n\t    strcasecmp(options.chroot_directory, \"none\") == 0) {\n\t\tchar *shell = xstrdup((pw->pw_shell[0] == '\\0') ?\n\t\t    _PATH_BSHELL : pw->pw_shell); /* empty = /bin/sh */\n\n\t\tif (stat(shell, &st) != 0) {\n\t\t\tlogit(\"User %.100s not allowed because shell %.100s \"\n\t\t\t    \"does not exist\", pw->pw_name, shell);\n\t\t\tfree(shell);\n\t\t\treturn 0;\n\t\t}\n\t\tif (S_ISREG(st.st_mode) == 0 ||\n\t\t    (st.st_mode & (S_IXOTH|S_IXUSR|S_IXGRP)) == 0) {\n\t\t\tlogit(\"User %.100s not allowed because shell %.100s \"\n\t\t\t    \"is not executable\", pw->pw_name, shell);\n\t\t\tfree(shell);\n\t\t\treturn 0;\n\t\t}\n\t\tfree(shell);\n\t}\n\n\tif (options.num_deny_users > 0 || options.num_allow_users > 0 ||\n\t    options.num_deny_groups > 0 || options.num_allow_groups > 0) {\n\t\thostname = auth_get_canonical_hostname(ssh, options.use_dns);\n\t\tipaddr = ssh_remote_ipaddr(ssh);\n\t}\n\n\t/* Return false if user is listed in DenyUsers */\n\tif (options.num_deny_users > 0) {\n\t\tfor (i = 0; i < options.num_deny_users; i++) {\n\t\t\tr = match_user(pw->pw_name, hostname, ipaddr,\n\t\t\t    options.deny_users[i]);\n\t\t\tif (r < 0) {\n\t\t\t\tfatal(\"Invalid DenyUsers pattern \\\"%.100s\\\"\",\n\t\t\t\t    options.deny_users[i]);\n\t\t\t} else if (r != 0) {\n\t\t\t\tlogit(\"User %.100s from %.100s not allowed \"\n\t\t\t\t    \"because listed in DenyUsers\",\n\t\t\t\t    pw->pw_name, hostname);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t/* Return false if AllowUsers isn't empty and user isn't listed there */\n\tif (options.num_allow_users > 0) {\n\t\tfor (i = 0; i < options.num_allow_users; i++) {\n\t\t\tr = match_user(pw->pw_name, hostname, ipaddr,\n\t\t\t    options.allow_users[i]);\n\t\t\tif (r < 0) {\n\t\t\t\tfatal(\"Invalid AllowUsers pattern \\\"%.100s\\\"\",\n\t\t\t\t    options.allow_users[i]);\n\t\t\t} else if (r == 1)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* i < options.num_allow_users iff we break for loop */\n\t\tif (i >= options.num_allow_users) {\n\t\t\tlogit(\"User %.100s from %.100s not allowed because \"\n\t\t\t    \"not listed in AllowUsers\", pw->pw_name, hostname);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (options.num_deny_groups > 0 || options.num_allow_groups > 0) {\n\t\t/* Get the user's group access list (primary and supplementary) */\n\t\tif (ga_init(pw->pw_name, pw->pw_gid) == 0) {\n\t\t\tlogit(\"User %.100s from %.100s not allowed because \"\n\t\t\t    \"not in any group\", pw->pw_name, hostname);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Return false if one of user's groups is listed in DenyGroups */\n\t\tif (options.num_deny_groups > 0)\n\t\t\tif (ga_match(options.deny_groups,\n\t\t\t    options.num_deny_groups)) {\n\t\t\t\tga_free();\n\t\t\t\tlogit(\"User %.100s from %.100s not allowed \"\n\t\t\t\t    \"because a group is listed in DenyGroups\",\n\t\t\t\t    pw->pw_name, hostname);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t/*\n\t\t * Return false if AllowGroups isn't empty and one of user's groups\n\t\t * isn't listed there\n\t\t */\n\t\tif (options.num_allow_groups > 0)\n\t\t\tif (!ga_match(options.allow_groups,\n\t\t\t    options.num_allow_groups)) {\n\t\t\t\tga_free();\n\t\t\t\tlogit(\"User %.100s from %.100s not allowed \"\n\t\t\t\t    \"because none of user's groups are listed \"\n\t\t\t\t    \"in AllowGroups\", pw->pw_name, hostname);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tga_free();\n\t}\n\n#ifdef CUSTOM_SYS_AUTH_ALLOWED_USER\n\tif (!sys_auth_allowed_user(pw, &loginmsg))\n\t\treturn 0;\n#endif\n\n\t/* We found no reason not to let this user try to log on... */\n\treturn 1;\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "extern struct sshbuf *loginmsg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern struct sshbuf *loginmsg;\n\nint\nallowed_user(struct passwd * pw)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tstruct stat st;\n\tconst char *hostname = NULL, *ipaddr = NULL, *passwd = NULL;\n\tu_int i;\n\tint r;\n#ifdef USE_SHADOW\n\tstruct spwd *spw = NULL;\n#endif\n\n\t/* Shouldn't be called if pw is NULL, but better safe than sorry... */\n\tif (!pw || !pw->pw_name)\n\t\treturn 0;\n\n#ifdef USE_SHADOW\n\tif (!options.use_pam)\n\t\tspw = getspnam(pw->pw_name);\n#ifdef HAS_SHADOW_EXPIRE\n\tif (!options.use_pam && spw != NULL && auth_shadow_acctexpired(spw))\n\t\treturn 0;\n#endif /* HAS_SHADOW_EXPIRE */\n#endif /* USE_SHADOW */\n\n\t/* grab passwd field for locked account check */\n\tpasswd = pw->pw_passwd;\n#ifdef USE_SHADOW\n\tif (spw != NULL)\n#ifdef USE_LIBIAF\n\t\tpasswd = get_iaf_password(pw);\n#else\n\t\tpasswd = spw->sp_pwdp;\n#endif /* USE_LIBIAF */\n#endif\n\n\t/* check for locked account */\n\tif (!options.use_pam && passwd && *passwd) {\n\t\tint locked = 0;\n\n#ifdef LOCKED_PASSWD_STRING\n\t\tif (strcmp(passwd, LOCKED_PASSWD_STRING) == 0)\n\t\t\t locked = 1;\n#endif\n#ifdef LOCKED_PASSWD_PREFIX\n\t\tif (strncmp(passwd, LOCKED_PASSWD_PREFIX,\n\t\t    strlen(LOCKED_PASSWD_PREFIX)) == 0)\n\t\t\t locked = 1;\n#endif\n#ifdef LOCKED_PASSWD_SUBSTR\n\t\tif (strstr(passwd, LOCKED_PASSWD_SUBSTR))\n\t\t\tlocked = 1;\n#endif\n#ifdef USE_LIBIAF\n\t\tfree((void *) passwd);\n#endif /* USE_LIBIAF */\n\t\tif (locked) {\n\t\t\tlogit(\"User %.100s not allowed because account is locked\",\n\t\t\t    pw->pw_name);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Deny if shell does not exist or is not executable unless we\n\t * are chrooting.\n\t */\n\tif (options.chroot_directory == NULL ||\n\t    strcasecmp(options.chroot_directory, \"none\") == 0) {\n\t\tchar *shell = xstrdup((pw->pw_shell[0] == '\\0') ?\n\t\t    _PATH_BSHELL : pw->pw_shell); /* empty = /bin/sh */\n\n\t\tif (stat(shell, &st) != 0) {\n\t\t\tlogit(\"User %.100s not allowed because shell %.100s \"\n\t\t\t    \"does not exist\", pw->pw_name, shell);\n\t\t\tfree(shell);\n\t\t\treturn 0;\n\t\t}\n\t\tif (S_ISREG(st.st_mode) == 0 ||\n\t\t    (st.st_mode & (S_IXOTH|S_IXUSR|S_IXGRP)) == 0) {\n\t\t\tlogit(\"User %.100s not allowed because shell %.100s \"\n\t\t\t    \"is not executable\", pw->pw_name, shell);\n\t\t\tfree(shell);\n\t\t\treturn 0;\n\t\t}\n\t\tfree(shell);\n\t}\n\n\tif (options.num_deny_users > 0 || options.num_allow_users > 0 ||\n\t    options.num_deny_groups > 0 || options.num_allow_groups > 0) {\n\t\thostname = auth_get_canonical_hostname(ssh, options.use_dns);\n\t\tipaddr = ssh_remote_ipaddr(ssh);\n\t}\n\n\t/* Return false if user is listed in DenyUsers */\n\tif (options.num_deny_users > 0) {\n\t\tfor (i = 0; i < options.num_deny_users; i++) {\n\t\t\tr = match_user(pw->pw_name, hostname, ipaddr,\n\t\t\t    options.deny_users[i]);\n\t\t\tif (r < 0) {\n\t\t\t\tfatal(\"Invalid DenyUsers pattern \\\"%.100s\\\"\",\n\t\t\t\t    options.deny_users[i]);\n\t\t\t} else if (r != 0) {\n\t\t\t\tlogit(\"User %.100s from %.100s not allowed \"\n\t\t\t\t    \"because listed in DenyUsers\",\n\t\t\t\t    pw->pw_name, hostname);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t/* Return false if AllowUsers isn't empty and user isn't listed there */\n\tif (options.num_allow_users > 0) {\n\t\tfor (i = 0; i < options.num_allow_users; i++) {\n\t\t\tr = match_user(pw->pw_name, hostname, ipaddr,\n\t\t\t    options.allow_users[i]);\n\t\t\tif (r < 0) {\n\t\t\t\tfatal(\"Invalid AllowUsers pattern \\\"%.100s\\\"\",\n\t\t\t\t    options.allow_users[i]);\n\t\t\t} else if (r == 1)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* i < options.num_allow_users iff we break for loop */\n\t\tif (i >= options.num_allow_users) {\n\t\t\tlogit(\"User %.100s from %.100s not allowed because \"\n\t\t\t    \"not listed in AllowUsers\", pw->pw_name, hostname);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (options.num_deny_groups > 0 || options.num_allow_groups > 0) {\n\t\t/* Get the user's group access list (primary and supplementary) */\n\t\tif (ga_init(pw->pw_name, pw->pw_gid) == 0) {\n\t\t\tlogit(\"User %.100s from %.100s not allowed because \"\n\t\t\t    \"not in any group\", pw->pw_name, hostname);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Return false if one of user's groups is listed in DenyGroups */\n\t\tif (options.num_deny_groups > 0)\n\t\t\tif (ga_match(options.deny_groups,\n\t\t\t    options.num_deny_groups)) {\n\t\t\t\tga_free();\n\t\t\t\tlogit(\"User %.100s from %.100s not allowed \"\n\t\t\t\t    \"because a group is listed in DenyGroups\",\n\t\t\t\t    pw->pw_name, hostname);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t/*\n\t\t * Return false if AllowGroups isn't empty and one of user's groups\n\t\t * isn't listed there\n\t\t */\n\t\tif (options.num_allow_groups > 0)\n\t\t\tif (!ga_match(options.allow_groups,\n\t\t\t    options.num_allow_groups)) {\n\t\t\t\tga_free();\n\t\t\t\tlogit(\"User %.100s from %.100s not allowed \"\n\t\t\t\t    \"because none of user's groups are listed \"\n\t\t\t\t    \"in AllowGroups\", pw->pw_name, hostname);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tga_free();\n\t}\n\n#ifdef CUSTOM_SYS_AUTH_ALLOWED_USER\n\tif (!sys_auth_allowed_user(pw, &loginmsg))\n\t\treturn 0;\n#endif\n\n\t/* We found no reason not to let this user try to log on... */\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_event",
          "args": [
            "SSH_INVALID_USER"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "audit_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit.c",
          "lines": "133-138",
          "snippet": "void\naudit_event(ssh_audit_event_t event)\n{\n\tdebug(\"audit event euid %d user %s event %d (%s)\", geteuid(),\n\t    audit_username(), event, audit_event_lookup(event));\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"log.h\"",
            "#include \"audit.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"audit.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\naudit_event(ssh_audit_event_t event)\n{\n\tdebug(\"audit event euid %d user %s event %d (%s)\", geteuid(),\n\t    audit_username(), event, audit_event_lookup(event));\n}"
        }
      },
      {
        "call_info": {
          "callee": "record_failed_login",
          "args": [
            "user",
            "auth_get_canonical_hostname(ssh, options.use_dns)",
            "\"ssh\""
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "record_failed_login",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/loginrec.c",
          "lines": "1655-1723",
          "snippet": "void\nrecord_failed_login(const char *username, const char *hostname,\n    const char *ttyn)\n{\n\tint fd;\n\tstruct utmp ut;\n\tstruct sockaddr_storage from;\n\tsocklen_t fromlen = sizeof(from);\n\tstruct sockaddr_in *a4;\n\tstruct sockaddr_in6 *a6;\n\ttime_t t;\n\tstruct stat fst;\n\n\tif (geteuid() != 0)\n\t\treturn;\n\tif ((fd = open(_PATH_BTMP, O_WRONLY | O_APPEND)) < 0) {\n\t\tdebug(\"Unable to open the btmp file %s: %s\", _PATH_BTMP,\n\t\t    strerror(errno));\n\t\treturn;\n\t}\n\tif (fstat(fd, &fst) < 0) {\n\t\tlogit(\"%s: fstat of %s failed: %s\", __func__, _PATH_BTMP,\n\t\t    strerror(errno));\n\t\tgoto out;\n\t}\n\tif((fst.st_mode & (S_IXGRP | S_IRWXO)) || (fst.st_uid != 0)){\n\t\tlogit(\"Excess permission or bad ownership on file %s\",\n\t\t    _PATH_BTMP);\n\t\tgoto out;\n\t}\n\n\tmemset(&ut, 0, sizeof(ut));\n\t/* strncpy because we don't necessarily want nul termination */\n\tstrncpy(ut.ut_user, username, sizeof(ut.ut_user));\n\tstrlcpy(ut.ut_line, \"ssh:notty\", sizeof(ut.ut_line));\n\n\ttime(&t);\n\tut.ut_time = t;     /* ut_time is not always a time_t */\n\tut.ut_type = LOGIN_PROCESS;\n\tut.ut_pid = getpid();\n\n\t/* strncpy because we don't necessarily want nul termination */\n\tstrncpy(ut.ut_host, hostname, sizeof(ut.ut_host));\n\n\tif (packet_connection_is_on_socket() &&\n\t    getpeername(packet_get_connection_in(),\n\t    (struct sockaddr *)&from, &fromlen) == 0) {\n\t\tipv64_normalise_mapped(&from, &fromlen);\n\t\tif (from.ss_family == AF_INET) {\n\t\t\ta4 = (struct sockaddr_in *)&from;\n\t\t\tmemcpy(&ut.ut_addr, &(a4->sin_addr),\n\t\t\t    MIN_SIZEOF(ut.ut_addr, a4->sin_addr));\n\t\t}\n#ifdef HAVE_ADDR_V6_IN_UTMP\n\t\tif (from.ss_family == AF_INET6) {\n\t\t\ta6 = (struct sockaddr_in6 *)&from;\n\t\t\tmemcpy(&ut.ut_addr_v6, &(a6->sin6_addr),\n\t\t\t    MIN_SIZEOF(ut.ut_addr_v6, a6->sin6_addr));\n\t\t}\n#endif\n\t}\n\n\tif (atomicio(vwrite, fd, &ut, sizeof(ut)) != sizeof(ut))\n\t\terror(\"Failed to write to %s: %s\", _PATH_BTMP,\n\t\t    strerror(errno));\n\nout:\n\tclose(fd);\n}",
          "includes": [
            "# include <util.h>",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"canohost.h\"",
            "#include \"packet.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"loginrec.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <util.h>\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"canohost.h\"\n#include \"packet.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"loginrec.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nrecord_failed_login(const char *username, const char *hostname,\n    const char *ttyn)\n{\n\tint fd;\n\tstruct utmp ut;\n\tstruct sockaddr_storage from;\n\tsocklen_t fromlen = sizeof(from);\n\tstruct sockaddr_in *a4;\n\tstruct sockaddr_in6 *a6;\n\ttime_t t;\n\tstruct stat fst;\n\n\tif (geteuid() != 0)\n\t\treturn;\n\tif ((fd = open(_PATH_BTMP, O_WRONLY | O_APPEND)) < 0) {\n\t\tdebug(\"Unable to open the btmp file %s: %s\", _PATH_BTMP,\n\t\t    strerror(errno));\n\t\treturn;\n\t}\n\tif (fstat(fd, &fst) < 0) {\n\t\tlogit(\"%s: fstat of %s failed: %s\", __func__, _PATH_BTMP,\n\t\t    strerror(errno));\n\t\tgoto out;\n\t}\n\tif((fst.st_mode & (S_IXGRP | S_IRWXO)) || (fst.st_uid != 0)){\n\t\tlogit(\"Excess permission or bad ownership on file %s\",\n\t\t    _PATH_BTMP);\n\t\tgoto out;\n\t}\n\n\tmemset(&ut, 0, sizeof(ut));\n\t/* strncpy because we don't necessarily want nul termination */\n\tstrncpy(ut.ut_user, username, sizeof(ut.ut_user));\n\tstrlcpy(ut.ut_line, \"ssh:notty\", sizeof(ut.ut_line));\n\n\ttime(&t);\n\tut.ut_time = t;     /* ut_time is not always a time_t */\n\tut.ut_type = LOGIN_PROCESS;\n\tut.ut_pid = getpid();\n\n\t/* strncpy because we don't necessarily want nul termination */\n\tstrncpy(ut.ut_host, hostname, sizeof(ut.ut_host));\n\n\tif (packet_connection_is_on_socket() &&\n\t    getpeername(packet_get_connection_in(),\n\t    (struct sockaddr *)&from, &fromlen) == 0) {\n\t\tipv64_normalise_mapped(&from, &fromlen);\n\t\tif (from.ss_family == AF_INET) {\n\t\t\ta4 = (struct sockaddr_in *)&from;\n\t\t\tmemcpy(&ut.ut_addr, &(a4->sin_addr),\n\t\t\t    MIN_SIZEOF(ut.ut_addr, a4->sin_addr));\n\t\t}\n#ifdef HAVE_ADDR_V6_IN_UTMP\n\t\tif (from.ss_family == AF_INET6) {\n\t\t\ta6 = (struct sockaddr_in6 *)&from;\n\t\t\tmemcpy(&ut.ut_addr_v6, &(a6->sin6_addr),\n\t\t\t    MIN_SIZEOF(ut.ut_addr_v6, a6->sin6_addr));\n\t\t}\n#endif\n\t}\n\n\tif (atomicio(vwrite, fd, &ut, sizeof(ut)) != sizeof(ut))\n\t\terror(\"Failed to write to %s: %s\", _PATH_BTMP,\n\t\t    strerror(errno));\n\nout:\n\tclose(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_get_canonical_hostname",
          "args": [
            "ssh",
            "options.use_dns"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "auth_get_canonical_hostname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "839-852",
          "snippet": "const char *\nauth_get_canonical_hostname(struct ssh *ssh, int use_dns)\n{\n\tstatic char *dnsname;\n\n\tif (!use_dns)\n\t\treturn ssh_remote_ipaddr(ssh);\n\telse if (dnsname != NULL)\n\t\treturn dnsname;\n\telse {\n\t\tdnsname = remote_hostname(ssh);\n\t\treturn dnsname;\n\t}\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nauth_get_canonical_hostname(struct ssh *ssh, int use_dns)\n{\n\tstatic char *dnsname;\n\n\tif (!use_dns)\n\t\treturn ssh_remote_ipaddr(ssh);\n\telse if (dnsname != NULL)\n\t\treturn dnsname;\n\telse {\n\t\tdnsname = remote_hostname(ssh);\n\t\treturn dnsname;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Invalid user %.100s from %.100s port %d\"",
            "user",
            "ssh_remote_ipaddr(ssh)",
            "ssh_remote_port(ssh)"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_port",
          "args": [
            "ssh"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "539-544",
          "snippet": "int\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->remote_port;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->remote_port;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_ipaddr",
          "args": [
            "ssh"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "514-535",
          "snippet": "const char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "user",
            "pw->pw_name"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aix_restoreauthdb",
          "args": [],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "aix_restoreauthdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "368-379",
          "snippet": "void\naix_restoreauthdb(void)\n{\n#  ifdef HAVE_SETAUTHDB\n\tif (setauthdb(old_registry, NULL) == 0)\n\t\tdebug3(\"%s: restoring old registry '%s'\", __func__,\n\t\t    old_registry);\n\telse\n\t\tdebug3(\"%s: failed to restore old registry %s\", __func__,\n\t\t    old_registry);\n#  endif /* HAVE_SETAUTHDB */\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nvoid\naix_restoreauthdb(void)\n{\n#  ifdef HAVE_SETAUTHDB\n\tif (setauthdb(old_registry, NULL) == 0)\n\t\tdebug3(\"%s: restoring old registry '%s'\", __func__,\n\t\t    old_registry);\n\telse\n\t\tdebug3(\"%s: failed to restore old registry %s\", __func__,\n\t\t    old_registry);\n#  endif /* HAVE_SETAUTHDB */\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpwnam",
          "args": [
            "user"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "getpwnamallow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "560-632",
          "snippet": "struct passwd *\ngetpwnamallow(const char *user)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n#ifdef HAVE_LOGIN_CAP\n\textern login_cap_t *lc;\n#ifdef BSD_AUTH\n\tauth_session_t *as;\n#endif\n#endif\n\tstruct passwd *pw;\n\tstruct connection_info *ci = get_connection_info(1, options.use_dns);\n\n\tci->user = user;\n\tparse_server_match_config(&options, ci);\n\tlog_change_level(options.log_level);\n\tprocess_permitopen(ssh, &options);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_setauthdb(user);\n#endif\n\n\tpw = getpwnam(user);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_restoreauthdb();\n#endif\n#ifdef HAVE_CYGWIN\n\t/*\n\t * Windows usernames are case-insensitive.  To avoid later problems\n\t * when trying to match the username, the user is only allowed to\n\t * login if the username is given in the same case as stored in the\n\t * user database.\n\t */\n\tif (pw != NULL && strcmp(user, pw->pw_name) != 0) {\n\t\tlogit(\"Login name %.100s does not match stored username %.100s\",\n\t\t    user, pw->pw_name);\n\t\tpw = NULL;\n\t}\n#endif\n\tif (pw == NULL) {\n\t\tlogit(\"Invalid user %.100s from %.100s port %d\",\n\t\t    user, ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n#ifdef CUSTOM_FAILED_LOGIN\n\t\trecord_failed_login(user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\");\n#endif\n#ifdef SSH_AUDIT_EVENTS\n\t\taudit_event(SSH_INVALID_USER);\n#endif /* SSH_AUDIT_EVENTS */\n\t\treturn (NULL);\n\t}\n\tif (!allowed_user(pw))\n\t\treturn (NULL);\n#ifdef HAVE_LOGIN_CAP\n\tif ((lc = login_getclass(pw->pw_class)) == NULL) {\n\t\tdebug(\"unable to get login class: %s\", user);\n\t\treturn (NULL);\n\t}\n#ifdef BSD_AUTH\n\tif ((as = auth_open()) == NULL || auth_setpwd(as, pw) != 0 ||\n\t    auth_approval(as, lc, pw->pw_name, \"ssh\") <= 0) {\n\t\tdebug(\"Approval failure for %s\", user);\n\t\tpw = NULL;\n\t}\n\tif (as != NULL)\n\t\tauth_close(as);\n#endif\n#endif\n\tif (pw != NULL)\n\t\treturn (pwcopy(pw));\n\treturn (NULL);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "aix_setauthdb",
          "args": [
            "user"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "aix_setauthdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "338-360",
          "snippet": "void\naix_setauthdb(const char *user)\n{\n#  ifdef HAVE_SETAUTHDB\n\tchar *registry;\n\n\tif (setuserdb(S_READ) == -1) {\n\t\tdebug3(\"%s: Could not open userdb to read\", __func__);\n\t\treturn;\n\t}\n\n\tif (getuserattr((char *)user, S_REGISTRY, &registry, SEC_CHAR) == 0) {\n\t\tif (setauthdb(registry, old_registry) == 0)\n\t\t\tdebug3(\"AIX/setauthdb set registry '%s'\", registry);\n\t\telse\n\t\t\tdebug3(\"AIX/setauthdb set registry '%s' failed: %s\",\n\t\t\t    registry, strerror(errno));\n\t} else\n\t\tdebug3(\"%s: Could not read S_REGISTRY for user: %s\", __func__,\n\t\t    strerror(errno));\n\tenduserdb();\n#  endif /* HAVE_SETAUTHDB */\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nvoid\naix_setauthdb(const char *user)\n{\n#  ifdef HAVE_SETAUTHDB\n\tchar *registry;\n\n\tif (setuserdb(S_READ) == -1) {\n\t\tdebug3(\"%s: Could not open userdb to read\", __func__);\n\t\treturn;\n\t}\n\n\tif (getuserattr((char *)user, S_REGISTRY, &registry, SEC_CHAR) == 0) {\n\t\tif (setauthdb(registry, old_registry) == 0)\n\t\t\tdebug3(\"AIX/setauthdb set registry '%s'\", registry);\n\t\telse\n\t\t\tdebug3(\"AIX/setauthdb set registry '%s' failed: %s\",\n\t\t\t    registry, strerror(errno));\n\t} else\n\t\tdebug3(\"%s: Could not read S_REGISTRY for user: %s\", __func__,\n\t\t    strerror(errno));\n\tenduserdb();\n#  endif /* HAVE_SETAUTHDB */\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_permitopen",
          "args": [
            "ssh",
            "&options"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "process_permitopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "901-909",
          "snippet": "void\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_change_level",
          "args": [
            "options.log_level"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "log_change_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "338-359",
          "snippet": "int\nlog_change_level(LogLevel new_log_level)\n{\n\t/* no-op if log_init has not been called */\n\tif (argv0 == NULL)\n\t\treturn 0;\n\n\tswitch (new_log_level) {\n\tcase SYSLOG_LEVEL_QUIET:\n\tcase SYSLOG_LEVEL_FATAL:\n\tcase SYSLOG_LEVEL_ERROR:\n\tcase SYSLOG_LEVEL_INFO:\n\tcase SYSLOG_LEVEL_VERBOSE:\n\tcase SYSLOG_LEVEL_DEBUG1:\n\tcase SYSLOG_LEVEL_DEBUG2:\n\tcase SYSLOG_LEVEL_DEBUG3:\n\t\tlog_level = new_log_level;\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LogLevel log_level = SYSLOG_LEVEL_INFO;",
            "static char *argv0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic LogLevel log_level = SYSLOG_LEVEL_INFO;\nstatic char *argv0;\n\nint\nlog_change_level(LogLevel new_log_level)\n{\n\t/* no-op if log_init has not been called */\n\tif (argv0 == NULL)\n\t\treturn 0;\n\n\tswitch (new_log_level) {\n\tcase SYSLOG_LEVEL_QUIET:\n\tcase SYSLOG_LEVEL_FATAL:\n\tcase SYSLOG_LEVEL_ERROR:\n\tcase SYSLOG_LEVEL_INFO:\n\tcase SYSLOG_LEVEL_VERBOSE:\n\tcase SYSLOG_LEVEL_DEBUG1:\n\tcase SYSLOG_LEVEL_DEBUG2:\n\tcase SYSLOG_LEVEL_DEBUG3:\n\t\tlog_level = new_log_level;\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_server_match_config",
          "args": [
            "&options",
            "ci"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "parse_server_match_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2209-2218",
          "snippet": "void\nparse_server_match_config(ServerOptions *options,\n   struct connection_info *connectinfo)\n{\n\tServerOptions mo;\n\n\tinitialize_server_options(&mo);\n\tparse_server_config(&mo, \"reprocess config\", cfg, connectinfo);\n\tcopy_set_server_options(options, &mo, 0);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "extern struct sshbuf *cfg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nextern struct sshbuf *cfg;\n\nvoid\nparse_server_match_config(ServerOptions *options,\n   struct connection_info *connectinfo)\n{\n\tServerOptions mo;\n\n\tinitialize_server_options(&mo);\n\tparse_server_config(&mo, \"reprocess config\", cfg, connectinfo);\n\tcopy_set_server_options(options, &mo, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_connection_info",
          "args": [
            "1",
            "options.use_dns"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "get_connection_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "911-925",
          "snippet": "struct connection_info *\nget_connection_info(int populate, int use_dns)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tstatic struct connection_info ci;\n\n\tif (!populate)\n\t\treturn &ci;\n\tci.host = auth_get_canonical_hostname(ssh, use_dns);\n\tci.address = ssh_remote_ipaddr(ssh);\n\tci.laddress = ssh_local_ipaddr(ssh);\n\tci.lport = ssh_local_port(ssh);\n\tci.rdomain = ssh_packet_rdomain_in(ssh);\n\treturn &ci;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct connection_info *\nget_connection_info(int populate, int use_dns)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tstatic struct connection_info ci;\n\n\tif (!populate)\n\t\treturn &ci;\n\tci.host = auth_get_canonical_hostname(ssh, use_dns);\n\tci.address = ssh_remote_ipaddr(ssh);\n\tci.laddress = ssh_local_ipaddr(ssh);\n\tci.lport = ssh_local_port(ssh);\n\tci.rdomain = ssh_packet_rdomain_in(ssh);\n\treturn &ci;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstruct passwd *\ngetpwnamallow(const char *user)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n#ifdef HAVE_LOGIN_CAP\n\textern login_cap_t *lc;\n#ifdef BSD_AUTH\n\tauth_session_t *as;\n#endif\n#endif\n\tstruct passwd *pw;\n\tstruct connection_info *ci = get_connection_info(1, options.use_dns);\n\n\tci->user = user;\n\tparse_server_match_config(&options, ci);\n\tlog_change_level(options.log_level);\n\tprocess_permitopen(ssh, &options);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_setauthdb(user);\n#endif\n\n\tpw = getpwnam(user);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_restoreauthdb();\n#endif\n#ifdef HAVE_CYGWIN\n\t/*\n\t * Windows usernames are case-insensitive.  To avoid later problems\n\t * when trying to match the username, the user is only allowed to\n\t * login if the username is given in the same case as stored in the\n\t * user database.\n\t */\n\tif (pw != NULL && strcmp(user, pw->pw_name) != 0) {\n\t\tlogit(\"Login name %.100s does not match stored username %.100s\",\n\t\t    user, pw->pw_name);\n\t\tpw = NULL;\n\t}\n#endif\n\tif (pw == NULL) {\n\t\tlogit(\"Invalid user %.100s from %.100s port %d\",\n\t\t    user, ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n#ifdef CUSTOM_FAILED_LOGIN\n\t\trecord_failed_login(user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\");\n#endif\n#ifdef SSH_AUDIT_EVENTS\n\t\taudit_event(SSH_INVALID_USER);\n#endif /* SSH_AUDIT_EVENTS */\n\t\treturn (NULL);\n\t}\n\tif (!allowed_user(pw))\n\t\treturn (NULL);\n#ifdef HAVE_LOGIN_CAP\n\tif ((lc = login_getclass(pw->pw_class)) == NULL) {\n\t\tdebug(\"unable to get login class: %s\", user);\n\t\treturn (NULL);\n\t}\n#ifdef BSD_AUTH\n\tif ((as = auth_open()) == NULL || auth_setpwd(as, pw) != 0 ||\n\t    auth_approval(as, lc, pw->pw_name, \"ssh\") <= 0) {\n\t\tdebug(\"Approval failure for %s\", user);\n\t\tpw = NULL;\n\t}\n\tif (as != NULL)\n\t\tauth_close(as);\n#endif\n#endif\n\tif (pw != NULL)\n\t\treturn (pwcopy(pw));\n\treturn (NULL);\n}"
  },
  {
    "function_name": "auth_openprincipals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
    "lines": "553-558",
    "snippet": "FILE *\nauth_openprincipals(const char *file, struct passwd *pw, int strict_modes)\n{\n\treturn auth_openfile(file, pw, strict_modes, 0,\n\t    \"authorized principals\");\n}",
    "includes": [
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"authfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"loginrec.h\"",
      "#include \"packet.h\"",
      "#include \"uidswap.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"groupaccess.h\"",
      "#include \"match.h\"",
      "#include \"xmalloc.h\"",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <shadow.h>",
      "#include <login.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "auth_openfile",
          "args": [
            "file",
            "pw",
            "strict_modes",
            "0",
            "\"authorized principals\""
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "auth_openfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "504-544",
          "snippet": "static FILE *\nauth_openfile(const char *file, struct passwd *pw, int strict_modes,\n    int log_missing, char *file_type)\n{\n\tchar line[1024];\n\tstruct stat st;\n\tint fd;\n\tFILE *f;\n\n\tif ((fd = open(file, O_RDONLY|O_NONBLOCK)) == -1) {\n\t\tif (log_missing || errno != ENOENT)\n\t\t\tdebug(\"Could not open %s '%s': %s\", file_type, file,\n\t\t\t   strerror(errno));\n\t\treturn NULL;\n\t}\n\n\tif (fstat(fd, &st) < 0) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tif (!S_ISREG(st.st_mode)) {\n\t\tlogit(\"User %s %s %s is not a regular file\",\n\t\t    pw->pw_name, file_type, file);\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tunset_nonblock(fd);\n\tif ((f = fdopen(fd, \"r\")) == NULL) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tif (strict_modes &&\n\t    safe_path_fd(fileno(f), file, pw, line, sizeof(line)) != 0) {\n\t\tfclose(f);\n\t\tlogit(\"Authentication refused: %s\", line);\n\t\tauth_debug_add(\"Ignored %s: %s\", file_type, line);\n\t\treturn NULL;\n\t}\n\n\treturn f;\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic FILE *\nauth_openfile(const char *file, struct passwd *pw, int strict_modes,\n    int log_missing, char *file_type)\n{\n\tchar line[1024];\n\tstruct stat st;\n\tint fd;\n\tFILE *f;\n\n\tif ((fd = open(file, O_RDONLY|O_NONBLOCK)) == -1) {\n\t\tif (log_missing || errno != ENOENT)\n\t\t\tdebug(\"Could not open %s '%s': %s\", file_type, file,\n\t\t\t   strerror(errno));\n\t\treturn NULL;\n\t}\n\n\tif (fstat(fd, &st) < 0) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tif (!S_ISREG(st.st_mode)) {\n\t\tlogit(\"User %s %s %s is not a regular file\",\n\t\t    pw->pw_name, file_type, file);\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tunset_nonblock(fd);\n\tif ((f = fdopen(fd, \"r\")) == NULL) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tif (strict_modes &&\n\t    safe_path_fd(fileno(f), file, pw, line, sizeof(line)) != 0) {\n\t\tfclose(f);\n\t\tlogit(\"Authentication refused: %s\", line);\n\t\tauth_debug_add(\"Ignored %s: %s\", file_type, line);\n\t\treturn NULL;\n\t}\n\n\treturn f;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nFILE *\nauth_openprincipals(const char *file, struct passwd *pw, int strict_modes)\n{\n\treturn auth_openfile(file, pw, strict_modes, 0,\n\t    \"authorized principals\");\n}"
  },
  {
    "function_name": "auth_openkeyfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
    "lines": "547-551",
    "snippet": "FILE *\nauth_openkeyfile(const char *file, struct passwd *pw, int strict_modes)\n{\n\treturn auth_openfile(file, pw, strict_modes, 1, \"authorized keys\");\n}",
    "includes": [
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"authfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"loginrec.h\"",
      "#include \"packet.h\"",
      "#include \"uidswap.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"groupaccess.h\"",
      "#include \"match.h\"",
      "#include \"xmalloc.h\"",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <shadow.h>",
      "#include <login.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "auth_openfile",
          "args": [
            "file",
            "pw",
            "strict_modes",
            "1",
            "\"authorized keys\""
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "auth_openfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "504-544",
          "snippet": "static FILE *\nauth_openfile(const char *file, struct passwd *pw, int strict_modes,\n    int log_missing, char *file_type)\n{\n\tchar line[1024];\n\tstruct stat st;\n\tint fd;\n\tFILE *f;\n\n\tif ((fd = open(file, O_RDONLY|O_NONBLOCK)) == -1) {\n\t\tif (log_missing || errno != ENOENT)\n\t\t\tdebug(\"Could not open %s '%s': %s\", file_type, file,\n\t\t\t   strerror(errno));\n\t\treturn NULL;\n\t}\n\n\tif (fstat(fd, &st) < 0) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tif (!S_ISREG(st.st_mode)) {\n\t\tlogit(\"User %s %s %s is not a regular file\",\n\t\t    pw->pw_name, file_type, file);\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tunset_nonblock(fd);\n\tif ((f = fdopen(fd, \"r\")) == NULL) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tif (strict_modes &&\n\t    safe_path_fd(fileno(f), file, pw, line, sizeof(line)) != 0) {\n\t\tfclose(f);\n\t\tlogit(\"Authentication refused: %s\", line);\n\t\tauth_debug_add(\"Ignored %s: %s\", file_type, line);\n\t\treturn NULL;\n\t}\n\n\treturn f;\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic FILE *\nauth_openfile(const char *file, struct passwd *pw, int strict_modes,\n    int log_missing, char *file_type)\n{\n\tchar line[1024];\n\tstruct stat st;\n\tint fd;\n\tFILE *f;\n\n\tif ((fd = open(file, O_RDONLY|O_NONBLOCK)) == -1) {\n\t\tif (log_missing || errno != ENOENT)\n\t\t\tdebug(\"Could not open %s '%s': %s\", file_type, file,\n\t\t\t   strerror(errno));\n\t\treturn NULL;\n\t}\n\n\tif (fstat(fd, &st) < 0) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tif (!S_ISREG(st.st_mode)) {\n\t\tlogit(\"User %s %s %s is not a regular file\",\n\t\t    pw->pw_name, file_type, file);\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tunset_nonblock(fd);\n\tif ((f = fdopen(fd, \"r\")) == NULL) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tif (strict_modes &&\n\t    safe_path_fd(fileno(f), file, pw, line, sizeof(line)) != 0) {\n\t\tfclose(f);\n\t\tlogit(\"Authentication refused: %s\", line);\n\t\tauth_debug_add(\"Ignored %s: %s\", file_type, line);\n\t\treturn NULL;\n\t}\n\n\treturn f;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nFILE *\nauth_openkeyfile(const char *file, struct passwd *pw, int strict_modes)\n{\n\treturn auth_openfile(file, pw, strict_modes, 1, \"authorized keys\");\n}"
  },
  {
    "function_name": "auth_openfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
    "lines": "504-544",
    "snippet": "static FILE *\nauth_openfile(const char *file, struct passwd *pw, int strict_modes,\n    int log_missing, char *file_type)\n{\n\tchar line[1024];\n\tstruct stat st;\n\tint fd;\n\tFILE *f;\n\n\tif ((fd = open(file, O_RDONLY|O_NONBLOCK)) == -1) {\n\t\tif (log_missing || errno != ENOENT)\n\t\t\tdebug(\"Could not open %s '%s': %s\", file_type, file,\n\t\t\t   strerror(errno));\n\t\treturn NULL;\n\t}\n\n\tif (fstat(fd, &st) < 0) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tif (!S_ISREG(st.st_mode)) {\n\t\tlogit(\"User %s %s %s is not a regular file\",\n\t\t    pw->pw_name, file_type, file);\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tunset_nonblock(fd);\n\tif ((f = fdopen(fd, \"r\")) == NULL) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tif (strict_modes &&\n\t    safe_path_fd(fileno(f), file, pw, line, sizeof(line)) != 0) {\n\t\tfclose(f);\n\t\tlogit(\"Authentication refused: %s\", line);\n\t\tauth_debug_add(\"Ignored %s: %s\", file_type, line);\n\t\treturn NULL;\n\t}\n\n\treturn f;\n}",
    "includes": [
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"authfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"loginrec.h\"",
      "#include \"packet.h\"",
      "#include \"uidswap.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"groupaccess.h\"",
      "#include \"match.h\"",
      "#include \"xmalloc.h\"",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <shadow.h>",
      "#include <login.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "auth_debug_add",
          "args": [
            "\"Ignored %s: %s\"",
            "file_type",
            "line"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "auth_debug_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "673-688",
          "snippet": "void\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sshbuf *auth_debug;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshbuf *auth_debug;\n\nvoid\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Authentication refused: %s\"",
            "line"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_path_fd",
          "args": [
            "fileno(f)",
            "file",
            "pw",
            "line",
            "sizeof(line)"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "safe_path_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1832-1845",
          "snippet": "int\nsafe_path_fd(int fd, const char *file, struct passwd *pw,\n    char *err, size_t errlen)\n{\n\tstruct stat st;\n\n\t/* check the open file to avoid races */\n\tif (fstat(fd, &st) < 0) {\n\t\tsnprintf(err, errlen, \"cannot stat file %s: %s\",\n\t\t    file, strerror(errno));\n\t\treturn -1;\n\t}\n\treturn safe_path(file, &st, pw->pw_dir, pw->pw_uid, err, errlen);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsafe_path_fd(int fd, const char *file, struct passwd *pw,\n    char *err, size_t errlen)\n{\n\tstruct stat st;\n\n\t/* check the open file to avoid races */\n\tif (fstat(fd, &st) < 0) {\n\t\tsnprintf(err, errlen, \"cannot stat file %s: %s\",\n\t\t    file, strerror(errno));\n\t\treturn -1;\n\t}\n\treturn safe_path(file, &st, pw->pw_dir, pw->pw_uid, err, errlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "f"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "fd",
            "\"r\""
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unset_nonblock",
          "args": [
            "fd"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "unset_nonblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "116-138",
          "snippet": "int\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "st.st_mode"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&st"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "fstatvfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-statvfs.c",
          "lines": "71-85",
          "snippet": "int fstatvfs(int fd, struct statvfs *buf)\n{\n#  ifdef HAVE_FSTATFS\n\tstruct statfs fs;\n\n\tmemset(&fs, 0, sizeof(fs));\n\tif (fstatfs(fd, &fs) == -1)\n\t\treturn -1;\n\tcopy_statfs_to_statvfs(buf, &fs);\n\treturn 0;\n#  else\n\terrno = ENOSYS;\n\treturn -1;\n#  endif\n}",
          "includes": [
            "#include <errno.h>",
            "# include <sys/mount.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n# include <sys/mount.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nint fstatvfs(int fd, struct statvfs *buf)\n{\n#  ifdef HAVE_FSTATFS\n\tstruct statfs fs;\n\n\tmemset(&fs, 0, sizeof(fs));\n\tif (fstatfs(fd, &fs) == -1)\n\t\treturn -1;\n\tcopy_statfs_to_statvfs(buf, &fs);\n\treturn 0;\n#  else\n\terrno = ENOSYS;\n\treturn -1;\n#  endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "file",
            "O_RDONLY|O_NONBLOCK"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "process_permitopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "901-909",
          "snippet": "void\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic FILE *\nauth_openfile(const char *file, struct passwd *pw, int strict_modes,\n    int log_missing, char *file_type)\n{\n\tchar line[1024];\n\tstruct stat st;\n\tint fd;\n\tFILE *f;\n\n\tif ((fd = open(file, O_RDONLY|O_NONBLOCK)) == -1) {\n\t\tif (log_missing || errno != ENOENT)\n\t\t\tdebug(\"Could not open %s '%s': %s\", file_type, file,\n\t\t\t   strerror(errno));\n\t\treturn NULL;\n\t}\n\n\tif (fstat(fd, &st) < 0) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tif (!S_ISREG(st.st_mode)) {\n\t\tlogit(\"User %s %s %s is not a regular file\",\n\t\t    pw->pw_name, file_type, file);\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tunset_nonblock(fd);\n\tif ((f = fdopen(fd, \"r\")) == NULL) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tif (strict_modes &&\n\t    safe_path_fd(fileno(f), file, pw, line, sizeof(line)) != 0) {\n\t\tfclose(f);\n\t\tlogit(\"Authentication refused: %s\", line);\n\t\tauth_debug_add(\"Ignored %s: %s\", file_type, line);\n\t\treturn NULL;\n\t}\n\n\treturn f;\n}"
  },
  {
    "function_name": "check_key_in_hostfiles",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
    "lines": "459-502",
    "snippet": "HostStatus\ncheck_key_in_hostfiles(struct passwd *pw, struct sshkey *key, const char *host,\n    const char *sysfile, const char *userfile)\n{\n\tchar *user_hostfile;\n\tstruct stat st;\n\tHostStatus host_status;\n\tstruct hostkeys *hostkeys;\n\tconst struct hostkey_entry *found;\n\n\thostkeys = init_hostkeys();\n\tload_hostkeys(hostkeys, host, sysfile);\n\tif (userfile != NULL) {\n\t\tuser_hostfile = tilde_expand_filename(userfile, pw->pw_uid);\n\t\tif (options.strict_modes &&\n\t\t    (stat(user_hostfile, &st) == 0) &&\n\t\t    ((st.st_uid != 0 && st.st_uid != pw->pw_uid) ||\n\t\t    (st.st_mode & 022) != 0)) {\n\t\t\tlogit(\"Authentication refused for %.100s: \"\n\t\t\t    \"bad owner or modes for %.200s\",\n\t\t\t    pw->pw_name, user_hostfile);\n\t\t\tauth_debug_add(\"Ignored %.200s: bad ownership or modes\",\n\t\t\t    user_hostfile);\n\t\t} else {\n\t\t\ttemporarily_use_uid(pw);\n\t\t\tload_hostkeys(hostkeys, host, user_hostfile);\n\t\t\trestore_uid();\n\t\t}\n\t\tfree(user_hostfile);\n\t}\n\thost_status = check_key_in_hostkeys(hostkeys, key, &found);\n\tif (host_status == HOST_REVOKED)\n\t\terror(\"WARNING: revoked key for %s attempted authentication\",\n\t\t    found->host);\n\telse if (host_status == HOST_OK)\n\t\tdebug(\"%s: key for %s found at %s:%ld\", __func__,\n\t\t    found->host, found->file, found->line);\n\telse\n\t\tdebug(\"%s: key for host %s not found\", __func__, host);\n\n\tfree_hostkeys(hostkeys);\n\n\treturn host_status;\n}",
    "includes": [
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"authfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"loginrec.h\"",
      "#include \"packet.h\"",
      "#include \"uidswap.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"groupaccess.h\"",
      "#include \"match.h\"",
      "#include \"xmalloc.h\"",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <shadow.h>",
      "#include <login.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_hostkeys",
          "args": [
            "hostkeys"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "free_hostkeys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/hostfile.c",
          "lines": "291-305",
          "snippet": "void\nfree_hostkeys(struct hostkeys *hostkeys)\n{\n\tu_int i;\n\n\tfor (i = 0; i < hostkeys->num_entries; i++) {\n\t\tfree(hostkeys->entries[i].host);\n\t\tfree(hostkeys->entries[i].file);\n\t\tsshkey_free(hostkeys->entries[i].key);\n\t\texplicit_bzero(hostkeys->entries + i, sizeof(*hostkeys->entries));\n\t}\n\tfree(hostkeys->entries);\n\texplicit_bzero(hostkeys, sizeof(*hostkeys));\n\tfree(hostkeys);\n}",
          "includes": [
            "#include \"hmac.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <resolv.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <resolv.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfree_hostkeys(struct hostkeys *hostkeys)\n{\n\tu_int i;\n\n\tfor (i = 0; i < hostkeys->num_entries; i++) {\n\t\tfree(hostkeys->entries[i].host);\n\t\tfree(hostkeys->entries[i].file);\n\t\tsshkey_free(hostkeys->entries[i].key);\n\t\texplicit_bzero(hostkeys->entries + i, sizeof(*hostkeys->entries));\n\t}\n\tfree(hostkeys->entries);\n\texplicit_bzero(hostkeys, sizeof(*hostkeys));\n\tfree(hostkeys);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: key for host %s not found\"",
            "__func__",
            "host"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "auth_debug_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "673-688",
          "snippet": "void\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sshbuf *auth_debug;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshbuf *auth_debug;\n\nvoid\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"WARNING: revoked key for %s attempted authentication\"",
            "found->host"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_key_in_hostkeys",
          "args": [
            "hostkeys",
            "key",
            "&found"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "check_key_in_hostkeys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/hostfile.c",
          "lines": "395-402",
          "snippet": "HostStatus\ncheck_key_in_hostkeys(struct hostkeys *hostkeys, struct sshkey *key,\n    const struct hostkey_entry **found)\n{\n\tif (key == NULL)\n\t\tfatal(\"no key to look up\");\n\treturn check_hostkeys_by_key_or_type(hostkeys, key, 0, found);\n}",
          "includes": [
            "#include \"hmac.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <resolv.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <resolv.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nHostStatus\ncheck_key_in_hostkeys(struct hostkeys *hostkeys, struct sshkey *key,\n    const struct hostkey_entry **found)\n{\n\tif (key == NULL)\n\t\tfatal(\"no key to look up\");\n\treturn check_hostkeys_by_key_or_type(hostkeys, key, 0, found);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "user_hostfile"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_uid",
          "args": [],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "restore_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "141-172",
          "snippet": "void\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_hostkeys",
          "args": [
            "hostkeys",
            "host",
            "user_hostfile"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "load_hostkeys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/hostfile.c",
          "lines": "270-289",
          "snippet": "void\nload_hostkeys(struct hostkeys *hostkeys, const char *host, const char *path)\n{\n\tint r;\n\tstruct load_callback_ctx ctx;\n\n\tctx.host = host;\n\tctx.num_loaded = 0;\n\tctx.hostkeys = hostkeys;\n\n\tif ((r = hostkeys_foreach(path, record_hostkey, &ctx, host, NULL,\n\t    HKF_WANT_MATCH|HKF_WANT_PARSE_KEY)) != 0) {\n\t\tif (r != SSH_ERR_SYSTEM_ERROR && errno != ENOENT)\n\t\t\tdebug(\"%s: hostkeys_foreach failed for %s: %s\",\n\t\t\t    __func__, path, ssh_err(r));\n\t}\n\tif (ctx.num_loaded != 0)\n\t\tdebug3(\"%s: loaded %lu keys from %s\", __func__,\n\t\t    ctx.num_loaded, host);\n}",
          "includes": [
            "#include \"hmac.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <resolv.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <resolv.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nload_hostkeys(struct hostkeys *hostkeys, const char *host, const char *path)\n{\n\tint r;\n\tstruct load_callback_ctx ctx;\n\n\tctx.host = host;\n\tctx.num_loaded = 0;\n\tctx.hostkeys = hostkeys;\n\n\tif ((r = hostkeys_foreach(path, record_hostkey, &ctx, host, NULL,\n\t    HKF_WANT_MATCH|HKF_WANT_PARSE_KEY)) != 0) {\n\t\tif (r != SSH_ERR_SYSTEM_ERROR && errno != ENOENT)\n\t\t\tdebug(\"%s: hostkeys_foreach failed for %s: %s\",\n\t\t\t    __func__, path, ssh_err(r));\n\t}\n\tif (ctx.num_loaded != 0)\n\t\tdebug3(\"%s: loaded %lu keys from %s\", __func__,\n\t\t    ctx.num_loaded, host);\n}"
        }
      },
      {
        "call_info": {
          "callee": "temporarily_use_uid",
          "args": [
            "pw"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "temporarily_use_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "60-136",
          "snippet": "void\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static uid_t\tuser_groups_uid;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic uid_t\tuser_groups_uid;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Authentication refused for %.100s: \"\n\t\t\t    \"bad owner or modes for %.200s\"",
            "pw->pw_name",
            "user_hostfile"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "user_hostfile",
            "&st"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "tilde_expand_filename",
          "args": [
            "userfile",
            "pw->pw_uid"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "tilde_expand_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "926-965",
          "snippet": "char *\ntilde_expand_filename(const char *filename, uid_t uid)\n{\n\tconst char *path, *sep;\n\tchar user[128], *ret;\n\tstruct passwd *pw;\n\tu_int len, slash;\n\n\tif (*filename != '~')\n\t\treturn (xstrdup(filename));\n\tfilename++;\n\n\tpath = strchr(filename, '/');\n\tif (path != NULL && path > filename) {\t\t/* ~user/path */\n\t\tslash = path - filename;\n\t\tif (slash > sizeof(user) - 1)\n\t\t\tfatal(\"tilde_expand_filename: ~username too long\");\n\t\tmemcpy(user, filename, slash);\n\t\tuser[slash] = '\\0';\n\t\tif ((pw = getpwnam(user)) == NULL)\n\t\t\tfatal(\"tilde_expand_filename: No such user %s\", user);\n\t} else if ((pw = getpwuid(uid)) == NULL)\t/* ~/path */\n\t\tfatal(\"tilde_expand_filename: No such uid %ld\", (long)uid);\n\n\t/* Make sure directory has a trailing '/' */\n\tlen = strlen(pw->pw_dir);\n\tif (len == 0 || pw->pw_dir[len - 1] != '/')\n\t\tsep = \"/\";\n\telse\n\t\tsep = \"\";\n\n\t/* Skip leading '/' from specified path */\n\tif (path != NULL)\n\t\tfilename = path + 1;\n\n\tif (xasprintf(&ret, \"%s%s%s\", pw->pw_dir, sep, filename) >= PATH_MAX)\n\t\tfatal(\"tilde_expand_filename: Path too long\");\n\n\treturn (ret);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ntilde_expand_filename(const char *filename, uid_t uid)\n{\n\tconst char *path, *sep;\n\tchar user[128], *ret;\n\tstruct passwd *pw;\n\tu_int len, slash;\n\n\tif (*filename != '~')\n\t\treturn (xstrdup(filename));\n\tfilename++;\n\n\tpath = strchr(filename, '/');\n\tif (path != NULL && path > filename) {\t\t/* ~user/path */\n\t\tslash = path - filename;\n\t\tif (slash > sizeof(user) - 1)\n\t\t\tfatal(\"tilde_expand_filename: ~username too long\");\n\t\tmemcpy(user, filename, slash);\n\t\tuser[slash] = '\\0';\n\t\tif ((pw = getpwnam(user)) == NULL)\n\t\t\tfatal(\"tilde_expand_filename: No such user %s\", user);\n\t} else if ((pw = getpwuid(uid)) == NULL)\t/* ~/path */\n\t\tfatal(\"tilde_expand_filename: No such uid %ld\", (long)uid);\n\n\t/* Make sure directory has a trailing '/' */\n\tlen = strlen(pw->pw_dir);\n\tif (len == 0 || pw->pw_dir[len - 1] != '/')\n\t\tsep = \"/\";\n\telse\n\t\tsep = \"\";\n\n\t/* Skip leading '/' from specified path */\n\tif (path != NULL)\n\t\tfilename = path + 1;\n\n\tif (xasprintf(&ret, \"%s%s%s\", pw->pw_dir, sep, filename) >= PATH_MAX)\n\t\tfatal(\"tilde_expand_filename: Path too long\");\n\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_hostkeys",
          "args": [],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "init_hostkeys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/hostfile.c",
          "lines": "221-228",
          "snippet": "struct hostkeys *\ninit_hostkeys(void)\n{\n\tstruct hostkeys *ret = xcalloc(1, sizeof(*ret));\n\n\tret->entries = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"hmac.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <resolv.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <resolv.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct hostkeys *\ninit_hostkeys(void)\n{\n\tstruct hostkeys *ret = xcalloc(1, sizeof(*ret));\n\n\tret->entries = NULL;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nHostStatus\ncheck_key_in_hostfiles(struct passwd *pw, struct sshkey *key, const char *host,\n    const char *sysfile, const char *userfile)\n{\n\tchar *user_hostfile;\n\tstruct stat st;\n\tHostStatus host_status;\n\tstruct hostkeys *hostkeys;\n\tconst struct hostkey_entry *found;\n\n\thostkeys = init_hostkeys();\n\tload_hostkeys(hostkeys, host, sysfile);\n\tif (userfile != NULL) {\n\t\tuser_hostfile = tilde_expand_filename(userfile, pw->pw_uid);\n\t\tif (options.strict_modes &&\n\t\t    (stat(user_hostfile, &st) == 0) &&\n\t\t    ((st.st_uid != 0 && st.st_uid != pw->pw_uid) ||\n\t\t    (st.st_mode & 022) != 0)) {\n\t\t\tlogit(\"Authentication refused for %.100s: \"\n\t\t\t    \"bad owner or modes for %.200s\",\n\t\t\t    pw->pw_name, user_hostfile);\n\t\t\tauth_debug_add(\"Ignored %.200s: bad ownership or modes\",\n\t\t\t    user_hostfile);\n\t\t} else {\n\t\t\ttemporarily_use_uid(pw);\n\t\t\tload_hostkeys(hostkeys, host, user_hostfile);\n\t\t\trestore_uid();\n\t\t}\n\t\tfree(user_hostfile);\n\t}\n\thost_status = check_key_in_hostkeys(hostkeys, key, &found);\n\tif (host_status == HOST_REVOKED)\n\t\terror(\"WARNING: revoked key for %s attempted authentication\",\n\t\t    found->host);\n\telse if (host_status == HOST_OK)\n\t\tdebug(\"%s: key for %s found at %s:%ld\", __func__,\n\t\t    found->host, found->file, found->line);\n\telse\n\t\tdebug(\"%s: key for host %s not found\", __func__, host);\n\n\tfree_hostkeys(hostkeys);\n\n\treturn host_status;\n}"
  },
  {
    "function_name": "authorized_principals_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
    "lines": "450-456",
    "snippet": "char *\nauthorized_principals_file(struct passwd *pw)\n{\n\tif (options.authorized_principals_file == NULL)\n\t\treturn NULL;\n\treturn expand_authorized_keys(options.authorized_principals_file, pw);\n}",
    "includes": [
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"authfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"loginrec.h\"",
      "#include \"packet.h\"",
      "#include \"uidswap.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"groupaccess.h\"",
      "#include \"match.h\"",
      "#include \"xmalloc.h\"",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <shadow.h>",
      "#include <login.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "expand_authorized_keys",
          "args": [
            "options.authorized_principals_file",
            "pw"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "expand_authorized_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "425-448",
          "snippet": "char *\nexpand_authorized_keys(const char *filename, struct passwd *pw)\n{\n\tchar *file, uidstr[32], ret[PATH_MAX];\n\tint i;\n\n\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t    (unsigned long long)pw->pw_uid);\n\tfile = percent_expand(filename, \"h\", pw->pw_dir,\n\t    \"u\", pw->pw_name, \"U\", uidstr, (char *)NULL);\n\n\t/*\n\t * Ensure that filename starts anchored. If not, be backward\n\t * compatible and prepend the '%h/'\n\t */\n\tif (*file == '/')\n\t\treturn (file);\n\n\ti = snprintf(ret, sizeof(ret), \"%s/%s\", pw->pw_dir, file);\n\tif (i < 0 || (size_t)i >= sizeof(ret))\n\t\tfatal(\"expand_authorized_keys: path too long\");\n\tfree(file);\n\treturn (xstrdup(ret));\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nexpand_authorized_keys(const char *filename, struct passwd *pw)\n{\n\tchar *file, uidstr[32], ret[PATH_MAX];\n\tint i;\n\n\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t    (unsigned long long)pw->pw_uid);\n\tfile = percent_expand(filename, \"h\", pw->pw_dir,\n\t    \"u\", pw->pw_name, \"U\", uidstr, (char *)NULL);\n\n\t/*\n\t * Ensure that filename starts anchored. If not, be backward\n\t * compatible and prepend the '%h/'\n\t */\n\tif (*file == '/')\n\t\treturn (file);\n\n\ti = snprintf(ret, sizeof(ret), \"%s/%s\", pw->pw_dir, file);\n\tif (i < 0 || (size_t)i >= sizeof(ret))\n\t\tfatal(\"expand_authorized_keys: path too long\");\n\tfree(file);\n\treturn (xstrdup(ret));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nchar *\nauthorized_principals_file(struct passwd *pw)\n{\n\tif (options.authorized_principals_file == NULL)\n\t\treturn NULL;\n\treturn expand_authorized_keys(options.authorized_principals_file, pw);\n}"
  },
  {
    "function_name": "expand_authorized_keys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
    "lines": "425-448",
    "snippet": "char *\nexpand_authorized_keys(const char *filename, struct passwd *pw)\n{\n\tchar *file, uidstr[32], ret[PATH_MAX];\n\tint i;\n\n\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t    (unsigned long long)pw->pw_uid);\n\tfile = percent_expand(filename, \"h\", pw->pw_dir,\n\t    \"u\", pw->pw_name, \"U\", uidstr, (char *)NULL);\n\n\t/*\n\t * Ensure that filename starts anchored. If not, be backward\n\t * compatible and prepend the '%h/'\n\t */\n\tif (*file == '/')\n\t\treturn (file);\n\n\ti = snprintf(ret, sizeof(ret), \"%s/%s\", pw->pw_dir, file);\n\tif (i < 0 || (size_t)i >= sizeof(ret))\n\t\tfatal(\"expand_authorized_keys: path too long\");\n\tfree(file);\n\treturn (xstrdup(ret));\n}",
    "includes": [
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"authfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"loginrec.h\"",
      "#include \"packet.h\"",
      "#include \"uidswap.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"groupaccess.h\"",
      "#include \"match.h\"",
      "#include \"xmalloc.h\"",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <shadow.h>",
      "#include <login.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "ret"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "file"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"expand_authorized_keys: path too long\""
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ret",
            "sizeof(ret)",
            "\"%s/%s\"",
            "pw->pw_dir",
            "file"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "percent_expand",
          "args": [
            "filename",
            "\"h\"",
            "pw->pw_dir",
            "\"u\"",
            "pw->pw_name",
            "\"U\"",
            "uidstr",
            "(char *)NULL"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "percent_expand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "973-1029",
          "snippet": "char *\npercent_expand(const char *string, ...)\n{\n#define EXPAND_MAX_KEYS\t16\n\tu_int num_keys, i, j;\n\tstruct {\n\t\tconst char *key;\n\t\tconst char *repl;\n\t} keys[EXPAND_MAX_KEYS];\n\tchar buf[4096];\n\tva_list ap;\n\n\t/* Gather keys */\n\tva_start(ap, string);\n\tfor (num_keys = 0; num_keys < EXPAND_MAX_KEYS; num_keys++) {\n\t\tkeys[num_keys].key = va_arg(ap, char *);\n\t\tif (keys[num_keys].key == NULL)\n\t\t\tbreak;\n\t\tkeys[num_keys].repl = va_arg(ap, char *);\n\t\tif (keys[num_keys].repl == NULL)\n\t\t\tfatal(\"%s: NULL replacement\", __func__);\n\t}\n\tif (num_keys == EXPAND_MAX_KEYS && va_arg(ap, char *) != NULL)\n\t\tfatal(\"%s: too many keys\", __func__);\n\tva_end(ap);\n\n\t/* Expand string */\n\t*buf = '\\0';\n\tfor (i = 0; *string != '\\0'; string++) {\n\t\tif (*string != '%') {\n append:\n\t\t\tbuf[i++] = *string;\n\t\t\tif (i >= sizeof(buf))\n\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\tbuf[i] = '\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tstring++;\n\t\t/* %% case */\n\t\tif (*string == '%')\n\t\t\tgoto append;\n\t\tif (*string == '\\0')\n\t\t\tfatal(\"%s: invalid format\", __func__);\n\t\tfor (j = 0; j < num_keys; j++) {\n\t\t\tif (strchr(keys[j].key, *string) != NULL) {\n\t\t\t\ti = strlcat(buf, keys[j].repl, sizeof(buf));\n\t\t\t\tif (i >= sizeof(buf))\n\t\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j >= num_keys)\n\t\t\tfatal(\"%s: unknown key %%%c\", __func__, *string);\n\t}\n\treturn (xstrdup(buf));\n#undef EXPAND_MAX_KEYS\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define EXPAND_MAX_KEYS\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define EXPAND_MAX_KEYS\t16\n\nchar *\npercent_expand(const char *string, ...)\n{\n#define EXPAND_MAX_KEYS\t16\n\tu_int num_keys, i, j;\n\tstruct {\n\t\tconst char *key;\n\t\tconst char *repl;\n\t} keys[EXPAND_MAX_KEYS];\n\tchar buf[4096];\n\tva_list ap;\n\n\t/* Gather keys */\n\tva_start(ap, string);\n\tfor (num_keys = 0; num_keys < EXPAND_MAX_KEYS; num_keys++) {\n\t\tkeys[num_keys].key = va_arg(ap, char *);\n\t\tif (keys[num_keys].key == NULL)\n\t\t\tbreak;\n\t\tkeys[num_keys].repl = va_arg(ap, char *);\n\t\tif (keys[num_keys].repl == NULL)\n\t\t\tfatal(\"%s: NULL replacement\", __func__);\n\t}\n\tif (num_keys == EXPAND_MAX_KEYS && va_arg(ap, char *) != NULL)\n\t\tfatal(\"%s: too many keys\", __func__);\n\tva_end(ap);\n\n\t/* Expand string */\n\t*buf = '\\0';\n\tfor (i = 0; *string != '\\0'; string++) {\n\t\tif (*string != '%') {\n append:\n\t\t\tbuf[i++] = *string;\n\t\t\tif (i >= sizeof(buf))\n\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\tbuf[i] = '\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tstring++;\n\t\t/* %% case */\n\t\tif (*string == '%')\n\t\t\tgoto append;\n\t\tif (*string == '\\0')\n\t\t\tfatal(\"%s: invalid format\", __func__);\n\t\tfor (j = 0; j < num_keys; j++) {\n\t\t\tif (strchr(keys[j].key, *string) != NULL) {\n\t\t\t\ti = strlcat(buf, keys[j].repl, sizeof(buf));\n\t\t\t\tif (i >= sizeof(buf))\n\t\t\t\t\tfatal(\"%s: string too long\", __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j >= num_keys)\n\t\t\tfatal(\"%s: unknown key %%%c\", __func__, *string);\n\t}\n\treturn (xstrdup(buf));\n#undef EXPAND_MAX_KEYS\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nexpand_authorized_keys(const char *filename, struct passwd *pw)\n{\n\tchar *file, uidstr[32], ret[PATH_MAX];\n\tint i;\n\n\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t    (unsigned long long)pw->pw_uid);\n\tfile = percent_expand(filename, \"h\", pw->pw_dir,\n\t    \"u\", pw->pw_name, \"U\", uidstr, (char *)NULL);\n\n\t/*\n\t * Ensure that filename starts anchored. If not, be backward\n\t * compatible and prepend the '%h/'\n\t */\n\tif (*file == '/')\n\t\treturn (file);\n\n\ti = snprintf(ret, sizeof(ret), \"%s/%s\", pw->pw_dir, file);\n\tif (i < 0 || (size_t)i >= sizeof(ret))\n\t\tfatal(\"expand_authorized_keys: path too long\");\n\tfree(file);\n\treturn (xstrdup(ret));\n}"
  },
  {
    "function_name": "auth_root_allowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
    "lines": "393-415",
    "snippet": "int\nauth_root_allowed(struct ssh *ssh, const char *method)\n{\n\tswitch (options.permit_root_login) {\n\tcase PERMIT_YES:\n\t\treturn 1;\n\tcase PERMIT_NO_PASSWD:\n\t\tif (strcmp(method, \"publickey\") == 0 ||\n\t\t    strcmp(method, \"hostbased\") == 0 ||\n\t\t    strcmp(method, \"gssapi-with-mic\") == 0)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase PERMIT_FORCED_ONLY:\n\t\tif (auth_opts->force_command != NULL) {\n\t\t\tlogit(\"Root login accepted for forced command.\");\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\t}\n\tlogit(\"ROOT LOGIN REFUSED FROM %.200s port %d\",\n\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\treturn 0;\n}",
    "includes": [
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"authfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"loginrec.h\"",
      "#include \"packet.h\"",
      "#include \"uidswap.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"groupaccess.h\"",
      "#include \"match.h\"",
      "#include \"xmalloc.h\"",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <shadow.h>",
      "#include <login.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "extern struct sshauthopt *auth_opts;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"ROOT LOGIN REFUSED FROM %.200s port %d\"",
            "ssh_remote_ipaddr(ssh)",
            "ssh_remote_port(ssh)"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_port",
          "args": [
            "ssh"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "539-544",
          "snippet": "int\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->remote_port;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->remote_port;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_ipaddr",
          "args": [
            "ssh"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "514-535",
          "snippet": "const char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "method",
            "\"gssapi-with-mic\""
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern struct sshauthopt *auth_opts;\n\nint\nauth_root_allowed(struct ssh *ssh, const char *method)\n{\n\tswitch (options.permit_root_login) {\n\tcase PERMIT_YES:\n\t\treturn 1;\n\tcase PERMIT_NO_PASSWD:\n\t\tif (strcmp(method, \"publickey\") == 0 ||\n\t\t    strcmp(method, \"hostbased\") == 0 ||\n\t\t    strcmp(method, \"gssapi-with-mic\") == 0)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase PERMIT_FORCED_ONLY:\n\t\tif (auth_opts->force_command != NULL) {\n\t\t\tlogit(\"Root login accepted for forced command.\");\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\t}\n\tlogit(\"ROOT LOGIN REFUSED FROM %.200s port %d\",\n\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\treturn 0;\n}"
  },
  {
    "function_name": "auth_maxtries_exceeded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
    "lines": "375-388",
    "snippet": "void\nauth_maxtries_exceeded(Authctxt *authctxt)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\n\terror(\"maximum authentication attempts exceeded for \"\n\t    \"%s%.100s from %.200s port %d ssh2\",\n\t    authctxt->valid ? \"\" : \"invalid user \",\n\t    authctxt->user,\n\t    ssh_remote_ipaddr(ssh),\n\t    ssh_remote_port(ssh));\n\tpacket_disconnect(\"Too many authentication failures\");\n\t/* NOTREACHED */\n}",
    "includes": [
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"authfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"loginrec.h\"",
      "#include \"packet.h\"",
      "#include \"uidswap.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"groupaccess.h\"",
      "#include \"match.h\"",
      "#include \"xmalloc.h\"",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <shadow.h>",
      "#include <login.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "packet_disconnect",
          "args": [
            "\"Too many authentication failures\""
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "packet_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/opacket.c",
          "lines": "298-308",
          "snippet": "void\npacket_disconnect(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_disconnect(active_state, \"%s\", buf);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\npacket_disconnect(const char *fmt, ...)\n{\n\tchar buf[1024];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tssh_packet_disconnect(active_state, \"%s\", buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"maximum authentication attempts exceeded for \"\n\t    \"%s%.100s from %.200s port %d ssh2\"",
            "authctxt->valid ? \"\" : \"invalid user \"",
            "authctxt->user",
            "ssh_remote_ipaddr(ssh)",
            "ssh_remote_port(ssh)"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_port",
          "args": [
            "ssh"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "539-544",
          "snippet": "int\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->remote_port;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->remote_port;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_ipaddr",
          "args": [
            "ssh"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "514-535",
          "snippet": "const char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nauth_maxtries_exceeded(Authctxt *authctxt)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\n\terror(\"maximum authentication attempts exceeded for \"\n\t    \"%s%.100s from %.200s port %d ssh2\",\n\t    authctxt->valid ? \"\" : \"invalid user \",\n\t    authctxt->user,\n\t    ssh_remote_ipaddr(ssh),\n\t    ssh_remote_port(ssh));\n\tpacket_disconnect(\"Too many authentication failures\");\n\t/* NOTREACHED */\n}"
  },
  {
    "function_name": "auth_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
    "lines": "310-372",
    "snippet": "void\nauth_log(Authctxt *authctxt, int authenticated, int partial,\n    const char *method, const char *submethod)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tint level = SYSLOG_LEVEL_VERBOSE;\n\tconst char *authmsg;\n\tchar *extra = NULL;\n\n\tif (use_privsep && !mm_is_monitor() && !authctxt->postponed)\n\t\treturn;\n\n\t/* Raise logging level */\n\tif (authenticated == 1 ||\n\t    !authctxt->valid ||\n\t    authctxt->failures >= options.max_authtries / 2 ||\n\t    strcmp(method, \"password\") == 0)\n\t\tlevel = SYSLOG_LEVEL_INFO;\n\n\tif (authctxt->postponed)\n\t\tauthmsg = \"Postponed\";\n\telse if (partial)\n\t\tauthmsg = \"Partial\";\n\telse\n\t\tauthmsg = authenticated ? \"Accepted\" : \"Failed\";\n\n\tif ((extra = format_method_key(authctxt)) == NULL) {\n\t\tif (authctxt->auth_method_info != NULL)\n\t\t\textra = xstrdup(authctxt->auth_method_info);\n\t}\n\n\tdo_log2(level, \"%s %s%s%s for %s%.100s from %.200s port %d ssh2%s%s\",\n\t    authmsg,\n\t    method,\n\t    submethod != NULL ? \"/\" : \"\", submethod == NULL ? \"\" : submethod,\n\t    authctxt->valid ? \"\" : \"invalid user \",\n\t    authctxt->user,\n\t    ssh_remote_ipaddr(ssh),\n\t    ssh_remote_port(ssh),\n\t    extra != NULL ? \": \" : \"\",\n\t    extra != NULL ? extra : \"\");\n\n\tfree(extra);\n\n#ifdef CUSTOM_FAILED_LOGIN\n\tif (authenticated == 0 && !authctxt->postponed &&\n\t    (strcmp(method, \"password\") == 0 ||\n\t    strncmp(method, \"keyboard-interactive\", 20) == 0 ||\n\t    strcmp(method, \"challenge-response\") == 0))\n\t\trecord_failed_login(authctxt->user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\");\n# ifdef WITH_AIXAUTHENTICATE\n\tif (authenticated)\n\t\tsys_auth_record_login(authctxt->user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\",\n\t\t    &loginmsg);\n# endif\n#endif\n#ifdef SSH_AUDIT_EVENTS\n\tif (authenticated == 0 && !authctxt->postponed)\n\t\taudit_event(audit_classify_auth(method));\n#endif\n}",
    "includes": [
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"authfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"loginrec.h\"",
      "#include \"packet.h\"",
      "#include \"uidswap.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"groupaccess.h\"",
      "#include \"match.h\"",
      "#include \"xmalloc.h\"",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <shadow.h>",
      "#include <login.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "extern int use_privsep;",
      "extern struct sshbuf *loginmsg;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_event",
          "args": [
            "audit_classify_auth(method)"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "audit_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit.c",
          "lines": "133-138",
          "snippet": "void\naudit_event(ssh_audit_event_t event)\n{\n\tdebug(\"audit event euid %d user %s event %d (%s)\", geteuid(),\n\t    audit_username(), event, audit_event_lookup(event));\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"log.h\"",
            "#include \"audit.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"audit.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\naudit_event(ssh_audit_event_t event)\n{\n\tdebug(\"audit event euid %d user %s event %d (%s)\", geteuid(),\n\t    audit_username(), event, audit_event_lookup(event));\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_classify_auth",
          "args": [
            "method"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "audit_classify_auth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit.c",
          "lines": "46-66",
          "snippet": "ssh_audit_event_t\naudit_classify_auth(const char *method)\n{\n\tif (strcmp(method, \"none\") == 0)\n\t\treturn SSH_AUTH_FAIL_NONE;\n\telse if (strcmp(method, \"password\") == 0)\n\t\treturn SSH_AUTH_FAIL_PASSWD;\n\telse if (strcmp(method, \"publickey\") == 0 ||\n\t    strcmp(method, \"rsa\") == 0)\n\t\treturn SSH_AUTH_FAIL_PUBKEY;\n\telse if (strncmp(method, \"keyboard-interactive\", 20) == 0 ||\n\t    strcmp(method, \"challenge-response\") == 0)\n\t\treturn SSH_AUTH_FAIL_KBDINT;\n\telse if (strcmp(method, \"hostbased\") == 0 ||\n\t    strcmp(method, \"rhosts-rsa\") == 0)\n\t\treturn SSH_AUTH_FAIL_HOSTBASED;\n\telse if (strcmp(method, \"gssapi-with-mic\") == 0)\n\t\treturn SSH_AUTH_FAIL_GSSAPI;\n\telse\n\t\treturn SSH_AUDIT_UNKNOWN;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"log.h\"",
            "#include \"audit.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"audit.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nssh_audit_event_t\naudit_classify_auth(const char *method)\n{\n\tif (strcmp(method, \"none\") == 0)\n\t\treturn SSH_AUTH_FAIL_NONE;\n\telse if (strcmp(method, \"password\") == 0)\n\t\treturn SSH_AUTH_FAIL_PASSWD;\n\telse if (strcmp(method, \"publickey\") == 0 ||\n\t    strcmp(method, \"rsa\") == 0)\n\t\treturn SSH_AUTH_FAIL_PUBKEY;\n\telse if (strncmp(method, \"keyboard-interactive\", 20) == 0 ||\n\t    strcmp(method, \"challenge-response\") == 0)\n\t\treturn SSH_AUTH_FAIL_KBDINT;\n\telse if (strcmp(method, \"hostbased\") == 0 ||\n\t    strcmp(method, \"rhosts-rsa\") == 0)\n\t\treturn SSH_AUTH_FAIL_HOSTBASED;\n\telse if (strcmp(method, \"gssapi-with-mic\") == 0)\n\t\treturn SSH_AUTH_FAIL_GSSAPI;\n\telse\n\t\treturn SSH_AUDIT_UNKNOWN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sys_auth_record_login",
          "args": [
            "authctxt->user",
            "auth_get_canonical_hostname(ssh, options.use_dns)",
            "\"ssh\"",
            "&loginmsg"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "sys_auth_record_login",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "282-300",
          "snippet": "int\nsys_auth_record_login(const char *user, const char *host, const char *ttynm,\n    struct sshbuf *loginmsg)\n{\n\tchar *msg = NULL;\n\tint success = 0;\n\n\taix_setauthdb(user);\n\tif (loginsuccess((char *)user, (char *)host, (char *)ttynm, &msg) == 0) {\n\t\tsuccess = 1;\n\t\tif (msg != NULL) {\n\t\t\tdebug(\"AIX/loginsuccess: msg %s\", msg);\n\t\t\tif (lastlogin_msg == NULL)\n\t\t\t\tlastlogin_msg = msg;\n\t\t}\n\t}\n\taix_restoreauthdb();\n\treturn (success);\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nint\nsys_auth_record_login(const char *user, const char *host, const char *ttynm,\n    struct sshbuf *loginmsg)\n{\n\tchar *msg = NULL;\n\tint success = 0;\n\n\taix_setauthdb(user);\n\tif (loginsuccess((char *)user, (char *)host, (char *)ttynm, &msg) == 0) {\n\t\tsuccess = 1;\n\t\tif (msg != NULL) {\n\t\t\tdebug(\"AIX/loginsuccess: msg %s\", msg);\n\t\t\tif (lastlogin_msg == NULL)\n\t\t\t\tlastlogin_msg = msg;\n\t\t}\n\t}\n\taix_restoreauthdb();\n\treturn (success);\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_get_canonical_hostname",
          "args": [
            "ssh",
            "options.use_dns"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "auth_get_canonical_hostname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "839-852",
          "snippet": "const char *\nauth_get_canonical_hostname(struct ssh *ssh, int use_dns)\n{\n\tstatic char *dnsname;\n\n\tif (!use_dns)\n\t\treturn ssh_remote_ipaddr(ssh);\n\telse if (dnsname != NULL)\n\t\treturn dnsname;\n\telse {\n\t\tdnsname = remote_hostname(ssh);\n\t\treturn dnsname;\n\t}\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nauth_get_canonical_hostname(struct ssh *ssh, int use_dns)\n{\n\tstatic char *dnsname;\n\n\tif (!use_dns)\n\t\treturn ssh_remote_ipaddr(ssh);\n\telse if (dnsname != NULL)\n\t\treturn dnsname;\n\telse {\n\t\tdnsname = remote_hostname(ssh);\n\t\treturn dnsname;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "record_failed_login",
          "args": [
            "authctxt->user",
            "auth_get_canonical_hostname(ssh, options.use_dns)",
            "\"ssh\""
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "record_failed_login",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/loginrec.c",
          "lines": "1655-1723",
          "snippet": "void\nrecord_failed_login(const char *username, const char *hostname,\n    const char *ttyn)\n{\n\tint fd;\n\tstruct utmp ut;\n\tstruct sockaddr_storage from;\n\tsocklen_t fromlen = sizeof(from);\n\tstruct sockaddr_in *a4;\n\tstruct sockaddr_in6 *a6;\n\ttime_t t;\n\tstruct stat fst;\n\n\tif (geteuid() != 0)\n\t\treturn;\n\tif ((fd = open(_PATH_BTMP, O_WRONLY | O_APPEND)) < 0) {\n\t\tdebug(\"Unable to open the btmp file %s: %s\", _PATH_BTMP,\n\t\t    strerror(errno));\n\t\treturn;\n\t}\n\tif (fstat(fd, &fst) < 0) {\n\t\tlogit(\"%s: fstat of %s failed: %s\", __func__, _PATH_BTMP,\n\t\t    strerror(errno));\n\t\tgoto out;\n\t}\n\tif((fst.st_mode & (S_IXGRP | S_IRWXO)) || (fst.st_uid != 0)){\n\t\tlogit(\"Excess permission or bad ownership on file %s\",\n\t\t    _PATH_BTMP);\n\t\tgoto out;\n\t}\n\n\tmemset(&ut, 0, sizeof(ut));\n\t/* strncpy because we don't necessarily want nul termination */\n\tstrncpy(ut.ut_user, username, sizeof(ut.ut_user));\n\tstrlcpy(ut.ut_line, \"ssh:notty\", sizeof(ut.ut_line));\n\n\ttime(&t);\n\tut.ut_time = t;     /* ut_time is not always a time_t */\n\tut.ut_type = LOGIN_PROCESS;\n\tut.ut_pid = getpid();\n\n\t/* strncpy because we don't necessarily want nul termination */\n\tstrncpy(ut.ut_host, hostname, sizeof(ut.ut_host));\n\n\tif (packet_connection_is_on_socket() &&\n\t    getpeername(packet_get_connection_in(),\n\t    (struct sockaddr *)&from, &fromlen) == 0) {\n\t\tipv64_normalise_mapped(&from, &fromlen);\n\t\tif (from.ss_family == AF_INET) {\n\t\t\ta4 = (struct sockaddr_in *)&from;\n\t\t\tmemcpy(&ut.ut_addr, &(a4->sin_addr),\n\t\t\t    MIN_SIZEOF(ut.ut_addr, a4->sin_addr));\n\t\t}\n#ifdef HAVE_ADDR_V6_IN_UTMP\n\t\tif (from.ss_family == AF_INET6) {\n\t\t\ta6 = (struct sockaddr_in6 *)&from;\n\t\t\tmemcpy(&ut.ut_addr_v6, &(a6->sin6_addr),\n\t\t\t    MIN_SIZEOF(ut.ut_addr_v6, a6->sin6_addr));\n\t\t}\n#endif\n\t}\n\n\tif (atomicio(vwrite, fd, &ut, sizeof(ut)) != sizeof(ut))\n\t\terror(\"Failed to write to %s: %s\", _PATH_BTMP,\n\t\t    strerror(errno));\n\nout:\n\tclose(fd);\n}",
          "includes": [
            "# include <util.h>",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"canohost.h\"",
            "#include \"packet.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"loginrec.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <util.h>\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"canohost.h\"\n#include \"packet.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"loginrec.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nrecord_failed_login(const char *username, const char *hostname,\n    const char *ttyn)\n{\n\tint fd;\n\tstruct utmp ut;\n\tstruct sockaddr_storage from;\n\tsocklen_t fromlen = sizeof(from);\n\tstruct sockaddr_in *a4;\n\tstruct sockaddr_in6 *a6;\n\ttime_t t;\n\tstruct stat fst;\n\n\tif (geteuid() != 0)\n\t\treturn;\n\tif ((fd = open(_PATH_BTMP, O_WRONLY | O_APPEND)) < 0) {\n\t\tdebug(\"Unable to open the btmp file %s: %s\", _PATH_BTMP,\n\t\t    strerror(errno));\n\t\treturn;\n\t}\n\tif (fstat(fd, &fst) < 0) {\n\t\tlogit(\"%s: fstat of %s failed: %s\", __func__, _PATH_BTMP,\n\t\t    strerror(errno));\n\t\tgoto out;\n\t}\n\tif((fst.st_mode & (S_IXGRP | S_IRWXO)) || (fst.st_uid != 0)){\n\t\tlogit(\"Excess permission or bad ownership on file %s\",\n\t\t    _PATH_BTMP);\n\t\tgoto out;\n\t}\n\n\tmemset(&ut, 0, sizeof(ut));\n\t/* strncpy because we don't necessarily want nul termination */\n\tstrncpy(ut.ut_user, username, sizeof(ut.ut_user));\n\tstrlcpy(ut.ut_line, \"ssh:notty\", sizeof(ut.ut_line));\n\n\ttime(&t);\n\tut.ut_time = t;     /* ut_time is not always a time_t */\n\tut.ut_type = LOGIN_PROCESS;\n\tut.ut_pid = getpid();\n\n\t/* strncpy because we don't necessarily want nul termination */\n\tstrncpy(ut.ut_host, hostname, sizeof(ut.ut_host));\n\n\tif (packet_connection_is_on_socket() &&\n\t    getpeername(packet_get_connection_in(),\n\t    (struct sockaddr *)&from, &fromlen) == 0) {\n\t\tipv64_normalise_mapped(&from, &fromlen);\n\t\tif (from.ss_family == AF_INET) {\n\t\t\ta4 = (struct sockaddr_in *)&from;\n\t\t\tmemcpy(&ut.ut_addr, &(a4->sin_addr),\n\t\t\t    MIN_SIZEOF(ut.ut_addr, a4->sin_addr));\n\t\t}\n#ifdef HAVE_ADDR_V6_IN_UTMP\n\t\tif (from.ss_family == AF_INET6) {\n\t\t\ta6 = (struct sockaddr_in6 *)&from;\n\t\t\tmemcpy(&ut.ut_addr_v6, &(a6->sin6_addr),\n\t\t\t    MIN_SIZEOF(ut.ut_addr_v6, a6->sin6_addr));\n\t\t}\n#endif\n\t}\n\n\tif (atomicio(vwrite, fd, &ut, sizeof(ut)) != sizeof(ut))\n\t\terror(\"Failed to write to %s: %s\", _PATH_BTMP,\n\t\t    strerror(errno));\n\nout:\n\tclose(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "method",
            "\"challenge-response\""
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "method",
            "\"keyboard-interactive\"",
            "20"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "g_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "422-435",
          "snippet": "static int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "extra"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_log2",
          "args": [
            "level",
            "\"%s %s%s%s for %s%.100s from %.200s port %d ssh2%s%s\"",
            "authmsg",
            "method",
            "submethod != NULL ? \"/\" : \"\"",
            "submethod == NULL ? \"\" : submethod",
            "authctxt->valid ? \"\" : \"invalid user \"",
            "authctxt->user",
            "ssh_remote_ipaddr(ssh)",
            "ssh_remote_port(ssh)",
            "extra != NULL ? \": \" : \"\"",
            "extra != NULL ? extra : \"\""
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "do_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "390-398",
          "snippet": "void\ndo_log2(LogLevel level, const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(level, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndo_log2(LogLevel level, const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(level, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_port",
          "args": [
            "ssh"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "539-544",
          "snippet": "int\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->remote_port;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh); /* Will lookup and cache. */\n\treturn ssh->remote_port;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_ipaddr",
          "args": [
            "ssh"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "514-535",
          "snippet": "const char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "authctxt->auth_method_info"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_method_key",
          "args": [
            "authctxt"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "format_method_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "273-308",
          "snippet": "static char *\nformat_method_key(Authctxt *authctxt)\n{\n\tconst struct sshkey *key = authctxt->auth_method_key;\n\tconst char *methinfo = authctxt->auth_method_info;\n\tchar *fp, *cafp, *ret = NULL;\n\n\tif (key == NULL)\n\t\treturn NULL;\n\n\tif (sshkey_is_cert(key)) {\n\t\tfp = sshkey_fingerprint(key,\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\tcafp = sshkey_fingerprint(key->cert->signature_key,\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\txasprintf(&ret, \"%s %s ID %s (serial %llu) CA %s %s%s%s\",\n\t\t    sshkey_type(key), fp == NULL ? \"(null)\" : fp,\n\t\t    key->cert->key_id,\n\t\t    (unsigned long long)key->cert->serial,\n\t\t    sshkey_type(key->cert->signature_key),\n\t\t    cafp == NULL ? \"(null)\" : cafp,\n\t\t    methinfo == NULL ? \"\" : \", \",\n\t\t    methinfo == NULL ? \"\" : methinfo);\n\t\tfree(fp);\n\t\tfree(cafp);\n\t} else {\n\t\tfp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t\txasprintf(&ret, \"%s %s%s%s\", sshkey_type(key),\n\t\t    fp == NULL ? \"(null)\" : fp,\n\t\t    methinfo == NULL ? \"\" : \", \",\n\t\t    methinfo == NULL ? \"\" : methinfo);\n\t\tfree(fp);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstatic char *\nformat_method_key(Authctxt *authctxt)\n{\n\tconst struct sshkey *key = authctxt->auth_method_key;\n\tconst char *methinfo = authctxt->auth_method_info;\n\tchar *fp, *cafp, *ret = NULL;\n\n\tif (key == NULL)\n\t\treturn NULL;\n\n\tif (sshkey_is_cert(key)) {\n\t\tfp = sshkey_fingerprint(key,\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\tcafp = sshkey_fingerprint(key->cert->signature_key,\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\txasprintf(&ret, \"%s %s ID %s (serial %llu) CA %s %s%s%s\",\n\t\t    sshkey_type(key), fp == NULL ? \"(null)\" : fp,\n\t\t    key->cert->key_id,\n\t\t    (unsigned long long)key->cert->serial,\n\t\t    sshkey_type(key->cert->signature_key),\n\t\t    cafp == NULL ? \"(null)\" : cafp,\n\t\t    methinfo == NULL ? \"\" : \", \",\n\t\t    methinfo == NULL ? \"\" : methinfo);\n\t\tfree(fp);\n\t\tfree(cafp);\n\t} else {\n\t\tfp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t\txasprintf(&ret, \"%s %s%s%s\", sshkey_type(key),\n\t\t    fp == NULL ? \"(null)\" : fp,\n\t\t    methinfo == NULL ? \"\" : \", \",\n\t\t    methinfo == NULL ? \"\" : methinfo);\n\t\tfree(fp);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_is_monitor",
          "args": [],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "mm_is_monitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/monitor_wrap.c",
          "lines": "111-119",
          "snippet": "int\nmm_is_monitor(void)\n{\n\t/*\n\t * m_pid is only set in the privileged part, and\n\t * points to the unprivileged child.\n\t */\n\treturn (pmonitor && pmonitor->m_pid > 0);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"servconf.h\"",
            "#include \"session.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"atomicio.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"monitor.h\"",
            "#include \"auth-pam.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"packet.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"dh.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <openssl/evp.h>",
            "#include <openssl/dh.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct monitor *pmonitor;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"servconf.h\"\n#include \"session.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"monitor_fdpass.h\"\n#include \"atomicio.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"monitor.h\"\n#include \"auth-pam.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"dh.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <openssl/evp.h>\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern struct monitor *pmonitor;\n\nint\nmm_is_monitor(void)\n{\n\t/*\n\t * m_pid is only set in the privileged part, and\n\t * points to the unprivileged child.\n\t */\n\treturn (pmonitor && pmonitor->m_pid > 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern int use_privsep;\nextern struct sshbuf *loginmsg;\n\nvoid\nauth_log(Authctxt *authctxt, int authenticated, int partial,\n    const char *method, const char *submethod)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tint level = SYSLOG_LEVEL_VERBOSE;\n\tconst char *authmsg;\n\tchar *extra = NULL;\n\n\tif (use_privsep && !mm_is_monitor() && !authctxt->postponed)\n\t\treturn;\n\n\t/* Raise logging level */\n\tif (authenticated == 1 ||\n\t    !authctxt->valid ||\n\t    authctxt->failures >= options.max_authtries / 2 ||\n\t    strcmp(method, \"password\") == 0)\n\t\tlevel = SYSLOG_LEVEL_INFO;\n\n\tif (authctxt->postponed)\n\t\tauthmsg = \"Postponed\";\n\telse if (partial)\n\t\tauthmsg = \"Partial\";\n\telse\n\t\tauthmsg = authenticated ? \"Accepted\" : \"Failed\";\n\n\tif ((extra = format_method_key(authctxt)) == NULL) {\n\t\tif (authctxt->auth_method_info != NULL)\n\t\t\textra = xstrdup(authctxt->auth_method_info);\n\t}\n\n\tdo_log2(level, \"%s %s%s%s for %s%.100s from %.200s port %d ssh2%s%s\",\n\t    authmsg,\n\t    method,\n\t    submethod != NULL ? \"/\" : \"\", submethod == NULL ? \"\" : submethod,\n\t    authctxt->valid ? \"\" : \"invalid user \",\n\t    authctxt->user,\n\t    ssh_remote_ipaddr(ssh),\n\t    ssh_remote_port(ssh),\n\t    extra != NULL ? \": \" : \"\",\n\t    extra != NULL ? extra : \"\");\n\n\tfree(extra);\n\n#ifdef CUSTOM_FAILED_LOGIN\n\tif (authenticated == 0 && !authctxt->postponed &&\n\t    (strcmp(method, \"password\") == 0 ||\n\t    strncmp(method, \"keyboard-interactive\", 20) == 0 ||\n\t    strcmp(method, \"challenge-response\") == 0))\n\t\trecord_failed_login(authctxt->user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\");\n# ifdef WITH_AIXAUTHENTICATE\n\tif (authenticated)\n\t\tsys_auth_record_login(authctxt->user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\",\n\t\t    &loginmsg);\n# endif\n#endif\n#ifdef SSH_AUDIT_EVENTS\n\tif (authenticated == 0 && !authctxt->postponed)\n\t\taudit_event(audit_classify_auth(method));\n#endif\n}"
  },
  {
    "function_name": "format_method_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
    "lines": "273-308",
    "snippet": "static char *\nformat_method_key(Authctxt *authctxt)\n{\n\tconst struct sshkey *key = authctxt->auth_method_key;\n\tconst char *methinfo = authctxt->auth_method_info;\n\tchar *fp, *cafp, *ret = NULL;\n\n\tif (key == NULL)\n\t\treturn NULL;\n\n\tif (sshkey_is_cert(key)) {\n\t\tfp = sshkey_fingerprint(key,\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\tcafp = sshkey_fingerprint(key->cert->signature_key,\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\txasprintf(&ret, \"%s %s ID %s (serial %llu) CA %s %s%s%s\",\n\t\t    sshkey_type(key), fp == NULL ? \"(null)\" : fp,\n\t\t    key->cert->key_id,\n\t\t    (unsigned long long)key->cert->serial,\n\t\t    sshkey_type(key->cert->signature_key),\n\t\t    cafp == NULL ? \"(null)\" : cafp,\n\t\t    methinfo == NULL ? \"\" : \", \",\n\t\t    methinfo == NULL ? \"\" : methinfo);\n\t\tfree(fp);\n\t\tfree(cafp);\n\t} else {\n\t\tfp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t\txasprintf(&ret, \"%s %s%s%s\", sshkey_type(key),\n\t\t    fp == NULL ? \"(null)\" : fp,\n\t\t    methinfo == NULL ? \"\" : \", \",\n\t\t    methinfo == NULL ? \"\" : methinfo);\n\t\tfree(fp);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"authfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"loginrec.h\"",
      "#include \"packet.h\"",
      "#include \"uidswap.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"groupaccess.h\"",
      "#include \"match.h\"",
      "#include \"xmalloc.h\"",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <shadow.h>",
      "#include <login.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fp"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&ret",
            "\"%s %s%s%s\"",
            "sshkey_type(key)",
            "fp == NULL ? \"(null)\" : fp",
            "methinfo == NULL ? \"\" : \", \"",
            "methinfo == NULL ? \"\" : methinfo"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "key"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "key",
            "options.fingerprint_hash",
            "SSH_FP_DEFAULT"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "key"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nstatic char *\nformat_method_key(Authctxt *authctxt)\n{\n\tconst struct sshkey *key = authctxt->auth_method_key;\n\tconst char *methinfo = authctxt->auth_method_info;\n\tchar *fp, *cafp, *ret = NULL;\n\n\tif (key == NULL)\n\t\treturn NULL;\n\n\tif (sshkey_is_cert(key)) {\n\t\tfp = sshkey_fingerprint(key,\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\tcafp = sshkey_fingerprint(key->cert->signature_key,\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\txasprintf(&ret, \"%s %s ID %s (serial %llu) CA %s %s%s%s\",\n\t\t    sshkey_type(key), fp == NULL ? \"(null)\" : fp,\n\t\t    key->cert->key_id,\n\t\t    (unsigned long long)key->cert->serial,\n\t\t    sshkey_type(key->cert->signature_key),\n\t\t    cafp == NULL ? \"(null)\" : cafp,\n\t\t    methinfo == NULL ? \"\" : \", \",\n\t\t    methinfo == NULL ? \"\" : methinfo);\n\t\tfree(fp);\n\t\tfree(cafp);\n\t} else {\n\t\tfp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t\txasprintf(&ret, \"%s %s%s%s\", sshkey_type(key),\n\t\t    fp == NULL ? \"(null)\" : fp,\n\t\t    methinfo == NULL ? \"\" : \", \",\n\t\t    methinfo == NULL ? \"\" : methinfo);\n\t\tfree(fp);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "allowed_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
    "lines": "98-267",
    "snippet": "int\nallowed_user(struct passwd * pw)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tstruct stat st;\n\tconst char *hostname = NULL, *ipaddr = NULL, *passwd = NULL;\n\tu_int i;\n\tint r;\n#ifdef USE_SHADOW\n\tstruct spwd *spw = NULL;\n#endif\n\n\t/* Shouldn't be called if pw is NULL, but better safe than sorry... */\n\tif (!pw || !pw->pw_name)\n\t\treturn 0;\n\n#ifdef USE_SHADOW\n\tif (!options.use_pam)\n\t\tspw = getspnam(pw->pw_name);\n#ifdef HAS_SHADOW_EXPIRE\n\tif (!options.use_pam && spw != NULL && auth_shadow_acctexpired(spw))\n\t\treturn 0;\n#endif /* HAS_SHADOW_EXPIRE */\n#endif /* USE_SHADOW */\n\n\t/* grab passwd field for locked account check */\n\tpasswd = pw->pw_passwd;\n#ifdef USE_SHADOW\n\tif (spw != NULL)\n#ifdef USE_LIBIAF\n\t\tpasswd = get_iaf_password(pw);\n#else\n\t\tpasswd = spw->sp_pwdp;\n#endif /* USE_LIBIAF */\n#endif\n\n\t/* check for locked account */\n\tif (!options.use_pam && passwd && *passwd) {\n\t\tint locked = 0;\n\n#ifdef LOCKED_PASSWD_STRING\n\t\tif (strcmp(passwd, LOCKED_PASSWD_STRING) == 0)\n\t\t\t locked = 1;\n#endif\n#ifdef LOCKED_PASSWD_PREFIX\n\t\tif (strncmp(passwd, LOCKED_PASSWD_PREFIX,\n\t\t    strlen(LOCKED_PASSWD_PREFIX)) == 0)\n\t\t\t locked = 1;\n#endif\n#ifdef LOCKED_PASSWD_SUBSTR\n\t\tif (strstr(passwd, LOCKED_PASSWD_SUBSTR))\n\t\t\tlocked = 1;\n#endif\n#ifdef USE_LIBIAF\n\t\tfree((void *) passwd);\n#endif /* USE_LIBIAF */\n\t\tif (locked) {\n\t\t\tlogit(\"User %.100s not allowed because account is locked\",\n\t\t\t    pw->pw_name);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Deny if shell does not exist or is not executable unless we\n\t * are chrooting.\n\t */\n\tif (options.chroot_directory == NULL ||\n\t    strcasecmp(options.chroot_directory, \"none\") == 0) {\n\t\tchar *shell = xstrdup((pw->pw_shell[0] == '\\0') ?\n\t\t    _PATH_BSHELL : pw->pw_shell); /* empty = /bin/sh */\n\n\t\tif (stat(shell, &st) != 0) {\n\t\t\tlogit(\"User %.100s not allowed because shell %.100s \"\n\t\t\t    \"does not exist\", pw->pw_name, shell);\n\t\t\tfree(shell);\n\t\t\treturn 0;\n\t\t}\n\t\tif (S_ISREG(st.st_mode) == 0 ||\n\t\t    (st.st_mode & (S_IXOTH|S_IXUSR|S_IXGRP)) == 0) {\n\t\t\tlogit(\"User %.100s not allowed because shell %.100s \"\n\t\t\t    \"is not executable\", pw->pw_name, shell);\n\t\t\tfree(shell);\n\t\t\treturn 0;\n\t\t}\n\t\tfree(shell);\n\t}\n\n\tif (options.num_deny_users > 0 || options.num_allow_users > 0 ||\n\t    options.num_deny_groups > 0 || options.num_allow_groups > 0) {\n\t\thostname = auth_get_canonical_hostname(ssh, options.use_dns);\n\t\tipaddr = ssh_remote_ipaddr(ssh);\n\t}\n\n\t/* Return false if user is listed in DenyUsers */\n\tif (options.num_deny_users > 0) {\n\t\tfor (i = 0; i < options.num_deny_users; i++) {\n\t\t\tr = match_user(pw->pw_name, hostname, ipaddr,\n\t\t\t    options.deny_users[i]);\n\t\t\tif (r < 0) {\n\t\t\t\tfatal(\"Invalid DenyUsers pattern \\\"%.100s\\\"\",\n\t\t\t\t    options.deny_users[i]);\n\t\t\t} else if (r != 0) {\n\t\t\t\tlogit(\"User %.100s from %.100s not allowed \"\n\t\t\t\t    \"because listed in DenyUsers\",\n\t\t\t\t    pw->pw_name, hostname);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t/* Return false if AllowUsers isn't empty and user isn't listed there */\n\tif (options.num_allow_users > 0) {\n\t\tfor (i = 0; i < options.num_allow_users; i++) {\n\t\t\tr = match_user(pw->pw_name, hostname, ipaddr,\n\t\t\t    options.allow_users[i]);\n\t\t\tif (r < 0) {\n\t\t\t\tfatal(\"Invalid AllowUsers pattern \\\"%.100s\\\"\",\n\t\t\t\t    options.allow_users[i]);\n\t\t\t} else if (r == 1)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* i < options.num_allow_users iff we break for loop */\n\t\tif (i >= options.num_allow_users) {\n\t\t\tlogit(\"User %.100s from %.100s not allowed because \"\n\t\t\t    \"not listed in AllowUsers\", pw->pw_name, hostname);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (options.num_deny_groups > 0 || options.num_allow_groups > 0) {\n\t\t/* Get the user's group access list (primary and supplementary) */\n\t\tif (ga_init(pw->pw_name, pw->pw_gid) == 0) {\n\t\t\tlogit(\"User %.100s from %.100s not allowed because \"\n\t\t\t    \"not in any group\", pw->pw_name, hostname);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Return false if one of user's groups is listed in DenyGroups */\n\t\tif (options.num_deny_groups > 0)\n\t\t\tif (ga_match(options.deny_groups,\n\t\t\t    options.num_deny_groups)) {\n\t\t\t\tga_free();\n\t\t\t\tlogit(\"User %.100s from %.100s not allowed \"\n\t\t\t\t    \"because a group is listed in DenyGroups\",\n\t\t\t\t    pw->pw_name, hostname);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t/*\n\t\t * Return false if AllowGroups isn't empty and one of user's groups\n\t\t * isn't listed there\n\t\t */\n\t\tif (options.num_allow_groups > 0)\n\t\t\tif (!ga_match(options.allow_groups,\n\t\t\t    options.num_allow_groups)) {\n\t\t\t\tga_free();\n\t\t\t\tlogit(\"User %.100s from %.100s not allowed \"\n\t\t\t\t    \"because none of user's groups are listed \"\n\t\t\t\t    \"in AllowGroups\", pw->pw_name, hostname);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tga_free();\n\t}\n\n#ifdef CUSTOM_SYS_AUTH_ALLOWED_USER\n\tif (!sys_auth_allowed_user(pw, &loginmsg))\n\t\treturn 0;\n#endif\n\n\t/* We found no reason not to let this user try to log on... */\n\treturn 1;\n}",
    "includes": [
      "#include \"channels.h\"",
      "#include \"compat.h\"",
      "#include \"ssherr.h\"",
      "#include \"authfile.h\"",
      "#include \"monitor_wrap.h\"",
      "#include \"authfile.h\"",
      "#include \"ssh-gss.h\"",
      "#include \"loginrec.h\"",
      "#include \"packet.h\"",
      "#include \"uidswap.h\"",
      "#include \"canohost.h\"",
      "#include \"auth-options.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"groupaccess.h\"",
      "#include \"match.h\"",
      "#include \"xmalloc.h\"",
      "#include <netdb.h>",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <shadow.h>",
      "#include <login.h>",
      "#include <pwd.h>",
      "# include <paths.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/in.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "extern struct sshbuf *loginmsg;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sys_auth_allowed_user",
          "args": [
            "pw",
            "&loginmsg"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "sys_auth_allowed_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "240-280",
          "snippet": "int\nsys_auth_allowed_user(struct passwd *pw, struct sshbuf *loginmsg)\n{\n\tchar *msg = NULL;\n\tint r, result, permitted = 0;\n\tstruct stat st;\n\n\t/*\n\t * Don't perform checks for root account (PermitRootLogin controls\n\t * logins via ssh) or if running as non-root user (since\n\t * loginrestrictions will always fail due to insufficient privilege).\n\t */\n\tif (pw->pw_uid == 0 || geteuid() != 0) {\n\t\tdebug3(\"%s: not checking\", __func__);\n\t\treturn 1;\n\t}\n\n\tresult = loginrestrictions(pw->pw_name, S_RLOGIN, NULL, &msg);\n\tif (result == 0)\n\t\tpermitted = 1;\n\t/*\n\t * If restricted because /etc/nologin exists, the login will be denied\n\t * in session.c after the nologin message is sent, so allow for now\n\t * and do not append the returned message.\n\t */\n\tif (result == -1 && errno == EPERM && stat(_PATH_NOLOGIN, &st) == 0)\n\t\tpermitted = 1;\n\telse if (msg != NULL) {\n\t\tif ((r = sshbuf_put(loginmsg, msg, strlen(msg))) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\tif (msg == NULL)\n\t\tmsg = xstrdup(\"(none)\");\n\taix_remove_embedded_newlines(msg);\n\tdebug3(\"AIX/loginrestrictions returned %d msg %.100s\", result, msg);\n\n\tif (!permitted)\n\t\tlogit(\"Login restricted for %s: %.100s\", pw->pw_name, msg);\n\tfree(msg);\n\treturn permitted;\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nint\nsys_auth_allowed_user(struct passwd *pw, struct sshbuf *loginmsg)\n{\n\tchar *msg = NULL;\n\tint r, result, permitted = 0;\n\tstruct stat st;\n\n\t/*\n\t * Don't perform checks for root account (PermitRootLogin controls\n\t * logins via ssh) or if running as non-root user (since\n\t * loginrestrictions will always fail due to insufficient privilege).\n\t */\n\tif (pw->pw_uid == 0 || geteuid() != 0) {\n\t\tdebug3(\"%s: not checking\", __func__);\n\t\treturn 1;\n\t}\n\n\tresult = loginrestrictions(pw->pw_name, S_RLOGIN, NULL, &msg);\n\tif (result == 0)\n\t\tpermitted = 1;\n\t/*\n\t * If restricted because /etc/nologin exists, the login will be denied\n\t * in session.c after the nologin message is sent, so allow for now\n\t * and do not append the returned message.\n\t */\n\tif (result == -1 && errno == EPERM && stat(_PATH_NOLOGIN, &st) == 0)\n\t\tpermitted = 1;\n\telse if (msg != NULL) {\n\t\tif ((r = sshbuf_put(loginmsg, msg, strlen(msg))) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\tif (msg == NULL)\n\t\tmsg = xstrdup(\"(none)\");\n\taix_remove_embedded_newlines(msg);\n\tdebug3(\"AIX/loginrestrictions returned %d msg %.100s\", result, msg);\n\n\tif (!permitted)\n\t\tlogit(\"Login restricted for %s: %.100s\", pw->pw_name, msg);\n\tfree(msg);\n\treturn permitted;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ga_free",
          "args": [],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "ga_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/groupaccess.c",
          "lines": "121-133",
          "snippet": "void\nga_free(void)\n{\n\tint i;\n\n\tif (ngroups > 0) {\n\t\tfor (i = 0; i < ngroups; i++)\n\t\t\tfree(groups_byname[i]);\n\t\tngroups = 0;\n\t\tfree(groups_byname);\n\t\tgroups_byname = NULL;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include \"groupaccess.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int ngroups;",
            "static char **groups_byname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include \"groupaccess.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int ngroups;\nstatic char **groups_byname;\n\nvoid\nga_free(void)\n{\n\tint i;\n\n\tif (ngroups > 0) {\n\t\tfor (i = 0; i < ngroups; i++)\n\t\t\tfree(groups_byname[i]);\n\t\tngroups = 0;\n\t\tfree(groups_byname);\n\t\tgroups_byname = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"User %.100s from %.100s not allowed \"\n\t\t\t\t    \"because none of user's groups are listed \"\n\t\t\t\t    \"in AllowGroups\"",
            "pw->pw_name",
            "hostname"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ga_match",
          "args": [
            "options.allow_groups",
            "options.num_allow_groups"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "ga_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/groupaccess.c",
          "lines": "84-94",
          "snippet": "int\nga_match(char * const *groups, int n)\n{\n\tint i, j;\n\n\tfor (i = 0; i < ngroups; i++)\n\t\tfor (j = 0; j < n; j++)\n\t\t\tif (match_pattern(groups_byname[i], groups[j]))\n\t\t\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include \"groupaccess.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int ngroups;",
            "static char **groups_byname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include \"groupaccess.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int ngroups;\nstatic char **groups_byname;\n\nint\nga_match(char * const *groups, int n)\n{\n\tint i, j;\n\n\tfor (i = 0; i < ngroups; i++)\n\t\tfor (j = 0; j < n; j++)\n\t\t\tif (match_pattern(groups_byname[i], groups[j]))\n\t\t\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ga_init",
          "args": [
            "pw->pw_name",
            "pw->pw_gid"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "ga_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/groupaccess.c",
          "lines": "49-78",
          "snippet": "int\nga_init(const char *user, gid_t base)\n{\n\tgid_t *groups_bygid;\n\tint i, j, retry = 0;\n\tstruct group *gr;\n\n\tif (ngroups > 0)\n\t\tga_free();\n\n\tngroups = NGROUPS_MAX;\n#if defined(HAVE_SYSCONF) && defined(_SC_NGROUPS_MAX)\n\tngroups = MAX(NGROUPS_MAX, sysconf(_SC_NGROUPS_MAX));\n#endif\n\n\tgroups_bygid = xcalloc(ngroups, sizeof(*groups_bygid));\n\twhile (getgrouplist(user, base, groups_bygid, &ngroups) == -1) {\n\t\tif (retry++ > 0)\n\t\t\tfatal(\"getgrouplist: groups list too small\");\n\t\tgroups_bygid = xreallocarray(groups_bygid, ngroups,\n\t\t    sizeof(*groups_bygid));\n\t}\n\tgroups_byname = xcalloc(ngroups, sizeof(*groups_byname));\n\n\tfor (i = 0, j = 0; i < ngroups; i++)\n\t\tif ((gr = getgrgid(groups_bygid[i])) != NULL)\n\t\t\tgroups_byname[j++] = xstrdup(gr->gr_name);\n\tfree(groups_bygid);\n\treturn (ngroups = j);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include \"groupaccess.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int ngroups;",
            "static char **groups_byname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include \"groupaccess.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int ngroups;\nstatic char **groups_byname;\n\nint\nga_init(const char *user, gid_t base)\n{\n\tgid_t *groups_bygid;\n\tint i, j, retry = 0;\n\tstruct group *gr;\n\n\tif (ngroups > 0)\n\t\tga_free();\n\n\tngroups = NGROUPS_MAX;\n#if defined(HAVE_SYSCONF) && defined(_SC_NGROUPS_MAX)\n\tngroups = MAX(NGROUPS_MAX, sysconf(_SC_NGROUPS_MAX));\n#endif\n\n\tgroups_bygid = xcalloc(ngroups, sizeof(*groups_bygid));\n\twhile (getgrouplist(user, base, groups_bygid, &ngroups) == -1) {\n\t\tif (retry++ > 0)\n\t\t\tfatal(\"getgrouplist: groups list too small\");\n\t\tgroups_bygid = xreallocarray(groups_bygid, ngroups,\n\t\t    sizeof(*groups_bygid));\n\t}\n\tgroups_byname = xcalloc(ngroups, sizeof(*groups_byname));\n\n\tfor (i = 0, j = 0; i < ngroups; i++)\n\t\tif ((gr = getgrgid(groups_bygid[i])) != NULL)\n\t\t\tgroups_byname[j++] = xstrdup(gr->gr_name);\n\tfree(groups_bygid);\n\treturn (ngroups = j);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Invalid AllowUsers pattern \\\"%.100s\\\"\"",
            "options.allow_users[i]"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_user",
          "args": [
            "pw->pw_name",
            "hostname",
            "ipaddr",
            "options.allow_users[i]"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "match_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "221-248",
          "snippet": "int\nmatch_user(const char *user, const char *host, const char *ipaddr,\n    const char *pattern)\n{\n\tchar *p, *pat;\n\tint ret;\n\n\t/* test mode */\n\tif (user == NULL && host == NULL && ipaddr == NULL) {\n\t\tif ((p = strchr(pattern, '@')) != NULL &&\n\t\t    match_host_and_ip(NULL, NULL, p + 1) < 0)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\tif ((p = strchr(pattern,'@')) == NULL)\n\t\treturn match_pattern(user, pattern);\n\n\tpat = xstrdup(pattern);\n\tp = strchr(pat, '@');\n\t*p++ = '\\0';\n\n\tif ((ret = match_pattern(user, pat)) == 1)\n\t\tret = match_host_and_ip(host, ipaddr, p);\n\tfree(pat);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_user(const char *user, const char *host, const char *ipaddr,\n    const char *pattern)\n{\n\tchar *p, *pat;\n\tint ret;\n\n\t/* test mode */\n\tif (user == NULL && host == NULL && ipaddr == NULL) {\n\t\tif ((p = strchr(pattern, '@')) != NULL &&\n\t\t    match_host_and_ip(NULL, NULL, p + 1) < 0)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\tif ((p = strchr(pattern,'@')) == NULL)\n\t\treturn match_pattern(user, pattern);\n\n\tpat = xstrdup(pattern);\n\tp = strchr(pat, '@');\n\t*p++ = '\\0';\n\n\tif ((ret = match_pattern(user, pat)) == 1)\n\t\tret = match_host_and_ip(host, ipaddr, p);\n\tfree(pat);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_remote_ipaddr",
          "args": [
            "ssh"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_remote_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "514-535",
          "snippet": "const char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t/* Check whether we have cached the ipaddr. */\n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = strdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_get_canonical_hostname",
          "args": [
            "ssh",
            "options.use_dns"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "auth_get_canonical_hostname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "839-852",
          "snippet": "const char *\nauth_get_canonical_hostname(struct ssh *ssh, int use_dns)\n{\n\tstatic char *dnsname;\n\n\tif (!use_dns)\n\t\treturn ssh_remote_ipaddr(ssh);\n\telse if (dnsname != NULL)\n\t\treturn dnsname;\n\telse {\n\t\tdnsname = remote_hostname(ssh);\n\t\treturn dnsname;\n\t}\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nauth_get_canonical_hostname(struct ssh *ssh, int use_dns)\n{\n\tstatic char *dnsname;\n\n\tif (!use_dns)\n\t\treturn ssh_remote_ipaddr(ssh);\n\telse if (dnsname != NULL)\n\t\treturn dnsname;\n\telse {\n\t\tdnsname = remote_hostname(ssh);\n\t\treturn dnsname;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "shell"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "st.st_mode"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "shell",
            "&st"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "(pw->pw_shell[0] == '\\0') ?\n\t\t    _PATH_BSHELL : pw->pw_shell"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "options.chroot_directory",
            "\"none\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "passwd",
            "LOCKED_PASSWD_SUBSTR"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "passwd",
            "LOCKED_PASSWD_PREFIX",
            "strlen(LOCKED_PASSWD_PREFIX)"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "g_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "422-435",
          "snippet": "static int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "LOCKED_PASSWD_PREFIX"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "passwd",
            "LOCKED_PASSWD_STRING"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_iaf_password",
          "args": [
            "pw"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "get_iaf_password",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-uw.c",
          "lines": "135-150",
          "snippet": "char *\nget_iaf_password(struct passwd *pw)\n{\n\tchar *pw_password = NULL;\n\n\tuinfo_t uinfo;\n\tif (!ia_openinfo(pw->pw_name,&uinfo)) {\n\t\tia_get_logpwd(uinfo, &pw_password);\n\t\tif (pw_password == NULL)\n\t\t\tfatal(\"ia_get_logpwd: Unable to get the shadow passwd\");\n\t\tia_closeinfo(uinfo);\n\t \treturn pw_password;\n\t}\n\telse\n\t\tfatal(\"ia_openinfo: Unable to open the shadow passwd file\");\n}",
          "includes": [
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"\t/* servconf.h needs misc.h for struct ForwardOptions */",
            "#include \"log.h\"",
            "#include \"auth-options.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "# include <crypt.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\t/* servconf.h needs misc.h for struct ForwardOptions */\n#include \"log.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <pwd.h>\n# include <crypt.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nget_iaf_password(struct passwd *pw)\n{\n\tchar *pw_password = NULL;\n\n\tuinfo_t uinfo;\n\tif (!ia_openinfo(pw->pw_name,&uinfo)) {\n\t\tia_get_logpwd(uinfo, &pw_password);\n\t\tif (pw_password == NULL)\n\t\t\tfatal(\"ia_get_logpwd: Unable to get the shadow passwd\");\n\t\tia_closeinfo(uinfo);\n\t \treturn pw_password;\n\t}\n\telse\n\t\tfatal(\"ia_openinfo: Unable to open the shadow passwd file\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_shadow_acctexpired",
          "args": [
            "spw"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "auth_shadow_acctexpired",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-shadow.c",
          "lines": "55-81",
          "snippet": "int\nauth_shadow_acctexpired(struct spwd *spw)\n{\n\ttime_t today;\n\tint daysleft;\n\tint r;\n\n\ttoday = time(NULL) / DAY;\n\tdaysleft = spw->sp_expire - today;\n\tdebug3(\"%s: today %d sp_expire %d days left %d\", __func__, (int)today,\n\t    (int)spw->sp_expire, daysleft);\n\n\tif (spw->sp_expire == -1) {\n\t\tdebug3(\"account expiration disabled\");\n\t} else if (daysleft < 0) {\n\t\tlogit(\"Account %.100s has expired\", spw->sp_namp);\n\t\treturn 1;\n\t} else if (daysleft <= spw->sp_warn) {\n\t\tdebug3(\"account will expire in %d days\", daysleft);\n\t\tif ((r = sshbuf_putf(loginmsg, \n\t\t    \"Your account will expire in %d day%s.\\n\", daysleft,\n\t\t    daysleft == 1 ? \"\" : \"s\")) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define DAY\t(24L * 60 * 60) /* 1 day in seconds */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include <time.h>\n#include <string.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include \"includes.h\"\n\n#define DAY\t(24L * 60 * 60) /* 1 day in seconds */\n\nint\nauth_shadow_acctexpired(struct spwd *spw)\n{\n\ttime_t today;\n\tint daysleft;\n\tint r;\n\n\ttoday = time(NULL) / DAY;\n\tdaysleft = spw->sp_expire - today;\n\tdebug3(\"%s: today %d sp_expire %d days left %d\", __func__, (int)today,\n\t    (int)spw->sp_expire, daysleft);\n\n\tif (spw->sp_expire == -1) {\n\t\tdebug3(\"account expiration disabled\");\n\t} else if (daysleft < 0) {\n\t\tlogit(\"Account %.100s has expired\", spw->sp_namp);\n\t\treturn 1;\n\t} else if (daysleft <= spw->sp_warn) {\n\t\tdebug3(\"account will expire in %d days\", daysleft);\n\t\tif ((r = sshbuf_putf(loginmsg, \n\t\t    \"Your account will expire in %d day%s.\\n\", daysleft,\n\t\t    daysleft == 1 ? \"\" : \"s\")) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getspnam",
          "args": [
            "pw->pw_name"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern struct sshbuf *loginmsg;\n\nint\nallowed_user(struct passwd * pw)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tstruct stat st;\n\tconst char *hostname = NULL, *ipaddr = NULL, *passwd = NULL;\n\tu_int i;\n\tint r;\n#ifdef USE_SHADOW\n\tstruct spwd *spw = NULL;\n#endif\n\n\t/* Shouldn't be called if pw is NULL, but better safe than sorry... */\n\tif (!pw || !pw->pw_name)\n\t\treturn 0;\n\n#ifdef USE_SHADOW\n\tif (!options.use_pam)\n\t\tspw = getspnam(pw->pw_name);\n#ifdef HAS_SHADOW_EXPIRE\n\tif (!options.use_pam && spw != NULL && auth_shadow_acctexpired(spw))\n\t\treturn 0;\n#endif /* HAS_SHADOW_EXPIRE */\n#endif /* USE_SHADOW */\n\n\t/* grab passwd field for locked account check */\n\tpasswd = pw->pw_passwd;\n#ifdef USE_SHADOW\n\tif (spw != NULL)\n#ifdef USE_LIBIAF\n\t\tpasswd = get_iaf_password(pw);\n#else\n\t\tpasswd = spw->sp_pwdp;\n#endif /* USE_LIBIAF */\n#endif\n\n\t/* check for locked account */\n\tif (!options.use_pam && passwd && *passwd) {\n\t\tint locked = 0;\n\n#ifdef LOCKED_PASSWD_STRING\n\t\tif (strcmp(passwd, LOCKED_PASSWD_STRING) == 0)\n\t\t\t locked = 1;\n#endif\n#ifdef LOCKED_PASSWD_PREFIX\n\t\tif (strncmp(passwd, LOCKED_PASSWD_PREFIX,\n\t\t    strlen(LOCKED_PASSWD_PREFIX)) == 0)\n\t\t\t locked = 1;\n#endif\n#ifdef LOCKED_PASSWD_SUBSTR\n\t\tif (strstr(passwd, LOCKED_PASSWD_SUBSTR))\n\t\t\tlocked = 1;\n#endif\n#ifdef USE_LIBIAF\n\t\tfree((void *) passwd);\n#endif /* USE_LIBIAF */\n\t\tif (locked) {\n\t\t\tlogit(\"User %.100s not allowed because account is locked\",\n\t\t\t    pw->pw_name);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Deny if shell does not exist or is not executable unless we\n\t * are chrooting.\n\t */\n\tif (options.chroot_directory == NULL ||\n\t    strcasecmp(options.chroot_directory, \"none\") == 0) {\n\t\tchar *shell = xstrdup((pw->pw_shell[0] == '\\0') ?\n\t\t    _PATH_BSHELL : pw->pw_shell); /* empty = /bin/sh */\n\n\t\tif (stat(shell, &st) != 0) {\n\t\t\tlogit(\"User %.100s not allowed because shell %.100s \"\n\t\t\t    \"does not exist\", pw->pw_name, shell);\n\t\t\tfree(shell);\n\t\t\treturn 0;\n\t\t}\n\t\tif (S_ISREG(st.st_mode) == 0 ||\n\t\t    (st.st_mode & (S_IXOTH|S_IXUSR|S_IXGRP)) == 0) {\n\t\t\tlogit(\"User %.100s not allowed because shell %.100s \"\n\t\t\t    \"is not executable\", pw->pw_name, shell);\n\t\t\tfree(shell);\n\t\t\treturn 0;\n\t\t}\n\t\tfree(shell);\n\t}\n\n\tif (options.num_deny_users > 0 || options.num_allow_users > 0 ||\n\t    options.num_deny_groups > 0 || options.num_allow_groups > 0) {\n\t\thostname = auth_get_canonical_hostname(ssh, options.use_dns);\n\t\tipaddr = ssh_remote_ipaddr(ssh);\n\t}\n\n\t/* Return false if user is listed in DenyUsers */\n\tif (options.num_deny_users > 0) {\n\t\tfor (i = 0; i < options.num_deny_users; i++) {\n\t\t\tr = match_user(pw->pw_name, hostname, ipaddr,\n\t\t\t    options.deny_users[i]);\n\t\t\tif (r < 0) {\n\t\t\t\tfatal(\"Invalid DenyUsers pattern \\\"%.100s\\\"\",\n\t\t\t\t    options.deny_users[i]);\n\t\t\t} else if (r != 0) {\n\t\t\t\tlogit(\"User %.100s from %.100s not allowed \"\n\t\t\t\t    \"because listed in DenyUsers\",\n\t\t\t\t    pw->pw_name, hostname);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t/* Return false if AllowUsers isn't empty and user isn't listed there */\n\tif (options.num_allow_users > 0) {\n\t\tfor (i = 0; i < options.num_allow_users; i++) {\n\t\t\tr = match_user(pw->pw_name, hostname, ipaddr,\n\t\t\t    options.allow_users[i]);\n\t\t\tif (r < 0) {\n\t\t\t\tfatal(\"Invalid AllowUsers pattern \\\"%.100s\\\"\",\n\t\t\t\t    options.allow_users[i]);\n\t\t\t} else if (r == 1)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* i < options.num_allow_users iff we break for loop */\n\t\tif (i >= options.num_allow_users) {\n\t\t\tlogit(\"User %.100s from %.100s not allowed because \"\n\t\t\t    \"not listed in AllowUsers\", pw->pw_name, hostname);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (options.num_deny_groups > 0 || options.num_allow_groups > 0) {\n\t\t/* Get the user's group access list (primary and supplementary) */\n\t\tif (ga_init(pw->pw_name, pw->pw_gid) == 0) {\n\t\t\tlogit(\"User %.100s from %.100s not allowed because \"\n\t\t\t    \"not in any group\", pw->pw_name, hostname);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Return false if one of user's groups is listed in DenyGroups */\n\t\tif (options.num_deny_groups > 0)\n\t\t\tif (ga_match(options.deny_groups,\n\t\t\t    options.num_deny_groups)) {\n\t\t\t\tga_free();\n\t\t\t\tlogit(\"User %.100s from %.100s not allowed \"\n\t\t\t\t    \"because a group is listed in DenyGroups\",\n\t\t\t\t    pw->pw_name, hostname);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t/*\n\t\t * Return false if AllowGroups isn't empty and one of user's groups\n\t\t * isn't listed there\n\t\t */\n\t\tif (options.num_allow_groups > 0)\n\t\t\tif (!ga_match(options.allow_groups,\n\t\t\t    options.num_allow_groups)) {\n\t\t\t\tga_free();\n\t\t\t\tlogit(\"User %.100s from %.100s not allowed \"\n\t\t\t\t    \"because none of user's groups are listed \"\n\t\t\t\t    \"in AllowGroups\", pw->pw_name, hostname);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tga_free();\n\t}\n\n#ifdef CUSTOM_SYS_AUTH_ALLOWED_USER\n\tif (!sys_auth_allowed_user(pw, &loginmsg))\n\t\treturn 0;\n#endif\n\n\t/* We found no reason not to let this user try to log on... */\n\treturn 1;\n}"
  }
]