[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/check-perm.c",
    "lines": "158-205",
    "snippet": "int\nmain(int argc, char **argv)\n{\n\tconst char *path = \".\";\n\tchar errmsg[256];\n\tint ch, mode = -1;\n\textern char *optarg;\n\textern int optind;\n\tstruct stat st;\n\n\twhile ((ch = getopt(argc, argv, \"hm:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'm':\n\t\t\tif (strcasecmp(optarg, \"chroot\") == 0)\n\t\t\t\tmode = 1;\n\t\t\telse if (strcasecmp(optarg, \"keys-command\") == 0)\n\t\t\t\tmode = 2;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Invalid -m option\\n\"),\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\n\tif (argc > 1)\n\t\tusage();\n\telse if (argc == 1)\n\t\tpath = argv[0];\n\n\tif (mode == 1)\n\t\tsafely_chroot(path, getuid());\n\telse if (mode == 2) {\n\t\tif (stat(path, &st) < 0)\n\t\t\tfatal(\"Could not stat %s: %s\", path, strerror(errno));\n\t\tif (auth_secure_path(path, &st, NULL, 0,\n\t\t    errmsg, sizeof(errmsg)) != 0)\n\t\t\tfatal(\"Unsafe %s: %s\", path, errmsg);\n\t} else {\n\t\tfprintf(stderr, \"Invalid mode\\n\");\n\t\tusage();\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <libgen.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "usage",
          "args": [],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/check-perm.c",
          "lines": "151-156",
          "snippet": "static void\nusage(void)\n{\n\tfprintf(stderr, \"check-perm -m [chroot | keys-command] [path]\\n\");\n\texit(1);\n}",
          "includes": [
            "#include <libgen.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libgen.h>\n#include <pwd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr, \"check-perm -m [chroot | keys-command] [path]\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Invalid mode\\n\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Unsafe %s: %s\"",
            "path",
            "errmsg"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/check-perm.c",
          "lines": "22-32",
          "snippet": "static void\nfatal(const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(1);\n}",
          "includes": [
            "#include <libgen.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libgen.h>\n#include <pwd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nfatal(const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_secure_path",
          "args": [
            "path",
            "&st",
            "NULL",
            "0",
            "errmsg",
            "sizeof(errmsg)"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "auth_secure_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/check-perm.c",
          "lines": "93-149",
          "snippet": "int\nauth_secure_path(const char *name, struct stat *stp, const char *pw_dir,\n    uid_t uid, char *err, size_t errlen)\n{\n\tchar buf[PATH_MAX], homedir[PATH_MAX];\n\tchar *cp;\n\tint comparehome = 0;\n\tstruct stat st;\n\n\tif (realpath(name, buf) == NULL) {\n\t\tsnprintf(err, errlen, \"realpath %s failed: %s\", name,\n\t\t    strerror(errno));\n\t\treturn -1;\n\t}\n\tif (pw_dir != NULL && realpath(pw_dir, homedir) != NULL)\n\t\tcomparehome = 1;\n\n\tif (!S_ISREG(stp->st_mode)) {\n\t\tsnprintf(err, errlen, \"%s is not a regular file\", buf);\n\t\treturn -1;\n\t}\n\tif ((!platform_sys_dir_uid(stp->st_uid) && stp->st_uid != uid) ||\n\t    (stp->st_mode & 022) != 0) {\n\t\tsnprintf(err, errlen, \"bad ownership or modes for file %s\",\n\t\t    buf);\n\t\treturn -1;\n\t}\n\n\t/* for each component of the canonical path, walking upwards */\n\tfor (;;) {\n\t\tif ((cp = dirname(buf)) == NULL) {\n\t\t\tsnprintf(err, errlen, \"dirname() failed\");\n\t\t\treturn -1;\n\t\t}\n\t\tstrlcpy(buf, cp, sizeof(buf));\n\n\t\tif (stat(buf, &st) < 0 ||\n\t\t    (!platform_sys_dir_uid(st.st_uid) && st.st_uid != uid) ||\n\t\t    (st.st_mode & 022) != 0) {\n\t\t\tsnprintf(err, errlen,\n\t\t\t    \"bad ownership or modes for directory %s\", buf);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* If are past the homedir then we can stop */\n\t\tif (comparehome && strcmp(homedir, buf) == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * dirname should always complete with a \"/\" path,\n\t\t * but we can be paranoid and check for \".\" too\n\t\t */\n\t\tif ((strcmp(\"/\", buf) == 0) || (strcmp(\".\", buf) == 0))\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <libgen.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libgen.h>\n#include <pwd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nauth_secure_path(const char *name, struct stat *stp, const char *pw_dir,\n    uid_t uid, char *err, size_t errlen)\n{\n\tchar buf[PATH_MAX], homedir[PATH_MAX];\n\tchar *cp;\n\tint comparehome = 0;\n\tstruct stat st;\n\n\tif (realpath(name, buf) == NULL) {\n\t\tsnprintf(err, errlen, \"realpath %s failed: %s\", name,\n\t\t    strerror(errno));\n\t\treturn -1;\n\t}\n\tif (pw_dir != NULL && realpath(pw_dir, homedir) != NULL)\n\t\tcomparehome = 1;\n\n\tif (!S_ISREG(stp->st_mode)) {\n\t\tsnprintf(err, errlen, \"%s is not a regular file\", buf);\n\t\treturn -1;\n\t}\n\tif ((!platform_sys_dir_uid(stp->st_uid) && stp->st_uid != uid) ||\n\t    (stp->st_mode & 022) != 0) {\n\t\tsnprintf(err, errlen, \"bad ownership or modes for file %s\",\n\t\t    buf);\n\t\treturn -1;\n\t}\n\n\t/* for each component of the canonical path, walking upwards */\n\tfor (;;) {\n\t\tif ((cp = dirname(buf)) == NULL) {\n\t\t\tsnprintf(err, errlen, \"dirname() failed\");\n\t\t\treturn -1;\n\t\t}\n\t\tstrlcpy(buf, cp, sizeof(buf));\n\n\t\tif (stat(buf, &st) < 0 ||\n\t\t    (!platform_sys_dir_uid(st.st_uid) && st.st_uid != uid) ||\n\t\t    (st.st_mode & 022) != 0) {\n\t\t\tsnprintf(err, errlen,\n\t\t\t    \"bad ownership or modes for directory %s\", buf);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* If are past the homedir then we can stop */\n\t\tif (comparehome && strcmp(homedir, buf) == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * dirname should always complete with a \"/\" path,\n\t\t * but we can be paranoid and check for \".\" too\n\t\t */\n\t\tif ((strcmp(\"/\", buf) == 0) || (strcmp(\".\", buf) == 0))\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&st"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "safely_chroot",
          "args": [
            "path",
            "getuid()"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "safely_chroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/check-perm.c",
          "lines": "34-77",
          "snippet": "static void\nsafely_chroot(const char *path, uid_t uid)\n{\n\tconst char *cp;\n\tchar component[PATH_MAX];\n\tstruct stat st;\n\n\tif (*path != '/')\n\t\tfatal(\"chroot path does not begin at root\");\n\tif (strlen(path) >= sizeof(component))\n\t\tfatal(\"chroot path too long\");\n\n\t/*\n\t * Descend the path, checking that each component is a\n\t * root-owned directory with strict permissions.\n\t */\n\tfor (cp = path; cp != NULL;) {\n\t\tif ((cp = strchr(cp, '/')) == NULL)\n\t\t\tstrlcpy(component, path, sizeof(component));\n\t\telse {\n\t\t\tcp++;\n\t\t\tmemcpy(component, path, cp - path);\n\t\t\tcomponent[cp - path] = '\\0';\n\t\t}\n\n\t\t/* debug3(\"%s: checking '%s'\", __func__, component); */\n\n\t\tif (stat(component, &st) != 0)\n\t\t\tfatal(\"%s: stat(\\\"%s\\\"): %s\", __func__,\n\t\t\t    component, strerror(errno));\n\t\tif (st.st_uid != 0 || (st.st_mode & 022) != 0)\n\t\t\tfatal(\"bad ownership or modes for chroot \"\n\t\t\t    \"directory %s\\\"%s\\\"\",\n\t\t\t    cp == NULL ? \"\" : \"component \", component);\n\t\tif (!S_ISDIR(st.st_mode))\n\t\t\tfatal(\"chroot path %s\\\"%s\\\" is not a directory\",\n\t\t\t    cp == NULL ? \"\" : \"component \", component);\n\n\t}\n\n\tif (chdir(path) == -1)\n\t\tfatal(\"Unable to chdir to chroot path \\\"%s\\\": \"\n\t\t    \"%s\", path, strerror(errno));\n}",
          "includes": [
            "#include <libgen.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libgen.h>\n#include <pwd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsafely_chroot(const char *path, uid_t uid)\n{\n\tconst char *cp;\n\tchar component[PATH_MAX];\n\tstruct stat st;\n\n\tif (*path != '/')\n\t\tfatal(\"chroot path does not begin at root\");\n\tif (strlen(path) >= sizeof(component))\n\t\tfatal(\"chroot path too long\");\n\n\t/*\n\t * Descend the path, checking that each component is a\n\t * root-owned directory with strict permissions.\n\t */\n\tfor (cp = path; cp != NULL;) {\n\t\tif ((cp = strchr(cp, '/')) == NULL)\n\t\t\tstrlcpy(component, path, sizeof(component));\n\t\telse {\n\t\t\tcp++;\n\t\t\tmemcpy(component, path, cp - path);\n\t\t\tcomponent[cp - path] = '\\0';\n\t\t}\n\n\t\t/* debug3(\"%s: checking '%s'\", __func__, component); */\n\n\t\tif (stat(component, &st) != 0)\n\t\t\tfatal(\"%s: stat(\\\"%s\\\"): %s\", __func__,\n\t\t\t    component, strerror(errno));\n\t\tif (st.st_uid != 0 || (st.st_mode & 022) != 0)\n\t\t\tfatal(\"bad ownership or modes for chroot \"\n\t\t\t    \"directory %s\\\"%s\\\"\",\n\t\t\t    cp == NULL ? \"\" : \"component \", component);\n\t\tif (!S_ISDIR(st.st_mode))\n\t\t\tfatal(\"chroot path %s\\\"%s\\\" is not a directory\",\n\t\t\t    cp == NULL ? \"\" : \"component \", component);\n\n\t}\n\n\tif (chdir(path) == -1)\n\t\tfatal(\"Unable to chdir to chroot path \\\"%s\\\": \"\n\t\t    \"%s\", path, strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Invalid -m option\\n\""
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "optarg",
            "\"keys-command\""
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "optarg",
            "\"chroot\""
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getopt",
          "args": [
            "argc",
            "argv",
            "\"hm:\""
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "getopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
          "lines": "489-502",
          "snippet": "int\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <getopt.h>",
            "#include <err.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\n#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */\n\nint\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <libgen.h>\n#include <pwd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmain(int argc, char **argv)\n{\n\tconst char *path = \".\";\n\tchar errmsg[256];\n\tint ch, mode = -1;\n\textern char *optarg;\n\textern int optind;\n\tstruct stat st;\n\n\twhile ((ch = getopt(argc, argv, \"hm:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'm':\n\t\t\tif (strcasecmp(optarg, \"chroot\") == 0)\n\t\t\t\tmode = 1;\n\t\t\telse if (strcasecmp(optarg, \"keys-command\") == 0)\n\t\t\t\tmode = 2;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Invalid -m option\\n\"),\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\n\tif (argc > 1)\n\t\tusage();\n\telse if (argc == 1)\n\t\tpath = argv[0];\n\n\tif (mode == 1)\n\t\tsafely_chroot(path, getuid());\n\telse if (mode == 2) {\n\t\tif (stat(path, &st) < 0)\n\t\t\tfatal(\"Could not stat %s: %s\", path, strerror(errno));\n\t\tif (auth_secure_path(path, &st, NULL, 0,\n\t\t    errmsg, sizeof(errmsg)) != 0)\n\t\t\tfatal(\"Unsafe %s: %s\", path, errmsg);\n\t} else {\n\t\tfprintf(stderr, \"Invalid mode\\n\");\n\t\tusage();\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/check-perm.c",
    "lines": "151-156",
    "snippet": "static void\nusage(void)\n{\n\tfprintf(stderr, \"check-perm -m [chroot | keys-command] [path]\\n\");\n\texit(1);\n}",
    "includes": [
      "#include <libgen.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check-perm -m [chroot | keys-command] [path]\\n\""
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libgen.h>\n#include <pwd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr, \"check-perm -m [chroot | keys-command] [path]\\n\");\n\texit(1);\n}"
  },
  {
    "function_name": "auth_secure_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/check-perm.c",
    "lines": "93-149",
    "snippet": "int\nauth_secure_path(const char *name, struct stat *stp, const char *pw_dir,\n    uid_t uid, char *err, size_t errlen)\n{\n\tchar buf[PATH_MAX], homedir[PATH_MAX];\n\tchar *cp;\n\tint comparehome = 0;\n\tstruct stat st;\n\n\tif (realpath(name, buf) == NULL) {\n\t\tsnprintf(err, errlen, \"realpath %s failed: %s\", name,\n\t\t    strerror(errno));\n\t\treturn -1;\n\t}\n\tif (pw_dir != NULL && realpath(pw_dir, homedir) != NULL)\n\t\tcomparehome = 1;\n\n\tif (!S_ISREG(stp->st_mode)) {\n\t\tsnprintf(err, errlen, \"%s is not a regular file\", buf);\n\t\treturn -1;\n\t}\n\tif ((!platform_sys_dir_uid(stp->st_uid) && stp->st_uid != uid) ||\n\t    (stp->st_mode & 022) != 0) {\n\t\tsnprintf(err, errlen, \"bad ownership or modes for file %s\",\n\t\t    buf);\n\t\treturn -1;\n\t}\n\n\t/* for each component of the canonical path, walking upwards */\n\tfor (;;) {\n\t\tif ((cp = dirname(buf)) == NULL) {\n\t\t\tsnprintf(err, errlen, \"dirname() failed\");\n\t\t\treturn -1;\n\t\t}\n\t\tstrlcpy(buf, cp, sizeof(buf));\n\n\t\tif (stat(buf, &st) < 0 ||\n\t\t    (!platform_sys_dir_uid(st.st_uid) && st.st_uid != uid) ||\n\t\t    (st.st_mode & 022) != 0) {\n\t\t\tsnprintf(err, errlen,\n\t\t\t    \"bad ownership or modes for directory %s\", buf);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* If are past the homedir then we can stop */\n\t\tif (comparehome && strcmp(homedir, buf) == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * dirname should always complete with a \"/\" path,\n\t\t * but we can be paranoid and check for \".\" too\n\t\t */\n\t\tif ((strcmp(\"/\", buf) == 0) || (strcmp(\".\", buf) == 0))\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <libgen.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\".\"",
            "buf"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "err",
            "errlen",
            "\"bad ownership or modes for directory %s\"",
            "buf"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "platform_sys_dir_uid",
          "args": [
            "st.st_uid"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "platform_sys_dir_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/check-perm.c",
          "lines": "80-90",
          "snippet": "int\nplatform_sys_dir_uid(uid_t uid)\n{\n\tif (uid == 0)\n\t\treturn 1;\n#ifdef PLATFORM_SYS_DIR_UID\n\tif (uid == PLATFORM_SYS_DIR_UID)\n\t\treturn 1;\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <libgen.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libgen.h>\n#include <pwd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nplatform_sys_dir_uid(uid_t uid)\n{\n\tif (uid == 0)\n\t\treturn 1;\n#ifdef PLATFORM_SYS_DIR_UID\n\tif (uid == PLATFORM_SYS_DIR_UID)\n\t\treturn 1;\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "buf",
            "&st"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "buf",
            "cp",
            "sizeof(buf)"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dirname",
          "args": [
            "buf"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "dirname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/dirname.c",
          "lines": "28-71",
          "snippet": "char *\ndirname(const char *path)\n{\n\tstatic char dname[MAXPATHLEN];\n\tsize_t len;\n\tconst char *endp;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tdname[0] = '.';\n\t\tdname[1] = '\\0';\n\t\treturn (dname);\n\t}\n\n\t/* Strip any trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* Find the start of the dir */\n\twhile (endp > path && *endp != '/')\n\t\tendp--;\n\n\t/* Either the dir is \"/\" or there are no slashes */\n\tif (endp == path) {\n\t\tdname[0] = *endp == '/' ? '/' : '.';\n\t\tdname[1] = '\\0';\n\t\treturn (dname);\n\t} else {\n\t\t/* Move forward past the separating slashes */\n\t\tdo {\n\t\t\tendp--;\n\t\t} while (endp > path && *endp == '/');\n\t}\n\n\tlen = endp - path + 1;\n\tif (len >= sizeof(dname)) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn (NULL);\n\t}\n\tmemcpy(dname, path, len);\n\tdname[len] = '\\0';\n\treturn (dname);\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include <string.h>\n#include <errno.h>\n#include \"includes.h\"\n\nchar *\ndirname(const char *path)\n{\n\tstatic char dname[MAXPATHLEN];\n\tsize_t len;\n\tconst char *endp;\n\n\t/* Empty or NULL string gets treated as \".\" */\n\tif (path == NULL || *path == '\\0') {\n\t\tdname[0] = '.';\n\t\tdname[1] = '\\0';\n\t\treturn (dname);\n\t}\n\n\t/* Strip any trailing slashes */\n\tendp = path + strlen(path) - 1;\n\twhile (endp > path && *endp == '/')\n\t\tendp--;\n\n\t/* Find the start of the dir */\n\twhile (endp > path && *endp != '/')\n\t\tendp--;\n\n\t/* Either the dir is \"/\" or there are no slashes */\n\tif (endp == path) {\n\t\tdname[0] = *endp == '/' ? '/' : '.';\n\t\tdname[1] = '\\0';\n\t\treturn (dname);\n\t} else {\n\t\t/* Move forward past the separating slashes */\n\t\tdo {\n\t\t\tendp--;\n\t\t} while (endp > path && *endp == '/');\n\t}\n\n\tlen = endp - path + 1;\n\tif (len >= sizeof(dname)) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn (NULL);\n\t}\n\tmemcpy(dname, path, len);\n\tdname[len] = '\\0';\n\treturn (dname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "stp->st_mode"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realpath",
          "args": [
            "pw_dir",
            "homedir"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "do_realpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-client.c",
          "lines": "825-880",
          "snippet": "char *\ndo_realpath(struct sftp_conn *conn, const char *path)\n{\n\tstruct sshbuf *msg;\n\tu_int expected_id, count, id;\n\tchar *filename, *longname;\n\tAttrib a;\n\tu_char type;\n\tint r;\n\n\texpected_id = id = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_REALPATH, path,\n\t    strlen(path));\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\terror(\"Couldn't canonicalize: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn NULL;\n\t} else if (type != SSH2_FXP_NAME)\n\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t    SSH2_FXP_NAME, type);\n\n\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (count != 1)\n\t\tfatal(\"Got multiple names (%d) from SSH_FXP_REALPATH\", count);\n\n\tif ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||\n\t    (r = decode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"SSH_FXP_REALPATH %s -> %s size %lu\", path, filename,\n\t    (unsigned long)a.size);\n\n\tfree(longname);\n\n\tsshbuf_free(msg);\n\n\treturn(filename);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"utf8.h\"",
            "#include \"misc.h\"",
            "#include \"progressmeter.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/uio.h>",
            "# include <sys/time.h>",
            "# include <sys/stat.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/statvfs.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"utf8.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n# include <sys/time.h>\n# include <sys/stat.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ndo_realpath(struct sftp_conn *conn, const char *path)\n{\n\tstruct sshbuf *msg;\n\tu_int expected_id, count, id;\n\tchar *filename, *longname;\n\tAttrib a;\n\tu_char type;\n\tint r;\n\n\texpected_id = id = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_REALPATH, path,\n\t    strlen(path));\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\terror(\"Couldn't canonicalize: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn NULL;\n\t} else if (type != SSH2_FXP_NAME)\n\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t    SSH2_FXP_NAME, type);\n\n\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (count != 1)\n\t\tfatal(\"Got multiple names (%d) from SSH_FXP_REALPATH\", count);\n\n\tif ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||\n\t    (r = decode_attrib(msg, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"SSH_FXP_REALPATH %s -> %s size %lu\", path, filename,\n\t    (unsigned long)a.size);\n\n\tfree(longname);\n\n\tsshbuf_free(msg);\n\n\treturn(filename);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <libgen.h>\n#include <pwd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nauth_secure_path(const char *name, struct stat *stp, const char *pw_dir,\n    uid_t uid, char *err, size_t errlen)\n{\n\tchar buf[PATH_MAX], homedir[PATH_MAX];\n\tchar *cp;\n\tint comparehome = 0;\n\tstruct stat st;\n\n\tif (realpath(name, buf) == NULL) {\n\t\tsnprintf(err, errlen, \"realpath %s failed: %s\", name,\n\t\t    strerror(errno));\n\t\treturn -1;\n\t}\n\tif (pw_dir != NULL && realpath(pw_dir, homedir) != NULL)\n\t\tcomparehome = 1;\n\n\tif (!S_ISREG(stp->st_mode)) {\n\t\tsnprintf(err, errlen, \"%s is not a regular file\", buf);\n\t\treturn -1;\n\t}\n\tif ((!platform_sys_dir_uid(stp->st_uid) && stp->st_uid != uid) ||\n\t    (stp->st_mode & 022) != 0) {\n\t\tsnprintf(err, errlen, \"bad ownership or modes for file %s\",\n\t\t    buf);\n\t\treturn -1;\n\t}\n\n\t/* for each component of the canonical path, walking upwards */\n\tfor (;;) {\n\t\tif ((cp = dirname(buf)) == NULL) {\n\t\t\tsnprintf(err, errlen, \"dirname() failed\");\n\t\t\treturn -1;\n\t\t}\n\t\tstrlcpy(buf, cp, sizeof(buf));\n\n\t\tif (stat(buf, &st) < 0 ||\n\t\t    (!platform_sys_dir_uid(st.st_uid) && st.st_uid != uid) ||\n\t\t    (st.st_mode & 022) != 0) {\n\t\t\tsnprintf(err, errlen,\n\t\t\t    \"bad ownership or modes for directory %s\", buf);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* If are past the homedir then we can stop */\n\t\tif (comparehome && strcmp(homedir, buf) == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * dirname should always complete with a \"/\" path,\n\t\t * but we can be paranoid and check for \".\" too\n\t\t */\n\t\tif ((strcmp(\"/\", buf) == 0) || (strcmp(\".\", buf) == 0))\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "platform_sys_dir_uid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/check-perm.c",
    "lines": "80-90",
    "snippet": "int\nplatform_sys_dir_uid(uid_t uid)\n{\n\tif (uid == 0)\n\t\treturn 1;\n#ifdef PLATFORM_SYS_DIR_UID\n\tif (uid == PLATFORM_SYS_DIR_UID)\n\t\treturn 1;\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include <libgen.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <libgen.h>\n#include <pwd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nplatform_sys_dir_uid(uid_t uid)\n{\n\tif (uid == 0)\n\t\treturn 1;\n#ifdef PLATFORM_SYS_DIR_UID\n\tif (uid == PLATFORM_SYS_DIR_UID)\n\t\treturn 1;\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "safely_chroot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/check-perm.c",
    "lines": "34-77",
    "snippet": "static void\nsafely_chroot(const char *path, uid_t uid)\n{\n\tconst char *cp;\n\tchar component[PATH_MAX];\n\tstruct stat st;\n\n\tif (*path != '/')\n\t\tfatal(\"chroot path does not begin at root\");\n\tif (strlen(path) >= sizeof(component))\n\t\tfatal(\"chroot path too long\");\n\n\t/*\n\t * Descend the path, checking that each component is a\n\t * root-owned directory with strict permissions.\n\t */\n\tfor (cp = path; cp != NULL;) {\n\t\tif ((cp = strchr(cp, '/')) == NULL)\n\t\t\tstrlcpy(component, path, sizeof(component));\n\t\telse {\n\t\t\tcp++;\n\t\t\tmemcpy(component, path, cp - path);\n\t\t\tcomponent[cp - path] = '\\0';\n\t\t}\n\n\t\t/* debug3(\"%s: checking '%s'\", __func__, component); */\n\n\t\tif (stat(component, &st) != 0)\n\t\t\tfatal(\"%s: stat(\\\"%s\\\"): %s\", __func__,\n\t\t\t    component, strerror(errno));\n\t\tif (st.st_uid != 0 || (st.st_mode & 022) != 0)\n\t\t\tfatal(\"bad ownership or modes for chroot \"\n\t\t\t    \"directory %s\\\"%s\\\"\",\n\t\t\t    cp == NULL ? \"\" : \"component \", component);\n\t\tif (!S_ISDIR(st.st_mode))\n\t\t\tfatal(\"chroot path %s\\\"%s\\\" is not a directory\",\n\t\t\t    cp == NULL ? \"\" : \"component \", component);\n\n\t}\n\n\tif (chdir(path) == -1)\n\t\tfatal(\"Unable to chdir to chroot path \\\"%s\\\": \"\n\t\t    \"%s\", path, strerror(errno));\n}",
    "includes": [
      "#include <libgen.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Unable to chdir to chroot path \\\"%s\\\": \"\n\t\t    \"%s\"",
            "path",
            "strerror(errno)"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/check-perm.c",
          "lines": "22-32",
          "snippet": "static void\nfatal(const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(1);\n}",
          "includes": [
            "#include <libgen.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libgen.h>\n#include <pwd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nfatal(const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "path"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "component",
            "&st"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "component",
            "path",
            "cp - path"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "component",
            "path",
            "sizeof(component)"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cp",
            "'/'"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libgen.h>\n#include <pwd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsafely_chroot(const char *path, uid_t uid)\n{\n\tconst char *cp;\n\tchar component[PATH_MAX];\n\tstruct stat st;\n\n\tif (*path != '/')\n\t\tfatal(\"chroot path does not begin at root\");\n\tif (strlen(path) >= sizeof(component))\n\t\tfatal(\"chroot path too long\");\n\n\t/*\n\t * Descend the path, checking that each component is a\n\t * root-owned directory with strict permissions.\n\t */\n\tfor (cp = path; cp != NULL;) {\n\t\tif ((cp = strchr(cp, '/')) == NULL)\n\t\t\tstrlcpy(component, path, sizeof(component));\n\t\telse {\n\t\t\tcp++;\n\t\t\tmemcpy(component, path, cp - path);\n\t\t\tcomponent[cp - path] = '\\0';\n\t\t}\n\n\t\t/* debug3(\"%s: checking '%s'\", __func__, component); */\n\n\t\tif (stat(component, &st) != 0)\n\t\t\tfatal(\"%s: stat(\\\"%s\\\"): %s\", __func__,\n\t\t\t    component, strerror(errno));\n\t\tif (st.st_uid != 0 || (st.st_mode & 022) != 0)\n\t\t\tfatal(\"bad ownership or modes for chroot \"\n\t\t\t    \"directory %s\\\"%s\\\"\",\n\t\t\t    cp == NULL ? \"\" : \"component \", component);\n\t\tif (!S_ISDIR(st.st_mode))\n\t\t\tfatal(\"chroot path %s\\\"%s\\\" is not a directory\",\n\t\t\t    cp == NULL ? \"\" : \"component \", component);\n\n\t}\n\n\tif (chdir(path) == -1)\n\t\tfatal(\"Unable to chdir to chroot path \\\"%s\\\": \"\n\t\t    \"%s\", path, strerror(errno));\n}"
  },
  {
    "function_name": "fatal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/check-perm.c",
    "lines": "22-32",
    "snippet": "static void\nfatal(const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(1);\n}",
    "includes": [
      "#include <libgen.h>",
      "#include <pwd.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fputc",
          "args": [
            "'\\n'",
            "stderr"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfprintf",
          "args": [
            "stderr",
            "fmt",
            "args"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libgen.h>\n#include <pwd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nfatal(const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(1);\n}"
  }
]