[
  {
    "function_name": "sshkey_fuzz_tests",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/test_fuzz.c",
    "lines": "99-360",
    "snippet": "void\nsshkey_fuzz_tests(void)\n{\n\tstruct sshkey *k1;\n\tstruct sshbuf *buf, *fuzzed;\n\tstruct fuzz *fuzz;\n\tint r;\n\n\n\tTEST_START(\"fuzz RSA private\");\n\tbuf = load_file(\"rsa_1\");\n\tfuzz = fuzz_begin(FUZZ_BASE64, sshbuf_mutable_ptr(buf),\n\t    sshbuf_len(buf));\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshkey_free(k1);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(fuzzed = sshbuf_new(), NULL);\n\tTEST_ONERROR(onerror, fuzz);\n\tfor(; !fuzz_done(fuzz); fuzz_next(fuzz)) {\n\t\tr = sshbuf_put(fuzzed, fuzz_ptr(fuzz), fuzz_len(fuzz));\n\t\tASSERT_INT_EQ(r, 0);\n\t\tif (sshkey_parse_private_fileblob(fuzzed, \"\", &k1, NULL) == 0)\n\t\t\tsshkey_free(k1);\n\t\tsshbuf_reset(fuzzed);\n\t}\n\tsshbuf_free(fuzzed);\n\tfuzz_cleanup(fuzz);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz RSA new-format private\");\n\tbuf = load_file(\"rsa_n\");\n\tfuzz = fuzz_begin(FUZZ_BASE64, sshbuf_mutable_ptr(buf),\n\t    sshbuf_len(buf));\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshkey_free(k1);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(fuzzed = sshbuf_new(), NULL);\n\tTEST_ONERROR(onerror, fuzz);\n\tfor(; !fuzz_done(fuzz); fuzz_next(fuzz)) {\n\t\tr = sshbuf_put(fuzzed, fuzz_ptr(fuzz), fuzz_len(fuzz));\n\t\tASSERT_INT_EQ(r, 0);\n\t\tif (sshkey_parse_private_fileblob(fuzzed, \"\", &k1, NULL) == 0)\n\t\t\tsshkey_free(k1);\n\t\tsshbuf_reset(fuzzed);\n\t}\n\tsshbuf_free(fuzzed);\n\tfuzz_cleanup(fuzz);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz DSA private\");\n\tbuf = load_file(\"dsa_1\");\n\tfuzz = fuzz_begin(FUZZ_BASE64, sshbuf_mutable_ptr(buf),\n\t    sshbuf_len(buf));\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshkey_free(k1);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(fuzzed = sshbuf_new(), NULL);\n\tTEST_ONERROR(onerror, fuzz);\n\tfor(; !fuzz_done(fuzz); fuzz_next(fuzz)) {\n\t\tr = sshbuf_put(fuzzed, fuzz_ptr(fuzz), fuzz_len(fuzz));\n\t\tASSERT_INT_EQ(r, 0);\n\t\tif (sshkey_parse_private_fileblob(fuzzed, \"\", &k1, NULL) == 0)\n\t\t\tsshkey_free(k1);\n\t\tsshbuf_reset(fuzzed);\n\t}\n\tsshbuf_free(fuzzed);\n\tfuzz_cleanup(fuzz);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz DSA new-format private\");\n\tbuf = load_file(\"dsa_n\");\n\tfuzz = fuzz_begin(FUZZ_BASE64, sshbuf_mutable_ptr(buf),\n\t    sshbuf_len(buf));\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshkey_free(k1);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(fuzzed = sshbuf_new(), NULL);\n\tTEST_ONERROR(onerror, fuzz);\n\tfor(; !fuzz_done(fuzz); fuzz_next(fuzz)) {\n\t\tr = sshbuf_put(fuzzed, fuzz_ptr(fuzz), fuzz_len(fuzz));\n\t\tASSERT_INT_EQ(r, 0);\n\t\tif (sshkey_parse_private_fileblob(fuzzed, \"\", &k1, NULL) == 0)\n\t\t\tsshkey_free(k1);\n\t\tsshbuf_reset(fuzzed);\n\t}\n\tsshbuf_free(fuzzed);\n\tfuzz_cleanup(fuzz);\n\tTEST_DONE();\n\n#ifdef OPENSSL_HAS_ECC\n\tTEST_START(\"fuzz ECDSA private\");\n\tbuf = load_file(\"ecdsa_1\");\n\tfuzz = fuzz_begin(FUZZ_BASE64, sshbuf_mutable_ptr(buf),\n\t    sshbuf_len(buf));\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshkey_free(k1);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(fuzzed = sshbuf_new(), NULL);\n\tTEST_ONERROR(onerror, fuzz);\n\tfor(; !fuzz_done(fuzz); fuzz_next(fuzz)) {\n\t\tr = sshbuf_put(fuzzed, fuzz_ptr(fuzz), fuzz_len(fuzz));\n\t\tASSERT_INT_EQ(r, 0);\n\t\tif (sshkey_parse_private_fileblob(fuzzed, \"\", &k1, NULL) == 0)\n\t\t\tsshkey_free(k1);\n\t\tsshbuf_reset(fuzzed);\n\t}\n\tsshbuf_free(fuzzed);\n\tfuzz_cleanup(fuzz);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz ECDSA new-format private\");\n\tbuf = load_file(\"ecdsa_n\");\n\tfuzz = fuzz_begin(FUZZ_BASE64, sshbuf_mutable_ptr(buf),\n\t    sshbuf_len(buf));\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshkey_free(k1);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(fuzzed = sshbuf_new(), NULL);\n\tTEST_ONERROR(onerror, fuzz);\n\tfor(; !fuzz_done(fuzz); fuzz_next(fuzz)) {\n\t\tr = sshbuf_put(fuzzed, fuzz_ptr(fuzz), fuzz_len(fuzz));\n\t\tASSERT_INT_EQ(r, 0);\n\t\tif (sshkey_parse_private_fileblob(fuzzed, \"\", &k1, NULL) == 0)\n\t\t\tsshkey_free(k1);\n\t\tsshbuf_reset(fuzzed);\n\t}\n\tsshbuf_free(fuzzed);\n\tfuzz_cleanup(fuzz);\n\tTEST_DONE();\n#endif\n\n\tTEST_START(\"fuzz Ed25519 private\");\n\tbuf = load_file(\"ed25519_1\");\n\tfuzz = fuzz_begin(FUZZ_BASE64, sshbuf_mutable_ptr(buf),\n\t    sshbuf_len(buf));\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshkey_free(k1);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(fuzzed = sshbuf_new(), NULL);\n\tTEST_ONERROR(onerror, fuzz);\n\tfor(; !fuzz_done(fuzz); fuzz_next(fuzz)) {\n\t\tr = sshbuf_put(fuzzed, fuzz_ptr(fuzz), fuzz_len(fuzz));\n\t\tASSERT_INT_EQ(r, 0);\n\t\tif (sshkey_parse_private_fileblob(fuzzed, \"\", &k1, NULL) == 0)\n\t\t\tsshkey_free(k1);\n\t\tsshbuf_reset(fuzzed);\n\t}\n\tsshbuf_free(fuzzed);\n\tfuzz_cleanup(fuzz);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz RSA public\");\n\tbuf = load_file(\"rsa_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tpublic_fuzz(k1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz RSA cert\");\n\tASSERT_INT_EQ(sshkey_load_cert(test_data_file(\"rsa_1\"), &k1), 0);\n\tpublic_fuzz(k1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz DSA public\");\n\tbuf = load_file(\"dsa_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tpublic_fuzz(k1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz DSA cert\");\n\tASSERT_INT_EQ(sshkey_load_cert(test_data_file(\"dsa_1\"), &k1), 0);\n\tpublic_fuzz(k1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n#ifdef OPENSSL_HAS_ECC\n\tTEST_START(\"fuzz ECDSA public\");\n\tbuf = load_file(\"ecdsa_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tpublic_fuzz(k1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz ECDSA cert\");\n\tASSERT_INT_EQ(sshkey_load_cert(test_data_file(\"ecdsa_1\"), &k1), 0);\n\tpublic_fuzz(k1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n#endif\n\n\tTEST_START(\"fuzz Ed25519 public\");\n\tbuf = load_file(\"ed25519_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tpublic_fuzz(k1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz Ed25519 cert\");\n\tASSERT_INT_EQ(sshkey_load_cert(test_data_file(\"ed25519_1\"), &k1), 0);\n\tpublic_fuzz(k1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz RSA sig\");\n\tbuf = load_file(\"rsa_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tsig_fuzz(k1, \"ssh-rsa\");\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz RSA SHA256 sig\");\n\tbuf = load_file(\"rsa_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tsig_fuzz(k1, \"rsa-sha2-256\");\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz RSA SHA512 sig\");\n\tbuf = load_file(\"rsa_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tsig_fuzz(k1, \"rsa-sha2-512\");\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz DSA sig\");\n\tbuf = load_file(\"dsa_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tsig_fuzz(k1, NULL);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n#ifdef OPENSSL_HAS_ECC\n\tTEST_START(\"fuzz ECDSA sig\");\n\tbuf = load_file(\"ecdsa_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tsig_fuzz(k1, NULL);\n\tsshkey_free(k1);\n\tTEST_DONE();\n#endif\n\n\tTEST_START(\"fuzz Ed25519 sig\");\n\tbuf = load_file(\"ed25519_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tsig_fuzz(k1, NULL);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n/* XXX fuzz decoded new-format blobs too */\n\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"../test_helper/test_helper.h\"",
      "# include <openssl/ec.h>",
      "#include <openssl/objects.h>",
      "#include <openssl/dsa.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/bn.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sshkey_fuzz_tests(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "k1"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sig_fuzz",
          "args": [
            "k1",
            "NULL"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "sig_fuzz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/test_fuzz.c",
          "lines": "74-97",
          "snippet": "static void\nsig_fuzz(struct sshkey *k, const char *sig_alg)\n{\n\tstruct fuzz *fuzz;\n\tu_char *sig, c[] = \"some junk to be signed\";\n\tsize_t l;\n\n\tASSERT_INT_EQ(sshkey_sign(k, &sig, &l, c, sizeof(c), sig_alg, 0), 0);\n\tASSERT_SIZE_T_GT(l, 0);\n\tfuzz = fuzz_begin(FUZZ_1_BIT_FLIP | /* too slow FUZZ_2_BIT_FLIP | */\n\t    FUZZ_1_BYTE_FLIP | FUZZ_2_BYTE_FLIP |\n\t    FUZZ_TRUNCATE_START | FUZZ_TRUNCATE_END, sig, l);\n\tASSERT_INT_EQ(sshkey_verify(k, sig, l, c, sizeof(c), NULL, 0), 0);\n\tfree(sig);\n\tTEST_ONERROR(onerror, fuzz);\n\tfor(; !fuzz_done(fuzz); fuzz_next(fuzz)) {\n\t\t/* Ensure 1-bit difference at least */\n\t\tif (fuzz_matches_original(fuzz))\n\t\t\tcontinue;\n\t\tASSERT_INT_NE(sshkey_verify(k, fuzz_ptr(fuzz), fuzz_len(fuzz),\n\t\t    c, sizeof(c), NULL, 0), 0);\n\t}\n\tfuzz_cleanup(fuzz);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/objects.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsig_fuzz(struct sshkey *k, const char *sig_alg)\n{\n\tstruct fuzz *fuzz;\n\tu_char *sig, c[] = \"some junk to be signed\";\n\tsize_t l;\n\n\tASSERT_INT_EQ(sshkey_sign(k, &sig, &l, c, sizeof(c), sig_alg, 0), 0);\n\tASSERT_SIZE_T_GT(l, 0);\n\tfuzz = fuzz_begin(FUZZ_1_BIT_FLIP | /* too slow FUZZ_2_BIT_FLIP | */\n\t    FUZZ_1_BYTE_FLIP | FUZZ_2_BYTE_FLIP |\n\t    FUZZ_TRUNCATE_START | FUZZ_TRUNCATE_END, sig, l);\n\tASSERT_INT_EQ(sshkey_verify(k, sig, l, c, sizeof(c), NULL, 0), 0);\n\tfree(sig);\n\tTEST_ONERROR(onerror, fuzz);\n\tfor(; !fuzz_done(fuzz); fuzz_next(fuzz)) {\n\t\t/* Ensure 1-bit difference at least */\n\t\tif (fuzz_matches_original(fuzz))\n\t\t\tcontinue;\n\t\tASSERT_INT_NE(sshkey_verify(k, fuzz_ptr(fuzz), fuzz_len(fuzz),\n\t\t    c, sizeof(c), NULL, 0), 0);\n\t}\n\tfuzz_cleanup(fuzz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "buf"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf, \"\", &k1, NULL)",
            "0"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_parse_private_fileblob",
          "args": [
            "buf",
            "\"\"",
            "&k1",
            "NULL"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_parse_private_fileblob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "4067-4078",
          "snippet": "int\nsshkey_parse_private_fileblob(struct sshbuf *buffer, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\treturn sshkey_parse_private_fileblob_type(buffer, KEY_UNSPEC,\n\t    passphrase, keyp, commentp);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_parse_private_fileblob(struct sshbuf *buffer, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\treturn sshkey_parse_private_fileblob_type(buffer, KEY_UNSPEC,\n\t    passphrase, keyp, commentp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_file",
          "args": [
            "\"ed25519_1\""
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "load_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/common.c",
          "lines": "41-52",
          "snippet": "struct sshbuf *\nload_file(const char *name)\n{\n\tint fd;\n\tstruct sshbuf *ret;\n\n\tASSERT_PTR_NE(ret = sshbuf_new(), NULL);\n\tASSERT_INT_NE(fd = open(test_data_file(name), O_RDONLY), -1);\n\tASSERT_INT_EQ(sshkey_load_file(fd, ret), 0);\n\tclose(fd);\n\treturn ret;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/objects.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nload_file(const char *name)\n{\n\tint fd;\n\tstruct sshbuf *ret;\n\n\tASSERT_PTR_NE(ret = sshbuf_new(), NULL);\n\tASSERT_INT_NE(fd = open(test_data_file(name), O_RDONLY), -1);\n\tASSERT_INT_EQ(sshkey_load_file(fd, ret), 0);\n\tclose(fd);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"fuzz Ed25519 sig\""
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf, \"\", &k1, NULL)",
            "0"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"fuzz ECDSA sig\""
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf, \"\", &k1, NULL)",
            "0"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"fuzz DSA sig\""
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf, \"\", &k1, NULL)",
            "0"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"fuzz RSA SHA512 sig\""
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf, \"\", &k1, NULL)",
            "0"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"fuzz RSA SHA256 sig\""
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf, \"\", &k1, NULL)",
            "0"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"fuzz RSA sig\""
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "public_fuzz",
          "args": [
            "k1"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "public_fuzz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/test_fuzz.c",
          "lines": "48-72",
          "snippet": "static void\npublic_fuzz(struct sshkey *k)\n{\n\tstruct sshkey *k1;\n\tstruct sshbuf *buf;\n\tstruct fuzz *fuzz;\n\n\tASSERT_PTR_NE(buf = sshbuf_new(), NULL);\n\tASSERT_INT_EQ(sshkey_putb(k, buf), 0);\n\t/* XXX need a way to run the tests in \"slow, but complete\" mode */\n\tfuzz = fuzz_begin(FUZZ_1_BIT_FLIP | /* XXX too slow FUZZ_2_BIT_FLIP | */\n\t    FUZZ_1_BYTE_FLIP | /* XXX too slow FUZZ_2_BYTE_FLIP | */\n\t    FUZZ_TRUNCATE_START | FUZZ_TRUNCATE_END,\n\t    sshbuf_mutable_ptr(buf), sshbuf_len(buf));\n\tASSERT_INT_EQ(sshkey_from_blob(sshbuf_ptr(buf), sshbuf_len(buf),\n\t    &k1), 0);\n\tsshkey_free(k1);\n\tsshbuf_free(buf);\n\tTEST_ONERROR(onerror, fuzz);\n\tfor(; !fuzz_done(fuzz); fuzz_next(fuzz)) {\n\t\tif (sshkey_from_blob(fuzz_ptr(fuzz), fuzz_len(fuzz), &k1) == 0)\n\t\t\tsshkey_free(k1);\n\t}\n\tfuzz_cleanup(fuzz);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/objects.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\npublic_fuzz(struct sshkey *k)\n{\n\tstruct sshkey *k1;\n\tstruct sshbuf *buf;\n\tstruct fuzz *fuzz;\n\n\tASSERT_PTR_NE(buf = sshbuf_new(), NULL);\n\tASSERT_INT_EQ(sshkey_putb(k, buf), 0);\n\t/* XXX need a way to run the tests in \"slow, but complete\" mode */\n\tfuzz = fuzz_begin(FUZZ_1_BIT_FLIP | /* XXX too slow FUZZ_2_BIT_FLIP | */\n\t    FUZZ_1_BYTE_FLIP | /* XXX too slow FUZZ_2_BYTE_FLIP | */\n\t    FUZZ_TRUNCATE_START | FUZZ_TRUNCATE_END,\n\t    sshbuf_mutable_ptr(buf), sshbuf_len(buf));\n\tASSERT_INT_EQ(sshkey_from_blob(sshbuf_ptr(buf), sshbuf_len(buf),\n\t    &k1), 0);\n\tsshkey_free(k1);\n\tsshbuf_free(buf);\n\tTEST_ONERROR(onerror, fuzz);\n\tfor(; !fuzz_done(fuzz); fuzz_next(fuzz)) {\n\t\tif (sshkey_from_blob(fuzz_ptr(fuzz), fuzz_len(fuzz), &k1) == 0)\n\t\t\tsshkey_free(k1);\n\t}\n\tfuzz_cleanup(fuzz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_load_cert(test_data_file(\"ed25519_1\"), &k1)",
            "0"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_load_cert",
          "args": [
            "test_data_file(\"ed25519_1\")",
            "&k1"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_load_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "357-385",
          "snippet": "int\nsshkey_load_cert(const char *filename, struct sshkey **keyp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\n\tif (asprintf(&file, \"%s-cert.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, NULL)) != 0)\n\t\tgoto out;\n\t/* success */\n\tif (keyp != NULL) {\n\t\t*keyp = pub;\n\t\tpub = NULL;\n\t}\n\tr = 0;\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_load_cert(const char *filename, struct sshkey **keyp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\n\tif (asprintf(&file, \"%s-cert.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, NULL)) != 0)\n\t\tgoto out;\n\t/* success */\n\tif (keyp != NULL) {\n\t\t*keyp = pub;\n\t\tpub = NULL;\n\t}\n\tr = 0;\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_data_file",
          "args": [
            "\"ed25519_1\""
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "test_data_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/test_helper.c",
          "lines": "181-196",
          "snippet": "const char *\ntest_data_file(const char *name)\n{\n\tstatic char ret[PATH_MAX];\n\n\tif (data_dir != NULL)\n\t\tsnprintf(ret, sizeof(ret), \"%s/%s\", data_dir, name);\n\telse\n\t\tstrlcpy(ret, name, sizeof(ret));\n\tif (access(ret, F_OK) != 0) {\n\t\tfprintf(stderr, \"Cannot access data file %s: %s\\n\",\n\t\t    ret, strerror(errno));\n\t\texit(1);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "# include <vis.h>",
            "#include <openssl/bn.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *data_dir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n# include <vis.h>\n#include <openssl/bn.h>\n#include <signal.h>\n#include <unistd.h>\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *data_dir = NULL;\n\nconst char *\ntest_data_file(const char *name)\n{\n\tstatic char ret[PATH_MAX];\n\n\tif (data_dir != NULL)\n\t\tsnprintf(ret, sizeof(ret), \"%s/%s\", data_dir, name);\n\telse\n\t\tstrlcpy(ret, name, sizeof(ret));\n\tif (access(ret, F_OK) != 0) {\n\t\tfprintf(stderr, \"Cannot access data file %s: %s\\n\",\n\t\t    ret, strerror(errno));\n\t\texit(1);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"fuzz Ed25519 cert\""
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf, \"\", &k1, NULL)",
            "0"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"fuzz Ed25519 public\""
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_load_cert(test_data_file(\"ecdsa_1\"), &k1)",
            "0"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"fuzz ECDSA cert\""
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf, \"\", &k1, NULL)",
            "0"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"fuzz ECDSA public\""
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_load_cert(test_data_file(\"dsa_1\"), &k1)",
            "0"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"fuzz DSA cert\""
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf, \"\", &k1, NULL)",
            "0"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"fuzz DSA public\""
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_load_cert(test_data_file(\"rsa_1\"), &k1)",
            "0"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"fuzz RSA cert\""
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf, \"\", &k1, NULL)",
            "0"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"fuzz RSA public\""
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuzz_cleanup",
          "args": [
            "fuzz"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "243-258",
          "snippet": "void\nfuzz_cleanup(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"cleanup, fuzz = %p\", fuzz));\n\tlast_fuzz = NULL;\n#ifdef SIGINFO\n\tsignal(SIGINFO, SIG_DFL);\n#endif\n\tsignal(SIGUSR1, SIG_DFL);\n\tassert(fuzz != NULL);\n\tassert(fuzz->seed != NULL);\n\tassert(fuzz->fuzzed != NULL);\n\tfree(fuzz->seed);\n\tfree(fuzz->fuzzed);\n\tfree(fuzz);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fuzz *last_fuzz;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct fuzz *last_fuzz;\n\nvoid\nfuzz_cleanup(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"cleanup, fuzz = %p\", fuzz));\n\tlast_fuzz = NULL;\n#ifdef SIGINFO\n\tsignal(SIGINFO, SIG_DFL);\n#endif\n\tsignal(SIGUSR1, SIG_DFL);\n\tassert(fuzz != NULL);\n\tassert(fuzz->seed != NULL);\n\tassert(fuzz->fuzzed != NULL);\n\tfree(fuzz->seed);\n\tfree(fuzz->fuzzed);\n\tfree(fuzz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "fuzzed"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "r",
            "0"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "fuzzed",
            "fuzz_ptr(fuzz)",
            "fuzz_len(fuzz)"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuzz_len",
          "args": [
            "fuzz"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "397-415",
          "snippet": "size_t\nfuzz_len(struct fuzz *fuzz)\n{\n\tassert(fuzz->fuzzed != NULL);\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\tcase FUZZ_2_BIT_FLIP:\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_2_BYTE_FLIP:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->slen;\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->slen - fuzz->o1;\n\tdefault:\n\t\tabort();\n\t}\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nfuzz_len(struct fuzz *fuzz)\n{\n\tassert(fuzz->fuzzed != NULL);\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\tcase FUZZ_2_BIT_FLIP:\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_2_BYTE_FLIP:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->slen;\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->slen - fuzz->o1;\n\tdefault:\n\t\tabort();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuzz_ptr",
          "args": [
            "fuzz"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "417-437",
          "snippet": "u_char *\nfuzz_ptr(struct fuzz *fuzz)\n{\n\tassert(fuzz->fuzzed != NULL);\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\tcase FUZZ_2_BIT_FLIP:\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_2_BYTE_FLIP:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->fuzzed;\n\tcase FUZZ_TRUNCATE_START:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->fuzzed + fuzz->o1;\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->fuzzed;\n\tdefault:\n\t\tabort();\n\t}\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_char *\nfuzz_ptr(struct fuzz *fuzz)\n{\n\tassert(fuzz->fuzzed != NULL);\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\tcase FUZZ_2_BIT_FLIP:\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_2_BYTE_FLIP:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->fuzzed;\n\tcase FUZZ_TRUNCATE_START:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->fuzzed + fuzz->o1;\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->fuzzed;\n\tdefault:\n\t\tabort();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuzz_next",
          "args": [
            "fuzz"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "283-378",
          "snippet": "void\nfuzz_next(struct fuzz *fuzz)\n{\n\tu_int i;\n\n\tFUZZ_DBG((\"start, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen));\n\n\tif (fuzz->strategy == 0 || fuzz_strategy_done(fuzz)) {\n\t\t/* If we are just starting out, we need to allocate too */\n\t\tif (fuzz->fuzzed == NULL) {\n\t\t\tFUZZ_DBG((\"alloc\"));\n\t\t\tfuzz->fuzzed = calloc(fuzz->slen, 1);\n\t\t}\n\t\t/* Pick next strategy */\n\t\tFUZZ_DBG((\"advance\"));\n\t\tfor (i = 1; i <= FUZZ_MAX; i <<= 1) {\n\t\t\tif ((fuzz->strategies & i) != 0) {\n\t\t\t\tfuzz->strategy = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tFUZZ_DBG((\"selected = %u\", fuzz->strategy));\n\t\tif (fuzz->strategy == 0) {\n\t\t\tFUZZ_DBG((\"done, no more strategies\"));\n\t\t\treturn;\n\t\t}\n\t\tfuzz->strategies &= ~(fuzz->strategy);\n\t\tfuzz->o1 = fuzz->o2 = 0;\n\t}\n\n\tassert(fuzz->fuzzed != NULL);\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\tassert(fuzz->o1 / 8 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1 / 8] ^= 1 << (fuzz->o1 % 8);\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_2_BIT_FLIP:\n\t\tassert(fuzz->o1 / 8 < fuzz->slen);\n\t\tassert(fuzz->o2 / 8 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1 / 8] ^= 1 << (fuzz->o1 % 8);\n\t\tfuzz->fuzzed[fuzz->o2 / 8] ^= 1 << (fuzz->o2 % 8);\n\t\tfuzz->o1++;\n\t\tif (fuzz->o1 >= fuzz->slen * 8) {\n\t\t\tfuzz->o1 = 0;\n\t\t\tfuzz->o2++;\n\t\t}\n\t\tbreak;\n\tcase FUZZ_1_BYTE_FLIP:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] ^= 0xff;\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tassert(fuzz->o2 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] ^= 0xff;\n\t\tfuzz->fuzzed[fuzz->o2] ^= 0xff;\n\t\tfuzz->o1++;\n\t\tif (fuzz->o1 >= fuzz->slen) {\n\t\t\tfuzz->o1 = 0;\n\t\t\tfuzz->o2++;\n\t\t}\n\t\tbreak;\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_BASE64:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tassert(fuzz->o2 < sizeof(fuzz_b64chars) - 1);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] = fuzz_b64chars[fuzz->o2];\n\t\tfuzz->o2++;\n\t\tif (fuzz->o2 >= sizeof(fuzz_b64chars) - 1) {\n\t\t\tfuzz->o2 = 0;\n\t\t\tfuzz->o1++;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t}\n\n\tFUZZ_DBG((\"done, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen));\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char fuzz_b64chars[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char fuzz_b64chars[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nvoid\nfuzz_next(struct fuzz *fuzz)\n{\n\tu_int i;\n\n\tFUZZ_DBG((\"start, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen));\n\n\tif (fuzz->strategy == 0 || fuzz_strategy_done(fuzz)) {\n\t\t/* If we are just starting out, we need to allocate too */\n\t\tif (fuzz->fuzzed == NULL) {\n\t\t\tFUZZ_DBG((\"alloc\"));\n\t\t\tfuzz->fuzzed = calloc(fuzz->slen, 1);\n\t\t}\n\t\t/* Pick next strategy */\n\t\tFUZZ_DBG((\"advance\"));\n\t\tfor (i = 1; i <= FUZZ_MAX; i <<= 1) {\n\t\t\tif ((fuzz->strategies & i) != 0) {\n\t\t\t\tfuzz->strategy = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tFUZZ_DBG((\"selected = %u\", fuzz->strategy));\n\t\tif (fuzz->strategy == 0) {\n\t\t\tFUZZ_DBG((\"done, no more strategies\"));\n\t\t\treturn;\n\t\t}\n\t\tfuzz->strategies &= ~(fuzz->strategy);\n\t\tfuzz->o1 = fuzz->o2 = 0;\n\t}\n\n\tassert(fuzz->fuzzed != NULL);\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\tassert(fuzz->o1 / 8 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1 / 8] ^= 1 << (fuzz->o1 % 8);\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_2_BIT_FLIP:\n\t\tassert(fuzz->o1 / 8 < fuzz->slen);\n\t\tassert(fuzz->o2 / 8 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1 / 8] ^= 1 << (fuzz->o1 % 8);\n\t\tfuzz->fuzzed[fuzz->o2 / 8] ^= 1 << (fuzz->o2 % 8);\n\t\tfuzz->o1++;\n\t\tif (fuzz->o1 >= fuzz->slen * 8) {\n\t\t\tfuzz->o1 = 0;\n\t\t\tfuzz->o2++;\n\t\t}\n\t\tbreak;\n\tcase FUZZ_1_BYTE_FLIP:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] ^= 0xff;\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tassert(fuzz->o2 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] ^= 0xff;\n\t\tfuzz->fuzzed[fuzz->o2] ^= 0xff;\n\t\tfuzz->o1++;\n\t\tif (fuzz->o1 >= fuzz->slen) {\n\t\t\tfuzz->o1 = 0;\n\t\t\tfuzz->o2++;\n\t\t}\n\t\tbreak;\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_BASE64:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tassert(fuzz->o2 < sizeof(fuzz_b64chars) - 1);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] = fuzz_b64chars[fuzz->o2];\n\t\tfuzz->o2++;\n\t\tif (fuzz->o2 >= sizeof(fuzz_b64chars) - 1) {\n\t\t\tfuzz->o2 = 0;\n\t\t\tfuzz->o1++;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t}\n\n\tFUZZ_DBG((\"done, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuzz_done",
          "args": [
            "fuzz"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "388-395",
          "snippet": "int\nfuzz_done(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"fuzz = %p, strategies = 0x%lx\", fuzz,\n\t    (u_long)fuzz->strategies));\n\n\treturn fuzz_strategy_done(fuzz) && fuzz->strategies == 0;\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nfuzz_done(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"fuzz = %p, strategies = 0x%lx\", fuzz,\n\t    (u_long)fuzz->strategies));\n\n\treturn fuzz_strategy_done(fuzz) && fuzz->strategies == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_ONERROR",
          "args": [
            "onerror",
            "fuzz"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "fuzzed = sshbuf_new()",
            "NULL"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf, \"\", &k1, NULL)",
            "0"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuzz_begin",
          "args": [
            "FUZZ_BASE64",
            "sshbuf_mutable_ptr(buf)",
            "sshbuf_len(buf)"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "214-241",
          "snippet": "struct fuzz *\nfuzz_begin(u_int strategies, const void *p, size_t l)\n{\n\tstruct fuzz *ret = calloc(sizeof(*ret), 1);\n\n\tassert(p != NULL);\n\tassert(ret != NULL);\n\tret->seed = malloc(l);\n\tassert(ret->seed != NULL);\n\tmemcpy(ret->seed, p, l);\n\tret->slen = l;\n\tret->strategies = strategies;\n\n\tassert(ret->slen < SIZE_MAX / 8);\n\tassert(ret->strategies <= (FUZZ_MAX|(FUZZ_MAX-1)));\n\n\tFUZZ_DBG((\"begin, ret = %p\", ret));\n\n\tfuzz_next(ret);\n\n\tlast_fuzz = ret;\n#ifdef SIGINFO\n\tsignal(SIGINFO, siginfo);\n#endif\n\tsignal(SIGUSR1, siginfo);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fuzz *last_fuzz;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct fuzz *last_fuzz;\n\nstruct fuzz *\nfuzz_begin(u_int strategies, const void *p, size_t l)\n{\n\tstruct fuzz *ret = calloc(sizeof(*ret), 1);\n\n\tassert(p != NULL);\n\tassert(ret != NULL);\n\tret->seed = malloc(l);\n\tassert(ret->seed != NULL);\n\tmemcpy(ret->seed, p, l);\n\tret->slen = l;\n\tret->strategies = strategies;\n\n\tassert(ret->slen < SIZE_MAX / 8);\n\tassert(ret->strategies <= (FUZZ_MAX|(FUZZ_MAX-1)));\n\n\tFUZZ_DBG((\"begin, ret = %p\", ret));\n\n\tfuzz_next(ret);\n\n\tlast_fuzz = ret;\n#ifdef SIGINFO\n\tsignal(SIGINFO, siginfo);\n#endif\n\tsignal(SIGUSR1, siginfo);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "buf"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_mutable_ptr",
          "args": [
            "buf"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_mutable_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "276-282",
          "snippet": "u_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"fuzz Ed25519 private\""
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "r",
            "0"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_ONERROR",
          "args": [
            "onerror",
            "fuzz"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "fuzzed = sshbuf_new()",
            "NULL"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf, \"\", &k1, NULL)",
            "0"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"fuzz ECDSA new-format private\""
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "r",
            "0"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_ONERROR",
          "args": [
            "onerror",
            "fuzz"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "fuzzed = sshbuf_new()",
            "NULL"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf, \"\", &k1, NULL)",
            "0"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"fuzz ECDSA private\""
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "r",
            "0"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_ONERROR",
          "args": [
            "onerror",
            "fuzz"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "fuzzed = sshbuf_new()",
            "NULL"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf, \"\", &k1, NULL)",
            "0"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"fuzz DSA new-format private\""
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "r",
            "0"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_ONERROR",
          "args": [
            "onerror",
            "fuzz"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "fuzzed = sshbuf_new()",
            "NULL"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf, \"\", &k1, NULL)",
            "0"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"fuzz DSA private\""
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "r",
            "0"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_ONERROR",
          "args": [
            "onerror",
            "fuzz"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "fuzzed = sshbuf_new()",
            "NULL"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf, \"\", &k1, NULL)",
            "0"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"fuzz RSA new-format private\""
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "r",
            "0"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_ONERROR",
          "args": [
            "onerror",
            "fuzz"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "fuzzed = sshbuf_new()",
            "NULL"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(buf, \"\", &k1, NULL)",
            "0"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"fuzz RSA private\""
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid sshkey_fuzz_tests(void);\n\nvoid\nsshkey_fuzz_tests(void)\n{\n\tstruct sshkey *k1;\n\tstruct sshbuf *buf, *fuzzed;\n\tstruct fuzz *fuzz;\n\tint r;\n\n\n\tTEST_START(\"fuzz RSA private\");\n\tbuf = load_file(\"rsa_1\");\n\tfuzz = fuzz_begin(FUZZ_BASE64, sshbuf_mutable_ptr(buf),\n\t    sshbuf_len(buf));\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshkey_free(k1);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(fuzzed = sshbuf_new(), NULL);\n\tTEST_ONERROR(onerror, fuzz);\n\tfor(; !fuzz_done(fuzz); fuzz_next(fuzz)) {\n\t\tr = sshbuf_put(fuzzed, fuzz_ptr(fuzz), fuzz_len(fuzz));\n\t\tASSERT_INT_EQ(r, 0);\n\t\tif (sshkey_parse_private_fileblob(fuzzed, \"\", &k1, NULL) == 0)\n\t\t\tsshkey_free(k1);\n\t\tsshbuf_reset(fuzzed);\n\t}\n\tsshbuf_free(fuzzed);\n\tfuzz_cleanup(fuzz);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz RSA new-format private\");\n\tbuf = load_file(\"rsa_n\");\n\tfuzz = fuzz_begin(FUZZ_BASE64, sshbuf_mutable_ptr(buf),\n\t    sshbuf_len(buf));\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshkey_free(k1);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(fuzzed = sshbuf_new(), NULL);\n\tTEST_ONERROR(onerror, fuzz);\n\tfor(; !fuzz_done(fuzz); fuzz_next(fuzz)) {\n\t\tr = sshbuf_put(fuzzed, fuzz_ptr(fuzz), fuzz_len(fuzz));\n\t\tASSERT_INT_EQ(r, 0);\n\t\tif (sshkey_parse_private_fileblob(fuzzed, \"\", &k1, NULL) == 0)\n\t\t\tsshkey_free(k1);\n\t\tsshbuf_reset(fuzzed);\n\t}\n\tsshbuf_free(fuzzed);\n\tfuzz_cleanup(fuzz);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz DSA private\");\n\tbuf = load_file(\"dsa_1\");\n\tfuzz = fuzz_begin(FUZZ_BASE64, sshbuf_mutable_ptr(buf),\n\t    sshbuf_len(buf));\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshkey_free(k1);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(fuzzed = sshbuf_new(), NULL);\n\tTEST_ONERROR(onerror, fuzz);\n\tfor(; !fuzz_done(fuzz); fuzz_next(fuzz)) {\n\t\tr = sshbuf_put(fuzzed, fuzz_ptr(fuzz), fuzz_len(fuzz));\n\t\tASSERT_INT_EQ(r, 0);\n\t\tif (sshkey_parse_private_fileblob(fuzzed, \"\", &k1, NULL) == 0)\n\t\t\tsshkey_free(k1);\n\t\tsshbuf_reset(fuzzed);\n\t}\n\tsshbuf_free(fuzzed);\n\tfuzz_cleanup(fuzz);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz DSA new-format private\");\n\tbuf = load_file(\"dsa_n\");\n\tfuzz = fuzz_begin(FUZZ_BASE64, sshbuf_mutable_ptr(buf),\n\t    sshbuf_len(buf));\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshkey_free(k1);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(fuzzed = sshbuf_new(), NULL);\n\tTEST_ONERROR(onerror, fuzz);\n\tfor(; !fuzz_done(fuzz); fuzz_next(fuzz)) {\n\t\tr = sshbuf_put(fuzzed, fuzz_ptr(fuzz), fuzz_len(fuzz));\n\t\tASSERT_INT_EQ(r, 0);\n\t\tif (sshkey_parse_private_fileblob(fuzzed, \"\", &k1, NULL) == 0)\n\t\t\tsshkey_free(k1);\n\t\tsshbuf_reset(fuzzed);\n\t}\n\tsshbuf_free(fuzzed);\n\tfuzz_cleanup(fuzz);\n\tTEST_DONE();\n\n#ifdef OPENSSL_HAS_ECC\n\tTEST_START(\"fuzz ECDSA private\");\n\tbuf = load_file(\"ecdsa_1\");\n\tfuzz = fuzz_begin(FUZZ_BASE64, sshbuf_mutable_ptr(buf),\n\t    sshbuf_len(buf));\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshkey_free(k1);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(fuzzed = sshbuf_new(), NULL);\n\tTEST_ONERROR(onerror, fuzz);\n\tfor(; !fuzz_done(fuzz); fuzz_next(fuzz)) {\n\t\tr = sshbuf_put(fuzzed, fuzz_ptr(fuzz), fuzz_len(fuzz));\n\t\tASSERT_INT_EQ(r, 0);\n\t\tif (sshkey_parse_private_fileblob(fuzzed, \"\", &k1, NULL) == 0)\n\t\t\tsshkey_free(k1);\n\t\tsshbuf_reset(fuzzed);\n\t}\n\tsshbuf_free(fuzzed);\n\tfuzz_cleanup(fuzz);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz ECDSA new-format private\");\n\tbuf = load_file(\"ecdsa_n\");\n\tfuzz = fuzz_begin(FUZZ_BASE64, sshbuf_mutable_ptr(buf),\n\t    sshbuf_len(buf));\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshkey_free(k1);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(fuzzed = sshbuf_new(), NULL);\n\tTEST_ONERROR(onerror, fuzz);\n\tfor(; !fuzz_done(fuzz); fuzz_next(fuzz)) {\n\t\tr = sshbuf_put(fuzzed, fuzz_ptr(fuzz), fuzz_len(fuzz));\n\t\tASSERT_INT_EQ(r, 0);\n\t\tif (sshkey_parse_private_fileblob(fuzzed, \"\", &k1, NULL) == 0)\n\t\t\tsshkey_free(k1);\n\t\tsshbuf_reset(fuzzed);\n\t}\n\tsshbuf_free(fuzzed);\n\tfuzz_cleanup(fuzz);\n\tTEST_DONE();\n#endif\n\n\tTEST_START(\"fuzz Ed25519 private\");\n\tbuf = load_file(\"ed25519_1\");\n\tfuzz = fuzz_begin(FUZZ_BASE64, sshbuf_mutable_ptr(buf),\n\t    sshbuf_len(buf));\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshkey_free(k1);\n\tsshbuf_free(buf);\n\tASSERT_PTR_NE(fuzzed = sshbuf_new(), NULL);\n\tTEST_ONERROR(onerror, fuzz);\n\tfor(; !fuzz_done(fuzz); fuzz_next(fuzz)) {\n\t\tr = sshbuf_put(fuzzed, fuzz_ptr(fuzz), fuzz_len(fuzz));\n\t\tASSERT_INT_EQ(r, 0);\n\t\tif (sshkey_parse_private_fileblob(fuzzed, \"\", &k1, NULL) == 0)\n\t\t\tsshkey_free(k1);\n\t\tsshbuf_reset(fuzzed);\n\t}\n\tsshbuf_free(fuzzed);\n\tfuzz_cleanup(fuzz);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz RSA public\");\n\tbuf = load_file(\"rsa_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tpublic_fuzz(k1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz RSA cert\");\n\tASSERT_INT_EQ(sshkey_load_cert(test_data_file(\"rsa_1\"), &k1), 0);\n\tpublic_fuzz(k1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz DSA public\");\n\tbuf = load_file(\"dsa_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tpublic_fuzz(k1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz DSA cert\");\n\tASSERT_INT_EQ(sshkey_load_cert(test_data_file(\"dsa_1\"), &k1), 0);\n\tpublic_fuzz(k1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n#ifdef OPENSSL_HAS_ECC\n\tTEST_START(\"fuzz ECDSA public\");\n\tbuf = load_file(\"ecdsa_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tpublic_fuzz(k1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz ECDSA cert\");\n\tASSERT_INT_EQ(sshkey_load_cert(test_data_file(\"ecdsa_1\"), &k1), 0);\n\tpublic_fuzz(k1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n#endif\n\n\tTEST_START(\"fuzz Ed25519 public\");\n\tbuf = load_file(\"ed25519_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tpublic_fuzz(k1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz Ed25519 cert\");\n\tASSERT_INT_EQ(sshkey_load_cert(test_data_file(\"ed25519_1\"), &k1), 0);\n\tpublic_fuzz(k1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz RSA sig\");\n\tbuf = load_file(\"rsa_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tsig_fuzz(k1, \"ssh-rsa\");\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz RSA SHA256 sig\");\n\tbuf = load_file(\"rsa_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tsig_fuzz(k1, \"rsa-sha2-256\");\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz RSA SHA512 sig\");\n\tbuf = load_file(\"rsa_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tsig_fuzz(k1, \"rsa-sha2-512\");\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"fuzz DSA sig\");\n\tbuf = load_file(\"dsa_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tsig_fuzz(k1, NULL);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n#ifdef OPENSSL_HAS_ECC\n\tTEST_START(\"fuzz ECDSA sig\");\n\tbuf = load_file(\"ecdsa_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tsig_fuzz(k1, NULL);\n\tsshkey_free(k1);\n\tTEST_DONE();\n#endif\n\n\tTEST_START(\"fuzz Ed25519 sig\");\n\tbuf = load_file(\"ed25519_1\");\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(buf, \"\", &k1, NULL), 0);\n\tsshbuf_free(buf);\n\tsig_fuzz(k1, NULL);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n/* XXX fuzz decoded new-format blobs too */\n\n}"
  },
  {
    "function_name": "sig_fuzz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/test_fuzz.c",
    "lines": "74-97",
    "snippet": "static void\nsig_fuzz(struct sshkey *k, const char *sig_alg)\n{\n\tstruct fuzz *fuzz;\n\tu_char *sig, c[] = \"some junk to be signed\";\n\tsize_t l;\n\n\tASSERT_INT_EQ(sshkey_sign(k, &sig, &l, c, sizeof(c), sig_alg, 0), 0);\n\tASSERT_SIZE_T_GT(l, 0);\n\tfuzz = fuzz_begin(FUZZ_1_BIT_FLIP | /* too slow FUZZ_2_BIT_FLIP | */\n\t    FUZZ_1_BYTE_FLIP | FUZZ_2_BYTE_FLIP |\n\t    FUZZ_TRUNCATE_START | FUZZ_TRUNCATE_END, sig, l);\n\tASSERT_INT_EQ(sshkey_verify(k, sig, l, c, sizeof(c), NULL, 0), 0);\n\tfree(sig);\n\tTEST_ONERROR(onerror, fuzz);\n\tfor(; !fuzz_done(fuzz); fuzz_next(fuzz)) {\n\t\t/* Ensure 1-bit difference at least */\n\t\tif (fuzz_matches_original(fuzz))\n\t\t\tcontinue;\n\t\tASSERT_INT_NE(sshkey_verify(k, fuzz_ptr(fuzz), fuzz_len(fuzz),\n\t\t    c, sizeof(c), NULL, 0), 0);\n\t}\n\tfuzz_cleanup(fuzz);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"../test_helper/test_helper.h\"",
      "# include <openssl/ec.h>",
      "#include <openssl/objects.h>",
      "#include <openssl/dsa.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/bn.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuzz_cleanup",
          "args": [
            "fuzz"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "243-258",
          "snippet": "void\nfuzz_cleanup(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"cleanup, fuzz = %p\", fuzz));\n\tlast_fuzz = NULL;\n#ifdef SIGINFO\n\tsignal(SIGINFO, SIG_DFL);\n#endif\n\tsignal(SIGUSR1, SIG_DFL);\n\tassert(fuzz != NULL);\n\tassert(fuzz->seed != NULL);\n\tassert(fuzz->fuzzed != NULL);\n\tfree(fuzz->seed);\n\tfree(fuzz->fuzzed);\n\tfree(fuzz);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fuzz *last_fuzz;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct fuzz *last_fuzz;\n\nvoid\nfuzz_cleanup(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"cleanup, fuzz = %p\", fuzz));\n\tlast_fuzz = NULL;\n#ifdef SIGINFO\n\tsignal(SIGINFO, SIG_DFL);\n#endif\n\tsignal(SIGUSR1, SIG_DFL);\n\tassert(fuzz != NULL);\n\tassert(fuzz->seed != NULL);\n\tassert(fuzz->fuzzed != NULL);\n\tfree(fuzz->seed);\n\tfree(fuzz->fuzzed);\n\tfree(fuzz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_NE",
          "args": [
            "sshkey_verify(k, fuzz_ptr(fuzz), fuzz_len(fuzz),\n\t\t    c, sizeof(c), NULL, 0)",
            "0"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_verify",
          "args": [
            "k",
            "fuzz_ptr(fuzz)",
            "fuzz_len(fuzz)",
            "c",
            "sizeof(c)",
            "NULL",
            "0"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2427-2459",
          "snippet": "int\nsshkey_verify(const struct sshkey *key,\n    const u_char *sig, size_t siglen,\n    const u_char *data, size_t dlen, const char *alg, u_int compat)\n{\n\tif (siglen == 0 || dlen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_verify(key, sig, siglen, data, dlen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_verify(key, sig, siglen, data, dlen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_verify(key, sig, siglen, data, dlen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_verify(key, sig, siglen, data, dlen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_verify(key, sig, siglen, data, dlen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_verify(const struct sshkey *key,\n    const u_char *sig, size_t siglen,\n    const u_char *data, size_t dlen, const char *alg, u_int compat)\n{\n\tif (siglen == 0 || dlen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_verify(key, sig, siglen, data, dlen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_verify(key, sig, siglen, data, dlen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_verify(key, sig, siglen, data, dlen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_verify(key, sig, siglen, data, dlen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_verify(key, sig, siglen, data, dlen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuzz_len",
          "args": [
            "fuzz"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "397-415",
          "snippet": "size_t\nfuzz_len(struct fuzz *fuzz)\n{\n\tassert(fuzz->fuzzed != NULL);\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\tcase FUZZ_2_BIT_FLIP:\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_2_BYTE_FLIP:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->slen;\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->slen - fuzz->o1;\n\tdefault:\n\t\tabort();\n\t}\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nfuzz_len(struct fuzz *fuzz)\n{\n\tassert(fuzz->fuzzed != NULL);\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\tcase FUZZ_2_BIT_FLIP:\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_2_BYTE_FLIP:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->slen;\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->slen - fuzz->o1;\n\tdefault:\n\t\tabort();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuzz_ptr",
          "args": [
            "fuzz"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "417-437",
          "snippet": "u_char *\nfuzz_ptr(struct fuzz *fuzz)\n{\n\tassert(fuzz->fuzzed != NULL);\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\tcase FUZZ_2_BIT_FLIP:\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_2_BYTE_FLIP:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->fuzzed;\n\tcase FUZZ_TRUNCATE_START:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->fuzzed + fuzz->o1;\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->fuzzed;\n\tdefault:\n\t\tabort();\n\t}\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_char *\nfuzz_ptr(struct fuzz *fuzz)\n{\n\tassert(fuzz->fuzzed != NULL);\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\tcase FUZZ_2_BIT_FLIP:\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_2_BYTE_FLIP:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->fuzzed;\n\tcase FUZZ_TRUNCATE_START:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->fuzzed + fuzz->o1;\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->fuzzed;\n\tdefault:\n\t\tabort();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuzz_matches_original",
          "args": [
            "fuzz"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_matches_original",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "380-386",
          "snippet": "int\nfuzz_matches_original(struct fuzz *fuzz)\n{\n\tif (fuzz_len(fuzz) != fuzz->slen)\n\t\treturn 0;\n\treturn memcmp(fuzz_ptr(fuzz), fuzz->seed, fuzz->slen) == 0;\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nfuzz_matches_original(struct fuzz *fuzz)\n{\n\tif (fuzz_len(fuzz) != fuzz->slen)\n\t\treturn 0;\n\treturn memcmp(fuzz_ptr(fuzz), fuzz->seed, fuzz->slen) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuzz_next",
          "args": [
            "fuzz"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "283-378",
          "snippet": "void\nfuzz_next(struct fuzz *fuzz)\n{\n\tu_int i;\n\n\tFUZZ_DBG((\"start, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen));\n\n\tif (fuzz->strategy == 0 || fuzz_strategy_done(fuzz)) {\n\t\t/* If we are just starting out, we need to allocate too */\n\t\tif (fuzz->fuzzed == NULL) {\n\t\t\tFUZZ_DBG((\"alloc\"));\n\t\t\tfuzz->fuzzed = calloc(fuzz->slen, 1);\n\t\t}\n\t\t/* Pick next strategy */\n\t\tFUZZ_DBG((\"advance\"));\n\t\tfor (i = 1; i <= FUZZ_MAX; i <<= 1) {\n\t\t\tif ((fuzz->strategies & i) != 0) {\n\t\t\t\tfuzz->strategy = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tFUZZ_DBG((\"selected = %u\", fuzz->strategy));\n\t\tif (fuzz->strategy == 0) {\n\t\t\tFUZZ_DBG((\"done, no more strategies\"));\n\t\t\treturn;\n\t\t}\n\t\tfuzz->strategies &= ~(fuzz->strategy);\n\t\tfuzz->o1 = fuzz->o2 = 0;\n\t}\n\n\tassert(fuzz->fuzzed != NULL);\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\tassert(fuzz->o1 / 8 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1 / 8] ^= 1 << (fuzz->o1 % 8);\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_2_BIT_FLIP:\n\t\tassert(fuzz->o1 / 8 < fuzz->slen);\n\t\tassert(fuzz->o2 / 8 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1 / 8] ^= 1 << (fuzz->o1 % 8);\n\t\tfuzz->fuzzed[fuzz->o2 / 8] ^= 1 << (fuzz->o2 % 8);\n\t\tfuzz->o1++;\n\t\tif (fuzz->o1 >= fuzz->slen * 8) {\n\t\t\tfuzz->o1 = 0;\n\t\t\tfuzz->o2++;\n\t\t}\n\t\tbreak;\n\tcase FUZZ_1_BYTE_FLIP:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] ^= 0xff;\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tassert(fuzz->o2 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] ^= 0xff;\n\t\tfuzz->fuzzed[fuzz->o2] ^= 0xff;\n\t\tfuzz->o1++;\n\t\tif (fuzz->o1 >= fuzz->slen) {\n\t\t\tfuzz->o1 = 0;\n\t\t\tfuzz->o2++;\n\t\t}\n\t\tbreak;\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_BASE64:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tassert(fuzz->o2 < sizeof(fuzz_b64chars) - 1);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] = fuzz_b64chars[fuzz->o2];\n\t\tfuzz->o2++;\n\t\tif (fuzz->o2 >= sizeof(fuzz_b64chars) - 1) {\n\t\t\tfuzz->o2 = 0;\n\t\t\tfuzz->o1++;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t}\n\n\tFUZZ_DBG((\"done, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen));\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char fuzz_b64chars[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char fuzz_b64chars[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nvoid\nfuzz_next(struct fuzz *fuzz)\n{\n\tu_int i;\n\n\tFUZZ_DBG((\"start, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen));\n\n\tif (fuzz->strategy == 0 || fuzz_strategy_done(fuzz)) {\n\t\t/* If we are just starting out, we need to allocate too */\n\t\tif (fuzz->fuzzed == NULL) {\n\t\t\tFUZZ_DBG((\"alloc\"));\n\t\t\tfuzz->fuzzed = calloc(fuzz->slen, 1);\n\t\t}\n\t\t/* Pick next strategy */\n\t\tFUZZ_DBG((\"advance\"));\n\t\tfor (i = 1; i <= FUZZ_MAX; i <<= 1) {\n\t\t\tif ((fuzz->strategies & i) != 0) {\n\t\t\t\tfuzz->strategy = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tFUZZ_DBG((\"selected = %u\", fuzz->strategy));\n\t\tif (fuzz->strategy == 0) {\n\t\t\tFUZZ_DBG((\"done, no more strategies\"));\n\t\t\treturn;\n\t\t}\n\t\tfuzz->strategies &= ~(fuzz->strategy);\n\t\tfuzz->o1 = fuzz->o2 = 0;\n\t}\n\n\tassert(fuzz->fuzzed != NULL);\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\tassert(fuzz->o1 / 8 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1 / 8] ^= 1 << (fuzz->o1 % 8);\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_2_BIT_FLIP:\n\t\tassert(fuzz->o1 / 8 < fuzz->slen);\n\t\tassert(fuzz->o2 / 8 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1 / 8] ^= 1 << (fuzz->o1 % 8);\n\t\tfuzz->fuzzed[fuzz->o2 / 8] ^= 1 << (fuzz->o2 % 8);\n\t\tfuzz->o1++;\n\t\tif (fuzz->o1 >= fuzz->slen * 8) {\n\t\t\tfuzz->o1 = 0;\n\t\t\tfuzz->o2++;\n\t\t}\n\t\tbreak;\n\tcase FUZZ_1_BYTE_FLIP:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] ^= 0xff;\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tassert(fuzz->o2 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] ^= 0xff;\n\t\tfuzz->fuzzed[fuzz->o2] ^= 0xff;\n\t\tfuzz->o1++;\n\t\tif (fuzz->o1 >= fuzz->slen) {\n\t\t\tfuzz->o1 = 0;\n\t\t\tfuzz->o2++;\n\t\t}\n\t\tbreak;\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_BASE64:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tassert(fuzz->o2 < sizeof(fuzz_b64chars) - 1);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] = fuzz_b64chars[fuzz->o2];\n\t\tfuzz->o2++;\n\t\tif (fuzz->o2 >= sizeof(fuzz_b64chars) - 1) {\n\t\t\tfuzz->o2 = 0;\n\t\t\tfuzz->o1++;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t}\n\n\tFUZZ_DBG((\"done, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuzz_done",
          "args": [
            "fuzz"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "388-395",
          "snippet": "int\nfuzz_done(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"fuzz = %p, strategies = 0x%lx\", fuzz,\n\t    (u_long)fuzz->strategies));\n\n\treturn fuzz_strategy_done(fuzz) && fuzz->strategies == 0;\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nfuzz_done(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"fuzz = %p, strategies = 0x%lx\", fuzz,\n\t    (u_long)fuzz->strategies));\n\n\treturn fuzz_strategy_done(fuzz) && fuzz->strategies == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_ONERROR",
          "args": [
            "onerror",
            "fuzz"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sig"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_verify(k, sig, l, c, sizeof(c), NULL, 0)",
            "0"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuzz_begin",
          "args": [
            "FUZZ_1_BIT_FLIP | /* too slow FUZZ_2_BIT_FLIP | */\n\t    FUZZ_1_BYTE_FLIP | FUZZ_2_BYTE_FLIP |\n\t    FUZZ_TRUNCATE_START | FUZZ_TRUNCATE_END",
            "sig",
            "l"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "214-241",
          "snippet": "struct fuzz *\nfuzz_begin(u_int strategies, const void *p, size_t l)\n{\n\tstruct fuzz *ret = calloc(sizeof(*ret), 1);\n\n\tassert(p != NULL);\n\tassert(ret != NULL);\n\tret->seed = malloc(l);\n\tassert(ret->seed != NULL);\n\tmemcpy(ret->seed, p, l);\n\tret->slen = l;\n\tret->strategies = strategies;\n\n\tassert(ret->slen < SIZE_MAX / 8);\n\tassert(ret->strategies <= (FUZZ_MAX|(FUZZ_MAX-1)));\n\n\tFUZZ_DBG((\"begin, ret = %p\", ret));\n\n\tfuzz_next(ret);\n\n\tlast_fuzz = ret;\n#ifdef SIGINFO\n\tsignal(SIGINFO, siginfo);\n#endif\n\tsignal(SIGUSR1, siginfo);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fuzz *last_fuzz;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct fuzz *last_fuzz;\n\nstruct fuzz *\nfuzz_begin(u_int strategies, const void *p, size_t l)\n{\n\tstruct fuzz *ret = calloc(sizeof(*ret), 1);\n\n\tassert(p != NULL);\n\tassert(ret != NULL);\n\tret->seed = malloc(l);\n\tassert(ret->seed != NULL);\n\tmemcpy(ret->seed, p, l);\n\tret->slen = l;\n\tret->strategies = strategies;\n\n\tassert(ret->slen < SIZE_MAX / 8);\n\tassert(ret->strategies <= (FUZZ_MAX|(FUZZ_MAX-1)));\n\n\tFUZZ_DBG((\"begin, ret = %p\", ret));\n\n\tfuzz_next(ret);\n\n\tlast_fuzz = ret;\n#ifdef SIGINFO\n\tsignal(SIGINFO, siginfo);\n#endif\n\tsignal(SIGUSR1, siginfo);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_SIZE_T_GT",
          "args": [
            "l",
            "0"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_sign(k, &sig, &l, c, sizeof(c), sig_alg, 0)",
            "0"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_sign",
          "args": [
            "k",
            "&sig",
            "&l",
            "c",
            "sizeof(c)",
            "sig_alg",
            "0"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2385-2421",
          "snippet": "int\nsshkey_sign(const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_sign(key, sigp, lenp, data, datalen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_sign(key, sigp, lenp, data, datalen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_sign(key, sigp, lenp, data, datalen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_sign(key, sigp, lenp, data, datalen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_sign(key, sigp, lenp, data, datalen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_sign(const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_sign(key, sigp, lenp, data, datalen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_sign(key, sigp, lenp, data, datalen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_sign(key, sigp, lenp, data, datalen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_sign(key, sigp, lenp, data, datalen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_sign(key, sigp, lenp, data, datalen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsig_fuzz(struct sshkey *k, const char *sig_alg)\n{\n\tstruct fuzz *fuzz;\n\tu_char *sig, c[] = \"some junk to be signed\";\n\tsize_t l;\n\n\tASSERT_INT_EQ(sshkey_sign(k, &sig, &l, c, sizeof(c), sig_alg, 0), 0);\n\tASSERT_SIZE_T_GT(l, 0);\n\tfuzz = fuzz_begin(FUZZ_1_BIT_FLIP | /* too slow FUZZ_2_BIT_FLIP | */\n\t    FUZZ_1_BYTE_FLIP | FUZZ_2_BYTE_FLIP |\n\t    FUZZ_TRUNCATE_START | FUZZ_TRUNCATE_END, sig, l);\n\tASSERT_INT_EQ(sshkey_verify(k, sig, l, c, sizeof(c), NULL, 0), 0);\n\tfree(sig);\n\tTEST_ONERROR(onerror, fuzz);\n\tfor(; !fuzz_done(fuzz); fuzz_next(fuzz)) {\n\t\t/* Ensure 1-bit difference at least */\n\t\tif (fuzz_matches_original(fuzz))\n\t\t\tcontinue;\n\t\tASSERT_INT_NE(sshkey_verify(k, fuzz_ptr(fuzz), fuzz_len(fuzz),\n\t\t    c, sizeof(c), NULL, 0), 0);\n\t}\n\tfuzz_cleanup(fuzz);\n}"
  },
  {
    "function_name": "public_fuzz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/test_fuzz.c",
    "lines": "48-72",
    "snippet": "static void\npublic_fuzz(struct sshkey *k)\n{\n\tstruct sshkey *k1;\n\tstruct sshbuf *buf;\n\tstruct fuzz *fuzz;\n\n\tASSERT_PTR_NE(buf = sshbuf_new(), NULL);\n\tASSERT_INT_EQ(sshkey_putb(k, buf), 0);\n\t/* XXX need a way to run the tests in \"slow, but complete\" mode */\n\tfuzz = fuzz_begin(FUZZ_1_BIT_FLIP | /* XXX too slow FUZZ_2_BIT_FLIP | */\n\t    FUZZ_1_BYTE_FLIP | /* XXX too slow FUZZ_2_BYTE_FLIP | */\n\t    FUZZ_TRUNCATE_START | FUZZ_TRUNCATE_END,\n\t    sshbuf_mutable_ptr(buf), sshbuf_len(buf));\n\tASSERT_INT_EQ(sshkey_from_blob(sshbuf_ptr(buf), sshbuf_len(buf),\n\t    &k1), 0);\n\tsshkey_free(k1);\n\tsshbuf_free(buf);\n\tTEST_ONERROR(onerror, fuzz);\n\tfor(; !fuzz_done(fuzz); fuzz_next(fuzz)) {\n\t\tif (sshkey_from_blob(fuzz_ptr(fuzz), fuzz_len(fuzz), &k1) == 0)\n\t\t\tsshkey_free(k1);\n\t}\n\tfuzz_cleanup(fuzz);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"../test_helper/test_helper.h\"",
      "# include <openssl/ec.h>",
      "#include <openssl/objects.h>",
      "#include <openssl/dsa.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/bn.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuzz_cleanup",
          "args": [
            "fuzz"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "243-258",
          "snippet": "void\nfuzz_cleanup(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"cleanup, fuzz = %p\", fuzz));\n\tlast_fuzz = NULL;\n#ifdef SIGINFO\n\tsignal(SIGINFO, SIG_DFL);\n#endif\n\tsignal(SIGUSR1, SIG_DFL);\n\tassert(fuzz != NULL);\n\tassert(fuzz->seed != NULL);\n\tassert(fuzz->fuzzed != NULL);\n\tfree(fuzz->seed);\n\tfree(fuzz->fuzzed);\n\tfree(fuzz);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fuzz *last_fuzz;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct fuzz *last_fuzz;\n\nvoid\nfuzz_cleanup(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"cleanup, fuzz = %p\", fuzz));\n\tlast_fuzz = NULL;\n#ifdef SIGINFO\n\tsignal(SIGINFO, SIG_DFL);\n#endif\n\tsignal(SIGUSR1, SIG_DFL);\n\tassert(fuzz != NULL);\n\tassert(fuzz->seed != NULL);\n\tassert(fuzz->fuzzed != NULL);\n\tfree(fuzz->seed);\n\tfree(fuzz->fuzzed);\n\tfree(fuzz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "k1"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_from_blob",
          "args": [
            "fuzz_ptr(fuzz)",
            "fuzz_len(fuzz)",
            "&k1"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2263-2274",
          "snippet": "int\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuzz_len",
          "args": [
            "fuzz"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "397-415",
          "snippet": "size_t\nfuzz_len(struct fuzz *fuzz)\n{\n\tassert(fuzz->fuzzed != NULL);\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\tcase FUZZ_2_BIT_FLIP:\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_2_BYTE_FLIP:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->slen;\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->slen - fuzz->o1;\n\tdefault:\n\t\tabort();\n\t}\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nfuzz_len(struct fuzz *fuzz)\n{\n\tassert(fuzz->fuzzed != NULL);\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\tcase FUZZ_2_BIT_FLIP:\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_2_BYTE_FLIP:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->slen;\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->slen - fuzz->o1;\n\tdefault:\n\t\tabort();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuzz_ptr",
          "args": [
            "fuzz"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "417-437",
          "snippet": "u_char *\nfuzz_ptr(struct fuzz *fuzz)\n{\n\tassert(fuzz->fuzzed != NULL);\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\tcase FUZZ_2_BIT_FLIP:\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_2_BYTE_FLIP:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->fuzzed;\n\tcase FUZZ_TRUNCATE_START:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->fuzzed + fuzz->o1;\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->fuzzed;\n\tdefault:\n\t\tabort();\n\t}\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_char *\nfuzz_ptr(struct fuzz *fuzz)\n{\n\tassert(fuzz->fuzzed != NULL);\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\tcase FUZZ_2_BIT_FLIP:\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_2_BYTE_FLIP:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->fuzzed;\n\tcase FUZZ_TRUNCATE_START:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->fuzzed + fuzz->o1;\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->fuzzed;\n\tdefault:\n\t\tabort();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuzz_next",
          "args": [
            "fuzz"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "283-378",
          "snippet": "void\nfuzz_next(struct fuzz *fuzz)\n{\n\tu_int i;\n\n\tFUZZ_DBG((\"start, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen));\n\n\tif (fuzz->strategy == 0 || fuzz_strategy_done(fuzz)) {\n\t\t/* If we are just starting out, we need to allocate too */\n\t\tif (fuzz->fuzzed == NULL) {\n\t\t\tFUZZ_DBG((\"alloc\"));\n\t\t\tfuzz->fuzzed = calloc(fuzz->slen, 1);\n\t\t}\n\t\t/* Pick next strategy */\n\t\tFUZZ_DBG((\"advance\"));\n\t\tfor (i = 1; i <= FUZZ_MAX; i <<= 1) {\n\t\t\tif ((fuzz->strategies & i) != 0) {\n\t\t\t\tfuzz->strategy = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tFUZZ_DBG((\"selected = %u\", fuzz->strategy));\n\t\tif (fuzz->strategy == 0) {\n\t\t\tFUZZ_DBG((\"done, no more strategies\"));\n\t\t\treturn;\n\t\t}\n\t\tfuzz->strategies &= ~(fuzz->strategy);\n\t\tfuzz->o1 = fuzz->o2 = 0;\n\t}\n\n\tassert(fuzz->fuzzed != NULL);\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\tassert(fuzz->o1 / 8 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1 / 8] ^= 1 << (fuzz->o1 % 8);\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_2_BIT_FLIP:\n\t\tassert(fuzz->o1 / 8 < fuzz->slen);\n\t\tassert(fuzz->o2 / 8 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1 / 8] ^= 1 << (fuzz->o1 % 8);\n\t\tfuzz->fuzzed[fuzz->o2 / 8] ^= 1 << (fuzz->o2 % 8);\n\t\tfuzz->o1++;\n\t\tif (fuzz->o1 >= fuzz->slen * 8) {\n\t\t\tfuzz->o1 = 0;\n\t\t\tfuzz->o2++;\n\t\t}\n\t\tbreak;\n\tcase FUZZ_1_BYTE_FLIP:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] ^= 0xff;\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tassert(fuzz->o2 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] ^= 0xff;\n\t\tfuzz->fuzzed[fuzz->o2] ^= 0xff;\n\t\tfuzz->o1++;\n\t\tif (fuzz->o1 >= fuzz->slen) {\n\t\t\tfuzz->o1 = 0;\n\t\t\tfuzz->o2++;\n\t\t}\n\t\tbreak;\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_BASE64:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tassert(fuzz->o2 < sizeof(fuzz_b64chars) - 1);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] = fuzz_b64chars[fuzz->o2];\n\t\tfuzz->o2++;\n\t\tif (fuzz->o2 >= sizeof(fuzz_b64chars) - 1) {\n\t\t\tfuzz->o2 = 0;\n\t\t\tfuzz->o1++;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t}\n\n\tFUZZ_DBG((\"done, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen));\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char fuzz_b64chars[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char fuzz_b64chars[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nvoid\nfuzz_next(struct fuzz *fuzz)\n{\n\tu_int i;\n\n\tFUZZ_DBG((\"start, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen));\n\n\tif (fuzz->strategy == 0 || fuzz_strategy_done(fuzz)) {\n\t\t/* If we are just starting out, we need to allocate too */\n\t\tif (fuzz->fuzzed == NULL) {\n\t\t\tFUZZ_DBG((\"alloc\"));\n\t\t\tfuzz->fuzzed = calloc(fuzz->slen, 1);\n\t\t}\n\t\t/* Pick next strategy */\n\t\tFUZZ_DBG((\"advance\"));\n\t\tfor (i = 1; i <= FUZZ_MAX; i <<= 1) {\n\t\t\tif ((fuzz->strategies & i) != 0) {\n\t\t\t\tfuzz->strategy = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tFUZZ_DBG((\"selected = %u\", fuzz->strategy));\n\t\tif (fuzz->strategy == 0) {\n\t\t\tFUZZ_DBG((\"done, no more strategies\"));\n\t\t\treturn;\n\t\t}\n\t\tfuzz->strategies &= ~(fuzz->strategy);\n\t\tfuzz->o1 = fuzz->o2 = 0;\n\t}\n\n\tassert(fuzz->fuzzed != NULL);\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\tassert(fuzz->o1 / 8 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1 / 8] ^= 1 << (fuzz->o1 % 8);\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_2_BIT_FLIP:\n\t\tassert(fuzz->o1 / 8 < fuzz->slen);\n\t\tassert(fuzz->o2 / 8 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1 / 8] ^= 1 << (fuzz->o1 % 8);\n\t\tfuzz->fuzzed[fuzz->o2 / 8] ^= 1 << (fuzz->o2 % 8);\n\t\tfuzz->o1++;\n\t\tif (fuzz->o1 >= fuzz->slen * 8) {\n\t\t\tfuzz->o1 = 0;\n\t\t\tfuzz->o2++;\n\t\t}\n\t\tbreak;\n\tcase FUZZ_1_BYTE_FLIP:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] ^= 0xff;\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tassert(fuzz->o2 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] ^= 0xff;\n\t\tfuzz->fuzzed[fuzz->o2] ^= 0xff;\n\t\tfuzz->o1++;\n\t\tif (fuzz->o1 >= fuzz->slen) {\n\t\t\tfuzz->o1 = 0;\n\t\t\tfuzz->o2++;\n\t\t}\n\t\tbreak;\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_BASE64:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tassert(fuzz->o2 < sizeof(fuzz_b64chars) - 1);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] = fuzz_b64chars[fuzz->o2];\n\t\tfuzz->o2++;\n\t\tif (fuzz->o2 >= sizeof(fuzz_b64chars) - 1) {\n\t\t\tfuzz->o2 = 0;\n\t\t\tfuzz->o1++;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t}\n\n\tFUZZ_DBG((\"done, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuzz_done",
          "args": [
            "fuzz"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "388-395",
          "snippet": "int\nfuzz_done(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"fuzz = %p, strategies = 0x%lx\", fuzz,\n\t    (u_long)fuzz->strategies));\n\n\treturn fuzz_strategy_done(fuzz) && fuzz->strategies == 0;\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nfuzz_done(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"fuzz = %p, strategies = 0x%lx\", fuzz,\n\t    (u_long)fuzz->strategies));\n\n\treturn fuzz_strategy_done(fuzz) && fuzz->strategies == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_ONERROR",
          "args": [
            "onerror",
            "fuzz"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "buf"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_from_blob(sshbuf_ptr(buf), sshbuf_len(buf),\n\t    &k1)",
            "0"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "buf"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "buf"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuzz_begin",
          "args": [
            "FUZZ_1_BIT_FLIP | /* XXX too slow FUZZ_2_BIT_FLIP | */\n\t    FUZZ_1_BYTE_FLIP | /* XXX too slow FUZZ_2_BYTE_FLIP | */\n\t    FUZZ_TRUNCATE_START | FUZZ_TRUNCATE_END",
            "sshbuf_mutable_ptr(buf)",
            "sshbuf_len(buf)"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "214-241",
          "snippet": "struct fuzz *\nfuzz_begin(u_int strategies, const void *p, size_t l)\n{\n\tstruct fuzz *ret = calloc(sizeof(*ret), 1);\n\n\tassert(p != NULL);\n\tassert(ret != NULL);\n\tret->seed = malloc(l);\n\tassert(ret->seed != NULL);\n\tmemcpy(ret->seed, p, l);\n\tret->slen = l;\n\tret->strategies = strategies;\n\n\tassert(ret->slen < SIZE_MAX / 8);\n\tassert(ret->strategies <= (FUZZ_MAX|(FUZZ_MAX-1)));\n\n\tFUZZ_DBG((\"begin, ret = %p\", ret));\n\n\tfuzz_next(ret);\n\n\tlast_fuzz = ret;\n#ifdef SIGINFO\n\tsignal(SIGINFO, siginfo);\n#endif\n\tsignal(SIGUSR1, siginfo);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fuzz *last_fuzz;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct fuzz *last_fuzz;\n\nstruct fuzz *\nfuzz_begin(u_int strategies, const void *p, size_t l)\n{\n\tstruct fuzz *ret = calloc(sizeof(*ret), 1);\n\n\tassert(p != NULL);\n\tassert(ret != NULL);\n\tret->seed = malloc(l);\n\tassert(ret->seed != NULL);\n\tmemcpy(ret->seed, p, l);\n\tret->slen = l;\n\tret->strategies = strategies;\n\n\tassert(ret->slen < SIZE_MAX / 8);\n\tassert(ret->strategies <= (FUZZ_MAX|(FUZZ_MAX-1)));\n\n\tFUZZ_DBG((\"begin, ret = %p\", ret));\n\n\tfuzz_next(ret);\n\n\tlast_fuzz = ret;\n#ifdef SIGINFO\n\tsignal(SIGINFO, siginfo);\n#endif\n\tsignal(SIGUSR1, siginfo);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_mutable_ptr",
          "args": [
            "buf"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_mutable_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "276-282",
          "snippet": "u_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_putb(k, buf)",
            "0"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_putb",
          "args": [
            "k",
            "buf"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_putb_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "842-846",
          "snippet": "int\nsshkey_putb_plain(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn to_blob_buf(key, b, 1, SSHKEY_SERIALIZE_DEFAULT);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_putb_plain(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn to_blob_buf(key, b, 1, SSHKEY_SERIALIZE_DEFAULT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "buf = sshbuf_new()",
            "NULL"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\npublic_fuzz(struct sshkey *k)\n{\n\tstruct sshkey *k1;\n\tstruct sshbuf *buf;\n\tstruct fuzz *fuzz;\n\n\tASSERT_PTR_NE(buf = sshbuf_new(), NULL);\n\tASSERT_INT_EQ(sshkey_putb(k, buf), 0);\n\t/* XXX need a way to run the tests in \"slow, but complete\" mode */\n\tfuzz = fuzz_begin(FUZZ_1_BIT_FLIP | /* XXX too slow FUZZ_2_BIT_FLIP | */\n\t    FUZZ_1_BYTE_FLIP | /* XXX too slow FUZZ_2_BYTE_FLIP | */\n\t    FUZZ_TRUNCATE_START | FUZZ_TRUNCATE_END,\n\t    sshbuf_mutable_ptr(buf), sshbuf_len(buf));\n\tASSERT_INT_EQ(sshkey_from_blob(sshbuf_ptr(buf), sshbuf_len(buf),\n\t    &k1), 0);\n\tsshkey_free(k1);\n\tsshbuf_free(buf);\n\tTEST_ONERROR(onerror, fuzz);\n\tfor(; !fuzz_done(fuzz); fuzz_next(fuzz)) {\n\t\tif (sshkey_from_blob(fuzz_ptr(fuzz), fuzz_len(fuzz), &k1) == 0)\n\t\t\tsshkey_free(k1);\n\t}\n\tfuzz_cleanup(fuzz);\n}"
  },
  {
    "function_name": "onerror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/test_fuzz.c",
    "lines": "41-46",
    "snippet": "static void\nonerror(void *fuzz)\n{\n\tfprintf(stderr, \"Failed during fuzz:\\n\");\n\tfuzz_dump((struct fuzz *)fuzz);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"sshbuf.h\"",
      "#include \"sshkey.h\"",
      "#include \"authfile.h\"",
      "#include \"ssherr.h\"",
      "#include \"../test_helper/test_helper.h\"",
      "# include <openssl/ec.h>",
      "#include <openssl/objects.h>",
      "#include <openssl/dsa.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/bn.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuzz_dump",
          "args": [
            "(struct fuzz *)fuzz"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "fuzz_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/fuzz.c",
          "lines": "183-197",
          "snippet": "void\nfuzz_dump(struct fuzz *fuzz)\n{\n\tchar buf[256];\n\n\tif (fuzz_fmt(fuzz, buf, sizeof(buf)) != 0) {\n\t\tfprintf(stderr, \"%s: fuzz invalid\\n\", __func__);\n\t\tabort();\n\t}\n\tfputs(buf, stderr);\n\tfprintf(stderr, \"fuzz original %p len = %zu\\n\", fuzz->seed, fuzz->slen);\n\tdump(fuzz->seed, fuzz->slen);\n\tfprintf(stderr, \"fuzz context %p len = %zu\\n\", fuzz, fuzz_len(fuzz));\n\tdump(fuzz_ptr(fuzz), fuzz_len(fuzz));\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfuzz_dump(struct fuzz *fuzz)\n{\n\tchar buf[256];\n\n\tif (fuzz_fmt(fuzz, buf, sizeof(buf)) != 0) {\n\t\tfprintf(stderr, \"%s: fuzz invalid\\n\", __func__);\n\t\tabort();\n\t}\n\tfputs(buf, stderr);\n\tfprintf(stderr, \"fuzz original %p len = %zu\\n\", fuzz->seed, fuzz->slen);\n\tdump(fuzz->seed, fuzz->slen);\n\tfprintf(stderr, \"fuzz context %p len = %zu\\n\", fuzz, fuzz_len(fuzz));\n\tdump(fuzz_ptr(fuzz), fuzz_len(fuzz));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed during fuzz:\\n\""
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nonerror(void *fuzz)\n{\n\tfprintf(stderr, \"Failed during fuzz:\\n\");\n\tfuzz_dump((struct fuzz *)fuzz);\n}"
  }
]