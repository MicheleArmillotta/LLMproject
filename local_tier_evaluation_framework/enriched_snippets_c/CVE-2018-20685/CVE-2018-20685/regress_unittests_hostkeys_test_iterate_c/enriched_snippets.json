[
  {
    "function_name": "test_iterate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/hostkeys/test_iterate.c",
    "lines": "826-1046",
    "snippet": "void\ntest_iterate(void)\n{\n\tstruct cbctx ctx;\n\n\tTEST_START(\"hostkeys_iterate all with key parse\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = HKF_WANT_PARSE_KEY;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, NULL, NULL, ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate all without key parse\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = 0;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, NULL, NULL, ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate specify host 1\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = 0;\n\tctx.match_host_p = 1;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"prometheus.example.com\", NULL, ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate specify host 2\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = 0;\n\tctx.match_host_s = 1;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"sisyphus.example.com\", NULL, ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate match host 1\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = HKF_WANT_MATCH;\n\tctx.match_host_p = 1;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"prometheus.example.com\", NULL, ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate match host 2\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = HKF_WANT_MATCH;\n\tctx.match_host_s = 1;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"sisyphus.example.com\", NULL, ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate specify host missing\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = 0;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"actaeon.example.org\", NULL, ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate match host missing\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = HKF_WANT_MATCH;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"actaeon.example.org\", NULL, ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate specify IPv4\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = 0;\n\tctx.match_ipv4 = 1;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"tiresias.example.org\", \"192.0.2.1\", ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate specify IPv6\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = 0;\n\tctx.match_ipv6 = 1;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"tiresias.example.org\", \"2001:db8::1\", ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate match IPv4\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = HKF_WANT_MATCH;\n\tctx.match_ipv4 = 1;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"tiresias.example.org\", \"192.0.2.1\", ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate match IPv6\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = HKF_WANT_MATCH;\n\tctx.match_ipv6 = 1;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"tiresias.example.org\", \"2001:db8::1\", ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate specify addr missing\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = 0;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"tiresias.example.org\", \"192.168.0.1\", ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate match addr missing\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = HKF_WANT_MATCH;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"tiresias.example.org\", \"::1\", ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate specify host 2 and IPv4\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = 0;\n\tctx.match_host_s = 1;\n\tctx.match_ipv4 = 1;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"sisyphus.example.com\", \"192.0.2.1\", ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate match host 1 and IPv6\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = HKF_WANT_MATCH;\n\tctx.match_host_p = 1;\n\tctx.match_ipv6 = 1;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"prometheus.example.com\",\n\t    \"2001:db8::1\", ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate specify host 2 and IPv4 w/ key parse\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = HKF_WANT_PARSE_KEY;\n\tctx.match_host_s = 1;\n\tctx.match_ipv4 = 1;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"sisyphus.example.com\", \"192.0.2.1\", ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate match host 1 and IPv6 w/ key parse\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = HKF_WANT_MATCH|HKF_WANT_PARSE_KEY;\n\tctx.match_host_p = 1;\n\tctx.match_ipv6 = 1;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"prometheus.example.com\",\n\t    \"2001:db8::1\", ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"../test_helper/test_helper.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct expected expected_full[] = {\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\t\t\t\t/* path, don't care */\n\t\t1,\t\t\t\t/* line number */\n\t\tHKF_STATUS_COMMENT,\t\t/* status */\n\t\t0,\t\t\t\t/* match flags */\n\t\t\"# Plain host keys, plain host names\", /* full line, optional */\n\t\tMRK_NONE,\t\t\t/* marker (CA / revoked) */\n\t\tNULL,\t\t\t\t/* hosts text */\n\t\tNULL,\t\t\t\t/* raw key, optional */\n\t\tKEY_UNSPEC,\t\t\t/* key type */\n\t\tNULL,\t\t\t\t/* deserialised key */\n\t\tNULL,\t\t\t\t/* comment */\n\t} },\n\t{ \"dsa_1.pub\" , -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {\n\t\tNULL,\n\t\t2,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"sisyphus.example.com\",\n\t\tNULL,\n\t\tKEY_DSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"DSA #1\",\n\t} },\n\t{ \"ecdsa_1.pub\" , -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {\n\t\tNULL,\n\t\t3,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"sisyphus.example.com\",\n\t\tNULL,\n\t\tKEY_ECDSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ECDSA #1\",\n\t} },\n\t{ \"ed25519_1.pub\" , -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {\n\t\tNULL,\n\t\t4,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"sisyphus.example.com\",\n\t\tNULL,\n\t\tKEY_ED25519,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ED25519 #1\",\n\t} },\n\t{ \"rsa_1.pub\" , -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {\n\t\tNULL,\n\t\t5,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"sisyphus.example.com\",\n\t\tNULL,\n\t\tKEY_RSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"RSA #1\",\n\t} },\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t6,\n\t\tHKF_STATUS_COMMENT,\n\t\t0,\n\t\t\"\",\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t7,\n\t\tHKF_STATUS_COMMENT,\n\t\t0,\n\t\t\"# Plain host keys, hostnames + addresses\",\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ \"dsa_2.pub\" , -1, -1, HKF_MATCH_HOST, 0, HKF_MATCH_IP, HKF_MATCH_IP, -1, {\n\t\tNULL,\n\t\t8,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"prometheus.example.com,192.0.2.1,2001:db8::1\",\n\t\tNULL,\n\t\tKEY_DSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"DSA #2\",\n\t} },\n\t{ \"ecdsa_2.pub\" , -1, -1, HKF_MATCH_HOST, 0, HKF_MATCH_IP, HKF_MATCH_IP, -1, {\n\t\tNULL,\n\t\t9,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"prometheus.example.com,192.0.2.1,2001:db8::1\",\n\t\tNULL,\n\t\tKEY_ECDSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ECDSA #2\",\n\t} },\n\t{ \"ed25519_2.pub\" , -1, -1, HKF_MATCH_HOST, 0, HKF_MATCH_IP, HKF_MATCH_IP, -1, {\n\t\tNULL,\n\t\t10,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"prometheus.example.com,192.0.2.1,2001:db8::1\",\n\t\tNULL,\n\t\tKEY_ED25519,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ED25519 #2\",\n\t} },\n\t{ \"rsa_2.pub\" , -1, -1, HKF_MATCH_HOST, 0, HKF_MATCH_IP, HKF_MATCH_IP, -1, {\n\t\tNULL,\n\t\t11,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"prometheus.example.com,192.0.2.1,2001:db8::1\",\n\t\tNULL,\n\t\tKEY_RSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"RSA #2\",\n\t} },\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t12,\n\t\tHKF_STATUS_COMMENT,\n\t\t0,\n\t\t\"\",\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t13,\n\t\tHKF_STATUS_COMMENT,\n\t\t0,\n\t\t\"# Some hosts with wildcard names / IPs\",\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ \"dsa_3.pub\" , -1, -1, HKF_MATCH_HOST, HKF_MATCH_HOST, HKF_MATCH_IP, HKF_MATCH_IP, -1, {\n\t\tNULL,\n\t\t14,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"*.example.com,192.0.2.*,2001:*\",\n\t\tNULL,\n\t\tKEY_DSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"DSA #3\",\n\t} },\n\t{ \"ecdsa_3.pub\" , -1, -1, HKF_MATCH_HOST, HKF_MATCH_HOST, HKF_MATCH_IP, HKF_MATCH_IP, -1, {\n\t\tNULL,\n\t\t15,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"*.example.com,192.0.2.*,2001:*\",\n\t\tNULL,\n\t\tKEY_ECDSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ECDSA #3\",\n\t} },\n\t{ \"ed25519_3.pub\" , -1, -1, HKF_MATCH_HOST, HKF_MATCH_HOST, HKF_MATCH_IP, HKF_MATCH_IP, -1, {\n\t\tNULL,\n\t\t16,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"*.example.com,192.0.2.*,2001:*\",\n\t\tNULL,\n\t\tKEY_ED25519,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ED25519 #3\",\n\t} },\n\t{ \"rsa_3.pub\" , -1, -1, HKF_MATCH_HOST, HKF_MATCH_HOST, HKF_MATCH_IP, HKF_MATCH_IP, -1, {\n\t\tNULL,\n\t\t17,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"*.example.com,192.0.2.*,2001:*\",\n\t\tNULL,\n\t\tKEY_RSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"RSA #3\",\n\t} },\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t18,\n\t\tHKF_STATUS_COMMENT,\n\t\t0,\n\t\t\"\",\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t19,\n\t\tHKF_STATUS_COMMENT,\n\t\t0,\n\t\t\"# Hashed hostname and address entries\",\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ \"dsa_5.pub\" , -1, -1, 0, HKF_MATCH_HOST|HKF_MATCH_HOST_HASHED, 0, 0, -1, {\n\t\tNULL,\n\t\t20,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_DSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"DSA #5\",\n\t} },\n\t{ \"ecdsa_5.pub\" , -1, -1, 0, HKF_MATCH_HOST|HKF_MATCH_HOST_HASHED, 0, 0, -1, {\n\t\tNULL,\n\t\t21,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_ECDSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ECDSA #5\",\n\t} },\n\t{ \"ed25519_5.pub\" , -1, -1, 0, HKF_MATCH_HOST|HKF_MATCH_HOST_HASHED, 0, 0, -1, {\n\t\tNULL,\n\t\t22,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_ED25519,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ED25519 #5\",\n\t} },\n\t{ \"rsa_5.pub\" , -1, -1, 0, HKF_MATCH_HOST|HKF_MATCH_HOST_HASHED, 0, 0, -1, {\n\t\tNULL,\n\t\t23,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_RSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"RSA #5\",\n\t} },\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t24,\n\t\tHKF_STATUS_COMMENT,\n\t\t0,\n\t\t\"\",\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t/*\n\t * The next series have each key listed multiple times, as the\n\t * hostname and addresses in the pre-hashed known_hosts are split\n\t * to separate lines.\n\t */\n\t{ \"dsa_6.pub\" , -1, -1, HKF_MATCH_HOST|HKF_MATCH_HOST_HASHED, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t25,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_DSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"DSA #6\",\n\t} },\n\t{ \"dsa_6.pub\" , -1, -1, 0, 0, HKF_MATCH_IP|HKF_MATCH_IP_HASHED, 0, -1, {\n\t\tNULL,\n\t\t26,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_DSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"DSA #6\",\n\t} },\n\t{ \"dsa_6.pub\" , -1, -1, 0, 0, 0, HKF_MATCH_IP|HKF_MATCH_IP_HASHED, -1, {\n\t\tNULL,\n\t\t27,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_DSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"DSA #6\",\n\t} },\n\t{ \"ecdsa_6.pub\" , -1, -1, HKF_MATCH_HOST|HKF_MATCH_HOST_HASHED, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t28,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_ECDSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ECDSA #6\",\n\t} },\n\t{ \"ecdsa_6.pub\" , -1, -1, 0, 0, HKF_MATCH_IP|HKF_MATCH_IP_HASHED, 0, -1, {\n\t\tNULL,\n\t\t29,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_ECDSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ECDSA #6\",\n\t} },\n\t{ \"ecdsa_6.pub\" , -1, -1, 0, 0, 0, HKF_MATCH_IP|HKF_MATCH_IP_HASHED, -1, {\n\t\tNULL,\n\t\t30,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_ECDSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ECDSA #6\",\n\t} },\n\t{ \"ed25519_6.pub\" , -1, -1, HKF_MATCH_HOST|HKF_MATCH_HOST_HASHED, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t31,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_ED25519,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ED25519 #6\",\n\t} },\n\t{ \"ed25519_6.pub\" , -1, -1, 0, 0, HKF_MATCH_IP|HKF_MATCH_IP_HASHED, 0, -1, {\n\t\tNULL,\n\t\t32,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_ED25519,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ED25519 #6\",\n\t} },\n\t{ \"ed25519_6.pub\" , -1, -1, 0, 0, 0, HKF_MATCH_IP|HKF_MATCH_IP_HASHED, -1, {\n\t\tNULL,\n\t\t33,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_ED25519,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ED25519 #6\",\n\t} },\n\t{ \"rsa_6.pub\" , -1, -1, HKF_MATCH_HOST|HKF_MATCH_HOST_HASHED, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t34,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_RSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"RSA #6\",\n\t} },\n\t{ \"rsa_6.pub\" , -1, -1, 0, 0, HKF_MATCH_IP|HKF_MATCH_IP_HASHED, 0, -1, {\n\t\tNULL,\n\t\t35,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_RSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"RSA #6\",\n\t} },\n\t{ \"rsa_6.pub\" , -1, -1, 0, 0, 0, HKF_MATCH_IP|HKF_MATCH_IP_HASHED, -1, {\n\t\tNULL,\n\t\t36,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_RSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"RSA #6\",\n\t} },\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t37,\n\t\tHKF_STATUS_COMMENT,\n\t\t0,\n\t\t\"\",\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t38,\n\t\tHKF_STATUS_COMMENT,\n\t\t0,\n\t\t\"\",\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t39,\n\t\tHKF_STATUS_COMMENT,\n\t\t0,\n\t\t\"# Revoked and CA keys\",\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ \"ed25519_4.pub\" , -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {\n\t\tNULL,\n\t\t40,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_REVOKE,\n\t\t\"sisyphus.example.com\",\n\t\tNULL,\n\t\tKEY_ED25519,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ED25519 #4\",\n\t} },\n\t{ \"ecdsa_4.pub\" , -1, -1, HKF_MATCH_HOST, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t41,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_CA,\n\t\t\"prometheus.example.com\",\n\t\tNULL,\n\t\tKEY_ECDSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ECDSA #4\",\n\t} },\n\t{ \"dsa_4.pub\" , -1, -1, HKF_MATCH_HOST, HKF_MATCH_HOST, 0, 0, -1, {\n\t\tNULL,\n\t\t42,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_CA,\n\t\t\"*.example.com\",\n\t\tNULL,\n\t\tKEY_DSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"DSA #4\",\n\t} },\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t43,\n\t\tHKF_STATUS_COMMENT,\n\t\t0,\n\t\t\"\",\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t44,\n\t\tHKF_STATUS_COMMENT,\n\t\t0,\n\t\t\"# Some invalid lines\",\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t45,\n\t\tHKF_STATUS_INVALID,\n\t\t0,\n\t\tNULL,\n\t\tMRK_ERROR,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ NULL, -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {\n\t\tNULL,\n\t\t46,\n\t\tHKF_STATUS_INVALID,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"sisyphus.example.com\",\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ NULL, -1, -1, HKF_MATCH_HOST, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t47,\n\t\tHKF_STATUS_INVALID,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"prometheus.example.com\",\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ NULL, -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {\n\t\tNULL,\n\t\t48,\n\t\tHKF_STATUS_INVALID,\t/* Would be ok if key not parsed */\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"sisyphus.example.com\",\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ NULL, -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {\n\t\tNULL,\n\t\t49,\n\t\tHKF_STATUS_INVALID,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"sisyphus.example.com\",\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\t/* filled at runtime */\n\t\tNULL,\n\t} },\n\t{ NULL, HKF_STATUS_OK, KEY_RSA, HKF_MATCH_HOST, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t50,\n\t\tHKF_STATUS_INVALID,\t/* Would be ok if key not parsed */\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"prometheus.example.com\",\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\t/* filled at runtime */\n\t\tNULL,\n\t} },\n};",
      "void test_iterate(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cleanup_expected",
          "args": [
            "expected_full",
            "ctx.nexpected"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_expected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/hostkeys/test_iterate.c",
          "lines": "155-164",
          "snippet": "static void\ncleanup_expected(struct expected *expected, size_t n)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tsshkey_free(expected[i].l.key);\n\t\texpected[i].l.key = NULL;\n\t}\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"../test_helper/test_helper.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ncleanup_expected(struct expected *expected, size_t n)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tsshkey_free(expected[i].l.key);\n\t\texpected[i].l.key = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"prometheus.example.com\",\n\t    \"2001:db8::1\", ctx.flags)",
            "0"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hostkeys_foreach",
          "args": [
            "test_data_file(\"known_hosts\")",
            "check",
            "&ctx",
            "\"prometheus.example.com\"",
            "\"2001:db8::1\"",
            "ctx.flags"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "hostkeys_foreach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/hostfile.c",
          "lines": "661-834",
          "snippet": "int\nhostkeys_foreach(const char *path, hostkeys_foreach_fn *callback, void *ctx,\n    const char *host, const char *ip, u_int options)\n{\n\tFILE *f;\n\tchar *line = NULL, ktype[128];\n\tu_long linenum = 0;\n\tchar *cp, *cp2;\n\tu_int kbits;\n\tint hashed;\n\tint s, r = 0;\n\tstruct hostkey_foreach_line lineinfo;\n\tsize_t linesize = 0, l;\n\n\tmemset(&lineinfo, 0, sizeof(lineinfo));\n\tif (host == NULL && (options & HKF_WANT_MATCH) != 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((f = fopen(path, \"r\")) == NULL)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\tdebug3(\"%s: reading file \\\"%s\\\"\", __func__, path);\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\tline[strcspn(line, \"\\n\")] = '\\0';\n\n\t\tfree(lineinfo.line);\n\t\tsshkey_free(lineinfo.key);\n\t\tmemset(&lineinfo, 0, sizeof(lineinfo));\n\t\tlineinfo.path = path;\n\t\tlineinfo.linenum = linenum;\n\t\tlineinfo.line = xstrdup(line);\n\t\tlineinfo.marker = MRK_NONE;\n\t\tlineinfo.status = HKF_STATUS_OK;\n\t\tlineinfo.keytype = KEY_UNSPEC;\n\n\t\t/* Skip any leading whitespace, comments and empty lines. */\n\t\tfor (cp = line; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\tif (!*cp || *cp == '#' || *cp == '\\n') {\n\t\t\tif ((options & HKF_WANT_MATCH) == 0) {\n\t\t\t\tlineinfo.status = HKF_STATUS_COMMENT;\n\t\t\t\tif ((r = callback(&lineinfo, ctx)) != 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((lineinfo.marker = check_markers(&cp)) == MRK_ERROR) {\n\t\t\tverbose(\"%s: invalid marker at %s:%lu\",\n\t\t\t    __func__, path, linenum);\n\t\t\tif ((options & HKF_WANT_MATCH) == 0)\n\t\t\t\tgoto bad;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Find the end of the host name portion. */\n\t\tfor (cp2 = cp; *cp2 && *cp2 != ' ' && *cp2 != '\\t'; cp2++)\n\t\t\t;\n\t\tlineinfo.hosts = cp;\n\t\t*cp2++ = '\\0';\n\n\t\t/* Check if the host name matches. */\n\t\tif (host != NULL) {\n\t\t\tif ((s = match_maybe_hashed(host, lineinfo.hosts,\n\t\t\t    &hashed)) == -1) {\n\t\t\t\tdebug2(\"%s: %s:%ld: bad host hash \\\"%.32s\\\"\",\n\t\t\t\t    __func__, path, linenum, lineinfo.hosts);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (s == 1) {\n\t\t\t\tlineinfo.status = HKF_STATUS_MATCHED;\n\t\t\t\tlineinfo.match |= HKF_MATCH_HOST |\n\t\t\t\t    (hashed ? HKF_MATCH_HOST_HASHED : 0);\n\t\t\t}\n\t\t\t/* Try matching IP address if supplied */\n\t\t\tif (ip != NULL) {\n\t\t\t\tif ((s = match_maybe_hashed(ip, lineinfo.hosts,\n\t\t\t\t    &hashed)) == -1) {\n\t\t\t\t\tdebug2(\"%s: %s:%ld: bad ip hash \"\n\t\t\t\t\t    \"\\\"%.32s\\\"\", __func__, path,\n\t\t\t\t\t    linenum, lineinfo.hosts);\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\tif (s == 1) {\n\t\t\t\t\tlineinfo.status = HKF_STATUS_MATCHED;\n\t\t\t\t\tlineinfo.match |= HKF_MATCH_IP |\n\t\t\t\t\t    (hashed ? HKF_MATCH_IP_HASHED : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * Skip this line if host matching requested and\n\t\t\t * neither host nor address matched.\n\t\t\t */\n\t\t\tif ((options & HKF_WANT_MATCH) != 0 &&\n\t\t\t    lineinfo.status != HKF_STATUS_MATCHED)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Got a match.  Skip host name and any following whitespace */\n\t\tfor (; *cp2 == ' ' || *cp2 == '\\t'; cp2++)\n\t\t\t;\n\t\tif (*cp2 == '\\0' || *cp2 == '#') {\n\t\t\tdebug2(\"%s:%ld: truncated before key type\",\n\t\t\t    path, linenum);\n\t\t\tgoto bad;\n\t\t}\n\t\tlineinfo.rawkey = cp = cp2;\n\n\t\tif ((options & HKF_WANT_PARSE_KEY) != 0) {\n\t\t\t/*\n\t\t\t * Extract the key from the line.  This will skip\n\t\t\t * any leading whitespace.  Ignore badly formatted\n\t\t\t * lines.\n\t\t\t */\n\t\t\tif ((lineinfo.key = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\t\terror(\"%s: sshkey_new failed\", __func__);\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!hostfile_read_key(&cp, &kbits, lineinfo.key)) {\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tlineinfo.keytype = lineinfo.key->type;\n\t\t\tlineinfo.comment = cp;\n\t\t} else {\n\t\t\t/* Extract and parse key type */\n\t\t\tl = strcspn(lineinfo.rawkey, \" \\t\");\n\t\t\tif (l <= 1 || l >= sizeof(ktype) ||\n\t\t\t    lineinfo.rawkey[l] == '\\0')\n\t\t\t\tgoto bad;\n\t\t\tmemcpy(ktype, lineinfo.rawkey, l);\n\t\t\tktype[l] = '\\0';\n\t\t\tlineinfo.keytype = sshkey_type_from_name(ktype);\n\n\t\t\t/*\n\t\t\t * Assume legacy RSA1 if the first component is a short\n\t\t\t * decimal number.\n\t\t\t */\n\t\t\tif (lineinfo.keytype == KEY_UNSPEC && l < 8 &&\n\t\t\t    strspn(ktype, \"0123456789\") == l)\n\t\t\t\tgoto bad;\n\n\t\t\t/*\n\t\t\t * Check that something other than whitespace follows\n\t\t\t * the key type. This won't catch all corruption, but\n\t\t\t * it does catch trivial truncation.\n\t\t\t */\n\t\t\tcp2 += l; /* Skip past key type */\n\t\t\tfor (; *cp2 == ' ' || *cp2 == '\\t'; cp2++)\n\t\t\t\t;\n\t\t\tif (*cp2 == '\\0' || *cp2 == '#') {\n\t\t\t\tdebug2(\"%s:%ld: truncated after key type\",\n\t\t\t\t    path, linenum);\n\t\t\t\tlineinfo.keytype = KEY_UNSPEC;\n\t\t\t}\n\t\t\tif (lineinfo.keytype == KEY_UNSPEC) {\n bad:\n\t\t\t\tsshkey_free(lineinfo.key);\n\t\t\t\tlineinfo.key = NULL;\n\t\t\t\tlineinfo.status = HKF_STATUS_INVALID;\n\t\t\t\tif ((r = callback(&lineinfo, ctx)) != 0)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif ((r = callback(&lineinfo, ctx)) != 0)\n\t\t\tbreak;\n\t}\n\tsshkey_free(lineinfo.key);\n\tfree(lineinfo.line);\n\tfree(line);\n\tfclose(f);\n\treturn r;\n}",
          "includes": [
            "#include \"hmac.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <resolv.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <resolv.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nhostkeys_foreach(const char *path, hostkeys_foreach_fn *callback, void *ctx,\n    const char *host, const char *ip, u_int options)\n{\n\tFILE *f;\n\tchar *line = NULL, ktype[128];\n\tu_long linenum = 0;\n\tchar *cp, *cp2;\n\tu_int kbits;\n\tint hashed;\n\tint s, r = 0;\n\tstruct hostkey_foreach_line lineinfo;\n\tsize_t linesize = 0, l;\n\n\tmemset(&lineinfo, 0, sizeof(lineinfo));\n\tif (host == NULL && (options & HKF_WANT_MATCH) != 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((f = fopen(path, \"r\")) == NULL)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\tdebug3(\"%s: reading file \\\"%s\\\"\", __func__, path);\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\tline[strcspn(line, \"\\n\")] = '\\0';\n\n\t\tfree(lineinfo.line);\n\t\tsshkey_free(lineinfo.key);\n\t\tmemset(&lineinfo, 0, sizeof(lineinfo));\n\t\tlineinfo.path = path;\n\t\tlineinfo.linenum = linenum;\n\t\tlineinfo.line = xstrdup(line);\n\t\tlineinfo.marker = MRK_NONE;\n\t\tlineinfo.status = HKF_STATUS_OK;\n\t\tlineinfo.keytype = KEY_UNSPEC;\n\n\t\t/* Skip any leading whitespace, comments and empty lines. */\n\t\tfor (cp = line; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\tif (!*cp || *cp == '#' || *cp == '\\n') {\n\t\t\tif ((options & HKF_WANT_MATCH) == 0) {\n\t\t\t\tlineinfo.status = HKF_STATUS_COMMENT;\n\t\t\t\tif ((r = callback(&lineinfo, ctx)) != 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((lineinfo.marker = check_markers(&cp)) == MRK_ERROR) {\n\t\t\tverbose(\"%s: invalid marker at %s:%lu\",\n\t\t\t    __func__, path, linenum);\n\t\t\tif ((options & HKF_WANT_MATCH) == 0)\n\t\t\t\tgoto bad;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Find the end of the host name portion. */\n\t\tfor (cp2 = cp; *cp2 && *cp2 != ' ' && *cp2 != '\\t'; cp2++)\n\t\t\t;\n\t\tlineinfo.hosts = cp;\n\t\t*cp2++ = '\\0';\n\n\t\t/* Check if the host name matches. */\n\t\tif (host != NULL) {\n\t\t\tif ((s = match_maybe_hashed(host, lineinfo.hosts,\n\t\t\t    &hashed)) == -1) {\n\t\t\t\tdebug2(\"%s: %s:%ld: bad host hash \\\"%.32s\\\"\",\n\t\t\t\t    __func__, path, linenum, lineinfo.hosts);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (s == 1) {\n\t\t\t\tlineinfo.status = HKF_STATUS_MATCHED;\n\t\t\t\tlineinfo.match |= HKF_MATCH_HOST |\n\t\t\t\t    (hashed ? HKF_MATCH_HOST_HASHED : 0);\n\t\t\t}\n\t\t\t/* Try matching IP address if supplied */\n\t\t\tif (ip != NULL) {\n\t\t\t\tif ((s = match_maybe_hashed(ip, lineinfo.hosts,\n\t\t\t\t    &hashed)) == -1) {\n\t\t\t\t\tdebug2(\"%s: %s:%ld: bad ip hash \"\n\t\t\t\t\t    \"\\\"%.32s\\\"\", __func__, path,\n\t\t\t\t\t    linenum, lineinfo.hosts);\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\tif (s == 1) {\n\t\t\t\t\tlineinfo.status = HKF_STATUS_MATCHED;\n\t\t\t\t\tlineinfo.match |= HKF_MATCH_IP |\n\t\t\t\t\t    (hashed ? HKF_MATCH_IP_HASHED : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * Skip this line if host matching requested and\n\t\t\t * neither host nor address matched.\n\t\t\t */\n\t\t\tif ((options & HKF_WANT_MATCH) != 0 &&\n\t\t\t    lineinfo.status != HKF_STATUS_MATCHED)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Got a match.  Skip host name and any following whitespace */\n\t\tfor (; *cp2 == ' ' || *cp2 == '\\t'; cp2++)\n\t\t\t;\n\t\tif (*cp2 == '\\0' || *cp2 == '#') {\n\t\t\tdebug2(\"%s:%ld: truncated before key type\",\n\t\t\t    path, linenum);\n\t\t\tgoto bad;\n\t\t}\n\t\tlineinfo.rawkey = cp = cp2;\n\n\t\tif ((options & HKF_WANT_PARSE_KEY) != 0) {\n\t\t\t/*\n\t\t\t * Extract the key from the line.  This will skip\n\t\t\t * any leading whitespace.  Ignore badly formatted\n\t\t\t * lines.\n\t\t\t */\n\t\t\tif ((lineinfo.key = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\t\terror(\"%s: sshkey_new failed\", __func__);\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!hostfile_read_key(&cp, &kbits, lineinfo.key)) {\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tlineinfo.keytype = lineinfo.key->type;\n\t\t\tlineinfo.comment = cp;\n\t\t} else {\n\t\t\t/* Extract and parse key type */\n\t\t\tl = strcspn(lineinfo.rawkey, \" \\t\");\n\t\t\tif (l <= 1 || l >= sizeof(ktype) ||\n\t\t\t    lineinfo.rawkey[l] == '\\0')\n\t\t\t\tgoto bad;\n\t\t\tmemcpy(ktype, lineinfo.rawkey, l);\n\t\t\tktype[l] = '\\0';\n\t\t\tlineinfo.keytype = sshkey_type_from_name(ktype);\n\n\t\t\t/*\n\t\t\t * Assume legacy RSA1 if the first component is a short\n\t\t\t * decimal number.\n\t\t\t */\n\t\t\tif (lineinfo.keytype == KEY_UNSPEC && l < 8 &&\n\t\t\t    strspn(ktype, \"0123456789\") == l)\n\t\t\t\tgoto bad;\n\n\t\t\t/*\n\t\t\t * Check that something other than whitespace follows\n\t\t\t * the key type. This won't catch all corruption, but\n\t\t\t * it does catch trivial truncation.\n\t\t\t */\n\t\t\tcp2 += l; /* Skip past key type */\n\t\t\tfor (; *cp2 == ' ' || *cp2 == '\\t'; cp2++)\n\t\t\t\t;\n\t\t\tif (*cp2 == '\\0' || *cp2 == '#') {\n\t\t\t\tdebug2(\"%s:%ld: truncated after key type\",\n\t\t\t\t    path, linenum);\n\t\t\t\tlineinfo.keytype = KEY_UNSPEC;\n\t\t\t}\n\t\t\tif (lineinfo.keytype == KEY_UNSPEC) {\n bad:\n\t\t\t\tsshkey_free(lineinfo.key);\n\t\t\t\tlineinfo.key = NULL;\n\t\t\t\tlineinfo.status = HKF_STATUS_INVALID;\n\t\t\t\tif ((r = callback(&lineinfo, ctx)) != 0)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif ((r = callback(&lineinfo, ctx)) != 0)\n\t\t\tbreak;\n\t}\n\tsshkey_free(lineinfo.key);\n\tfree(lineinfo.line);\n\tfree(line);\n\tfclose(f);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_data_file",
          "args": [
            "\"known_hosts\""
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "test_data_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/test_helper.c",
          "lines": "181-196",
          "snippet": "const char *\ntest_data_file(const char *name)\n{\n\tstatic char ret[PATH_MAX];\n\n\tif (data_dir != NULL)\n\t\tsnprintf(ret, sizeof(ret), \"%s/%s\", data_dir, name);\n\telse\n\t\tstrlcpy(ret, name, sizeof(ret));\n\tif (access(ret, F_OK) != 0) {\n\t\tfprintf(stderr, \"Cannot access data file %s: %s\\n\",\n\t\t    ret, strerror(errno));\n\t\texit(1);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "# include <vis.h>",
            "#include <openssl/bn.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *data_dir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n# include <vis.h>\n#include <openssl/bn.h>\n#include <signal.h>\n#include <unistd.h>\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *data_dir = NULL;\n\nconst char *\ntest_data_file(const char *name)\n{\n\tstatic char ret[PATH_MAX];\n\n\tif (data_dir != NULL)\n\t\tsnprintf(ret, sizeof(ret), \"%s/%s\", data_dir, name);\n\telse\n\t\tstrlcpy(ret, name, sizeof(ret));\n\tif (access(ret, F_OK) != 0) {\n\t\tfprintf(stderr, \"Cannot access data file %s: %s\\n\",\n\t\t    ret, strerror(errno));\n\t\texit(1);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_expected",
          "args": [
            "expected_full",
            "ctx.nexpected"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_expected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/hostkeys/test_iterate.c",
          "lines": "137-153",
          "snippet": "static void\nprepare_expected(struct expected *expected, size_t n)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (expected[i].key_file == NULL)\n\t\t\tcontinue;\n#ifndef OPENSSL_HAS_ECC\n\t\tif (expected[i].l.keytype == KEY_ECDSA)\n\t\t\tcontinue;\n#endif\n\t\tASSERT_INT_EQ(sshkey_load_public(\n\t\t    test_data_file(expected[i].key_file), &expected[i].l.key,\n\t\t    NULL), 0);\n\t}\n}",
          "includes": [
            "#include \"hostfile.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hostfile.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"../test_helper/test_helper.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nprepare_expected(struct expected *expected, size_t n)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (expected[i].key_file == NULL)\n\t\t\tcontinue;\n#ifndef OPENSSL_HAS_ECC\n\t\tif (expected[i].l.keytype == KEY_ECDSA)\n\t\t\tcontinue;\n#endif\n\t\tASSERT_INT_EQ(sshkey_load_public(\n\t\t    test_data_file(expected[i].key_file), &expected[i].l.key,\n\t\t    NULL), 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctx",
            "0",
            "sizeof(ctx)"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"hostkeys_iterate match host 1 and IPv6 w/ key parse\""
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"sisyphus.example.com\", \"192.0.2.1\", ctx.flags)",
            "0"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctx",
            "0",
            "sizeof(ctx)"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"hostkeys_iterate specify host 2 and IPv4 w/ key parse\""
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"prometheus.example.com\",\n\t    \"2001:db8::1\", ctx.flags)",
            "0"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctx",
            "0",
            "sizeof(ctx)"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"hostkeys_iterate match host 1 and IPv6\""
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"sisyphus.example.com\", \"192.0.2.1\", ctx.flags)",
            "0"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctx",
            "0",
            "sizeof(ctx)"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"hostkeys_iterate specify host 2 and IPv4\""
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"tiresias.example.org\", \"::1\", ctx.flags)",
            "0"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctx",
            "0",
            "sizeof(ctx)"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"hostkeys_iterate match addr missing\""
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"tiresias.example.org\", \"192.168.0.1\", ctx.flags)",
            "0"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctx",
            "0",
            "sizeof(ctx)"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"hostkeys_iterate specify addr missing\""
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"tiresias.example.org\", \"2001:db8::1\", ctx.flags)",
            "0"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctx",
            "0",
            "sizeof(ctx)"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"hostkeys_iterate match IPv6\""
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"tiresias.example.org\", \"192.0.2.1\", ctx.flags)",
            "0"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctx",
            "0",
            "sizeof(ctx)"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"hostkeys_iterate match IPv4\""
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"tiresias.example.org\", \"2001:db8::1\", ctx.flags)",
            "0"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctx",
            "0",
            "sizeof(ctx)"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"hostkeys_iterate specify IPv6\""
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"tiresias.example.org\", \"192.0.2.1\", ctx.flags)",
            "0"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctx",
            "0",
            "sizeof(ctx)"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"hostkeys_iterate specify IPv4\""
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"actaeon.example.org\", NULL, ctx.flags)",
            "0"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctx",
            "0",
            "sizeof(ctx)"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"hostkeys_iterate match host missing\""
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"actaeon.example.org\", NULL, ctx.flags)",
            "0"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctx",
            "0",
            "sizeof(ctx)"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"hostkeys_iterate specify host missing\""
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"sisyphus.example.com\", NULL, ctx.flags)",
            "0"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctx",
            "0",
            "sizeof(ctx)"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"hostkeys_iterate match host 2\""
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"prometheus.example.com\", NULL, ctx.flags)",
            "0"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctx",
            "0",
            "sizeof(ctx)"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"hostkeys_iterate match host 1\""
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"sisyphus.example.com\", NULL, ctx.flags)",
            "0"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctx",
            "0",
            "sizeof(ctx)"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"hostkeys_iterate specify host 2\""
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"prometheus.example.com\", NULL, ctx.flags)",
            "0"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctx",
            "0",
            "sizeof(ctx)"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"hostkeys_iterate specify host 1\""
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, NULL, NULL, ctx.flags)",
            "0"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctx",
            "0",
            "sizeof(ctx)"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"hostkeys_iterate all without key parse\""
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, NULL, NULL, ctx.flags)",
            "0"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ctx",
            "0",
            "sizeof(ctx)"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"hostkeys_iterate all with key parse\""
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"../test_helper/test_helper.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct expected expected_full[] = {\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\t\t\t\t/* path, don't care */\n\t\t1,\t\t\t\t/* line number */\n\t\tHKF_STATUS_COMMENT,\t\t/* status */\n\t\t0,\t\t\t\t/* match flags */\n\t\t\"# Plain host keys, plain host names\", /* full line, optional */\n\t\tMRK_NONE,\t\t\t/* marker (CA / revoked) */\n\t\tNULL,\t\t\t\t/* hosts text */\n\t\tNULL,\t\t\t\t/* raw key, optional */\n\t\tKEY_UNSPEC,\t\t\t/* key type */\n\t\tNULL,\t\t\t\t/* deserialised key */\n\t\tNULL,\t\t\t\t/* comment */\n\t} },\n\t{ \"dsa_1.pub\" , -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {\n\t\tNULL,\n\t\t2,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"sisyphus.example.com\",\n\t\tNULL,\n\t\tKEY_DSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"DSA #1\",\n\t} },\n\t{ \"ecdsa_1.pub\" , -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {\n\t\tNULL,\n\t\t3,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"sisyphus.example.com\",\n\t\tNULL,\n\t\tKEY_ECDSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ECDSA #1\",\n\t} },\n\t{ \"ed25519_1.pub\" , -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {\n\t\tNULL,\n\t\t4,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"sisyphus.example.com\",\n\t\tNULL,\n\t\tKEY_ED25519,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ED25519 #1\",\n\t} },\n\t{ \"rsa_1.pub\" , -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {\n\t\tNULL,\n\t\t5,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"sisyphus.example.com\",\n\t\tNULL,\n\t\tKEY_RSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"RSA #1\",\n\t} },\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t6,\n\t\tHKF_STATUS_COMMENT,\n\t\t0,\n\t\t\"\",\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t7,\n\t\tHKF_STATUS_COMMENT,\n\t\t0,\n\t\t\"# Plain host keys, hostnames + addresses\",\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ \"dsa_2.pub\" , -1, -1, HKF_MATCH_HOST, 0, HKF_MATCH_IP, HKF_MATCH_IP, -1, {\n\t\tNULL,\n\t\t8,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"prometheus.example.com,192.0.2.1,2001:db8::1\",\n\t\tNULL,\n\t\tKEY_DSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"DSA #2\",\n\t} },\n\t{ \"ecdsa_2.pub\" , -1, -1, HKF_MATCH_HOST, 0, HKF_MATCH_IP, HKF_MATCH_IP, -1, {\n\t\tNULL,\n\t\t9,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"prometheus.example.com,192.0.2.1,2001:db8::1\",\n\t\tNULL,\n\t\tKEY_ECDSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ECDSA #2\",\n\t} },\n\t{ \"ed25519_2.pub\" , -1, -1, HKF_MATCH_HOST, 0, HKF_MATCH_IP, HKF_MATCH_IP, -1, {\n\t\tNULL,\n\t\t10,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"prometheus.example.com,192.0.2.1,2001:db8::1\",\n\t\tNULL,\n\t\tKEY_ED25519,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ED25519 #2\",\n\t} },\n\t{ \"rsa_2.pub\" , -1, -1, HKF_MATCH_HOST, 0, HKF_MATCH_IP, HKF_MATCH_IP, -1, {\n\t\tNULL,\n\t\t11,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"prometheus.example.com,192.0.2.1,2001:db8::1\",\n\t\tNULL,\n\t\tKEY_RSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"RSA #2\",\n\t} },\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t12,\n\t\tHKF_STATUS_COMMENT,\n\t\t0,\n\t\t\"\",\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t13,\n\t\tHKF_STATUS_COMMENT,\n\t\t0,\n\t\t\"# Some hosts with wildcard names / IPs\",\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ \"dsa_3.pub\" , -1, -1, HKF_MATCH_HOST, HKF_MATCH_HOST, HKF_MATCH_IP, HKF_MATCH_IP, -1, {\n\t\tNULL,\n\t\t14,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"*.example.com,192.0.2.*,2001:*\",\n\t\tNULL,\n\t\tKEY_DSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"DSA #3\",\n\t} },\n\t{ \"ecdsa_3.pub\" , -1, -1, HKF_MATCH_HOST, HKF_MATCH_HOST, HKF_MATCH_IP, HKF_MATCH_IP, -1, {\n\t\tNULL,\n\t\t15,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"*.example.com,192.0.2.*,2001:*\",\n\t\tNULL,\n\t\tKEY_ECDSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ECDSA #3\",\n\t} },\n\t{ \"ed25519_3.pub\" , -1, -1, HKF_MATCH_HOST, HKF_MATCH_HOST, HKF_MATCH_IP, HKF_MATCH_IP, -1, {\n\t\tNULL,\n\t\t16,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"*.example.com,192.0.2.*,2001:*\",\n\t\tNULL,\n\t\tKEY_ED25519,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ED25519 #3\",\n\t} },\n\t{ \"rsa_3.pub\" , -1, -1, HKF_MATCH_HOST, HKF_MATCH_HOST, HKF_MATCH_IP, HKF_MATCH_IP, -1, {\n\t\tNULL,\n\t\t17,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"*.example.com,192.0.2.*,2001:*\",\n\t\tNULL,\n\t\tKEY_RSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"RSA #3\",\n\t} },\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t18,\n\t\tHKF_STATUS_COMMENT,\n\t\t0,\n\t\t\"\",\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t19,\n\t\tHKF_STATUS_COMMENT,\n\t\t0,\n\t\t\"# Hashed hostname and address entries\",\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ \"dsa_5.pub\" , -1, -1, 0, HKF_MATCH_HOST|HKF_MATCH_HOST_HASHED, 0, 0, -1, {\n\t\tNULL,\n\t\t20,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_DSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"DSA #5\",\n\t} },\n\t{ \"ecdsa_5.pub\" , -1, -1, 0, HKF_MATCH_HOST|HKF_MATCH_HOST_HASHED, 0, 0, -1, {\n\t\tNULL,\n\t\t21,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_ECDSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ECDSA #5\",\n\t} },\n\t{ \"ed25519_5.pub\" , -1, -1, 0, HKF_MATCH_HOST|HKF_MATCH_HOST_HASHED, 0, 0, -1, {\n\t\tNULL,\n\t\t22,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_ED25519,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ED25519 #5\",\n\t} },\n\t{ \"rsa_5.pub\" , -1, -1, 0, HKF_MATCH_HOST|HKF_MATCH_HOST_HASHED, 0, 0, -1, {\n\t\tNULL,\n\t\t23,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_RSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"RSA #5\",\n\t} },\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t24,\n\t\tHKF_STATUS_COMMENT,\n\t\t0,\n\t\t\"\",\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t/*\n\t * The next series have each key listed multiple times, as the\n\t * hostname and addresses in the pre-hashed known_hosts are split\n\t * to separate lines.\n\t */\n\t{ \"dsa_6.pub\" , -1, -1, HKF_MATCH_HOST|HKF_MATCH_HOST_HASHED, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t25,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_DSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"DSA #6\",\n\t} },\n\t{ \"dsa_6.pub\" , -1, -1, 0, 0, HKF_MATCH_IP|HKF_MATCH_IP_HASHED, 0, -1, {\n\t\tNULL,\n\t\t26,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_DSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"DSA #6\",\n\t} },\n\t{ \"dsa_6.pub\" , -1, -1, 0, 0, 0, HKF_MATCH_IP|HKF_MATCH_IP_HASHED, -1, {\n\t\tNULL,\n\t\t27,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_DSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"DSA #6\",\n\t} },\n\t{ \"ecdsa_6.pub\" , -1, -1, HKF_MATCH_HOST|HKF_MATCH_HOST_HASHED, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t28,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_ECDSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ECDSA #6\",\n\t} },\n\t{ \"ecdsa_6.pub\" , -1, -1, 0, 0, HKF_MATCH_IP|HKF_MATCH_IP_HASHED, 0, -1, {\n\t\tNULL,\n\t\t29,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_ECDSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ECDSA #6\",\n\t} },\n\t{ \"ecdsa_6.pub\" , -1, -1, 0, 0, 0, HKF_MATCH_IP|HKF_MATCH_IP_HASHED, -1, {\n\t\tNULL,\n\t\t30,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_ECDSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ECDSA #6\",\n\t} },\n\t{ \"ed25519_6.pub\" , -1, -1, HKF_MATCH_HOST|HKF_MATCH_HOST_HASHED, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t31,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_ED25519,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ED25519 #6\",\n\t} },\n\t{ \"ed25519_6.pub\" , -1, -1, 0, 0, HKF_MATCH_IP|HKF_MATCH_IP_HASHED, 0, -1, {\n\t\tNULL,\n\t\t32,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_ED25519,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ED25519 #6\",\n\t} },\n\t{ \"ed25519_6.pub\" , -1, -1, 0, 0, 0, HKF_MATCH_IP|HKF_MATCH_IP_HASHED, -1, {\n\t\tNULL,\n\t\t33,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_ED25519,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ED25519 #6\",\n\t} },\n\t{ \"rsa_6.pub\" , -1, -1, HKF_MATCH_HOST|HKF_MATCH_HOST_HASHED, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t34,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_RSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"RSA #6\",\n\t} },\n\t{ \"rsa_6.pub\" , -1, -1, 0, 0, HKF_MATCH_IP|HKF_MATCH_IP_HASHED, 0, -1, {\n\t\tNULL,\n\t\t35,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_RSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"RSA #6\",\n\t} },\n\t{ \"rsa_6.pub\" , -1, -1, 0, 0, 0, HKF_MATCH_IP|HKF_MATCH_IP_HASHED, -1, {\n\t\tNULL,\n\t\t36,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_RSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"RSA #6\",\n\t} },\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t37,\n\t\tHKF_STATUS_COMMENT,\n\t\t0,\n\t\t\"\",\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t38,\n\t\tHKF_STATUS_COMMENT,\n\t\t0,\n\t\t\"\",\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t39,\n\t\tHKF_STATUS_COMMENT,\n\t\t0,\n\t\t\"# Revoked and CA keys\",\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ \"ed25519_4.pub\" , -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {\n\t\tNULL,\n\t\t40,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_REVOKE,\n\t\t\"sisyphus.example.com\",\n\t\tNULL,\n\t\tKEY_ED25519,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ED25519 #4\",\n\t} },\n\t{ \"ecdsa_4.pub\" , -1, -1, HKF_MATCH_HOST, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t41,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_CA,\n\t\t\"prometheus.example.com\",\n\t\tNULL,\n\t\tKEY_ECDSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"ECDSA #4\",\n\t} },\n\t{ \"dsa_4.pub\" , -1, -1, HKF_MATCH_HOST, HKF_MATCH_HOST, 0, 0, -1, {\n\t\tNULL,\n\t\t42,\n\t\tHKF_STATUS_OK,\n\t\t0,\n\t\tNULL,\n\t\tMRK_CA,\n\t\t\"*.example.com\",\n\t\tNULL,\n\t\tKEY_DSA,\n\t\tNULL,\t/* filled at runtime */\n\t\t\"DSA #4\",\n\t} },\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t43,\n\t\tHKF_STATUS_COMMENT,\n\t\t0,\n\t\t\"\",\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t44,\n\t\tHKF_STATUS_COMMENT,\n\t\t0,\n\t\t\"# Some invalid lines\",\n\t\tMRK_NONE,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ NULL, -1, -1, 0, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t45,\n\t\tHKF_STATUS_INVALID,\n\t\t0,\n\t\tNULL,\n\t\tMRK_ERROR,\n\t\tNULL,\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ NULL, -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {\n\t\tNULL,\n\t\t46,\n\t\tHKF_STATUS_INVALID,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"sisyphus.example.com\",\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ NULL, -1, -1, HKF_MATCH_HOST, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t47,\n\t\tHKF_STATUS_INVALID,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"prometheus.example.com\",\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ NULL, -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {\n\t\tNULL,\n\t\t48,\n\t\tHKF_STATUS_INVALID,\t/* Would be ok if key not parsed */\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"sisyphus.example.com\",\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\n\t\tNULL,\n\t} },\n\t{ NULL, -1, -1, 0, HKF_MATCH_HOST, 0, 0, -1, {\n\t\tNULL,\n\t\t49,\n\t\tHKF_STATUS_INVALID,\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"sisyphus.example.com\",\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\t/* filled at runtime */\n\t\tNULL,\n\t} },\n\t{ NULL, HKF_STATUS_OK, KEY_RSA, HKF_MATCH_HOST, 0, 0, 0, -1, {\n\t\tNULL,\n\t\t50,\n\t\tHKF_STATUS_INVALID,\t/* Would be ok if key not parsed */\n\t\t0,\n\t\tNULL,\n\t\tMRK_NONE,\n\t\t\"prometheus.example.com\",\n\t\tNULL,\n\t\tKEY_UNSPEC,\n\t\tNULL,\t/* filled at runtime */\n\t\tNULL,\n\t} },\n};\nvoid test_iterate(void);\n\nvoid\ntest_iterate(void)\n{\n\tstruct cbctx ctx;\n\n\tTEST_START(\"hostkeys_iterate all with key parse\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = HKF_WANT_PARSE_KEY;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, NULL, NULL, ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate all without key parse\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = 0;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, NULL, NULL, ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate specify host 1\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = 0;\n\tctx.match_host_p = 1;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"prometheus.example.com\", NULL, ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate specify host 2\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = 0;\n\tctx.match_host_s = 1;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"sisyphus.example.com\", NULL, ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate match host 1\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = HKF_WANT_MATCH;\n\tctx.match_host_p = 1;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"prometheus.example.com\", NULL, ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate match host 2\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = HKF_WANT_MATCH;\n\tctx.match_host_s = 1;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"sisyphus.example.com\", NULL, ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate specify host missing\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = 0;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"actaeon.example.org\", NULL, ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate match host missing\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = HKF_WANT_MATCH;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"actaeon.example.org\", NULL, ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate specify IPv4\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = 0;\n\tctx.match_ipv4 = 1;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"tiresias.example.org\", \"192.0.2.1\", ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate specify IPv6\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = 0;\n\tctx.match_ipv6 = 1;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"tiresias.example.org\", \"2001:db8::1\", ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate match IPv4\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = HKF_WANT_MATCH;\n\tctx.match_ipv4 = 1;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"tiresias.example.org\", \"192.0.2.1\", ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate match IPv6\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = HKF_WANT_MATCH;\n\tctx.match_ipv6 = 1;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"tiresias.example.org\", \"2001:db8::1\", ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate specify addr missing\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = 0;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"tiresias.example.org\", \"192.168.0.1\", ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate match addr missing\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = HKF_WANT_MATCH;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"tiresias.example.org\", \"::1\", ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate specify host 2 and IPv4\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = 0;\n\tctx.match_host_s = 1;\n\tctx.match_ipv4 = 1;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"sisyphus.example.com\", \"192.0.2.1\", ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate match host 1 and IPv6\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = HKF_WANT_MATCH;\n\tctx.match_host_p = 1;\n\tctx.match_ipv6 = 1;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"prometheus.example.com\",\n\t    \"2001:db8::1\", ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate specify host 2 and IPv4 w/ key parse\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = HKF_WANT_PARSE_KEY;\n\tctx.match_host_s = 1;\n\tctx.match_ipv4 = 1;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"sisyphus.example.com\", \"192.0.2.1\", ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n\n\tTEST_START(\"hostkeys_iterate match host 1 and IPv6 w/ key parse\");\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.expected = expected_full;\n\tctx.nexpected = sizeof(expected_full)/sizeof(*expected_full);\n\tctx.flags = HKF_WANT_MATCH|HKF_WANT_PARSE_KEY;\n\tctx.match_host_p = 1;\n\tctx.match_ipv6 = 1;\n\tprepare_expected(expected_full, ctx.nexpected);\n\tASSERT_INT_EQ(hostkeys_foreach(test_data_file(\"known_hosts\"),\n\t    check, &ctx, \"prometheus.example.com\",\n\t    \"2001:db8::1\", ctx.flags), 0);\n\tcleanup_expected(expected_full, ctx.nexpected);\n\tTEST_DONE();\n}"
  },
  {
    "function_name": "cleanup_expected",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/hostkeys/test_iterate.c",
    "lines": "155-164",
    "snippet": "static void\ncleanup_expected(struct expected *expected, size_t n)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tsshkey_free(expected[i].l.key);\n\t\texpected[i].l.key = NULL;\n\t}\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"../test_helper/test_helper.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "expected[i].l.key"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"../test_helper/test_helper.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\ncleanup_expected(struct expected *expected, size_t n)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tsshkey_free(expected[i].l.key);\n\t\texpected[i].l.key = NULL;\n\t}\n}"
  },
  {
    "function_name": "prepare_expected",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/hostkeys/test_iterate.c",
    "lines": "137-153",
    "snippet": "static void\nprepare_expected(struct expected *expected, size_t n)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (expected[i].key_file == NULL)\n\t\t\tcontinue;\n#ifndef OPENSSL_HAS_ECC\n\t\tif (expected[i].l.keytype == KEY_ECDSA)\n\t\t\tcontinue;\n#endif\n\t\tASSERT_INT_EQ(sshkey_load_public(\n\t\t    test_data_file(expected[i].key_file), &expected[i].l.key,\n\t\t    NULL), 0);\n\t}\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"../test_helper/test_helper.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_load_public(\n\t\t    test_data_file(expected[i].key_file), &expected[i].l.key,\n\t\t    NULL)",
            "0"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_load_public",
          "args": [
            "test_data_file(expected[i].key_file)",
            "&expected[i].l.key",
            "NULL"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_load_public",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "312-354",
          "snippet": "int\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tsshkey_free(pub);\n\n\t/* try .pub suffix */\n\tif (asprintf(&file, \"%s.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t}\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tsshkey_free(pub);\n\n\t/* try .pub suffix */\n\tif (asprintf(&file, \"%s.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t}\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_data_file",
          "args": [
            "expected[i].key_file"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "test_data_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/test_helper.c",
          "lines": "181-196",
          "snippet": "const char *\ntest_data_file(const char *name)\n{\n\tstatic char ret[PATH_MAX];\n\n\tif (data_dir != NULL)\n\t\tsnprintf(ret, sizeof(ret), \"%s/%s\", data_dir, name);\n\telse\n\t\tstrlcpy(ret, name, sizeof(ret));\n\tif (access(ret, F_OK) != 0) {\n\t\tfprintf(stderr, \"Cannot access data file %s: %s\\n\",\n\t\t    ret, strerror(errno));\n\t\texit(1);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "# include <vis.h>",
            "#include <openssl/bn.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *data_dir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n# include <vis.h>\n#include <openssl/bn.h>\n#include <signal.h>\n#include <unistd.h>\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *data_dir = NULL;\n\nconst char *\ntest_data_file(const char *name)\n{\n\tstatic char ret[PATH_MAX];\n\n\tif (data_dir != NULL)\n\t\tsnprintf(ret, sizeof(ret), \"%s/%s\", data_dir, name);\n\telse\n\t\tstrlcpy(ret, name, sizeof(ret));\n\tif (access(ret, F_OK) != 0) {\n\t\tfprintf(stderr, \"Cannot access data file %s: %s\\n\",\n\t\t    ret, strerror(errno));\n\t\texit(1);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"../test_helper/test_helper.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nprepare_expected(struct expected *expected, size_t n)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (expected[i].key_file == NULL)\n\t\t\tcontinue;\n#ifndef OPENSSL_HAS_ECC\n\t\tif (expected[i].l.keytype == KEY_ECDSA)\n\t\t\tcontinue;\n#endif\n\t\tASSERT_INT_EQ(sshkey_load_public(\n\t\t    test_data_file(expected[i].key_file), &expected[i].l.key,\n\t\t    NULL), 0);\n\t}\n}"
  },
  {
    "function_name": "check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/hostkeys/test_iterate.c",
    "lines": "52-134",
    "snippet": "static int\ncheck(struct hostkey_foreach_line *l, void *_ctx)\n{\n\tstruct cbctx *ctx = (struct cbctx *)_ctx;\n\tconst struct expected *expected;\n\tint parse_key = (ctx->flags & HKF_WANT_PARSE_KEY) != 0;\n\tconst int matching = (ctx->flags & HKF_WANT_MATCH) != 0;\n\tu_int expected_status, expected_match;\n\tint expected_keytype;\n\n\ttest_subtest_info(\"entry %zu/%zu, file line %ld\",\n\t    ctx->i + 1, ctx->nexpected, l->linenum);\n\n\tfor (;;) {\n\t\tASSERT_SIZE_T_LT(ctx->i, ctx->nexpected);\n\t\texpected = ctx->expected + ctx->i++;\n\t\t/* If we are matching host/IP then skip entries that don't */\n\t\tif (!matching)\n\t\t\tbreak;\n\t\tif (ctx->match_host_p && expected->match_host_p)\n\t\t\tbreak;\n\t\tif (ctx->match_host_s && expected->match_host_s)\n\t\t\tbreak;\n\t\tif (ctx->match_ipv4 && expected->match_ipv4)\n\t\t\tbreak;\n\t\tif (ctx->match_ipv6 && expected->match_ipv6)\n\t\t\tbreak;\n\t}\n\texpected_status = (parse_key || expected->no_parse_status < 0) ?\n\t    expected->l.status : (u_int)expected->no_parse_status;\n\texpected_match = expected->l.match;\n#define UPDATE_MATCH_STATUS(x) do { \\\n\t\tif (ctx->x && expected->x) { \\\n\t\t\texpected_match |= expected->x; \\\n\t\t\tif (expected_status == HKF_STATUS_OK) \\\n\t\t\t\texpected_status = HKF_STATUS_MATCHED; \\\n\t\t} \\\n\t} while (0)\n\texpected_keytype = (parse_key || expected->no_parse_keytype < 0) ?\n\t    expected->l.keytype : expected->no_parse_keytype;\n\n#ifndef OPENSSL_HAS_ECC\n\tif (expected->l.keytype == KEY_ECDSA ||\n\t    expected->no_parse_keytype == KEY_ECDSA) {\n\t\texpected_status = HKF_STATUS_INVALID;\n\t\texpected_keytype = KEY_UNSPEC;\n\t\tparse_key = 0;\n\t}\n#endif\n\n\tUPDATE_MATCH_STATUS(match_host_p);\n\tUPDATE_MATCH_STATUS(match_host_s);\n\tUPDATE_MATCH_STATUS(match_ipv4);\n\tUPDATE_MATCH_STATUS(match_ipv6);\n\n\tASSERT_PTR_NE(l->path, NULL); /* Don't care about path */\n\tASSERT_LONG_LONG_EQ(l->linenum, expected->l.linenum);\n\tASSERT_U_INT_EQ(l->status, expected_status);\n\tASSERT_U_INT_EQ(l->match, expected_match);\n\t/* Not all test entries contain fulltext */\n\tif (expected->l.line != NULL)\n\t\tASSERT_STRING_EQ(l->line, expected->l.line);\n\tASSERT_INT_EQ(l->marker, expected->l.marker);\n\t/* XXX we skip hashed hostnames for now; implement checking */\n\tif (expected->l.hosts != NULL)\n\t\tASSERT_STRING_EQ(l->hosts, expected->l.hosts);\n\t/* Not all test entries contain raw keys */\n\tif (expected->l.rawkey != NULL)\n\t\tASSERT_STRING_EQ(l->rawkey, expected->l.rawkey);\n\t/* XXX synthesise raw key for cases lacking and compare */\n\tASSERT_INT_EQ(l->keytype, expected_keytype);\n\tif (parse_key) {\n\t\tif (expected->l.key == NULL)\n\t\t\tASSERT_PTR_EQ(l->key, NULL);\n\t\tif (expected->l.key != NULL) {\n\t\t\tASSERT_PTR_NE(l->key, NULL);\n\t\t\tASSERT_INT_EQ(sshkey_equal(l->key, expected->l.key), 1);\n\t\t}\n\t}\n\tif (parse_key && !(l->comment == NULL && expected->l.comment == NULL))\n\t\tASSERT_STRING_EQ(l->comment, expected->l.comment);\n\treturn 0;\n}",
    "includes": [
      "#include \"hostfile.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"../test_helper/test_helper.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_STRING_EQ",
          "args": [
            "l->comment",
            "expected->l.comment"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(l->key, expected->l.key)",
            "1"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_equal",
          "args": [
            "l->key",
            "expected->l.key"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "704-714",
          "snippet": "int\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "l->key",
            "NULL"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_EQ",
          "args": [
            "l->key",
            "NULL"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "l->keytype",
            "expected_keytype"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_STRING_EQ",
          "args": [
            "l->rawkey",
            "expected->l.rawkey"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_STRING_EQ",
          "args": [
            "l->hosts",
            "expected->l.hosts"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "l->marker",
            "expected->l.marker"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_STRING_EQ",
          "args": [
            "l->line",
            "expected->l.line"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_U_INT_EQ",
          "args": [
            "l->match",
            "expected_match"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_U_INT_EQ",
          "args": [
            "l->status",
            "expected_status"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_LONG_LONG_EQ",
          "args": [
            "l->linenum",
            "expected->l.linenum"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "l->path",
            "NULL"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPDATE_MATCH_STATUS",
          "args": [
            "match_ipv6"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPDATE_MATCH_STATUS",
          "args": [
            "match_ipv4"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPDATE_MATCH_STATUS",
          "args": [
            "match_host_s"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPDATE_MATCH_STATUS",
          "args": [
            "match_host_p"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_SIZE_T_LT",
          "args": [
            "ctx->i",
            "ctx->nexpected"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_subtest_info",
          "args": [
            "\"entry %zu/%zu, file line %ld\"",
            "ctx->i + 1",
            "ctx->nexpected",
            "l->linenum"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "test_subtest_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/test_helper.c",
          "lines": "252-260",
          "snippet": "void\ntest_subtest_info(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvsnprintf(subtest_info, sizeof(subtest_info), fmt, ap);\n\tva_end(ap);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "# include <vis.h>",
            "#include <openssl/bn.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char subtest_info[512];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n# include <vis.h>\n#include <openssl/bn.h>\n#include <signal.h>\n#include <unistd.h>\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char subtest_info[512];\n\nvoid\ntest_subtest_info(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvsnprintf(subtest_info, sizeof(subtest_info), fmt, ap);\n\tva_end(ap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hostfile.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"../test_helper/test_helper.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ncheck(struct hostkey_foreach_line *l, void *_ctx)\n{\n\tstruct cbctx *ctx = (struct cbctx *)_ctx;\n\tconst struct expected *expected;\n\tint parse_key = (ctx->flags & HKF_WANT_PARSE_KEY) != 0;\n\tconst int matching = (ctx->flags & HKF_WANT_MATCH) != 0;\n\tu_int expected_status, expected_match;\n\tint expected_keytype;\n\n\ttest_subtest_info(\"entry %zu/%zu, file line %ld\",\n\t    ctx->i + 1, ctx->nexpected, l->linenum);\n\n\tfor (;;) {\n\t\tASSERT_SIZE_T_LT(ctx->i, ctx->nexpected);\n\t\texpected = ctx->expected + ctx->i++;\n\t\t/* If we are matching host/IP then skip entries that don't */\n\t\tif (!matching)\n\t\t\tbreak;\n\t\tif (ctx->match_host_p && expected->match_host_p)\n\t\t\tbreak;\n\t\tif (ctx->match_host_s && expected->match_host_s)\n\t\t\tbreak;\n\t\tif (ctx->match_ipv4 && expected->match_ipv4)\n\t\t\tbreak;\n\t\tif (ctx->match_ipv6 && expected->match_ipv6)\n\t\t\tbreak;\n\t}\n\texpected_status = (parse_key || expected->no_parse_status < 0) ?\n\t    expected->l.status : (u_int)expected->no_parse_status;\n\texpected_match = expected->l.match;\n#define UPDATE_MATCH_STATUS(x) do { \\\n\t\tif (ctx->x && expected->x) { \\\n\t\t\texpected_match |= expected->x; \\\n\t\t\tif (expected_status == HKF_STATUS_OK) \\\n\t\t\t\texpected_status = HKF_STATUS_MATCHED; \\\n\t\t} \\\n\t} while (0)\n\texpected_keytype = (parse_key || expected->no_parse_keytype < 0) ?\n\t    expected->l.keytype : expected->no_parse_keytype;\n\n#ifndef OPENSSL_HAS_ECC\n\tif (expected->l.keytype == KEY_ECDSA ||\n\t    expected->no_parse_keytype == KEY_ECDSA) {\n\t\texpected_status = HKF_STATUS_INVALID;\n\t\texpected_keytype = KEY_UNSPEC;\n\t\tparse_key = 0;\n\t}\n#endif\n\n\tUPDATE_MATCH_STATUS(match_host_p);\n\tUPDATE_MATCH_STATUS(match_host_s);\n\tUPDATE_MATCH_STATUS(match_ipv4);\n\tUPDATE_MATCH_STATUS(match_ipv6);\n\n\tASSERT_PTR_NE(l->path, NULL); /* Don't care about path */\n\tASSERT_LONG_LONG_EQ(l->linenum, expected->l.linenum);\n\tASSERT_U_INT_EQ(l->status, expected_status);\n\tASSERT_U_INT_EQ(l->match, expected_match);\n\t/* Not all test entries contain fulltext */\n\tif (expected->l.line != NULL)\n\t\tASSERT_STRING_EQ(l->line, expected->l.line);\n\tASSERT_INT_EQ(l->marker, expected->l.marker);\n\t/* XXX we skip hashed hostnames for now; implement checking */\n\tif (expected->l.hosts != NULL)\n\t\tASSERT_STRING_EQ(l->hosts, expected->l.hosts);\n\t/* Not all test entries contain raw keys */\n\tif (expected->l.rawkey != NULL)\n\t\tASSERT_STRING_EQ(l->rawkey, expected->l.rawkey);\n\t/* XXX synthesise raw key for cases lacking and compare */\n\tASSERT_INT_EQ(l->keytype, expected_keytype);\n\tif (parse_key) {\n\t\tif (expected->l.key == NULL)\n\t\t\tASSERT_PTR_EQ(l->key, NULL);\n\t\tif (expected->l.key != NULL) {\n\t\t\tASSERT_PTR_NE(l->key, NULL);\n\t\t\tASSERT_INT_EQ(sshkey_equal(l->key, expected->l.key), 1);\n\t\t}\n\t}\n\tif (parse_key && !(l->comment == NULL && expected->l.comment == NULL))\n\t\tASSERT_STRING_EQ(l->comment, expected->l.comment);\n\treturn 0;\n}"
  }
]