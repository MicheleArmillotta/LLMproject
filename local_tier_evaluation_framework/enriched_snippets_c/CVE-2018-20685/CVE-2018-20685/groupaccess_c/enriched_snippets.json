[
  {
    "function_name": "ga_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/groupaccess.c",
    "lines": "121-133",
    "snippet": "void\nga_free(void)\n{\n\tint i;\n\n\tif (ngroups > 0) {\n\t\tfor (i = 0; i < ngroups; i++)\n\t\t\tfree(groups_byname[i]);\n\t\tngroups = 0;\n\t\tfree(groups_byname);\n\t\tgroups_byname = NULL;\n\t}\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"match.h\"",
      "#include \"groupaccess.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int ngroups;",
      "static char **groups_byname;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "groups_byname"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include \"groupaccess.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int ngroups;\nstatic char **groups_byname;\n\nvoid\nga_free(void)\n{\n\tint i;\n\n\tif (ngroups > 0) {\n\t\tfor (i = 0; i < ngroups; i++)\n\t\t\tfree(groups_byname[i]);\n\t\tngroups = 0;\n\t\tfree(groups_byname);\n\t\tgroups_byname = NULL;\n\t}\n}"
  },
  {
    "function_name": "ga_match_pattern_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/groupaccess.c",
    "lines": "100-116",
    "snippet": "int\nga_match_pattern_list(const char *group_pattern)\n{\n\tint i, found = 0;\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tswitch (match_pattern_list(groups_byname[i], group_pattern, 0)) {\n\t\tcase -1:\n\t\t\treturn 0;\t/* Negated match wins */\n\t\tcase 0:\n\t\t\tcontinue;\n\t\tcase 1:\n\t\t\tfound = 1;\n\t\t}\n\t}\n\treturn found;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"match.h\"",
      "#include \"groupaccess.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int ngroups;",
      "static char **groups_byname;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "match_pattern_list",
          "args": [
            "groups_byname[i]",
            "group_pattern",
            "0"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "match_pattern_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "120-171",
          "snippet": "int\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include \"groupaccess.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int ngroups;\nstatic char **groups_byname;\n\nint\nga_match_pattern_list(const char *group_pattern)\n{\n\tint i, found = 0;\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tswitch (match_pattern_list(groups_byname[i], group_pattern, 0)) {\n\t\tcase -1:\n\t\t\treturn 0;\t/* Negated match wins */\n\t\tcase 0:\n\t\t\tcontinue;\n\t\tcase 1:\n\t\t\tfound = 1;\n\t\t}\n\t}\n\treturn found;\n}"
  },
  {
    "function_name": "ga_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/groupaccess.c",
    "lines": "84-94",
    "snippet": "int\nga_match(char * const *groups, int n)\n{\n\tint i, j;\n\n\tfor (i = 0; i < ngroups; i++)\n\t\tfor (j = 0; j < n; j++)\n\t\t\tif (match_pattern(groups_byname[i], groups[j]))\n\t\t\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"match.h\"",
      "#include \"groupaccess.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int ngroups;",
      "static char **groups_byname;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "match_pattern",
          "args": [
            "groups_byname[i]",
            "groups[j]"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "match_pattern",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "56-112",
          "snippet": "int\nmatch_pattern(const char *s, const char *pattern)\n{\n\tfor (;;) {\n\t\t/* If at end of pattern, accept if also at end of string. */\n\t\tif (!*pattern)\n\t\t\treturn !*s;\n\n\t\tif (*pattern == '*') {\n\t\t\t/* Skip the asterisk. */\n\t\t\tpattern++;\n\n\t\t\t/* If at end of pattern, accept immediately. */\n\t\t\tif (!*pattern)\n\t\t\t\treturn 1;\n\n\t\t\t/* If next character in pattern is known, optimize. */\n\t\t\tif (*pattern != '?' && *pattern != '*') {\n\t\t\t\t/*\n\t\t\t\t * Look instances of the next character in\n\t\t\t\t * pattern, and try to match starting from\n\t\t\t\t * those.\n\t\t\t\t */\n\t\t\t\tfor (; *s; s++)\n\t\t\t\t\tif (*s == *pattern &&\n\t\t\t\t\t    match_pattern(s + 1, pattern + 1))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t/* Failed. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Move ahead one character at a time and try to\n\t\t\t * match at each position.\n\t\t\t */\n\t\t\tfor (; *s; s++)\n\t\t\t\tif (match_pattern(s, pattern))\n\t\t\t\t\treturn 1;\n\t\t\t/* Failed. */\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * There must be at least one more character in the string.\n\t\t * If we are at the end, fail.\n\t\t */\n\t\tif (!*s)\n\t\t\treturn 0;\n\n\t\t/* Check if the next character of the string is acceptable. */\n\t\tif (*pattern != '?' && *pattern != *s)\n\t\t\treturn 0;\n\n\t\t/* Move to the next character, both in string and in pattern. */\n\t\ts++;\n\t\tpattern++;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_pattern(const char *s, const char *pattern)\n{\n\tfor (;;) {\n\t\t/* If at end of pattern, accept if also at end of string. */\n\t\tif (!*pattern)\n\t\t\treturn !*s;\n\n\t\tif (*pattern == '*') {\n\t\t\t/* Skip the asterisk. */\n\t\t\tpattern++;\n\n\t\t\t/* If at end of pattern, accept immediately. */\n\t\t\tif (!*pattern)\n\t\t\t\treturn 1;\n\n\t\t\t/* If next character in pattern is known, optimize. */\n\t\t\tif (*pattern != '?' && *pattern != '*') {\n\t\t\t\t/*\n\t\t\t\t * Look instances of the next character in\n\t\t\t\t * pattern, and try to match starting from\n\t\t\t\t * those.\n\t\t\t\t */\n\t\t\t\tfor (; *s; s++)\n\t\t\t\t\tif (*s == *pattern &&\n\t\t\t\t\t    match_pattern(s + 1, pattern + 1))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t/* Failed. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Move ahead one character at a time and try to\n\t\t\t * match at each position.\n\t\t\t */\n\t\t\tfor (; *s; s++)\n\t\t\t\tif (match_pattern(s, pattern))\n\t\t\t\t\treturn 1;\n\t\t\t/* Failed. */\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * There must be at least one more character in the string.\n\t\t * If we are at the end, fail.\n\t\t */\n\t\tif (!*s)\n\t\t\treturn 0;\n\n\t\t/* Check if the next character of the string is acceptable. */\n\t\tif (*pattern != '?' && *pattern != *s)\n\t\t\treturn 0;\n\n\t\t/* Move to the next character, both in string and in pattern. */\n\t\ts++;\n\t\tpattern++;\n\t}\n\t/* NOTREACHED */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include \"groupaccess.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int ngroups;\nstatic char **groups_byname;\n\nint\nga_match(char * const *groups, int n)\n{\n\tint i, j;\n\n\tfor (i = 0; i < ngroups; i++)\n\t\tfor (j = 0; j < n; j++)\n\t\t\tif (match_pattern(groups_byname[i], groups[j]))\n\t\t\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ga_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/groupaccess.c",
    "lines": "49-78",
    "snippet": "int\nga_init(const char *user, gid_t base)\n{\n\tgid_t *groups_bygid;\n\tint i, j, retry = 0;\n\tstruct group *gr;\n\n\tif (ngroups > 0)\n\t\tga_free();\n\n\tngroups = NGROUPS_MAX;\n#if defined(HAVE_SYSCONF) && defined(_SC_NGROUPS_MAX)\n\tngroups = MAX(NGROUPS_MAX, sysconf(_SC_NGROUPS_MAX));\n#endif\n\n\tgroups_bygid = xcalloc(ngroups, sizeof(*groups_bygid));\n\twhile (getgrouplist(user, base, groups_bygid, &ngroups) == -1) {\n\t\tif (retry++ > 0)\n\t\t\tfatal(\"getgrouplist: groups list too small\");\n\t\tgroups_bygid = xreallocarray(groups_bygid, ngroups,\n\t\t    sizeof(*groups_bygid));\n\t}\n\tgroups_byname = xcalloc(ngroups, sizeof(*groups_byname));\n\n\tfor (i = 0, j = 0; i < ngroups; i++)\n\t\tif ((gr = getgrgid(groups_bygid[i])) != NULL)\n\t\t\tgroups_byname[j++] = xstrdup(gr->gr_name);\n\tfree(groups_bygid);\n\treturn (ngroups = j);\n}",
    "includes": [
      "#include \"log.h\"",
      "#include \"match.h\"",
      "#include \"groupaccess.h\"",
      "#include \"xmalloc.h\"",
      "#include <limits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int ngroups;",
      "static char **groups_byname;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "groups_bygid"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "gr->gr_name"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getgrgid",
          "args": [
            "groups_bygid[i]"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "ngroups",
            "sizeof(*groups_byname)"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xreallocarray",
          "args": [
            "groups_bygid",
            "ngroups",
            "sizeof(*groups_bygid)"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "xreallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "68-78",
          "snippet": "void *\nxreallocarray(void *ptr, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = reallocarray(ptr, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xreallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxreallocarray(void *ptr, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = reallocarray(ptr, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xreallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"getgrouplist: groups list too small\""
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getgrouplist",
          "args": [
            "user",
            "base",
            "groups_bygid",
            "&ngroups"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "getgrouplist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "439-477",
          "snippet": "int\ngetgrouplist(const char *user, gid_t pgid, gid_t *groups, int *grpcnt)\n{\n\tchar *cp, *grplist, *grp;\n\tgid_t gid;\n\tint ret = 0, ngroups = 0, maxgroups;\n\tlong l;\n\n\tmaxgroups = *grpcnt;\n\n\tif ((cp = grplist = getgrset(user)) == NULL)\n\t\treturn -1;\n\n\t/* handle zero-length case */\n\tif (maxgroups <= 0) {\n\t\t*grpcnt = 0;\n\t\treturn -1;\n\t}\n\n\t/* copy primary group */\n\tgroups[ngroups++] = pgid;\n\n\t/* copy each entry from getgrset into group list */\n\twhile ((grp = strsep(&grplist, \",\")) != NULL) {\n\t\tl = strtol(grp, NULL, 10);\n\t\tif (ngroups >= maxgroups || l == LONG_MIN || l == LONG_MAX) {\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tgid = (gid_t)l;\n\t\tif (gid == pgid)\n\t\t\tcontinue;\t/* we have already added primary gid */\n\t\tgroups[ngroups++] = gid;\n\t}\nout:\n\tfree(cp);\n\t*grpcnt = ngroups;\n\treturn ret;\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nint\ngetgrouplist(const char *user, gid_t pgid, gid_t *groups, int *grpcnt)\n{\n\tchar *cp, *grplist, *grp;\n\tgid_t gid;\n\tint ret = 0, ngroups = 0, maxgroups;\n\tlong l;\n\n\tmaxgroups = *grpcnt;\n\n\tif ((cp = grplist = getgrset(user)) == NULL)\n\t\treturn -1;\n\n\t/* handle zero-length case */\n\tif (maxgroups <= 0) {\n\t\t*grpcnt = 0;\n\t\treturn -1;\n\t}\n\n\t/* copy primary group */\n\tgroups[ngroups++] = pgid;\n\n\t/* copy each entry from getgrset into group list */\n\twhile ((grp = strsep(&grplist, \",\")) != NULL) {\n\t\tl = strtol(grp, NULL, 10);\n\t\tif (ngroups >= maxgroups || l == LONG_MIN || l == LONG_MAX) {\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tgid = (gid_t)l;\n\t\tif (gid == pgid)\n\t\t\tcontinue;\t/* we have already added primary gid */\n\t\tgroups[ngroups++] = gid;\n\t}\nout:\n\tfree(cp);\n\t*grpcnt = ngroups;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "NGROUPS_MAX",
            "sysconf(_SC_NGROUPS_MAX)"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "_SPLAY_MINMAX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/sys-tree.h",
          "lines": "247-278",
          "snippet": "void name##_SPLAY_MINMAX(struct name *head, int __comp) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct type __node, *__left, *__right, *__tmp;\t\t\t\\\n\\\n\tSPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\\\n\t__left = __right = &__node;\t\t\t\t\t\\\n\\\n\twhile (1) {\t\t\t\t\t\t\t\\\n\t\tif (__comp < 0) {\t\t\t\t\t\\\n\t\t\t__tmp = SPLAY_LEFT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp < 0){\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_RIGHT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_LEFT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKLEFT(head, __right, field);\t\t\\\n\t\t} else if (__comp > 0) {\t\t\t\t\\\n\t\t\t__tmp = SPLAY_RIGHT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp > 0) {\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_LEFT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_RIGHT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKRIGHT(head, __left, field);\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tSPLAY_ASSEMBLE(head, &__node, __left, __right, field);\t\t\\\n}",
          "includes": [
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n\nvoid name##_SPLAY_MINMAX(struct name *head, int __comp) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct type __node, *__left, *__right, *__tmp;\t\t\t\\\n\\\n\tSPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\\\n\t__left = __right = &__node;\t\t\t\t\t\\\n\\\n\twhile (1) {\t\t\t\t\t\t\t\\\n\t\tif (__comp < 0) {\t\t\t\t\t\\\n\t\t\t__tmp = SPLAY_LEFT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp < 0){\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_RIGHT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_LEFT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKLEFT(head, __right, field);\t\t\\\n\t\t} else if (__comp > 0) {\t\t\t\t\\\n\t\t\t__tmp = SPLAY_RIGHT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp > 0) {\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_LEFT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_RIGHT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKRIGHT(head, __left, field);\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tSPLAY_ASSEMBLE(head, &__node, __left, __right, field);\t\t\\\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysconf",
          "args": [
            "_SC_NGROUPS_MAX"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ga_free",
          "args": [],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "ga_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/groupaccess.c",
          "lines": "121-133",
          "snippet": "void\nga_free(void)\n{\n\tint i;\n\n\tif (ngroups > 0) {\n\t\tfor (i = 0; i < ngroups; i++)\n\t\t\tfree(groups_byname[i]);\n\t\tngroups = 0;\n\t\tfree(groups_byname);\n\t\tgroups_byname = NULL;\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include \"groupaccess.h\"",
            "#include \"xmalloc.h\"",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int ngroups;",
            "static char **groups_byname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include \"groupaccess.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int ngroups;\nstatic char **groups_byname;\n\nvoid\nga_free(void)\n{\n\tint i;\n\n\tif (ngroups > 0) {\n\t\tfor (i = 0; i < ngroups; i++)\n\t\t\tfree(groups_byname[i]);\n\t\tngroups = 0;\n\t\tfree(groups_byname);\n\t\tgroups_byname = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include \"groupaccess.h\"\n#include \"xmalloc.h\"\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int ngroups;\nstatic char **groups_byname;\n\nint\nga_init(const char *user, gid_t base)\n{\n\tgid_t *groups_bygid;\n\tint i, j, retry = 0;\n\tstruct group *gr;\n\n\tif (ngroups > 0)\n\t\tga_free();\n\n\tngroups = NGROUPS_MAX;\n#if defined(HAVE_SYSCONF) && defined(_SC_NGROUPS_MAX)\n\tngroups = MAX(NGROUPS_MAX, sysconf(_SC_NGROUPS_MAX));\n#endif\n\n\tgroups_bygid = xcalloc(ngroups, sizeof(*groups_bygid));\n\twhile (getgrouplist(user, base, groups_bygid, &ngroups) == -1) {\n\t\tif (retry++ > 0)\n\t\t\tfatal(\"getgrouplist: groups list too small\");\n\t\tgroups_bygid = xreallocarray(groups_bygid, ngroups,\n\t\t    sizeof(*groups_bygid));\n\t}\n\tgroups_byname = xcalloc(ngroups, sizeof(*groups_byname));\n\n\tfor (i = 0, j = 0; i < ngroups; i++)\n\t\tif ((gr = getgrgid(groups_bygid[i])) != NULL)\n\t\t\tgroups_byname[j++] = xstrdup(gr->gr_name);\n\tfree(groups_bygid);\n\treturn (ngroups = j);\n}"
  }
]