[
  {
    "function_name": "b64_pton",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/base64.c",
    "lines": "196-312",
    "snippet": "int\nb64_pton(char const *src, u_char *target, size_t targsize)\n{\n\tu_int tarindex, state;\n\tint ch;\n\tchar *pos;\n\n\tstate = 0;\n\ttarindex = 0;\n\n\twhile ((ch = *src++) != '\\0') {\n\t\tif (isspace(ch))\t/* Skip whitespace anywhere. */\n\t\t\tcontinue;\n\n\t\tif (ch == Pad64)\n\t\t\tbreak;\n\n\t\tpos = strchr(Base64, ch);\n\t\tif (pos == 0) \t\t/* A non-base64 character. */\n\t\t\treturn (-1);\n\n\t\tswitch (state) {\n\t\tcase 0:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex] = (pos - Base64) << 2;\n\t\t\t}\n\t\t\tstate = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex + 1 >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex]   |=  (pos - Base64) >> 4;\n\t\t\t\ttarget[tarindex+1]  = ((pos - Base64) & 0x0f)\n\t\t\t\t\t\t\t<< 4 ;\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex + 1 >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex]   |=  (pos - Base64) >> 2;\n\t\t\t\ttarget[tarindex+1]  = ((pos - Base64) & 0x03)\n\t\t\t\t\t\t\t<< 6;\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 3;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex] |= (pos - Base64);\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * We are done decoding Base-64 chars.  Let's see if we ended\n\t * on a byte boundary, and/or with erroneous trailing characters.\n\t */\n\n\tif (ch == Pad64) {\t\t/* We got a pad char. */\n\t\tch = *src++;\t\t/* Skip it, get next. */\n\t\tswitch (state) {\n\t\tcase 0:\t\t/* Invalid = in first position */\n\t\tcase 1:\t\t/* Invalid = in second position */\n\t\t\treturn (-1);\n\n\t\tcase 2:\t\t/* Valid, means one byte of info */\n\t\t\t/* Skip any number of spaces. */\n\t\t\tfor (; ch != '\\0'; ch = *src++)\n\t\t\t\tif (!isspace(ch))\n\t\t\t\t\tbreak;\n\t\t\t/* Make sure there is another trailing = sign. */\n\t\t\tif (ch != Pad64)\n\t\t\t\treturn (-1);\n\t\t\tch = *src++;\t\t/* Skip the = */\n\t\t\t/* Fall through to \"single trailing =\" case. */\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase 3:\t\t/* Valid, means two bytes of info */\n\t\t\t/*\n\t\t\t * We know this char is an =.  Is there anything but\n\t\t\t * whitespace after it?\n\t\t\t */\n\t\t\tfor (; ch != '\\0'; ch = *src++)\n\t\t\t\tif (!isspace(ch))\n\t\t\t\t\treturn (-1);\n\n\t\t\t/*\n\t\t\t * Now make sure for cases 2 and 3 that the \"extra\"\n\t\t\t * bits that slopped past the last full byte were\n\t\t\t * zeros.  If we don't check them, they become a\n\t\t\t * subliminal channel.\n\t\t\t */\n\t\t\tif (target && target[tarindex] != 0)\n\t\t\t\treturn (-1);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We ended by seeing the end of the string.  Make sure we\n\t\t * have no partial bytes lying around.\n\t\t */\n\t\tif (state != 0)\n\t\t\treturn (-1);\n\t}\n\n\treturn (tarindex);\n}",
    "includes": [
      "#include \"base64.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "ch"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "ch"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "Base64",
            "ch"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "ch"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"base64.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nb64_pton(char const *src, u_char *target, size_t targsize)\n{\n\tu_int tarindex, state;\n\tint ch;\n\tchar *pos;\n\n\tstate = 0;\n\ttarindex = 0;\n\n\twhile ((ch = *src++) != '\\0') {\n\t\tif (isspace(ch))\t/* Skip whitespace anywhere. */\n\t\t\tcontinue;\n\n\t\tif (ch == Pad64)\n\t\t\tbreak;\n\n\t\tpos = strchr(Base64, ch);\n\t\tif (pos == 0) \t\t/* A non-base64 character. */\n\t\t\treturn (-1);\n\n\t\tswitch (state) {\n\t\tcase 0:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex] = (pos - Base64) << 2;\n\t\t\t}\n\t\t\tstate = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex + 1 >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex]   |=  (pos - Base64) >> 4;\n\t\t\t\ttarget[tarindex+1]  = ((pos - Base64) & 0x0f)\n\t\t\t\t\t\t\t<< 4 ;\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex + 1 >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex]   |=  (pos - Base64) >> 2;\n\t\t\t\ttarget[tarindex+1]  = ((pos - Base64) & 0x03)\n\t\t\t\t\t\t\t<< 6;\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 3;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex] |= (pos - Base64);\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * We are done decoding Base-64 chars.  Let's see if we ended\n\t * on a byte boundary, and/or with erroneous trailing characters.\n\t */\n\n\tif (ch == Pad64) {\t\t/* We got a pad char. */\n\t\tch = *src++;\t\t/* Skip it, get next. */\n\t\tswitch (state) {\n\t\tcase 0:\t\t/* Invalid = in first position */\n\t\tcase 1:\t\t/* Invalid = in second position */\n\t\t\treturn (-1);\n\n\t\tcase 2:\t\t/* Valid, means one byte of info */\n\t\t\t/* Skip any number of spaces. */\n\t\t\tfor (; ch != '\\0'; ch = *src++)\n\t\t\t\tif (!isspace(ch))\n\t\t\t\t\tbreak;\n\t\t\t/* Make sure there is another trailing = sign. */\n\t\t\tif (ch != Pad64)\n\t\t\t\treturn (-1);\n\t\t\tch = *src++;\t\t/* Skip the = */\n\t\t\t/* Fall through to \"single trailing =\" case. */\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase 3:\t\t/* Valid, means two bytes of info */\n\t\t\t/*\n\t\t\t * We know this char is an =.  Is there anything but\n\t\t\t * whitespace after it?\n\t\t\t */\n\t\t\tfor (; ch != '\\0'; ch = *src++)\n\t\t\t\tif (!isspace(ch))\n\t\t\t\t\treturn (-1);\n\n\t\t\t/*\n\t\t\t * Now make sure for cases 2 and 3 that the \"extra\"\n\t\t\t * bits that slopped past the last full byte were\n\t\t\t * zeros.  If we don't check them, they become a\n\t\t\t * subliminal channel.\n\t\t\t */\n\t\t\tif (target && target[tarindex] != 0)\n\t\t\t\treturn (-1);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We ended by seeing the end of the string.  Make sure we\n\t\t * have no partial bytes lying around.\n\t\t */\n\t\tif (state != 0)\n\t\t\treturn (-1);\n\t}\n\n\treturn (tarindex);\n}"
  },
  {
    "function_name": "b64_ntop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/base64.c",
    "lines": "133-185",
    "snippet": "int\nb64_ntop(u_char const *src, size_t srclength, char *target, size_t targsize)\n{\n\tsize_t datalength = 0;\n\tu_char input[3];\n\tu_char output[4];\n\tu_int i;\n\n\twhile (2 < srclength) {\n\t\tinput[0] = *src++;\n\t\tinput[1] = *src++;\n\t\tinput[2] = *src++;\n\t\tsrclength -= 3;\n\n\t\toutput[0] = input[0] >> 2;\n\t\toutput[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);\n\t\toutput[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);\n\t\toutput[3] = input[2] & 0x3f;\n\n\t\tif (datalength + 4 > targsize)\n\t\t\treturn (-1);\n\t\ttarget[datalength++] = Base64[output[0]];\n\t\ttarget[datalength++] = Base64[output[1]];\n\t\ttarget[datalength++] = Base64[output[2]];\n\t\ttarget[datalength++] = Base64[output[3]];\n\t}\n    \n\t/* Now we worry about padding. */\n\tif (0 != srclength) {\n\t\t/* Get what's left. */\n\t\tinput[0] = input[1] = input[2] = '\\0';\n\t\tfor (i = 0; i < srclength; i++)\n\t\t\tinput[i] = *src++;\n\t\n\t\toutput[0] = input[0] >> 2;\n\t\toutput[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);\n\t\toutput[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);\n\n\t\tif (datalength + 4 > targsize)\n\t\t\treturn (-1);\n\t\ttarget[datalength++] = Base64[output[0]];\n\t\ttarget[datalength++] = Base64[output[1]];\n\t\tif (srclength == 1)\n\t\t\ttarget[datalength++] = Pad64;\n\t\telse\n\t\t\ttarget[datalength++] = Base64[output[2]];\n\t\ttarget[datalength++] = Pad64;\n\t}\n\tif (datalength >= targsize)\n\t\treturn (-1);\n\ttarget[datalength] = '\\0';\t/* Returned value doesn't count \\0. */\n\treturn (datalength);\n}",
    "includes": [
      "#include \"base64.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"base64.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nb64_ntop(u_char const *src, size_t srclength, char *target, size_t targsize)\n{\n\tsize_t datalength = 0;\n\tu_char input[3];\n\tu_char output[4];\n\tu_int i;\n\n\twhile (2 < srclength) {\n\t\tinput[0] = *src++;\n\t\tinput[1] = *src++;\n\t\tinput[2] = *src++;\n\t\tsrclength -= 3;\n\n\t\toutput[0] = input[0] >> 2;\n\t\toutput[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);\n\t\toutput[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);\n\t\toutput[3] = input[2] & 0x3f;\n\n\t\tif (datalength + 4 > targsize)\n\t\t\treturn (-1);\n\t\ttarget[datalength++] = Base64[output[0]];\n\t\ttarget[datalength++] = Base64[output[1]];\n\t\ttarget[datalength++] = Base64[output[2]];\n\t\ttarget[datalength++] = Base64[output[3]];\n\t}\n    \n\t/* Now we worry about padding. */\n\tif (0 != srclength) {\n\t\t/* Get what's left. */\n\t\tinput[0] = input[1] = input[2] = '\\0';\n\t\tfor (i = 0; i < srclength; i++)\n\t\t\tinput[i] = *src++;\n\t\n\t\toutput[0] = input[0] >> 2;\n\t\toutput[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);\n\t\toutput[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);\n\n\t\tif (datalength + 4 > targsize)\n\t\t\treturn (-1);\n\t\ttarget[datalength++] = Base64[output[0]];\n\t\ttarget[datalength++] = Base64[output[1]];\n\t\tif (srclength == 1)\n\t\t\ttarget[datalength++] = Pad64;\n\t\telse\n\t\t\ttarget[datalength++] = Base64[output[2]];\n\t\ttarget[datalength++] = Pad64;\n\t}\n\tif (datalength >= targsize)\n\t\treturn (-1);\n\ttarget[datalength] = '\\0';\t/* Returned value doesn't count \\0. */\n\treturn (datalength);\n}"
  }
]