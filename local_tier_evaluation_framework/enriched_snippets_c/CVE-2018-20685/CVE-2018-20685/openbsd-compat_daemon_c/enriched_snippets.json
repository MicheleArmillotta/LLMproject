[
  {
    "function_name": "daemon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/daemon.c",
    "lines": "51-79",
    "snippet": "int\ndaemon(int nochdir, int noclose)\n{\n\tint fd;\n\n\tswitch (fork()) {\n\tcase -1:\n\t\treturn (-1);\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\t_exit(0);\n\t}\n\n\tif (setsid() == -1)\n\t\treturn (-1);\n\n\tif (!nochdir)\n\t\t(void)chdir(\"/\");\n\n\tif (!noclose && (fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {\n\t\t(void)dup2(fd, STDIN_FILENO);\n\t\t(void)dup2(fd, STDOUT_FILENO);\n\t\t(void)dup2(fd, STDERR_FILENO);\n\t\tif (fd > 2)\n\t\t\t(void)close (fd);\n\t}\n\treturn (0);\n}",
    "includes": [
      "# include <unistd.h>",
      "# include <fcntl.h>",
      "# include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "closefrom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-closefrom.c",
          "lines": "68-107",
          "snippet": "void\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}",
          "includes": [
            "#  include <ndir.h>",
            "#  include <sys/dir.h>",
            "#  include <sys/ndir.h>",
            "# include <dirent.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "# include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <ndir.h>\n#  include <sys/dir.h>\n#  include <sys/ndir.h>\n# include <dirent.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <limits.h>\n# include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd",
            "STDERR_FILENO"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd",
            "STDOUT_FILENO"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd",
            "STDIN_FILENO"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "_PATH_DEVNULL",
            "O_RDWR",
            "0"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "binary_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-cygwin_util.c",
          "lines": "43-53",
          "snippet": "int\nbinary_open(const char *filename, int flags, ...)\n{\n\tva_list ap;\n\tmode_t mode;\n\n\tva_start(ap, flags);\n\tmode = va_arg(ap, mode_t);\n\tva_end(ap);\n\treturn (open(filename, flags | O_BINARY, mode));\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nbinary_open(const char *filename, int flags, ...)\n{\n\tva_list ap;\n\tmode_t mode;\n\n\tva_start(ap, flags);\n\tmode = va_arg(ap, mode_t);\n\tva_end(ap);\n\treturn (open(filename, flags | O_BINARY, mode));\n}"
        }
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "\"/\""
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsid",
          "args": [],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "0"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "solaris_contract_pre_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-solaris.c",
          "lines": "75-122",
          "snippet": "void\nsolaris_contract_pre_fork(void)\n{\n\tif ((tmpl_fd = open64(CT_TEMPLATE, O_RDWR)) == -1) {\n\t\terror(\"%s: open %s: %s\", __func__,\n\t\t    CT_TEMPLATE, strerror(errno));\n\t\treturn;\n\t}\n\n\tdebug2(\"%s: setting up process contract template on fd %d\",\n\t    __func__, tmpl_fd);\n\n\t/* First we set the template parameters and event sets. */\n\tif (ct_pr_tmpl_set_param(tmpl_fd, CT_PR_PGRPONLY) != 0) {\n\t\terror(\"%s: Error setting process contract parameter set \"\n\t\t    \"(pgrponly): %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\tif (ct_pr_tmpl_set_fatal(tmpl_fd, CT_PR_EV_HWERR) != 0) {\n\t\terror(\"%s: Error setting process contract template \"\n\t\t    \"fatal events: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\tif (ct_tmpl_set_critical(tmpl_fd, 0) != 0) {\n\t\terror(\"%s: Error setting process contract template \"\n\t\t    \"critical events: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\tif (ct_tmpl_set_informative(tmpl_fd, CT_PR_EV_HWERR) != 0) {\n\t\terror(\"%s: Error setting process contract template \"\n\t\t    \"informative events: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\n\t/* Now make this the active template for this process. */\n\tif (ct_tmpl_activate(tmpl_fd) != 0) {\n\t\terror(\"%s: Error activating process contract \"\n\t\t    \"template: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\treturn;\n\n fail:\n\tif (tmpl_fd != -1) {\n\t\tclose(tmpl_fd);\n\t\ttmpl_fd = -1;\n\t}\n}",
          "includes": [
            "#  include <priv.h>",
            "#include <project.h>",
            "#include <sys/task.h>",
            "#include \"log.h\"",
            "#include <sys/ctfs.h>",
            "#include <sys/contract/process.h>",
            "#include <libcontract.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "# include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CT_TEMPLATE\tCTFS_ROOT \"/process/template\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <priv.h>\n#include <project.h>\n#include <sys/task.h>\n#include \"log.h\"\n#include <sys/ctfs.h>\n#include <sys/contract/process.h>\n#include <libcontract.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n# include <fcntl.h>\n#include <errno.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n#include \"config.h\"\n\n#define CT_TEMPLATE\tCTFS_ROOT \"/process/template\"\n\nvoid\nsolaris_contract_pre_fork(void)\n{\n\tif ((tmpl_fd = open64(CT_TEMPLATE, O_RDWR)) == -1) {\n\t\terror(\"%s: open %s: %s\", __func__,\n\t\t    CT_TEMPLATE, strerror(errno));\n\t\treturn;\n\t}\n\n\tdebug2(\"%s: setting up process contract template on fd %d\",\n\t    __func__, tmpl_fd);\n\n\t/* First we set the template parameters and event sets. */\n\tif (ct_pr_tmpl_set_param(tmpl_fd, CT_PR_PGRPONLY) != 0) {\n\t\terror(\"%s: Error setting process contract parameter set \"\n\t\t    \"(pgrponly): %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\tif (ct_pr_tmpl_set_fatal(tmpl_fd, CT_PR_EV_HWERR) != 0) {\n\t\terror(\"%s: Error setting process contract template \"\n\t\t    \"fatal events: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\tif (ct_tmpl_set_critical(tmpl_fd, 0) != 0) {\n\t\terror(\"%s: Error setting process contract template \"\n\t\t    \"critical events: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\tif (ct_tmpl_set_informative(tmpl_fd, CT_PR_EV_HWERR) != 0) {\n\t\terror(\"%s: Error setting process contract template \"\n\t\t    \"informative events: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\n\t/* Now make this the active template for this process. */\n\tif (ct_tmpl_activate(tmpl_fd) != 0) {\n\t\terror(\"%s: Error activating process contract \"\n\t\t    \"template: %s\", __func__, strerror(errno));\n\t\tgoto fail;\n\t}\n\treturn;\n\n fail:\n\tif (tmpl_fd != -1) {\n\t\tclose(tmpl_fd);\n\t\ttmpl_fd = -1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "# include <unistd.h>\n# include <fcntl.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ndaemon(int nochdir, int noclose)\n{\n\tint fd;\n\n\tswitch (fork()) {\n\tcase -1:\n\t\treturn (-1);\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\t_exit(0);\n\t}\n\n\tif (setsid() == -1)\n\t\treturn (-1);\n\n\tif (!nochdir)\n\t\t(void)chdir(\"/\");\n\n\tif (!noclose && (fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {\n\t\t(void)dup2(fd, STDIN_FILENO);\n\t\t(void)dup2(fd, STDOUT_FILENO);\n\t\t(void)dup2(fd, STDERR_FILENO);\n\t\tif (fd > 2)\n\t\t\t(void)close (fd);\n\t}\n\treturn (0);\n}"
  }
]