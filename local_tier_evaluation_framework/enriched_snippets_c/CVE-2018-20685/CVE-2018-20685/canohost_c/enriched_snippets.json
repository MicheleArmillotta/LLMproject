[
  {
    "function_name": "get_local_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
    "lines": "200-204",
    "snippet": "int\nget_local_port(int sock)\n{\n\treturn get_sock_port(sock, 1);\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"canohost.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_sock_port",
          "args": [
            "sock",
            "1"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "get_sock_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "155-192",
          "snippet": "static int\nget_sock_port(int sock, int local)\n{\n\tstruct sockaddr_storage from;\n\tsocklen_t fromlen;\n\tchar strport[NI_MAXSERV];\n\tint r;\n\n\t/* Get IP address of client. */\n\tfromlen = sizeof(from);\n\tmemset(&from, 0, sizeof(from));\n\tif (local) {\n\t\tif (getsockname(sock, (struct sockaddr *)&from, &fromlen) < 0) {\n\t\t\terror(\"getsockname failed: %.100s\", strerror(errno));\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (getpeername(sock, (struct sockaddr *)&from, &fromlen) < 0) {\n\t\t\tdebug(\"getpeername failed: %.100s\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (from.ss_family == AF_INET6)\n\t\tfromlen = sizeof(struct sockaddr_in6);\n\n\t/* Non-inet sockets don't have a port number. */\n\tif (from.ss_family != AF_INET && from.ss_family != AF_INET6)\n\t\treturn 0;\n\n\t/* Return port number. */\n\tif ((r = getnameinfo((struct sockaddr *)&from, fromlen, NULL, 0,\n\t    strport, sizeof(strport), NI_NUMERICSERV)) != 0)\n\t\tfatal(\"%s: getnameinfo NI_NUMERICSERV failed: %s\", __func__,\n\t\t    ssh_gai_strerror(r));\n\treturn atoi(strport);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nget_sock_port(int sock, int local)\n{\n\tstruct sockaddr_storage from;\n\tsocklen_t fromlen;\n\tchar strport[NI_MAXSERV];\n\tint r;\n\n\t/* Get IP address of client. */\n\tfromlen = sizeof(from);\n\tmemset(&from, 0, sizeof(from));\n\tif (local) {\n\t\tif (getsockname(sock, (struct sockaddr *)&from, &fromlen) < 0) {\n\t\t\terror(\"getsockname failed: %.100s\", strerror(errno));\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (getpeername(sock, (struct sockaddr *)&from, &fromlen) < 0) {\n\t\t\tdebug(\"getpeername failed: %.100s\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (from.ss_family == AF_INET6)\n\t\tfromlen = sizeof(struct sockaddr_in6);\n\n\t/* Non-inet sockets don't have a port number. */\n\tif (from.ss_family != AF_INET && from.ss_family != AF_INET6)\n\t\treturn 0;\n\n\t/* Return port number. */\n\tif ((r = getnameinfo((struct sockaddr *)&from, fromlen, NULL, 0,\n\t    strport, sizeof(strport), NI_NUMERICSERV)) != 0)\n\t\tfatal(\"%s: getnameinfo NI_NUMERICSERV failed: %s\", __func__,\n\t\t    ssh_gai_strerror(r));\n\treturn atoi(strport);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nget_local_port(int sock)\n{\n\treturn get_sock_port(sock, 1);\n}"
  },
  {
    "function_name": "get_peer_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
    "lines": "194-198",
    "snippet": "int\nget_peer_port(int sock)\n{\n\treturn get_sock_port(sock, 0);\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"canohost.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_sock_port",
          "args": [
            "sock",
            "0"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "get_sock_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "155-192",
          "snippet": "static int\nget_sock_port(int sock, int local)\n{\n\tstruct sockaddr_storage from;\n\tsocklen_t fromlen;\n\tchar strport[NI_MAXSERV];\n\tint r;\n\n\t/* Get IP address of client. */\n\tfromlen = sizeof(from);\n\tmemset(&from, 0, sizeof(from));\n\tif (local) {\n\t\tif (getsockname(sock, (struct sockaddr *)&from, &fromlen) < 0) {\n\t\t\terror(\"getsockname failed: %.100s\", strerror(errno));\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (getpeername(sock, (struct sockaddr *)&from, &fromlen) < 0) {\n\t\t\tdebug(\"getpeername failed: %.100s\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (from.ss_family == AF_INET6)\n\t\tfromlen = sizeof(struct sockaddr_in6);\n\n\t/* Non-inet sockets don't have a port number. */\n\tif (from.ss_family != AF_INET && from.ss_family != AF_INET6)\n\t\treturn 0;\n\n\t/* Return port number. */\n\tif ((r = getnameinfo((struct sockaddr *)&from, fromlen, NULL, 0,\n\t    strport, sizeof(strport), NI_NUMERICSERV)) != 0)\n\t\tfatal(\"%s: getnameinfo NI_NUMERICSERV failed: %s\", __func__,\n\t\t    ssh_gai_strerror(r));\n\treturn atoi(strport);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nget_sock_port(int sock, int local)\n{\n\tstruct sockaddr_storage from;\n\tsocklen_t fromlen;\n\tchar strport[NI_MAXSERV];\n\tint r;\n\n\t/* Get IP address of client. */\n\tfromlen = sizeof(from);\n\tmemset(&from, 0, sizeof(from));\n\tif (local) {\n\t\tif (getsockname(sock, (struct sockaddr *)&from, &fromlen) < 0) {\n\t\t\terror(\"getsockname failed: %.100s\", strerror(errno));\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (getpeername(sock, (struct sockaddr *)&from, &fromlen) < 0) {\n\t\t\tdebug(\"getpeername failed: %.100s\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (from.ss_family == AF_INET6)\n\t\tfromlen = sizeof(struct sockaddr_in6);\n\n\t/* Non-inet sockets don't have a port number. */\n\tif (from.ss_family != AF_INET && from.ss_family != AF_INET6)\n\t\treturn 0;\n\n\t/* Return port number. */\n\tif ((r = getnameinfo((struct sockaddr *)&from, fromlen, NULL, 0,\n\t    strport, sizeof(strport), NI_NUMERICSERV)) != 0)\n\t\tfatal(\"%s: getnameinfo NI_NUMERICSERV failed: %s\", __func__,\n\t\t    ssh_gai_strerror(r));\n\treturn atoi(strport);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nget_peer_port(int sock)\n{\n\treturn get_sock_port(sock, 0);\n}"
  },
  {
    "function_name": "get_sock_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
    "lines": "155-192",
    "snippet": "static int\nget_sock_port(int sock, int local)\n{\n\tstruct sockaddr_storage from;\n\tsocklen_t fromlen;\n\tchar strport[NI_MAXSERV];\n\tint r;\n\n\t/* Get IP address of client. */\n\tfromlen = sizeof(from);\n\tmemset(&from, 0, sizeof(from));\n\tif (local) {\n\t\tif (getsockname(sock, (struct sockaddr *)&from, &fromlen) < 0) {\n\t\t\terror(\"getsockname failed: %.100s\", strerror(errno));\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (getpeername(sock, (struct sockaddr *)&from, &fromlen) < 0) {\n\t\t\tdebug(\"getpeername failed: %.100s\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (from.ss_family == AF_INET6)\n\t\tfromlen = sizeof(struct sockaddr_in6);\n\n\t/* Non-inet sockets don't have a port number. */\n\tif (from.ss_family != AF_INET && from.ss_family != AF_INET6)\n\t\treturn 0;\n\n\t/* Return port number. */\n\tif ((r = getnameinfo((struct sockaddr *)&from, fromlen, NULL, 0,\n\t    strport, sizeof(strport), NI_NUMERICSERV)) != 0)\n\t\tfatal(\"%s: getnameinfo NI_NUMERICSERV failed: %s\", __func__,\n\t\t    ssh_gai_strerror(r));\n\treturn atoi(strport);\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"canohost.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "strport"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: getnameinfo NI_NUMERICSERV failed: %s\"",
            "__func__",
            "ssh_gai_strerror(r)"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_gai_strerror",
          "args": [
            "r"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getnameinfo",
          "args": [
            "(struct sockaddr *)&from",
            "fromlen",
            "NULL",
            "0",
            "strport",
            "sizeof(strport)",
            "NI_NUMERICSERV"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "sshaix_getnameinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "415-434",
          "snippet": "int\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nint\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"getpeername failed: %.100s\"",
            "strerror(errno)"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpeername",
          "args": [
            "sock",
            "(struct sockaddr *)&from",
            "&fromlen"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"getsockname failed: %.100s\"",
            "strerror(errno)"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getsockname",
          "args": [
            "sock",
            "(struct sockaddr *)&from",
            "&fromlen"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&from",
            "0",
            "sizeof(from)"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nget_sock_port(int sock, int local)\n{\n\tstruct sockaddr_storage from;\n\tsocklen_t fromlen;\n\tchar strport[NI_MAXSERV];\n\tint r;\n\n\t/* Get IP address of client. */\n\tfromlen = sizeof(from);\n\tmemset(&from, 0, sizeof(from));\n\tif (local) {\n\t\tif (getsockname(sock, (struct sockaddr *)&from, &fromlen) < 0) {\n\t\t\terror(\"getsockname failed: %.100s\", strerror(errno));\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (getpeername(sock, (struct sockaddr *)&from, &fromlen) < 0) {\n\t\t\tdebug(\"getpeername failed: %.100s\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (from.ss_family == AF_INET6)\n\t\tfromlen = sizeof(struct sockaddr_in6);\n\n\t/* Non-inet sockets don't have a port number. */\n\tif (from.ss_family != AF_INET && from.ss_family != AF_INET6)\n\t\treturn 0;\n\n\t/* Return port number. */\n\tif ((r = getnameinfo((struct sockaddr *)&from, fromlen, NULL, 0,\n\t    strport, sizeof(strport), NI_NUMERICSERV)) != 0)\n\t\tfatal(\"%s: getnameinfo NI_NUMERICSERV failed: %s\", __func__,\n\t\t    ssh_gai_strerror(r));\n\treturn atoi(strport);\n}"
  },
  {
    "function_name": "get_local_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
    "lines": "133-151",
    "snippet": "char *\nget_local_name(int fd)\n{\n\tchar *host, myname[NI_MAXHOST];\n\n\t/* Assume we were passed a socket */\n\tif ((host = get_socket_address(fd, 0, NI_NAMEREQD)) != NULL)\n\t\treturn host;\n\n\t/* Handle the case where we were passed a pipe */\n\tif (gethostname(myname, sizeof(myname)) == -1) {\n\t\tverbose(\"%s: gethostname: %s\", __func__, strerror(errno));\n\t\thost = xstrdup(\"UNKNOWN\");\n\t} else {\n\t\thost = xstrdup(myname);\n\t}\n\n\treturn host;\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"canohost.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "myname"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"%s: gethostname: %s\"",
            "__func__",
            "strerror(errno)"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "210-218",
          "snippet": "void\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gethostname",
          "args": [
            "myname",
            "sizeof(myname)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_socket_address",
          "args": [
            "fd",
            "0",
            "NI_NAMEREQD"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "67-111",
          "snippet": "static char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nget_local_name(int fd)\n{\n\tchar *host, myname[NI_MAXHOST];\n\n\t/* Assume we were passed a socket */\n\tif ((host = get_socket_address(fd, 0, NI_NAMEREQD)) != NULL)\n\t\treturn host;\n\n\t/* Handle the case where we were passed a pipe */\n\tif (gethostname(myname, sizeof(myname)) == -1) {\n\t\tverbose(\"%s: gethostname: %s\", __func__, strerror(errno));\n\t\thost = xstrdup(\"UNKNOWN\");\n\t} else {\n\t\thost = xstrdup(myname);\n\t}\n\n\treturn host;\n}"
  },
  {
    "function_name": "get_local_ipaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
    "lines": "123-131",
    "snippet": "char *\nget_local_ipaddr(int sock)\n{\n\tchar *p;\n\n\tif ((p = get_socket_address(sock, 0, NI_NUMERICHOST)) != NULL)\n\t\treturn p;\n\treturn xstrdup(\"UNKNOWN\");\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"canohost.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "\"UNKNOWN\""
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_socket_address",
          "args": [
            "sock",
            "0",
            "NI_NUMERICHOST"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "67-111",
          "snippet": "static char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nget_local_ipaddr(int sock)\n{\n\tchar *p;\n\n\tif ((p = get_socket_address(sock, 0, NI_NUMERICHOST)) != NULL)\n\t\treturn p;\n\treturn xstrdup(\"UNKNOWN\");\n}"
  },
  {
    "function_name": "get_peer_ipaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
    "lines": "113-121",
    "snippet": "char *\nget_peer_ipaddr(int sock)\n{\n\tchar *p;\n\n\tif ((p = get_socket_address(sock, 1, NI_NUMERICHOST)) != NULL)\n\t\treturn p;\n\treturn xstrdup(\"UNKNOWN\");\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"canohost.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "\"UNKNOWN\""
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_socket_address",
          "args": [
            "sock",
            "1",
            "NI_NUMERICHOST"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "67-111",
          "snippet": "static char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nget_peer_ipaddr(int sock)\n{\n\tchar *p;\n\n\tif ((p = get_socket_address(sock, 1, NI_NUMERICHOST)) != NULL)\n\t\treturn p;\n\treturn xstrdup(\"UNKNOWN\");\n}"
  },
  {
    "function_name": "get_socket_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
    "lines": "67-111",
    "snippet": "static char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"canohost.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "((struct sockaddr_un *)&addr)->sun_path"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: getnameinfo %d failed: %s\"",
            "__func__",
            "flags",
            "ssh_gai_strerror(r)"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_gai_strerror",
          "args": [
            "r"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getnameinfo",
          "args": [
            "(struct sockaddr *)&addr",
            "addrlen",
            "ntop",
            "sizeof(ntop)",
            "NULL",
            "0",
            "flags"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "sshaix_getnameinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "415-434",
          "snippet": "int\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nint\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ipv64_normalise_mapped",
          "args": [
            "&addr",
            "&addrlen"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "ipv64_normalise_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "38-61",
          "snippet": "void\nipv64_normalise_mapped(struct sockaddr_storage *addr, socklen_t *len)\n{\n\tstruct sockaddr_in6 *a6 = (struct sockaddr_in6 *)addr;\n\tstruct sockaddr_in *a4 = (struct sockaddr_in *)addr;\n\tstruct in_addr inaddr;\n\tu_int16_t port;\n\n\tif (addr->ss_family != AF_INET6 ||\n\t    !IN6_IS_ADDR_V4MAPPED(&a6->sin6_addr))\n\t\treturn;\n\n\tdebug3(\"Normalising mapped IPv4 in IPv6 address\");\n\n\tmemcpy(&inaddr, ((char *)&a6->sin6_addr) + 12, sizeof(inaddr));\n\tport = a6->sin6_port;\n\n\tmemset(a4, 0, sizeof(*a4));\n\n\ta4->sin_family = AF_INET;\n\t*len = sizeof(*a4);\n\tmemcpy(&a4->sin_addr, &inaddr, sizeof(inaddr));\n\ta4->sin_port = port;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nipv64_normalise_mapped(struct sockaddr_storage *addr, socklen_t *len)\n{\n\tstruct sockaddr_in6 *a6 = (struct sockaddr_in6 *)addr;\n\tstruct sockaddr_in *a4 = (struct sockaddr_in *)addr;\n\tstruct in_addr inaddr;\n\tu_int16_t port;\n\n\tif (addr->ss_family != AF_INET6 ||\n\t    !IN6_IS_ADDR_V4MAPPED(&a6->sin6_addr))\n\t\treturn;\n\n\tdebug3(\"Normalising mapped IPv4 in IPv6 address\");\n\n\tmemcpy(&inaddr, ((char *)&a6->sin6_addr) + 12, sizeof(inaddr));\n\tport = a6->sin6_port;\n\n\tmemset(a4, 0, sizeof(*a4));\n\n\ta4->sin_family = AF_INET;\n\t*len = sizeof(*a4);\n\tmemcpy(&a4->sin_addr, &inaddr, sizeof(inaddr));\n\ta4->sin_port = port;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getsockname",
          "args": [
            "sock",
            "(struct sockaddr *)&addr",
            "&addrlen"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpeername",
          "args": [
            "sock",
            "(struct sockaddr *)&addr",
            "&addrlen"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&addr",
            "0",
            "sizeof(addr)"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}"
  },
  {
    "function_name": "ipv64_normalise_mapped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
    "lines": "38-61",
    "snippet": "void\nipv64_normalise_mapped(struct sockaddr_storage *addr, socklen_t *len)\n{\n\tstruct sockaddr_in6 *a6 = (struct sockaddr_in6 *)addr;\n\tstruct sockaddr_in *a4 = (struct sockaddr_in *)addr;\n\tstruct in_addr inaddr;\n\tu_int16_t port;\n\n\tif (addr->ss_family != AF_INET6 ||\n\t    !IN6_IS_ADDR_V4MAPPED(&a6->sin6_addr))\n\t\treturn;\n\n\tdebug3(\"Normalising mapped IPv4 in IPv6 address\");\n\n\tmemcpy(&inaddr, ((char *)&a6->sin6_addr) + 12, sizeof(inaddr));\n\tport = a6->sin6_port;\n\n\tmemset(a4, 0, sizeof(*a4));\n\n\ta4->sin_family = AF_INET;\n\t*len = sizeof(*a4);\n\tmemcpy(&a4->sin_addr, &inaddr, sizeof(inaddr));\n\ta4->sin_port = port;\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"canohost.h\"",
      "#include \"log.h\"",
      "#include \"packet.h\"",
      "#include \"xmalloc.h\"",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&a4->sin_addr",
            "&inaddr",
            "sizeof(inaddr)"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "a4",
            "0",
            "sizeof(*a4)"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&inaddr",
            "((char *)&a6->sin6_addr) + 12",
            "sizeof(inaddr)"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Normalising mapped IPv4 in IPv6 address\""
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IN6_IS_ADDR_V4MAPPED",
          "args": [
            "&a6->sin6_addr"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nipv64_normalise_mapped(struct sockaddr_storage *addr, socklen_t *len)\n{\n\tstruct sockaddr_in6 *a6 = (struct sockaddr_in6 *)addr;\n\tstruct sockaddr_in *a4 = (struct sockaddr_in *)addr;\n\tstruct in_addr inaddr;\n\tu_int16_t port;\n\n\tif (addr->ss_family != AF_INET6 ||\n\t    !IN6_IS_ADDR_V4MAPPED(&a6->sin6_addr))\n\t\treturn;\n\n\tdebug3(\"Normalising mapped IPv4 in IPv6 address\");\n\n\tmemcpy(&inaddr, ((char *)&a6->sin6_addr) + 12, sizeof(inaddr));\n\tport = a6->sin6_port;\n\n\tmemset(a4, 0, sizeof(*a4));\n\n\ta4->sin_family = AF_INET;\n\t*len = sizeof(*a4);\n\tmemcpy(&a4->sin_addr, &inaddr, sizeof(inaddr));\n\ta4->sin_port = port;\n}"
  }
]