[
  {
    "function_name": "getaddrinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
    "lines": "154-234",
    "snippet": "int\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}",
    "includes": [
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "*res"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc_ai",
          "args": [
            "port",
            "in->s_addr",
            "hints"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "malloc_ai",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "123-152",
          "snippet": "static struct\naddrinfo *malloc_ai(int port, u_long addr, const struct addrinfo *hints)\n{\n\tstruct addrinfo *ai;\n\n\tai = malloc(sizeof(*ai) + sizeof(struct sockaddr_in));\n\tif (ai == NULL)\n\t\treturn (NULL);\n\n\tmemset(ai, '\\0', sizeof(*ai) + sizeof(struct sockaddr_in));\n\n\tai->ai_addr = (struct sockaddr *)(ai + 1);\n\t/* XXX -- ssh doesn't use sa_len */\n\tai->ai_addrlen = sizeof(struct sockaddr_in);\n\tai->ai_addr->sa_family = ai->ai_family = AF_INET;\n\n\t((struct sockaddr_in *)(ai)->ai_addr)->sin_port = port;\n\t((struct sockaddr_in *)(ai)->ai_addr)->sin_addr.s_addr = addr;\n\n\t/* XXX: the following is not generally correct, but does what we want */\n\tif (hints->ai_socktype)\n\t\tai->ai_socktype = hints->ai_socktype;\n\telse\n\t\tai->ai_socktype = SOCK_STREAM;\n\n\tif (hints->ai_protocol)\n\t\tai->ai_protocol = hints->ai_protocol;\n\n\treturn (ai);\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic struct\naddrinfo *malloc_ai(int port, u_long addr, const struct addrinfo *hints)\n{\n\tstruct addrinfo *ai;\n\n\tai = malloc(sizeof(*ai) + sizeof(struct sockaddr_in));\n\tif (ai == NULL)\n\t\treturn (NULL);\n\n\tmemset(ai, '\\0', sizeof(*ai) + sizeof(struct sockaddr_in));\n\n\tai->ai_addr = (struct sockaddr *)(ai + 1);\n\t/* XXX -- ssh doesn't use sa_len */\n\tai->ai_addrlen = sizeof(struct sockaddr_in);\n\tai->ai_addr->sa_family = ai->ai_family = AF_INET;\n\n\t((struct sockaddr_in *)(ai)->ai_addr)->sin_port = port;\n\t((struct sockaddr_in *)(ai)->ai_addr)->sin_addr.s_addr = addr;\n\n\t/* XXX: the following is not generally correct, but does what we want */\n\tif (hints->ai_socktype)\n\t\tai->ai_socktype = hints->ai_socktype;\n\telse\n\t\tai->ai_socktype = SOCK_STREAM;\n\n\tif (hints->ai_protocol)\n\t\tai->ai_protocol = hints->ai_protocol;\n\n\treturn (ai);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gethostbyname",
          "args": [
            "hostname"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_aton",
          "args": [
            "hostname",
            "&in"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "inet_aton",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/inet_aton.c",
          "lines": "87-177",
          "snippet": "int\ninet_aton(const char *cp, struct in_addr *addr)\n{\n\tu_int32_t val;\n\tint base, n;\n\tchar c;\n\tu_int parts[4];\n\tu_int *pp = parts;\n\n\tc = *cp;\n\tfor (;;) {\n\t\t/*\n\t\t * Collect number up to ``.''.\n\t\t * Values are specified as for C:\n\t\t * 0x=hex, 0=octal, isdigit=decimal.\n\t\t */\n\t\tif (!isdigit(c))\n\t\t\treturn (0);\n\t\tval = 0; base = 10;\n\t\tif (c == '0') {\n\t\t\tc = *++cp;\n\t\t\tif (c == 'x' || c == 'X')\n\t\t\t\tbase = 16, c = *++cp;\n\t\t\telse\n\t\t\t\tbase = 8;\n\t\t}\n\t\tfor (;;) {\n\t\t\tif (isascii(c) && isdigit(c)) {\n\t\t\t\tval = (val * base) + (c - '0');\n\t\t\t\tc = *++cp;\n\t\t\t} else if (base == 16 && isascii(c) && isxdigit(c)) {\n\t\t\t\tval = (val << 4) |\n\t\t\t\t\t(c + 10 - (islower(c) ? 'a' : 'A'));\n\t\t\t\tc = *++cp;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\tif (c == '.') {\n\t\t\t/*\n\t\t\t * Internet format:\n\t\t\t *\ta.b.c.d\n\t\t\t *\ta.b.c\t(with c treated as 16 bits)\n\t\t\t *\ta.b\t(with b treated as 24 bits)\n\t\t\t */\n\t\t\tif (pp >= parts + 3)\n\t\t\t\treturn (0);\n\t\t\t*pp++ = val;\n\t\t\tc = *++cp;\n\t\t} else\n\t\t\tbreak;\n\t}\n\t/*\n\t * Check for trailing characters.\n\t */\n\tif (c != '\\0' && (!isascii(c) || !isspace(c)))\n\t\treturn (0);\n\t/*\n\t * Concoct the address according to\n\t * the number of parts specified.\n\t */\n\tn = pp - parts + 1;\n\tswitch (n) {\n\n\tcase 0:\n\t\treturn (0);\t\t/* initial nondigit */\n\n\tcase 1:\t\t\t\t/* a -- 32 bits */\n\t\tbreak;\n\n\tcase 2:\t\t\t\t/* a.b -- 8.24 bits */\n\t\tif ((val > 0xffffff) || (parts[0] > 0xff))\n\t\t\treturn (0);\n\t\tval |= parts[0] << 24;\n\t\tbreak;\n\n\tcase 3:\t\t\t\t/* a.b.c -- 8.8.16 bits */\n\t\tif ((val > 0xffff) || (parts[0] > 0xff) || (parts[1] > 0xff))\n\t\t\treturn (0);\n\t\tval |= (parts[0] << 24) | (parts[1] << 16);\n\t\tbreak;\n\n\tcase 4:\t\t\t\t/* a.b.c.d -- 8.8.8.8 bits */\n\t\tif ((val > 0xff) || (parts[0] > 0xff) || (parts[1] > 0xff) || (parts[2] > 0xff))\n\t\t\treturn (0);\n\t\tval |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);\n\t\tbreak;\n\t}\n\tif (addr)\n\t\taddr->s_addr = htonl(val);\n\treturn (1);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ninet_aton(const char *cp, struct in_addr *addr)\n{\n\tu_int32_t val;\n\tint base, n;\n\tchar c;\n\tu_int parts[4];\n\tu_int *pp = parts;\n\n\tc = *cp;\n\tfor (;;) {\n\t\t/*\n\t\t * Collect number up to ``.''.\n\t\t * Values are specified as for C:\n\t\t * 0x=hex, 0=octal, isdigit=decimal.\n\t\t */\n\t\tif (!isdigit(c))\n\t\t\treturn (0);\n\t\tval = 0; base = 10;\n\t\tif (c == '0') {\n\t\t\tc = *++cp;\n\t\t\tif (c == 'x' || c == 'X')\n\t\t\t\tbase = 16, c = *++cp;\n\t\t\telse\n\t\t\t\tbase = 8;\n\t\t}\n\t\tfor (;;) {\n\t\t\tif (isascii(c) && isdigit(c)) {\n\t\t\t\tval = (val * base) + (c - '0');\n\t\t\t\tc = *++cp;\n\t\t\t} else if (base == 16 && isascii(c) && isxdigit(c)) {\n\t\t\t\tval = (val << 4) |\n\t\t\t\t\t(c + 10 - (islower(c) ? 'a' : 'A'));\n\t\t\t\tc = *++cp;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\tif (c == '.') {\n\t\t\t/*\n\t\t\t * Internet format:\n\t\t\t *\ta.b.c.d\n\t\t\t *\ta.b.c\t(with c treated as 16 bits)\n\t\t\t *\ta.b\t(with b treated as 24 bits)\n\t\t\t */\n\t\t\tif (pp >= parts + 3)\n\t\t\t\treturn (0);\n\t\t\t*pp++ = val;\n\t\t\tc = *++cp;\n\t\t} else\n\t\t\tbreak;\n\t}\n\t/*\n\t * Check for trailing characters.\n\t */\n\tif (c != '\\0' && (!isascii(c) || !isspace(c)))\n\t\treturn (0);\n\t/*\n\t * Concoct the address according to\n\t * the number of parts specified.\n\t */\n\tn = pp - parts + 1;\n\tswitch (n) {\n\n\tcase 0:\n\t\treturn (0);\t\t/* initial nondigit */\n\n\tcase 1:\t\t\t\t/* a -- 32 bits */\n\t\tbreak;\n\n\tcase 2:\t\t\t\t/* a.b -- 8.24 bits */\n\t\tif ((val > 0xffffff) || (parts[0] > 0xff))\n\t\t\treturn (0);\n\t\tval |= parts[0] << 24;\n\t\tbreak;\n\n\tcase 3:\t\t\t\t/* a.b.c -- 8.8.16 bits */\n\t\tif ((val > 0xffff) || (parts[0] > 0xff) || (parts[1] > 0xff))\n\t\t\treturn (0);\n\t\tval |= (parts[0] << 24) | (parts[1] << 16);\n\t\tbreak;\n\n\tcase 4:\t\t\t\t/* a.b.c.d -- 8.8.8.8 bits */\n\t\tif ((val > 0xff) || (parts[0] > 0xff) || (parts[1] > 0xff) || (parts[2] > 0xff))\n\t\t\treturn (0);\n\t\tval |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);\n\t\tbreak;\n\t}\n\tif (addr)\n\t\taddr->s_addr = htonl(val);\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "0x7f000001"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "0x00000000"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getservbyname",
          "args": [
            "servname",
            "NULL"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "port"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "servname",
            "&cp",
            "10"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "strtoll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strtoll.c",
          "lines": "49-147",
          "snippet": "long long\nstrtoll(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\tlong long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * Skip white space and pick up leading +/- sign if any.\n\t * If base is 0, allow 0x for hex and 0 for octal, else\n\t * assume decimal; if base is already 16, allow 0x.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else {\n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\t/*\n\t * Compute the cutoff value between legal numbers and illegal\n\t * numbers.  That is the largest legal value, divided by the\n\t * base.  An input number that is greater than this value, if\n\t * followed by a legal input character, is too big.  One that\n\t * is equal to this value may be valid or not; the limit\n\t * between valid and invalid numbers is then based on the last\n\t * digit.  For instance, if the range for long longs is\n\t * [-9223372036854775808..9223372036854775807] and the input base\n\t * is 10, cutoff will be set to 922337203685477580 and cutlim to\n\t * either 7 (neg==0) or 8 (neg==1), meaning that if we have\n\t * accumulated a value > 922337203685477580, or equal but the\n\t * next digit is > 7 (or 8), the number is too big, and we will\n\t * return a range error.\n\t *\n\t * Set any if any `digits' consumed; make it negative to indicate\n\t * overflow.\n\t */\n\tcutoff = neg ? LLONG_MIN : LLONG_MAX;\n\tcutlim = cutoff % base;\n\tcutoff /= base;\n\tif (neg) {\n\t\tif (cutlim > 0) {\n\t\t\tcutlim -= base;\n\t\t\tcutoff += 1;\n\t\t}\n\t\tcutlim = -cutlim;\n\t}\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (neg) {\n\t\t\tif (acc < cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MIN;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc -= c;\n\t\t\t}\n\t\t} else {\n\t\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MAX;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc += c;\n\t\t\t}\n\t\t}\n\t}\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nlong long\nstrtoll(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\tlong long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * Skip white space and pick up leading +/- sign if any.\n\t * If base is 0, allow 0x for hex and 0 for octal, else\n\t * assume decimal; if base is already 16, allow 0x.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else {\n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\t/*\n\t * Compute the cutoff value between legal numbers and illegal\n\t * numbers.  That is the largest legal value, divided by the\n\t * base.  An input number that is greater than this value, if\n\t * followed by a legal input character, is too big.  One that\n\t * is equal to this value may be valid or not; the limit\n\t * between valid and invalid numbers is then based on the last\n\t * digit.  For instance, if the range for long longs is\n\t * [-9223372036854775808..9223372036854775807] and the input base\n\t * is 10, cutoff will be set to 922337203685477580 and cutlim to\n\t * either 7 (neg==0) or 8 (neg==1), meaning that if we have\n\t * accumulated a value > 922337203685477580, or equal but the\n\t * next digit is > 7 (or 8), the number is too big, and we will\n\t * return a range error.\n\t *\n\t * Set any if any `digits' consumed; make it negative to indicate\n\t * overflow.\n\t */\n\tcutoff = neg ? LLONG_MIN : LLONG_MAX;\n\tcutlim = cutoff % base;\n\tcutoff /= base;\n\tif (neg) {\n\t\tif (cutlim > 0) {\n\t\t\tcutlim -= base;\n\t\t\tcutoff += 1;\n\t\t}\n\t\tcutlim = -cutlim;\n\t}\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (neg) {\n\t\t\tif (acc < cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MIN;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc -= c;\n\t\t\t}\n\t\t} else {\n\t\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MAX;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc += c;\n\t\t\t}\n\t\t}\n\t}\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}"
  },
  {
    "function_name": "malloc_ai",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
    "lines": "123-152",
    "snippet": "static struct\naddrinfo *malloc_ai(int port, u_long addr, const struct addrinfo *hints)\n{\n\tstruct addrinfo *ai;\n\n\tai = malloc(sizeof(*ai) + sizeof(struct sockaddr_in));\n\tif (ai == NULL)\n\t\treturn (NULL);\n\n\tmemset(ai, '\\0', sizeof(*ai) + sizeof(struct sockaddr_in));\n\n\tai->ai_addr = (struct sockaddr *)(ai + 1);\n\t/* XXX -- ssh doesn't use sa_len */\n\tai->ai_addrlen = sizeof(struct sockaddr_in);\n\tai->ai_addr->sa_family = ai->ai_family = AF_INET;\n\n\t((struct sockaddr_in *)(ai)->ai_addr)->sin_port = port;\n\t((struct sockaddr_in *)(ai)->ai_addr)->sin_addr.s_addr = addr;\n\n\t/* XXX: the following is not generally correct, but does what we want */\n\tif (hints->ai_socktype)\n\t\tai->ai_socktype = hints->ai_socktype;\n\telse\n\t\tai->ai_socktype = SOCK_STREAM;\n\n\tif (hints->ai_protocol)\n\t\tai->ai_protocol = hints->ai_protocol;\n\n\treturn (ai);\n}",
    "includes": [
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ai",
            "'\\0'",
            "sizeof(*ai) + sizeof(struct sockaddr_in)"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*ai) + sizeof(struct sockaddr_in)"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "rpl_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-malloc.c",
          "lines": "26-32",
          "snippet": "void *\nrpl_malloc(size_t size)\n{\n\tif (size == 0)\n\t\tsize = 1;\n\treturn malloc(size);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nvoid *\nrpl_malloc(size_t size)\n{\n\tif (size == 0)\n\t\tsize = 1;\n\treturn malloc(size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic struct\naddrinfo *malloc_ai(int port, u_long addr, const struct addrinfo *hints)\n{\n\tstruct addrinfo *ai;\n\n\tai = malloc(sizeof(*ai) + sizeof(struct sockaddr_in));\n\tif (ai == NULL)\n\t\treturn (NULL);\n\n\tmemset(ai, '\\0', sizeof(*ai) + sizeof(struct sockaddr_in));\n\n\tai->ai_addr = (struct sockaddr *)(ai + 1);\n\t/* XXX -- ssh doesn't use sa_len */\n\tai->ai_addrlen = sizeof(struct sockaddr_in);\n\tai->ai_addr->sa_family = ai->ai_family = AF_INET;\n\n\t((struct sockaddr_in *)(ai)->ai_addr)->sin_port = port;\n\t((struct sockaddr_in *)(ai)->ai_addr)->sin_addr.s_addr = addr;\n\n\t/* XXX: the following is not generally correct, but does what we want */\n\tif (hints->ai_socktype)\n\t\tai->ai_socktype = hints->ai_socktype;\n\telse\n\t\tai->ai_socktype = SOCK_STREAM;\n\n\tif (hints->ai_protocol)\n\t\tai->ai_protocol = hints->ai_protocol;\n\n\treturn (ai);\n}"
  },
  {
    "function_name": "freeaddrinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
    "lines": "109-119",
    "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
    "includes": [
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ai"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
  },
  {
    "function_name": "gai_strerror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
    "lines": "87-105",
    "snippet": "const char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}",
    "includes": [
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nconst char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}"
  },
  {
    "function_name": "getnameinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
    "lines": "47-82",
    "snippet": "int getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n\t\tsize_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)sa;\n\tstruct hostent *hp;\n\tchar tmpserv[16];\n\n\tif (sa->sa_family != AF_UNSPEC && sa->sa_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (serv != NULL) {\n\t\tsnprintf(tmpserv, sizeof(tmpserv), \"%d\", ntohs(sin->sin_port));\n\t\tif (strlcpy(serv, tmpserv, servlen) >= servlen)\n\t\t\treturn (EAI_MEMORY);\n\t}\n\n\tif (host != NULL) {\n\t\tif (flags & NI_NUMERICHOST) {\n\t\t\tif (strlcpy(host, inet_ntoa(sin->sin_addr),\n\t\t\t    hostlen) >= hostlen)\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\telse\n\t\t\t\treturn (0);\n\t\t} else {\n\t\t\thp = gethostbyaddr((char *)&sin->sin_addr,\n\t\t\t    sizeof(struct in_addr), AF_INET);\n\t\t\tif (hp == NULL)\n\t\t\t\treturn (EAI_NODATA);\n\n\t\t\tif (strlcpy(host, hp->h_name, hostlen) >= hostlen)\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\telse\n\t\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "host",
            "hp->h_name",
            "hostlen"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "gethostbyaddr",
          "args": [
            "(char *)&sin->sin_addr",
            "sizeof(struct in_addr)",
            "AF_INET"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntoa",
          "args": [
            "sin->sin_addr"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "inet_ntoa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/inet_ntoa.c",
          "lines": "46-57",
          "snippet": "char *\ninet_ntoa(struct in_addr in)\n{\n\tstatic char b[18];\n\tchar *p;\n\n\tp = (char *)&in;\n#define\tUC(b)\t(((int)b)&0xff)\n\t(void)snprintf(b, sizeof(b),\n\t    \"%u.%u.%u.%u\", UC(p[0]), UC(p[1]), UC(p[2]), UC(p[3]));\n\treturn (b);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\ninet_ntoa(struct in_addr in)\n{\n\tstatic char b[18];\n\tchar *p;\n\n\tp = (char *)&in;\n#define\tUC(b)\t(((int)b)&0xff)\n\t(void)snprintf(b, sizeof(b),\n\t    \"%u.%u.%u.%u\", UC(p[0]), UC(p[1]), UC(p[2]), UC(p[3]));\n\treturn (b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tmpserv",
            "sizeof(tmpserv)",
            "\"%d\"",
            "ntohs(sin->sin_port)"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "sin->sin_port"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n\t\tsize_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)sa;\n\tstruct hostent *hp;\n\tchar tmpserv[16];\n\n\tif (sa->sa_family != AF_UNSPEC && sa->sa_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (serv != NULL) {\n\t\tsnprintf(tmpserv, sizeof(tmpserv), \"%d\", ntohs(sin->sin_port));\n\t\tif (strlcpy(serv, tmpserv, servlen) >= servlen)\n\t\t\treturn (EAI_MEMORY);\n\t}\n\n\tif (host != NULL) {\n\t\tif (flags & NI_NUMERICHOST) {\n\t\t\tif (strlcpy(host, inet_ntoa(sin->sin_addr),\n\t\t\t    hostlen) >= hostlen)\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\telse\n\t\t\t\treturn (0);\n\t\t} else {\n\t\t\thp = gethostbyaddr((char *)&sin->sin_addr,\n\t\t\t    sizeof(struct in_addr), AF_INET);\n\t\t\tif (hp == NULL)\n\t\t\t\treturn (EAI_NODATA);\n\n\t\t\tif (strlcpy(host, hp->h_name, hostlen) >= hostlen)\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\telse\n\t\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (0);\n}"
  }
]