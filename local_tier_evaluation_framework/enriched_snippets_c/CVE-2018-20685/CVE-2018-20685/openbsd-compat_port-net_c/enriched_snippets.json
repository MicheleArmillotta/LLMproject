[
  {
    "function_name": "sys_tun_outfilter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-net.c",
    "lines": "348-373",
    "snippet": "u_char *\nsys_tun_outfilter(struct ssh *ssh, struct Channel *c,\n    u_char **data, size_t *dlen)\n{\n\tu_char *buf;\n\tu_int32_t af;\n\tint r;\n\n\t/* XXX new API is incompatible with this signature. */\n\tif ((r = sshbuf_get_string(c->output, data, dlen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (*dlen < sizeof(af))\n\t\treturn (NULL);\n\tbuf = *data;\n\n#if defined(SSH_TUN_PREPEND_AF)\n\t/* skip address family */\n\t*dlen -= sizeof(af);\n\tbuf = *data + sizeof(af);\n#elif defined(SSH_TUN_COMPAT_AF)\n\t/* translate address family */\n\taf = (PEEK_U32(buf) == OPENBSD_AF_INET6) ? AF_INET6 : AF_INET;\n\tPOKE_U32(buf, af);\n#endif\n\treturn (buf);\n}",
    "includes": [
      "#include <net/if_tun.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <linux/if_tun.h>",
      "#include <linux/if.h>",
      "#include \"ssherr.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define OPENBSD_AF_INET6\t24"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "POKE_U32",
          "args": [
            "buf",
            "af"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PEEK_U32",
          "args": [
            "buf"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string",
          "args": [
            "c->output",
            "data",
            "dlen"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/if_tun.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <linux/if_tun.h>\n#include <linux/if.h>\n#include \"ssherr.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define OPENBSD_AF_INET6\t24\n\nu_char *\nsys_tun_outfilter(struct ssh *ssh, struct Channel *c,\n    u_char **data, size_t *dlen)\n{\n\tu_char *buf;\n\tu_int32_t af;\n\tint r;\n\n\t/* XXX new API is incompatible with this signature. */\n\tif ((r = sshbuf_get_string(c->output, data, dlen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (*dlen < sizeof(af))\n\t\treturn (NULL);\n\tbuf = *data;\n\n#if defined(SSH_TUN_PREPEND_AF)\n\t/* skip address family */\n\t*dlen -= sizeof(af);\n\tbuf = *data + sizeof(af);\n#elif defined(SSH_TUN_COMPAT_AF)\n\t/* translate address family */\n\taf = (PEEK_U32(buf) == OPENBSD_AF_INET6) ? AF_INET6 : AF_INET;\n\tPOKE_U32(buf, af);\n#endif\n\treturn (buf);\n}"
  },
  {
    "function_name": "sys_tun_infilter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-net.c",
    "lines": "304-346",
    "snippet": "int\nsys_tun_infilter(struct ssh *ssh, struct Channel *c, char *buf, int _len)\n{\n\tint r;\n\tsize_t len;\n\tchar *ptr = buf;\n#if defined(SSH_TUN_PREPEND_AF)\n\tchar rbuf[CHAN_RBUF];\n\tstruct ip iph;\n#endif\n#if defined(SSH_TUN_PREPEND_AF) || defined(SSH_TUN_COMPAT_AF)\n\tu_int32_t af;\n#endif\n\n\t/* XXX update channel input filter API to use unsigned length */\n\tif (_len < 0)\n\t\treturn -1;\n\tlen = _len;\n\n#if defined(SSH_TUN_PREPEND_AF)\n\tif (len <= sizeof(iph) || len > sizeof(rbuf) - 4)\n\t\treturn -1;\n\t/* Determine address family from packet IP header. */\n\tmemcpy(&iph, buf, sizeof(iph));\n\taf = iph.ip_v == 6 ? OPENBSD_AF_INET6 : OPENBSD_AF_INET;\n\t/* Prepend address family to packet using OpenBSD constants */\n\tmemcpy(rbuf + 4, buf, len);\n\tlen += 4;\n\tPOKE_U32(rbuf, af);\n\tptr = rbuf;\n#elif defined(SSH_TUN_COMPAT_AF)\n\t/* Convert existing address family header to OpenBSD value */\n\tif (len <= 4)\n\t\treturn -1;\n\taf = PEEK_U32(buf);\n\t/* Put it back */\n\tPOKE_U32(buf, af == AF_INET6 ? OPENBSD_AF_INET6 : OPENBSD_AF_INET);\n#endif\n\n\tif ((r = sshbuf_put_string(c->input, ptr, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\treturn (0);\n}",
    "includes": [
      "#include <net/if_tun.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <linux/if_tun.h>",
      "#include <linux/if.h>",
      "#include \"ssherr.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define OPENBSD_AF_INET6\t24",
      "#define OPENBSD_AF_INET\t\t2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "c->input",
            "ptr",
            "len"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "POKE_U32",
          "args": [
            "buf",
            "af == AF_INET6 ? OPENBSD_AF_INET6 : OPENBSD_AF_INET"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PEEK_U32",
          "args": [
            "buf"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POKE_U32",
          "args": [
            "rbuf",
            "af"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "rbuf + 4",
            "buf",
            "len"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&iph",
            "buf",
            "sizeof(iph)"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/if_tun.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <linux/if_tun.h>\n#include <linux/if.h>\n#include \"ssherr.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define OPENBSD_AF_INET6\t24\n#define OPENBSD_AF_INET\t\t2\n\nint\nsys_tun_infilter(struct ssh *ssh, struct Channel *c, char *buf, int _len)\n{\n\tint r;\n\tsize_t len;\n\tchar *ptr = buf;\n#if defined(SSH_TUN_PREPEND_AF)\n\tchar rbuf[CHAN_RBUF];\n\tstruct ip iph;\n#endif\n#if defined(SSH_TUN_PREPEND_AF) || defined(SSH_TUN_COMPAT_AF)\n\tu_int32_t af;\n#endif\n\n\t/* XXX update channel input filter API to use unsigned length */\n\tif (_len < 0)\n\t\treturn -1;\n\tlen = _len;\n\n#if defined(SSH_TUN_PREPEND_AF)\n\tif (len <= sizeof(iph) || len > sizeof(rbuf) - 4)\n\t\treturn -1;\n\t/* Determine address family from packet IP header. */\n\tmemcpy(&iph, buf, sizeof(iph));\n\taf = iph.ip_v == 6 ? OPENBSD_AF_INET6 : OPENBSD_AF_INET;\n\t/* Prepend address family to packet using OpenBSD constants */\n\tmemcpy(rbuf + 4, buf, len);\n\tlen += 4;\n\tPOKE_U32(rbuf, af);\n\tptr = rbuf;\n#elif defined(SSH_TUN_COMPAT_AF)\n\t/* Convert existing address family header to OpenBSD value */\n\tif (len <= 4)\n\t\treturn -1;\n\taf = PEEK_U32(buf);\n\t/* Put it back */\n\tPOKE_U32(buf, af == AF_INET6 ? OPENBSD_AF_INET6 : OPENBSD_AF_INET);\n#endif\n\n\tif ((r = sshbuf_put_string(c->input, ptr, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\treturn (0);\n}"
  },
  {
    "function_name": "sys_tun_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-net.c",
    "lines": "207-289",
    "snippet": "int\nsys_tun_open(int tun, int mode, char **ifname)\n{\n\tstruct ifreq ifr;\n\tchar name[100];\n\tint fd = -1, sock, flag;\n\tconst char *tunbase = \"tun\";\n\n\tif (ifname != NULL)\n\t\t*ifname = NULL;\n\n\tif (mode == SSH_TUNMODE_ETHERNET) {\n#ifdef SSH_TUN_NO_L2\n\t\tdebug(\"%s: no layer 2 tunnelling support\", __func__);\n\t\treturn (-1);\n#else\n\t\ttunbase = \"tap\";\n#endif\n\t}\n\n\t/* Open the tunnel device */\n\tif (tun <= SSH_TUNID_MAX) {\n\t\tsnprintf(name, sizeof(name), \"/dev/%s%d\", tunbase, tun);\n\t\tfd = open(name, O_RDWR);\n\t} else if (tun == SSH_TUNID_ANY) {\n\t\tfor (tun = 100; tun >= 0; tun--) {\n\t\t\tsnprintf(name, sizeof(name), \"/dev/%s%d\",\n\t\t\t    tunbase, tun);\n\t\t\tif ((fd = open(name, O_RDWR)) >= 0)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tdebug(\"%s: invalid tunnel %u\\n\", __func__, tun);\n\t\treturn (-1);\n\t}\n\n\tif (fd < 0) {\n\t\tdebug(\"%s: %s open failed: %s\", __func__, name,\n\t\t    strerror(errno));\n\t\treturn (-1);\n\t}\n\n\t/* Turn on tunnel headers */\n\tflag = 1;\n#if defined(TUNSIFHEAD) && !defined(SSH_TUN_PREPEND_AF)\n\tif (mode != SSH_TUNMODE_ETHERNET &&\n\t    ioctl(fd, TUNSIFHEAD, &flag) == -1) {\n\t\tdebug(\"%s: ioctl(%d, TUNSIFHEAD, 1): %s\", __func__, fd,\n\t\t    strerror(errno));\n\t\tclose(fd);\n\t}\n#endif\n\n\tdebug(\"%s: %s mode %d fd %d\", __func__, name, mode, fd);\n\n\t/* Set the tunnel device operation mode */\n\tsnprintf(ifr.ifr_name, sizeof(ifr.ifr_name), \"%s%d\", tunbase, tun);\n\tif ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) == -1)\n\t\tgoto failed;\n\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr) == -1)\n\t\tgoto failed;\n\tif ((ifr.ifr_flags & IFF_UP) == 0) {\n\t\tifr.ifr_flags |= IFF_UP;\n\t\tif (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1)\n\t\t\tgoto failed;\n\t}\n\n\tif (ifname != NULL && (*ifname = strdup(ifr.ifr_name)) == NULL)\n\t\tgoto failed;\n\n\tclose(sock);\n\treturn (fd);\n\n failed:\n\tif (fd >= 0)\n\t\tclose(fd);\n\tif (sock >= 0)\n\t\tclose(sock);\n\tdebug(\"%s: failed to set %s mode %d: %s\", __func__, name,\n\t    mode, strerror(errno));\n\treturn (-1);\n}",
    "includes": [
      "#include <net/if_tun.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <linux/if_tun.h>",
      "#include <linux/if.h>",
      "#include \"ssherr.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: failed to set %s mode %d: %s\"",
            "__func__",
            "name",
            "mode",
            "strerror(errno)"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "87-105",
          "snippet": "const char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nconst char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "closefrom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-closefrom.c",
          "lines": "68-107",
          "snippet": "void\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}",
          "includes": [
            "#  include <ndir.h>",
            "#  include <sys/dir.h>",
            "#  include <sys/ndir.h>",
            "# include <dirent.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "# include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <ndir.h>\n#  include <sys/dir.h>\n#  include <sys/ndir.h>\n# include <dirent.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <limits.h>\n# include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ifr.ifr_name"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "216-227",
          "snippet": "char *\nstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = malloc(len);\n\tif (cp != NULL)\n\t\treturn(memcpy(cp, str, len));\n\treturn NULL;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = malloc(len);\n\tif (cp != NULL)\n\t\treturn(memcpy(cp, str, len));\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCSIFFLAGS",
            "&ifr"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCGIFFLAGS",
            "&ifr"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "PF_UNIX",
            "SOCK_STREAM",
            "0"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "67-111",
          "snippet": "static char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ifr.ifr_name",
            "sizeof(ifr.ifr_name)",
            "\"%s%d\"",
            "tunbase",
            "tun"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "TUNSIFHEAD",
            "&flag"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "name",
            "O_RDWR"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "binary_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-cygwin_util.c",
          "lines": "43-53",
          "snippet": "int\nbinary_open(const char *filename, int flags, ...)\n{\n\tva_list ap;\n\tmode_t mode;\n\n\tva_start(ap, flags);\n\tmode = va_arg(ap, mode_t);\n\tva_end(ap);\n\treturn (open(filename, flags | O_BINARY, mode));\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nbinary_open(const char *filename, int flags, ...)\n{\n\tva_list ap;\n\tmode_t mode;\n\n\tva_start(ap, flags);\n\tmode = va_arg(ap, mode_t);\n\tva_end(ap);\n\treturn (open(filename, flags | O_BINARY, mode));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/if_tun.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <linux/if_tun.h>\n#include <linux/if.h>\n#include \"ssherr.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsys_tun_open(int tun, int mode, char **ifname)\n{\n\tstruct ifreq ifr;\n\tchar name[100];\n\tint fd = -1, sock, flag;\n\tconst char *tunbase = \"tun\";\n\n\tif (ifname != NULL)\n\t\t*ifname = NULL;\n\n\tif (mode == SSH_TUNMODE_ETHERNET) {\n#ifdef SSH_TUN_NO_L2\n\t\tdebug(\"%s: no layer 2 tunnelling support\", __func__);\n\t\treturn (-1);\n#else\n\t\ttunbase = \"tap\";\n#endif\n\t}\n\n\t/* Open the tunnel device */\n\tif (tun <= SSH_TUNID_MAX) {\n\t\tsnprintf(name, sizeof(name), \"/dev/%s%d\", tunbase, tun);\n\t\tfd = open(name, O_RDWR);\n\t} else if (tun == SSH_TUNID_ANY) {\n\t\tfor (tun = 100; tun >= 0; tun--) {\n\t\t\tsnprintf(name, sizeof(name), \"/dev/%s%d\",\n\t\t\t    tunbase, tun);\n\t\t\tif ((fd = open(name, O_RDWR)) >= 0)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tdebug(\"%s: invalid tunnel %u\\n\", __func__, tun);\n\t\treturn (-1);\n\t}\n\n\tif (fd < 0) {\n\t\tdebug(\"%s: %s open failed: %s\", __func__, name,\n\t\t    strerror(errno));\n\t\treturn (-1);\n\t}\n\n\t/* Turn on tunnel headers */\n\tflag = 1;\n#if defined(TUNSIFHEAD) && !defined(SSH_TUN_PREPEND_AF)\n\tif (mode != SSH_TUNMODE_ETHERNET &&\n\t    ioctl(fd, TUNSIFHEAD, &flag) == -1) {\n\t\tdebug(\"%s: ioctl(%d, TUNSIFHEAD, 1): %s\", __func__, fd,\n\t\t    strerror(errno));\n\t\tclose(fd);\n\t}\n#endif\n\n\tdebug(\"%s: %s mode %d fd %d\", __func__, name, mode, fd);\n\n\t/* Set the tunnel device operation mode */\n\tsnprintf(ifr.ifr_name, sizeof(ifr.ifr_name), \"%s%d\", tunbase, tun);\n\tif ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) == -1)\n\t\tgoto failed;\n\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr) == -1)\n\t\tgoto failed;\n\tif ((ifr.ifr_flags & IFF_UP) == 0) {\n\t\tifr.ifr_flags |= IFF_UP;\n\t\tif (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1)\n\t\t\tgoto failed;\n\t}\n\n\tif (ifname != NULL && (*ifname = strdup(ifr.ifr_name)) == NULL)\n\t\tgoto failed;\n\n\tclose(sock);\n\treturn (fd);\n\n failed:\n\tif (fd >= 0)\n\t\tclose(fd);\n\tif (sock >= 0)\n\t\tclose(sock);\n\tdebug(\"%s: failed to set %s mode %d: %s\", __func__, name,\n\t    mode, strerror(errno));\n\treturn (-1);\n}"
  },
  {
    "function_name": "sys_tun_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-net.c",
    "lines": "141-196",
    "snippet": "int\nsys_tun_open(int tun, int mode, char **ifname)\n{\n\tstruct ifreq ifr;\n\tint fd = -1;\n\tconst char *name = NULL;\n\n\tif (ifname != NULL)\n\t\t*ifname = NULL;\n\n\tif ((fd = open(\"/dev/net/tun\", O_RDWR)) == -1) {\n\t\tdebug(\"%s: failed to open tunnel control interface: %s\",\n\t\t    __func__, strerror(errno));\n\t\treturn (-1);\n\t}\n\n\tbzero(&ifr, sizeof(ifr));\n\n\tif (mode == SSH_TUNMODE_ETHERNET) {\n\t\tifr.ifr_flags = IFF_TAP;\n\t\tname = \"tap%d\";\n\t} else {\n\t\tifr.ifr_flags = IFF_TUN;\n\t\tname = \"tun%d\";\n\t}\n\tifr.ifr_flags |= IFF_NO_PI;\n\n\tif (tun != SSH_TUNID_ANY) {\n\t\tif (tun > SSH_TUNID_MAX) {\n\t\t\tdebug(\"%s: invalid tunnel id %x: %s\", __func__,\n\t\t\t    tun, strerror(errno));\n\t\t\tgoto failed;\n\t\t}\n\t\tsnprintf(ifr.ifr_name, sizeof(ifr.ifr_name), name, tun);\n\t}\n\n\tif (ioctl(fd, TUNSETIFF, &ifr) == -1) {\n\t\tdebug(\"%s: failed to configure tunnel (mode %d): %s\", __func__,\n\t\t    mode, strerror(errno));\n\t\tgoto failed;\n\t}\n\n\tif (tun == SSH_TUNID_ANY)\n\t\tdebug(\"%s: tunnel mode %d fd %d\", __func__, mode, fd);\n\telse\n\t\tdebug(\"%s: %s mode %d fd %d\", __func__, ifr.ifr_name, mode, fd);\n\n\tif (ifname != NULL && (*ifname = strdup(ifr.ifr_name)) == NULL)\n\t\tgoto failed;\n\n\treturn (fd);\n\n failed:\n\tclose(fd);\n\treturn (-1);\n}",
    "includes": [
      "#include <net/if_tun.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <linux/if_tun.h>",
      "#include <linux/if.h>",
      "#include \"ssherr.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "closefrom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-closefrom.c",
          "lines": "68-107",
          "snippet": "void\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}",
          "includes": [
            "#  include <ndir.h>",
            "#  include <sys/dir.h>",
            "#  include <sys/ndir.h>",
            "# include <dirent.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "# include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <ndir.h>\n#  include <sys/dir.h>\n#  include <sys/ndir.h>\n# include <dirent.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <limits.h>\n# include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ifr.ifr_name"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "216-227",
          "snippet": "char *\nstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = malloc(len);\n\tif (cp != NULL)\n\t\treturn(memcpy(cp, str, len));\n\treturn NULL;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = malloc(len);\n\tif (cp != NULL)\n\t\treturn(memcpy(cp, str, len));\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: %s mode %d fd %d\"",
            "__func__",
            "ifr.ifr_name",
            "mode",
            "fd"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "87-105",
          "snippet": "const char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nconst char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "TUNSETIFF",
            "&ifr"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ifr.ifr_name",
            "sizeof(ifr.ifr_name)",
            "name",
            "tun"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&ifr",
            "sizeof(ifr)"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "288-292",
          "snippet": "void\nbzero(void *b, size_t n)\n{\n\t(void)memset(b, 0, n);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nbzero(void *b, size_t n)\n{\n\t(void)memset(b, 0, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/net/tun\"",
            "O_RDWR"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "binary_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-cygwin_util.c",
          "lines": "43-53",
          "snippet": "int\nbinary_open(const char *filename, int flags, ...)\n{\n\tva_list ap;\n\tmode_t mode;\n\n\tva_start(ap, flags);\n\tmode = va_arg(ap, mode_t);\n\tva_end(ap);\n\treturn (open(filename, flags | O_BINARY, mode));\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nbinary_open(const char *filename, int flags, ...)\n{\n\tva_list ap;\n\tmode_t mode;\n\n\tva_start(ap, flags);\n\tmode = va_arg(ap, mode_t);\n\tva_end(ap);\n\treturn (open(filename, flags | O_BINARY, mode));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/if_tun.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <linux/if_tun.h>\n#include <linux/if.h>\n#include \"ssherr.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsys_tun_open(int tun, int mode, char **ifname)\n{\n\tstruct ifreq ifr;\n\tint fd = -1;\n\tconst char *name = NULL;\n\n\tif (ifname != NULL)\n\t\t*ifname = NULL;\n\n\tif ((fd = open(\"/dev/net/tun\", O_RDWR)) == -1) {\n\t\tdebug(\"%s: failed to open tunnel control interface: %s\",\n\t\t    __func__, strerror(errno));\n\t\treturn (-1);\n\t}\n\n\tbzero(&ifr, sizeof(ifr));\n\n\tif (mode == SSH_TUNMODE_ETHERNET) {\n\t\tifr.ifr_flags = IFF_TAP;\n\t\tname = \"tap%d\";\n\t} else {\n\t\tifr.ifr_flags = IFF_TUN;\n\t\tname = \"tun%d\";\n\t}\n\tifr.ifr_flags |= IFF_NO_PI;\n\n\tif (tun != SSH_TUNID_ANY) {\n\t\tif (tun > SSH_TUNID_MAX) {\n\t\t\tdebug(\"%s: invalid tunnel id %x: %s\", __func__,\n\t\t\t    tun, strerror(errno));\n\t\t\tgoto failed;\n\t\t}\n\t\tsnprintf(ifr.ifr_name, sizeof(ifr.ifr_name), name, tun);\n\t}\n\n\tif (ioctl(fd, TUNSETIFF, &ifr) == -1) {\n\t\tdebug(\"%s: failed to configure tunnel (mode %d): %s\", __func__,\n\t\t    mode, strerror(errno));\n\t\tgoto failed;\n\t}\n\n\tif (tun == SSH_TUNID_ANY)\n\t\tdebug(\"%s: tunnel mode %d fd %d\", __func__, mode, fd);\n\telse\n\t\tdebug(\"%s: %s mode %d fd %d\", __func__, ifr.ifr_name, mode, fd);\n\n\tif (ifname != NULL && (*ifname = strdup(ifr.ifr_name)) == NULL)\n\t\tgoto failed;\n\n\treturn (fd);\n\n failed:\n\tclose(fd);\n\treturn (-1);\n}"
  },
  {
    "function_name": "sys_set_process_rdomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-net.c",
    "lines": "116-120",
    "snippet": "void\nsys_set_process_rdomain(const char *name)\n{\n\tfatal(\"%s: not supported\", __func__);\n}",
    "includes": [
      "#include <net/if_tun.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <linux/if_tun.h>",
      "#include <linux/if.h>",
      "#include \"ssherr.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: not supported\"",
            "__func__"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/if_tun.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <linux/if_tun.h>\n#include <linux/if.h>\n#include \"ssherr.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsys_set_process_rdomain(const char *name)\n{\n\tfatal(\"%s: not supported\", __func__);\n}"
  },
  {
    "function_name": "valid_rdomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-net.c",
    "lines": "110-114",
    "snippet": "int\nvalid_rdomain(const char *name)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <net/if_tun.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <linux/if_tun.h>",
      "#include <linux/if.h>",
      "#include \"ssherr.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <net/if_tun.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <linux/if_tun.h>\n#include <linux/if.h>\n#include \"ssherr.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nvalid_rdomain(const char *name)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "sys_set_rdomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-net.c",
    "lines": "104-108",
    "snippet": "int\nsys_set_rdomain(int fd, const char *name)\n{\n\treturn -1;\n}",
    "includes": [
      "#include <net/if_tun.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <linux/if_tun.h>",
      "#include <linux/if.h>",
      "#include \"ssherr.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <net/if_tun.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <linux/if_tun.h>\n#include <linux/if.h>\n#include \"ssherr.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsys_set_rdomain(int fd, const char *name)\n{\n\treturn -1;\n}"
  },
  {
    "function_name": "sys_get_rdomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-net.c",
    "lines": "98-102",
    "snippet": "char *\nsys_get_rdomain(int fd)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include <net/if_tun.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <linux/if_tun.h>",
      "#include <linux/if.h>",
      "#include \"ssherr.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <net/if_tun.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <linux/if_tun.h>\n#include <linux/if.h>\n#include \"ssherr.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsys_get_rdomain(int fd)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "sys_valid_rdomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-net.c",
    "lines": "76-95",
    "snippet": "int\nsys_valid_rdomain(const char *name)\n{\n\tint fd;\n\n\t/*\n\t * This is a pretty crappy way to test. It would be better to\n\t * check whether \"name\" represents a VRF device, but apparently\n\t * that requires an rtnetlink transaction.\n\t */\n\tif ((fd = socket(AF_INET, SOCK_STREAM, 0)) == -1)\n\t\treturn 0;\n\tif (setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE,\n\t    name, strlen(name)) == -1) {\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\tclose(fd);\n\treturn 1;\n}",
    "includes": [
      "#include <net/if_tun.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <linux/if_tun.h>",
      "#include <linux/if.h>",
      "#include \"ssherr.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "closefrom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-closefrom.c",
          "lines": "68-107",
          "snippet": "void\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}",
          "includes": [
            "#  include <ndir.h>",
            "#  include <sys/dir.h>",
            "#  include <sys/ndir.h>",
            "# include <dirent.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "# include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <ndir.h>\n#  include <sys/dir.h>\n#  include <sys/ndir.h>\n# include <dirent.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <limits.h>\n# include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "fd",
            "SOL_SOCKET",
            "SO_BINDTODEVICE",
            "name",
            "strlen(name)"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_STREAM",
            "0"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "67-111",
          "snippet": "static char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/if_tun.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <linux/if_tun.h>\n#include <linux/if.h>\n#include \"ssherr.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsys_valid_rdomain(const char *name)\n{\n\tint fd;\n\n\t/*\n\t * This is a pretty crappy way to test. It would be better to\n\t * check whether \"name\" represents a VRF device, but apparently\n\t * that requires an rtnetlink transaction.\n\t */\n\tif ((fd = socket(AF_INET, SOCK_STREAM, 0)) == -1)\n\t\treturn 0;\n\tif (setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE,\n\t    name, strlen(name)) == -1) {\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\tclose(fd);\n\treturn 1;\n}"
  },
  {
    "function_name": "sys_set_rdomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-net.c",
    "lines": "64-74",
    "snippet": "int\nsys_set_rdomain(int fd, const char *name)\n{\n\tif (setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE,\n\t    name, strlen(name)) == -1) {\n\t\terror(\"%s: setsockopt(%d, SO_BINDTODEVICE, %s): %s\",\n\t\t      __func__, fd, name, strerror(errno));\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <net/if_tun.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <linux/if_tun.h>",
      "#include <linux/if.h>",
      "#include \"ssherr.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: setsockopt(%d, SO_BINDTODEVICE, %s): %s\"",
            "__func__",
            "fd",
            "name",
            "strerror(errno)"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "87-105",
          "snippet": "const char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nconst char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "fd",
            "SOL_SOCKET",
            "SO_BINDTODEVICE",
            "name",
            "strlen(name)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/if_tun.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <linux/if_tun.h>\n#include <linux/if.h>\n#include \"ssherr.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsys_set_rdomain(int fd, const char *name)\n{\n\tif (setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE,\n\t    name, strlen(name)) == -1) {\n\t\terror(\"%s: setsockopt(%d, SO_BINDTODEVICE, %s): %s\",\n\t\t      __func__, fd, name, strerror(errno));\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "sys_get_rdomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-net.c",
    "lines": "49-62",
    "snippet": "char *\nsys_get_rdomain(int fd)\n{\n\tchar dev[IFNAMSIZ + 1];\n\tsocklen_t len = sizeof(dev) - 1;\n\n\tif (getsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE, dev, &len) == -1) {\n\t\terror(\"%s: cannot determine VRF for fd=%d : %s\",\n\t\t    __func__, fd, strerror(errno));\n\t\treturn NULL;\n\t}\n\tdev[len] = '\\0';\n\treturn strdup(dev);\n}",
    "includes": [
      "#include <net/if_tun.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <linux/if_tun.h>",
      "#include <linux/if.h>",
      "#include \"ssherr.h\"",
      "#include \"channels.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "dev"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "216-227",
          "snippet": "char *\nstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = malloc(len);\n\tif (cp != NULL)\n\t\treturn(memcpy(cp, str, len));\n\treturn NULL;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = malloc(len);\n\tif (cp != NULL)\n\t\treturn(memcpy(cp, str, len));\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: cannot determine VRF for fd=%d : %s\"",
            "__func__",
            "fd",
            "strerror(errno)"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "87-105",
          "snippet": "const char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nconst char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getsockopt",
          "args": [
            "fd",
            "SOL_SOCKET",
            "SO_BINDTODEVICE",
            "dev",
            "&len"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/if_tun.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <linux/if_tun.h>\n#include <linux/if.h>\n#include \"ssherr.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsys_get_rdomain(int fd)\n{\n\tchar dev[IFNAMSIZ + 1];\n\tsocklen_t len = sizeof(dev) - 1;\n\n\tif (getsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE, dev, &len) == -1) {\n\t\terror(\"%s: cannot determine VRF for fd=%d : %s\",\n\t\t    __func__, fd, strerror(errno));\n\t\treturn NULL;\n\t}\n\tdev[len] = '\\0';\n\treturn strdup(dev);\n}"
  }
]