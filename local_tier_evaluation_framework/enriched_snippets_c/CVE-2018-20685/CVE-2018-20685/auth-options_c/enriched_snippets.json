[
  {
    "function_name": "sshauthopt_deserialise",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
    "lines": "876-935",
    "snippet": "int\nsshauthopt_deserialise(struct sshbuf *m, struct sshauthopt **optsp)\n{\n\tstruct sshauthopt *opts = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tu_char f;\n\tu_int tmp;\n\n\tif ((opts = calloc(1, sizeof(*opts))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n#define OPT_FLAG(x) \\\n\tdo { \\\n\t\tif ((r = sshbuf_get_u8(m, &f)) != 0) \\\n\t\t\tgoto out; \\\n\t\topts->x = f; \\\n\t} while (0)\n\tOPT_FLAG(permit_port_forwarding_flag);\n\tOPT_FLAG(permit_agent_forwarding_flag);\n\tOPT_FLAG(permit_x11_forwarding_flag);\n\tOPT_FLAG(permit_pty_flag);\n\tOPT_FLAG(permit_user_rc);\n\tOPT_FLAG(restricted);\n\tOPT_FLAG(cert_authority);\n#undef OPT_FLAG\n\n\tif ((r = sshbuf_get_u64(m, &opts->valid_before)) != 0)\n\t\tgoto out;\n\n\t/* tunnel number can be negative to indicate \"unset\" */\n\tif ((r = sshbuf_get_u8(m, &f)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &tmp)) != 0)\n\t\tgoto out;\n\topts->force_tun_device = f ? -1 : (int)tmp;\n\n\t/* String options may be NULL */\n\tif ((r = deserialise_nullable_string(m, &opts->cert_principals)) != 0 ||\n\t    (r = deserialise_nullable_string(m, &opts->force_command)) != 0 ||\n\t    (r = deserialise_nullable_string(m,\n\t    &opts->required_from_host_cert)) != 0 ||\n\t    (r = deserialise_nullable_string(m,\n\t    &opts->required_from_host_keys)) != 0)\n\t\tgoto out;\n\n\t/* Array options */\n\tif ((r = deserialise_array(m, &opts->env, &opts->nenv)) != 0 ||\n\t    (r = deserialise_array(m,\n\t    &opts->permitopen, &opts->npermitopen)) != 0 ||\n\t    (r = deserialise_array(m,\n\t    &opts->permitlisten, &opts->npermitlisten)) != 0)\n\t\tgoto out;\n\n\t/* success */\n\tr = 0;\n\t*optsp = opts;\n\topts = NULL;\n out:\n\tsshauthopt_free(opts);\n\treturn r;\n}",
    "includes": [
      "#include \"auth-options.h\"",
      "#include \"ssh2.h\"",
      "#include \"match.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshauthopt_free",
          "args": [
            "opts"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "265-292",
          "snippet": "void\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "deserialise_array",
          "args": [
            "m",
            "&opts->permitlisten",
            "&opts->npermitlisten"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "deserialise_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "766-803",
          "snippet": "static int\ndeserialise_array(struct sshbuf *m, char ***ap, size_t *np)\n{\n\tchar **a = NULL;\n\tsize_t i, n = 0;\n\tstruct sshbuf *b = NULL;\n\tu_int tmp;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((r = sshbuf_get_u32(m, &tmp)) != 0 ||\n\t    (r = sshbuf_froms(m, &b)) != 0)\n\t\tgoto out;\n\tif (tmp > INT_MAX) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tn = tmp;\n\tif (n > 0 && (a = calloc(n, sizeof(*a))) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tif ((r = sshbuf_get_cstring(b, &a[i], NULL)) != 0)\n\t\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n\t*ap = a;\n\ta = NULL;\n\t*np = n;\n\tn = 0;\n out:\n\tfor (i = 0; i < n; i++)\n\t\tfree(a[i]);\n\tfree(a);\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndeserialise_array(struct sshbuf *m, char ***ap, size_t *np)\n{\n\tchar **a = NULL;\n\tsize_t i, n = 0;\n\tstruct sshbuf *b = NULL;\n\tu_int tmp;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((r = sshbuf_get_u32(m, &tmp)) != 0 ||\n\t    (r = sshbuf_froms(m, &b)) != 0)\n\t\tgoto out;\n\tif (tmp > INT_MAX) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tn = tmp;\n\tif (n > 0 && (a = calloc(n, sizeof(*a))) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tif ((r = sshbuf_get_cstring(b, &a[i], NULL)) != 0)\n\t\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n\t*ap = a;\n\ta = NULL;\n\t*np = n;\n\tn = 0;\n out:\n\tfor (i = 0; i < n; i++)\n\t\tfree(a[i]);\n\tfree(a);\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "deserialise_nullable_string",
          "args": [
            "m",
            "&opts->required_from_host_keys"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "deserialise_nullable_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "816-827",
          "snippet": "static int\ndeserialise_nullable_string(struct sshbuf *m, char **sp)\n{\n\tint r;\n\tu_char flag;\n\n\t*sp = NULL;\n\tif ((r = sshbuf_get_u8(m, &flag)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, flag ? NULL : sp, NULL)) != 0)\n\t\treturn r;\n\treturn 0;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndeserialise_nullable_string(struct sshbuf *m, char **sp)\n{\n\tint r;\n\tu_char flag;\n\n\t*sp = NULL;\n\tif ((r = sshbuf_get_u8(m, &flag)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, flag ? NULL : sp, NULL)) != 0)\n\t\treturn r;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "m",
            "&tmp"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "m",
            "&f"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u64",
          "args": [
            "m",
            "&opts->valid_before"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "44-55",
          "snippet": "int\nsshbuf_get_u64(struct sshbuf *buf, u_int64_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 8)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U64(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u64(struct sshbuf *buf, u_int64_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 8)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U64(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OPT_FLAG",
          "args": [
            "cert_authority"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPT_FLAG",
          "args": [
            "restricted"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPT_FLAG",
          "args": [
            "permit_user_rc"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPT_FLAG",
          "args": [
            "permit_pty_flag"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPT_FLAG",
          "args": [
            "permit_x11_forwarding_flag"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPT_FLAG",
          "args": [
            "permit_agent_forwarding_flag"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPT_FLAG",
          "args": [
            "permit_port_forwarding_flag"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(*opts)"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshauthopt_deserialise(struct sshbuf *m, struct sshauthopt **optsp)\n{\n\tstruct sshauthopt *opts = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tu_char f;\n\tu_int tmp;\n\n\tif ((opts = calloc(1, sizeof(*opts))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n#define OPT_FLAG(x) \\\n\tdo { \\\n\t\tif ((r = sshbuf_get_u8(m, &f)) != 0) \\\n\t\t\tgoto out; \\\n\t\topts->x = f; \\\n\t} while (0)\n\tOPT_FLAG(permit_port_forwarding_flag);\n\tOPT_FLAG(permit_agent_forwarding_flag);\n\tOPT_FLAG(permit_x11_forwarding_flag);\n\tOPT_FLAG(permit_pty_flag);\n\tOPT_FLAG(permit_user_rc);\n\tOPT_FLAG(restricted);\n\tOPT_FLAG(cert_authority);\n#undef OPT_FLAG\n\n\tif ((r = sshbuf_get_u64(m, &opts->valid_before)) != 0)\n\t\tgoto out;\n\n\t/* tunnel number can be negative to indicate \"unset\" */\n\tif ((r = sshbuf_get_u8(m, &f)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &tmp)) != 0)\n\t\tgoto out;\n\topts->force_tun_device = f ? -1 : (int)tmp;\n\n\t/* String options may be NULL */\n\tif ((r = deserialise_nullable_string(m, &opts->cert_principals)) != 0 ||\n\t    (r = deserialise_nullable_string(m, &opts->force_command)) != 0 ||\n\t    (r = deserialise_nullable_string(m,\n\t    &opts->required_from_host_cert)) != 0 ||\n\t    (r = deserialise_nullable_string(m,\n\t    &opts->required_from_host_keys)) != 0)\n\t\tgoto out;\n\n\t/* Array options */\n\tif ((r = deserialise_array(m, &opts->env, &opts->nenv)) != 0 ||\n\t    (r = deserialise_array(m,\n\t    &opts->permitopen, &opts->npermitopen)) != 0 ||\n\t    (r = deserialise_array(m,\n\t    &opts->permitlisten, &opts->npermitlisten)) != 0)\n\t\tgoto out;\n\n\t/* success */\n\tr = 0;\n\t*optsp = opts;\n\topts = NULL;\n out:\n\tsshauthopt_free(opts);\n\treturn r;\n}"
  },
  {
    "function_name": "sshauthopt_serialise",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
    "lines": "829-874",
    "snippet": "int\nsshauthopt_serialise(const struct sshauthopt *opts, struct sshbuf *m,\n    int untrusted)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t/* Flag and simple integer options */\n\tif ((r = sshbuf_put_u8(m, opts->permit_port_forwarding_flag)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->permit_agent_forwarding_flag)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->permit_x11_forwarding_flag)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->permit_pty_flag)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->permit_user_rc)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->restricted)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->cert_authority)) != 0 ||\n\t    (r = sshbuf_put_u64(m, opts->valid_before)) != 0)\n\t\treturn r;\n\n\t/* tunnel number can be negative to indicate \"unset\" */\n\tif ((r = sshbuf_put_u8(m, opts->force_tun_device == -1)) != 0 ||\n\t    (r = sshbuf_put_u32(m, (opts->force_tun_device < 0) ?\n\t    0 : (u_int)opts->force_tun_device)) != 0)\n\t\treturn r;\n\n\t/* String options; these may be NULL */\n\tif ((r = serialise_nullable_string(m,\n\t    untrusted ? \"yes\" : opts->cert_principals)) != 0 ||\n\t    (r = serialise_nullable_string(m,\n\t    untrusted ? \"true\" : opts->force_command)) != 0 ||\n\t    (r = serialise_nullable_string(m,\n\t    untrusted ? NULL : opts->required_from_host_cert)) != 0 ||\n\t    (r = serialise_nullable_string(m,\n\t     untrusted ? NULL : opts->required_from_host_keys)) != 0)\n\t\treturn r;\n\n\t/* Array options */\n\tif ((r = serialise_array(m, opts->env,\n\t    untrusted ? 0 : opts->nenv)) != 0 ||\n\t    (r = serialise_array(m, opts->permitopen,\n\t    untrusted ? 0 : opts->npermitopen)) != 0 ||\n\t    (r = serialise_array(m, opts->permitlisten,\n\t    untrusted ? 0 : opts->npermitlisten)) != 0)\n\t\treturn r;\n\n\t/* success */\n\treturn 0;\n}",
    "includes": [
      "#include \"auth-options.h\"",
      "#include \"ssh2.h\"",
      "#include \"match.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "serialise_array",
          "args": [
            "m",
            "opts->permitlisten",
            "untrusted ? 0 : opts->npermitlisten"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "deserialise_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "766-803",
          "snippet": "static int\ndeserialise_array(struct sshbuf *m, char ***ap, size_t *np)\n{\n\tchar **a = NULL;\n\tsize_t i, n = 0;\n\tstruct sshbuf *b = NULL;\n\tu_int tmp;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((r = sshbuf_get_u32(m, &tmp)) != 0 ||\n\t    (r = sshbuf_froms(m, &b)) != 0)\n\t\tgoto out;\n\tif (tmp > INT_MAX) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tn = tmp;\n\tif (n > 0 && (a = calloc(n, sizeof(*a))) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tif ((r = sshbuf_get_cstring(b, &a[i], NULL)) != 0)\n\t\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n\t*ap = a;\n\ta = NULL;\n\t*np = n;\n\tn = 0;\n out:\n\tfor (i = 0; i < n; i++)\n\t\tfree(a[i]);\n\tfree(a);\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndeserialise_array(struct sshbuf *m, char ***ap, size_t *np)\n{\n\tchar **a = NULL;\n\tsize_t i, n = 0;\n\tstruct sshbuf *b = NULL;\n\tu_int tmp;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((r = sshbuf_get_u32(m, &tmp)) != 0 ||\n\t    (r = sshbuf_froms(m, &b)) != 0)\n\t\tgoto out;\n\tif (tmp > INT_MAX) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tn = tmp;\n\tif (n > 0 && (a = calloc(n, sizeof(*a))) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tif ((r = sshbuf_get_cstring(b, &a[i], NULL)) != 0)\n\t\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n\t*ap = a;\n\ta = NULL;\n\t*np = n;\n\tn = 0;\n out:\n\tfor (i = 0; i < n; i++)\n\t\tfree(a[i]);\n\tfree(a);\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "serialise_nullable_string",
          "args": [
            "m",
            "untrusted ? NULL : opts->required_from_host_keys"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "deserialise_nullable_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "816-827",
          "snippet": "static int\ndeserialise_nullable_string(struct sshbuf *m, char **sp)\n{\n\tint r;\n\tu_char flag;\n\n\t*sp = NULL;\n\tif ((r = sshbuf_get_u8(m, &flag)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, flag ? NULL : sp, NULL)) != 0)\n\t\treturn r;\n\treturn 0;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndeserialise_nullable_string(struct sshbuf *m, char **sp)\n{\n\tint r;\n\tu_char flag;\n\n\t*sp = NULL;\n\tif ((r = sshbuf_get_u8(m, &flag)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, flag ? NULL : sp, NULL)) != 0)\n\t\treturn r;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "(opts->force_tun_device < 0) ?\n\t    0 : (u_int)opts->force_tun_device"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "m",
            "opts->force_tun_device == -1"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u64",
          "args": [
            "m",
            "opts->valid_before"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "299-309",
          "snippet": "int\nsshbuf_put_u64(struct sshbuf *buf, u_int64_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 8, &p)) < 0)\n\t\treturn r;\n\tPOKE_U64(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u64(struct sshbuf *buf, u_int64_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 8, &p)) < 0)\n\t\treturn r;\n\tPOKE_U64(p, val);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshauthopt_serialise(const struct sshauthopt *opts, struct sshbuf *m,\n    int untrusted)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t/* Flag and simple integer options */\n\tif ((r = sshbuf_put_u8(m, opts->permit_port_forwarding_flag)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->permit_agent_forwarding_flag)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->permit_x11_forwarding_flag)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->permit_pty_flag)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->permit_user_rc)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->restricted)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->cert_authority)) != 0 ||\n\t    (r = sshbuf_put_u64(m, opts->valid_before)) != 0)\n\t\treturn r;\n\n\t/* tunnel number can be negative to indicate \"unset\" */\n\tif ((r = sshbuf_put_u8(m, opts->force_tun_device == -1)) != 0 ||\n\t    (r = sshbuf_put_u32(m, (opts->force_tun_device < 0) ?\n\t    0 : (u_int)opts->force_tun_device)) != 0)\n\t\treturn r;\n\n\t/* String options; these may be NULL */\n\tif ((r = serialise_nullable_string(m,\n\t    untrusted ? \"yes\" : opts->cert_principals)) != 0 ||\n\t    (r = serialise_nullable_string(m,\n\t    untrusted ? \"true\" : opts->force_command)) != 0 ||\n\t    (r = serialise_nullable_string(m,\n\t    untrusted ? NULL : opts->required_from_host_cert)) != 0 ||\n\t    (r = serialise_nullable_string(m,\n\t     untrusted ? NULL : opts->required_from_host_keys)) != 0)\n\t\treturn r;\n\n\t/* Array options */\n\tif ((r = serialise_array(m, opts->env,\n\t    untrusted ? 0 : opts->nenv)) != 0 ||\n\t    (r = serialise_array(m, opts->permitopen,\n\t    untrusted ? 0 : opts->npermitopen)) != 0 ||\n\t    (r = serialise_array(m, opts->permitlisten,\n\t    untrusted ? 0 : opts->npermitlisten)) != 0)\n\t\treturn r;\n\n\t/* success */\n\treturn 0;\n}"
  },
  {
    "function_name": "deserialise_nullable_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
    "lines": "816-827",
    "snippet": "static int\ndeserialise_nullable_string(struct sshbuf *m, char **sp)\n{\n\tint r;\n\tu_char flag;\n\n\t*sp = NULL;\n\tif ((r = sshbuf_get_u8(m, &flag)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, flag ? NULL : sp, NULL)) != 0)\n\t\treturn r;\n\treturn 0;\n}",
    "includes": [
      "#include \"auth-options.h\"",
      "#include \"ssh2.h\"",
      "#include \"match.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "m",
            "flag ? NULL : sp",
            "NULL"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "m",
            "&flag"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndeserialise_nullable_string(struct sshbuf *m, char **sp)\n{\n\tint r;\n\tu_char flag;\n\n\t*sp = NULL;\n\tif ((r = sshbuf_get_u8(m, &flag)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, flag ? NULL : sp, NULL)) != 0)\n\t\treturn r;\n\treturn 0;\n}"
  },
  {
    "function_name": "serialise_nullable_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
    "lines": "805-814",
    "snippet": "static int\nserialise_nullable_string(struct sshbuf *m, const char *s)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u8(m, s == NULL)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, s)) != 0)\n\t\treturn r;\n\treturn 0;\n}",
    "includes": [
      "#include \"auth-options.h\"",
      "#include \"ssh2.h\"",
      "#include \"match.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "m",
            "s"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "m",
            "s == NULL"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nserialise_nullable_string(struct sshbuf *m, const char *s)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u8(m, s == NULL)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, s)) != 0)\n\t\treturn r;\n\treturn 0;\n}"
  },
  {
    "function_name": "deserialise_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
    "lines": "766-803",
    "snippet": "static int\ndeserialise_array(struct sshbuf *m, char ***ap, size_t *np)\n{\n\tchar **a = NULL;\n\tsize_t i, n = 0;\n\tstruct sshbuf *b = NULL;\n\tu_int tmp;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((r = sshbuf_get_u32(m, &tmp)) != 0 ||\n\t    (r = sshbuf_froms(m, &b)) != 0)\n\t\tgoto out;\n\tif (tmp > INT_MAX) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tn = tmp;\n\tif (n > 0 && (a = calloc(n, sizeof(*a))) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tif ((r = sshbuf_get_cstring(b, &a[i], NULL)) != 0)\n\t\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n\t*ap = a;\n\ta = NULL;\n\t*np = n;\n\tn = 0;\n out:\n\tfor (i = 0; i < n; i++)\n\t\tfree(a[i]);\n\tfree(a);\n\tsshbuf_free(b);\n\treturn r;\n}",
    "includes": [
      "#include \"auth-options.h\"",
      "#include \"ssh2.h\"",
      "#include \"match.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "a"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "265-292",
          "snippet": "void\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "b",
            "&a[i]",
            "NULL"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "n",
            "sizeof(*a)"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_froms",
          "args": [
            "m",
            "&b"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_froms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "377-399",
          "snippet": "int\nsshbuf_froms(struct sshbuf *buf, struct sshbuf **bufp)\n{\n\tconst u_char *p;\n\tsize_t len;\n\tstruct sshbuf *ret;\n\tint r;\n\n\tif (buf == NULL || bufp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*bufp = NULL;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\tif ((ret = sshbuf_from(p, len)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_consume(buf, len + 4)) != 0 ||  /* Shouldn't happen */\n\t    (r = sshbuf_set_parent(ret, buf)) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn r;\n\t}\n\t*bufp = ret;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_froms(struct sshbuf *buf, struct sshbuf **bufp)\n{\n\tconst u_char *p;\n\tsize_t len;\n\tstruct sshbuf *ret;\n\tint r;\n\n\tif (buf == NULL || bufp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*bufp = NULL;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\tif ((ret = sshbuf_from(p, len)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_consume(buf, len + 4)) != 0 ||  /* Shouldn't happen */\n\t    (r = sshbuf_set_parent(ret, buf)) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn r;\n\t}\n\t*bufp = ret;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "m",
            "&tmp"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndeserialise_array(struct sshbuf *m, char ***ap, size_t *np)\n{\n\tchar **a = NULL;\n\tsize_t i, n = 0;\n\tstruct sshbuf *b = NULL;\n\tu_int tmp;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((r = sshbuf_get_u32(m, &tmp)) != 0 ||\n\t    (r = sshbuf_froms(m, &b)) != 0)\n\t\tgoto out;\n\tif (tmp > INT_MAX) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tn = tmp;\n\tif (n > 0 && (a = calloc(n, sizeof(*a))) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tif ((r = sshbuf_get_cstring(b, &a[i], NULL)) != 0)\n\t\t\tgoto out;\n\t}\n\t/* success */\n\tr = 0;\n\t*ap = a;\n\ta = NULL;\n\t*np = n;\n\tn = 0;\n out:\n\tfor (i = 0; i < n; i++)\n\t\tfree(a[i]);\n\tfree(a);\n\tsshbuf_free(b);\n\treturn r;\n}"
  },
  {
    "function_name": "serialise_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
    "lines": "738-764",
    "snippet": "static int\nserialise_array(struct sshbuf *m, char **a, size_t n)\n{\n\tstruct sshbuf *b;\n\tsize_t i;\n\tint r;\n\n\tif (n > INT_MAX)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\n\tif ((b = sshbuf_new()) == NULL) {\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tif ((r = sshbuf_put_cstring(b, a[i])) != 0) {\n\t\t\tsshbuf_free(b);\n\t\t\treturn r;\n\t\t}\n\t}\n\tif ((r = sshbuf_put_u32(m, n)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, b)) != 0) {\n\t\tsshbuf_free(b);\n\t\treturn r;\n\t}\n\t/* success */\n\treturn 0;\n}",
    "includes": [
      "#include \"auth-options.h\"",
      "#include \"ssh2.h\"",
      "#include \"match.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_stringb",
          "args": [
            "m",
            "b"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "371-375",
          "snippet": "int\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "m",
            "n"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "b",
            "a[i]"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nserialise_array(struct sshbuf *m, char **a, size_t n)\n{\n\tstruct sshbuf *b;\n\tsize_t i;\n\tint r;\n\n\tif (n > INT_MAX)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\n\tif ((b = sshbuf_new()) == NULL) {\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tif ((r = sshbuf_put_cstring(b, a[i])) != 0) {\n\t\t\tsshbuf_free(b);\n\t\t\treturn r;\n\t\t}\n\t}\n\tif ((r = sshbuf_put_u32(m, n)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, b)) != 0) {\n\t\tsshbuf_free(b);\n\t\treturn r;\n\t}\n\t/* success */\n\treturn 0;\n}"
  },
  {
    "function_name": "sshauthopt_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
    "lines": "695-736",
    "snippet": "struct sshauthopt *\nsshauthopt_copy(const struct sshauthopt *orig)\n{\n\tstruct sshauthopt *ret;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\treturn NULL;\n\n#define OPTSCALAR(x) ret->x = orig->x\n\tOPTSCALAR(permit_port_forwarding_flag);\n\tOPTSCALAR(permit_agent_forwarding_flag);\n\tOPTSCALAR(permit_x11_forwarding_flag);\n\tOPTSCALAR(permit_pty_flag);\n\tOPTSCALAR(permit_user_rc);\n\tOPTSCALAR(restricted);\n\tOPTSCALAR(cert_authority);\n\tOPTSCALAR(force_tun_device);\n\tOPTSCALAR(valid_before);\n#undef OPTSCALAR\n#define OPTSTRING(x) \\\n\tdo { \\\n\t\tif (orig->x != NULL && (ret->x = strdup(orig->x)) == NULL) { \\\n\t\t\tsshauthopt_free(ret); \\\n\t\t\treturn NULL; \\\n\t\t} \\\n\t} while (0)\n\tOPTSTRING(cert_principals);\n\tOPTSTRING(force_command);\n\tOPTSTRING(required_from_host_cert);\n\tOPTSTRING(required_from_host_keys);\n#undef OPTSTRING\n\n\tif (dup_strings(&ret->env, &ret->nenv, orig->env, orig->nenv) != 0 ||\n\t    dup_strings(&ret->permitopen, &ret->npermitopen,\n\t    orig->permitopen, orig->npermitopen) != 0 ||\n\t    dup_strings(&ret->permitlisten, &ret->npermitlisten,\n\t    orig->permitlisten, orig->npermitlisten) != 0) {\n\t\tsshauthopt_free(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"auth-options.h\"",
      "#include \"ssh2.h\"",
      "#include \"match.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshauthopt_free",
          "args": [
            "ret"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "265-292",
          "snippet": "void\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup_strings",
          "args": [
            "&ret->permitlisten",
            "&ret->npermitlisten",
            "orig->permitlisten",
            "orig->npermitlisten"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "dup_strings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "111-136",
          "snippet": "static int\ndup_strings(char ***dstp, size_t *ndstp, char **src, size_t nsrc)\n{\n\tchar **dst;\n\tsize_t i, j;\n\n\t*dstp = NULL;\n\t*ndstp = 0;\n\tif (nsrc == 0)\n\t\treturn 0;\n\n\tif ((dst = calloc(nsrc, sizeof(*src))) == NULL)\n\t\treturn -1;\n\tfor (i = 0; i < nsrc; i++) {\n\t\tif ((dst[i] = strdup(src[i])) == NULL) {\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tfree(dst[j]);\n\t\t\tfree(dst);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* success */\n\t*dstp = dst;\n\t*ndstp = nsrc;\n\treturn 0;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndup_strings(char ***dstp, size_t *ndstp, char **src, size_t nsrc)\n{\n\tchar **dst;\n\tsize_t i, j;\n\n\t*dstp = NULL;\n\t*ndstp = 0;\n\tif (nsrc == 0)\n\t\treturn 0;\n\n\tif ((dst = calloc(nsrc, sizeof(*src))) == NULL)\n\t\treturn -1;\n\tfor (i = 0; i < nsrc; i++) {\n\t\tif ((dst[i] = strdup(src[i])) == NULL) {\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tfree(dst[j]);\n\t\t\tfree(dst);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* success */\n\t*dstp = dst;\n\t*ndstp = nsrc;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OPTSTRING",
          "args": [
            "required_from_host_keys"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPTSTRING",
          "args": [
            "required_from_host_cert"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPTSTRING",
          "args": [
            "force_command"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPTSTRING",
          "args": [
            "cert_principals"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPTSCALAR",
          "args": [
            "valid_before"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPTSCALAR",
          "args": [
            "force_tun_device"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPTSCALAR",
          "args": [
            "cert_authority"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPTSCALAR",
          "args": [
            "restricted"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPTSCALAR",
          "args": [
            "permit_user_rc"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPTSCALAR",
          "args": [
            "permit_pty_flag"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPTSCALAR",
          "args": [
            "permit_x11_forwarding_flag"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPTSCALAR",
          "args": [
            "permit_agent_forwarding_flag"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPTSCALAR",
          "args": [
            "permit_port_forwarding_flag"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshauthopt_new",
          "args": [],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_new_with_keys_defaults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "294-309",
          "snippet": "struct sshauthopt *\nsshauthopt_new_with_keys_defaults(void)\n{\n\tstruct sshauthopt *ret = NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\treturn NULL;\n\n\t/* Defaults for authorized_keys flags */\n\tret->permit_port_forwarding_flag = 1;\n\tret->permit_agent_forwarding_flag = 1;\n\tret->permit_x11_forwarding_flag = 1;\n\tret->permit_pty_flag = 1;\n\tret->permit_user_rc = 1;\n\treturn ret;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshauthopt *\nsshauthopt_new_with_keys_defaults(void)\n{\n\tstruct sshauthopt *ret = NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\treturn NULL;\n\n\t/* Defaults for authorized_keys flags */\n\tret->permit_port_forwarding_flag = 1;\n\tret->permit_agent_forwarding_flag = 1;\n\tret->permit_x11_forwarding_flag = 1;\n\tret->permit_pty_flag = 1;\n\tret->permit_user_rc = 1;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshauthopt *\nsshauthopt_copy(const struct sshauthopt *orig)\n{\n\tstruct sshauthopt *ret;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\treturn NULL;\n\n#define OPTSCALAR(x) ret->x = orig->x\n\tOPTSCALAR(permit_port_forwarding_flag);\n\tOPTSCALAR(permit_agent_forwarding_flag);\n\tOPTSCALAR(permit_x11_forwarding_flag);\n\tOPTSCALAR(permit_pty_flag);\n\tOPTSCALAR(permit_user_rc);\n\tOPTSCALAR(restricted);\n\tOPTSCALAR(cert_authority);\n\tOPTSCALAR(force_tun_device);\n\tOPTSCALAR(valid_before);\n#undef OPTSCALAR\n#define OPTSTRING(x) \\\n\tdo { \\\n\t\tif (orig->x != NULL && (ret->x = strdup(orig->x)) == NULL) { \\\n\t\t\tsshauthopt_free(ret); \\\n\t\t\treturn NULL; \\\n\t\t} \\\n\t} while (0)\n\tOPTSTRING(cert_principals);\n\tOPTSTRING(force_command);\n\tOPTSTRING(required_from_host_cert);\n\tOPTSTRING(required_from_host_keys);\n#undef OPTSTRING\n\n\tif (dup_strings(&ret->env, &ret->nenv, orig->env, orig->nenv) != 0 ||\n\t    dup_strings(&ret->permitopen, &ret->npermitopen,\n\t    orig->permitopen, orig->npermitopen) != 0 ||\n\t    dup_strings(&ret->permitlisten, &ret->npermitlisten,\n\t    orig->permitlisten, orig->npermitlisten) != 0) {\n\t\tsshauthopt_free(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "sshauthopt_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
    "lines": "572-690",
    "snippet": "struct sshauthopt *\nsshauthopt_merge(const struct sshauthopt *primary,\n    const struct sshauthopt *additional, const char **errstrp)\n{\n\tstruct sshauthopt *ret;\n\tconst char *errstr = \"internal error\";\n\tconst char *tmp;\n\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\tgoto alloc_fail;\n\n\t/* cert_authority and cert_principals are cleared in result */\n\n\t/* Prefer access lists from primary. */\n\t/* XXX err is both set and mismatch? */\n\ttmp = primary->required_from_host_cert;\n\tif (tmp == NULL)\n\t\ttmp = additional->required_from_host_cert;\n\tif (tmp != NULL && (ret->required_from_host_cert = strdup(tmp)) == NULL)\n\t\tgoto alloc_fail;\n\ttmp = primary->required_from_host_keys;\n\tif (tmp == NULL)\n\t\ttmp = additional->required_from_host_keys;\n\tif (tmp != NULL && (ret->required_from_host_keys = strdup(tmp)) == NULL)\n\t\tgoto alloc_fail;\n\n\t/*\n\t * force_tun_device, permitopen/permitlisten and environment all\n\t * prefer the primary.\n\t */\n\tret->force_tun_device = primary->force_tun_device;\n\tif (ret->force_tun_device == -1)\n\t\tret->force_tun_device = additional->force_tun_device;\n\tif (primary->nenv > 0) {\n\t\tif (dup_strings(&ret->env, &ret->nenv,\n\t\t    primary->env, primary->nenv) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->nenv) {\n\t\tif (dup_strings(&ret->env, &ret->nenv,\n\t\t    additional->env, additional->nenv) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\tif (primary->npermitopen > 0) {\n\t\tif (dup_strings(&ret->permitopen, &ret->npermitopen,\n\t\t    primary->permitopen, primary->npermitopen) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->npermitopen > 0) {\n\t\tif (dup_strings(&ret->permitopen, &ret->npermitopen,\n\t\t    additional->permitopen, additional->npermitopen) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\n\tif (primary->npermitlisten > 0) {\n\t\tif (dup_strings(&ret->permitlisten, &ret->npermitlisten,\n\t\t    primary->permitlisten, primary->npermitlisten) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->npermitlisten > 0) {\n\t\tif (dup_strings(&ret->permitlisten, &ret->npermitlisten,\n\t\t    additional->permitlisten, additional->npermitlisten) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\n\t/* Flags are logical-AND (i.e. must be set in both for permission) */\n#define OPTFLAG(x) ret->x = (primary->x == 1) && (additional->x == 1)\n\tOPTFLAG(permit_port_forwarding_flag);\n\tOPTFLAG(permit_agent_forwarding_flag);\n\tOPTFLAG(permit_x11_forwarding_flag);\n\tOPTFLAG(permit_pty_flag);\n\tOPTFLAG(permit_user_rc);\n#undef OPTFLAG\n\n\t/* Earliest expiry time should win */\n\tif (primary->valid_before != 0)\n\t\tret->valid_before = primary->valid_before;\n\tif (additional->valid_before != 0 &&\n\t    additional->valid_before < ret->valid_before)\n\t\tret->valid_before = additional->valid_before;\n\n\t/*\n\t * When both multiple forced-command are specified, only\n\t * proceed if they are identical, otherwise fail.\n\t */\n\tif (primary->force_command != NULL &&\n\t    additional->force_command != NULL) {\n\t\tif (strcmp(primary->force_command,\n\t\t    additional->force_command) == 0) {\n\t\t\t/* ok */\n\t\t\tret->force_command = strdup(primary->force_command);\n\t\t\tif (ret->force_command == NULL)\n\t\t\t\tgoto alloc_fail;\n\t\t} else {\n\t\t\terrstr = \"forced command options do not match\";\n\t\t\tgoto fail;\n\t\t}\n\t} else if (primary->force_command != NULL) {\n\t\tif ((ret->force_command = strdup(\n\t\t    primary->force_command)) == NULL)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->force_command != NULL) {\n\t\tif ((ret->force_command = strdup(\n\t\t    additional->force_command)) == NULL)\n\t\t\tgoto alloc_fail;\n\t}\n\t/* success */\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\treturn ret;\n\n alloc_fail:\n\terrstr = \"memory allocation failed\";\n fail:\n\tif (errstrp != NULL)\n\t\t*errstrp = errstr;\n\tsshauthopt_free(ret);\n\treturn NULL;\n}",
    "includes": [
      "#include \"auth-options.h\"",
      "#include \"ssh2.h\"",
      "#include \"match.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshauthopt_free",
          "args": [
            "ret"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "265-292",
          "snippet": "void\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "additional->force_command"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "primary->force_command",
            "additional->force_command"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OPTFLAG",
          "args": [
            "permit_user_rc"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPTFLAG",
          "args": [
            "permit_pty_flag"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPTFLAG",
          "args": [
            "permit_x11_forwarding_flag"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPTFLAG",
          "args": [
            "permit_agent_forwarding_flag"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPTFLAG",
          "args": [
            "permit_port_forwarding_flag"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup_strings",
          "args": [
            "&ret->permitlisten",
            "&ret->npermitlisten",
            "additional->permitlisten",
            "additional->npermitlisten"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "dup_strings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "111-136",
          "snippet": "static int\ndup_strings(char ***dstp, size_t *ndstp, char **src, size_t nsrc)\n{\n\tchar **dst;\n\tsize_t i, j;\n\n\t*dstp = NULL;\n\t*ndstp = 0;\n\tif (nsrc == 0)\n\t\treturn 0;\n\n\tif ((dst = calloc(nsrc, sizeof(*src))) == NULL)\n\t\treturn -1;\n\tfor (i = 0; i < nsrc; i++) {\n\t\tif ((dst[i] = strdup(src[i])) == NULL) {\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tfree(dst[j]);\n\t\t\tfree(dst);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* success */\n\t*dstp = dst;\n\t*ndstp = nsrc;\n\treturn 0;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndup_strings(char ***dstp, size_t *ndstp, char **src, size_t nsrc)\n{\n\tchar **dst;\n\tsize_t i, j;\n\n\t*dstp = NULL;\n\t*ndstp = 0;\n\tif (nsrc == 0)\n\t\treturn 0;\n\n\tif ((dst = calloc(nsrc, sizeof(*src))) == NULL)\n\t\treturn -1;\n\tfor (i = 0; i < nsrc; i++) {\n\t\tif ((dst[i] = strdup(src[i])) == NULL) {\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tfree(dst[j]);\n\t\t\tfree(dst);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* success */\n\t*dstp = dst;\n\t*ndstp = nsrc;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshauthopt_new",
          "args": [],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_new_with_keys_defaults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "294-309",
          "snippet": "struct sshauthopt *\nsshauthopt_new_with_keys_defaults(void)\n{\n\tstruct sshauthopt *ret = NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\treturn NULL;\n\n\t/* Defaults for authorized_keys flags */\n\tret->permit_port_forwarding_flag = 1;\n\tret->permit_agent_forwarding_flag = 1;\n\tret->permit_x11_forwarding_flag = 1;\n\tret->permit_pty_flag = 1;\n\tret->permit_user_rc = 1;\n\treturn ret;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshauthopt *\nsshauthopt_new_with_keys_defaults(void)\n{\n\tstruct sshauthopt *ret = NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\treturn NULL;\n\n\t/* Defaults for authorized_keys flags */\n\tret->permit_port_forwarding_flag = 1;\n\tret->permit_agent_forwarding_flag = 1;\n\tret->permit_x11_forwarding_flag = 1;\n\tret->permit_pty_flag = 1;\n\tret->permit_user_rc = 1;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshauthopt *\nsshauthopt_merge(const struct sshauthopt *primary,\n    const struct sshauthopt *additional, const char **errstrp)\n{\n\tstruct sshauthopt *ret;\n\tconst char *errstr = \"internal error\";\n\tconst char *tmp;\n\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\tgoto alloc_fail;\n\n\t/* cert_authority and cert_principals are cleared in result */\n\n\t/* Prefer access lists from primary. */\n\t/* XXX err is both set and mismatch? */\n\ttmp = primary->required_from_host_cert;\n\tif (tmp == NULL)\n\t\ttmp = additional->required_from_host_cert;\n\tif (tmp != NULL && (ret->required_from_host_cert = strdup(tmp)) == NULL)\n\t\tgoto alloc_fail;\n\ttmp = primary->required_from_host_keys;\n\tif (tmp == NULL)\n\t\ttmp = additional->required_from_host_keys;\n\tif (tmp != NULL && (ret->required_from_host_keys = strdup(tmp)) == NULL)\n\t\tgoto alloc_fail;\n\n\t/*\n\t * force_tun_device, permitopen/permitlisten and environment all\n\t * prefer the primary.\n\t */\n\tret->force_tun_device = primary->force_tun_device;\n\tif (ret->force_tun_device == -1)\n\t\tret->force_tun_device = additional->force_tun_device;\n\tif (primary->nenv > 0) {\n\t\tif (dup_strings(&ret->env, &ret->nenv,\n\t\t    primary->env, primary->nenv) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->nenv) {\n\t\tif (dup_strings(&ret->env, &ret->nenv,\n\t\t    additional->env, additional->nenv) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\tif (primary->npermitopen > 0) {\n\t\tif (dup_strings(&ret->permitopen, &ret->npermitopen,\n\t\t    primary->permitopen, primary->npermitopen) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->npermitopen > 0) {\n\t\tif (dup_strings(&ret->permitopen, &ret->npermitopen,\n\t\t    additional->permitopen, additional->npermitopen) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\n\tif (primary->npermitlisten > 0) {\n\t\tif (dup_strings(&ret->permitlisten, &ret->npermitlisten,\n\t\t    primary->permitlisten, primary->npermitlisten) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->npermitlisten > 0) {\n\t\tif (dup_strings(&ret->permitlisten, &ret->npermitlisten,\n\t\t    additional->permitlisten, additional->npermitlisten) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\n\t/* Flags are logical-AND (i.e. must be set in both for permission) */\n#define OPTFLAG(x) ret->x = (primary->x == 1) && (additional->x == 1)\n\tOPTFLAG(permit_port_forwarding_flag);\n\tOPTFLAG(permit_agent_forwarding_flag);\n\tOPTFLAG(permit_x11_forwarding_flag);\n\tOPTFLAG(permit_pty_flag);\n\tOPTFLAG(permit_user_rc);\n#undef OPTFLAG\n\n\t/* Earliest expiry time should win */\n\tif (primary->valid_before != 0)\n\t\tret->valid_before = primary->valid_before;\n\tif (additional->valid_before != 0 &&\n\t    additional->valid_before < ret->valid_before)\n\t\tret->valid_before = additional->valid_before;\n\n\t/*\n\t * When both multiple forced-command are specified, only\n\t * proceed if they are identical, otherwise fail.\n\t */\n\tif (primary->force_command != NULL &&\n\t    additional->force_command != NULL) {\n\t\tif (strcmp(primary->force_command,\n\t\t    additional->force_command) == 0) {\n\t\t\t/* ok */\n\t\t\tret->force_command = strdup(primary->force_command);\n\t\t\tif (ret->force_command == NULL)\n\t\t\t\tgoto alloc_fail;\n\t\t} else {\n\t\t\terrstr = \"forced command options do not match\";\n\t\t\tgoto fail;\n\t\t}\n\t} else if (primary->force_command != NULL) {\n\t\tif ((ret->force_command = strdup(\n\t\t    primary->force_command)) == NULL)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->force_command != NULL) {\n\t\tif ((ret->force_command = strdup(\n\t\t    additional->force_command)) == NULL)\n\t\t\tgoto alloc_fail;\n\t}\n\t/* success */\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\treturn ret;\n\n alloc_fail:\n\terrstr = \"memory allocation failed\";\n fail:\n\tif (errstrp != NULL)\n\t\t*errstrp = errstr;\n\tsshauthopt_free(ret);\n\treturn NULL;\n}"
  },
  {
    "function_name": "sshauthopt_from_cert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
    "lines": "541-566",
    "snippet": "struct sshauthopt *\nsshauthopt_from_cert(struct sshkey *k)\n{\n\tstruct sshauthopt *ret;\n\n\tif (k == NULL || !sshkey_type_is_cert(k->type) || k->cert == NULL ||\n\t    k->cert->type != SSH2_CERT_TYPE_USER)\n\t\treturn NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\treturn NULL;\n\n\t/* Handle options and critical extensions separately */\n\tif (cert_option_list(ret, k->cert->critical,\n\t    OPTIONS_CRITICAL, 1) == -1) {\n\t\tsshauthopt_free(ret);\n\t\treturn NULL;\n\t}\n\tif (cert_option_list(ret, k->cert->extensions,\n\t    OPTIONS_EXTENSIONS, 0) == -1) {\n\t\tsshauthopt_free(ret);\n\t\treturn NULL;\n\t}\n\t/* success */\n\treturn ret;\n}",
    "includes": [
      "#include \"auth-options.h\"",
      "#include \"ssh2.h\"",
      "#include \"match.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define OPTIONS_EXTENSIONS\t2",
      "#define OPTIONS_CRITICAL\t1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshauthopt_free",
          "args": [
            "ret"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "265-292",
          "snippet": "void\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cert_option_list",
          "args": [
            "ret",
            "k->cert->extensions",
            "OPTIONS_EXTENSIONS",
            "0"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "cert_option_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "140-252",
          "snippet": "static int\ncert_option_list(struct sshauthopt *opts, struct sshbuf *oblob,\n    u_int which, int crit)\n{\n\tchar *command, *allowed;\n\tchar *name = NULL;\n\tstruct sshbuf *c = NULL, *data = NULL;\n\tint r, ret = -1, found;\n\n\tif ((c = sshbuf_fromb(oblob)) == NULL) {\n\t\terror(\"%s: sshbuf_fromb failed\", __func__);\n\t\tgoto out;\n\t}\n\n\twhile (sshbuf_len(c) > 0) {\n\t\tsshbuf_free(data);\n\t\tdata = NULL;\n\t\tif ((r = sshbuf_get_cstring(c, &name, NULL)) != 0 ||\n\t\t    (r = sshbuf_froms(c, &data)) != 0) {\n\t\t\terror(\"Unable to parse certificate options: %s\",\n\t\t\t    ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\tdebug3(\"found certificate option \\\"%.100s\\\" len %zu\",\n\t\t    name, sshbuf_len(data));\n\t\tfound = 0;\n\t\tif ((which & OPTIONS_EXTENSIONS) != 0) {\n\t\t\tif (strcmp(name, \"permit-X11-forwarding\") == 0) {\n\t\t\t\topts->permit_x11_forwarding_flag = 1;\n\t\t\t\tfound = 1;\n\t\t\t} else if (strcmp(name,\n\t\t\t    \"permit-agent-forwarding\") == 0) {\n\t\t\t\topts->permit_agent_forwarding_flag = 1;\n\t\t\t\tfound = 1;\n\t\t\t} else if (strcmp(name,\n\t\t\t    \"permit-port-forwarding\") == 0) {\n\t\t\t\topts->permit_port_forwarding_flag = 1;\n\t\t\t\tfound = 1;\n\t\t\t} else if (strcmp(name, \"permit-pty\") == 0) {\n\t\t\t\topts->permit_pty_flag = 1;\n\t\t\t\tfound = 1;\n\t\t\t} else if (strcmp(name, \"permit-user-rc\") == 0) {\n\t\t\t\topts->permit_user_rc = 1;\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t}\n\t\tif (!found && (which & OPTIONS_CRITICAL) != 0) {\n\t\t\tif (strcmp(name, \"force-command\") == 0) {\n\t\t\t\tif ((r = sshbuf_get_cstring(data, &command,\n\t\t\t\t    NULL)) != 0) {\n\t\t\t\t\terror(\"Unable to parse \\\"%s\\\" \"\n\t\t\t\t\t    \"section: %s\", name, ssh_err(r));\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (opts->force_command != NULL) {\n\t\t\t\t\terror(\"Certificate has multiple \"\n\t\t\t\t\t    \"force-command options\");\n\t\t\t\t\tfree(command);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\topts->force_command = command;\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t\tif (strcmp(name, \"source-address\") == 0) {\n\t\t\t\tif ((r = sshbuf_get_cstring(data, &allowed,\n\t\t\t\t    NULL)) != 0) {\n\t\t\t\t\terror(\"Unable to parse \\\"%s\\\" \"\n\t\t\t\t\t    \"section: %s\", name, ssh_err(r));\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (opts->required_from_host_cert != NULL) {\n\t\t\t\t\terror(\"Certificate has multiple \"\n\t\t\t\t\t    \"source-address options\");\n\t\t\t\t\tfree(allowed);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\t/* Check syntax */\n\t\t\t\tif (addr_match_cidr_list(NULL, allowed) == -1) {\n\t\t\t\t\terror(\"Certificate source-address \"\n\t\t\t\t\t    \"contents invalid\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\topts->required_from_host_cert = allowed;\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (!found) {\n\t\t\tif (crit) {\n\t\t\t\terror(\"Certificate critical option \\\"%s\\\" \"\n\t\t\t\t    \"is not supported\", name);\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tlogit(\"Certificate extension \\\"%s\\\" \"\n\t\t\t\t    \"is not supported\", name);\n\t\t\t}\n\t\t} else if (sshbuf_len(data) != 0) {\n\t\t\terror(\"Certificate option \\\"%s\\\" corrupt \"\n\t\t\t    \"(extra data)\", name);\n\t\t\tgoto out;\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\t/* successfully parsed all options */\n\tret = 0;\n\n out:\n\tfree(name);\n\tsshbuf_free(data);\n\tsshbuf_free(c);\n\treturn ret;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define OPTIONS_EXTENSIONS\t2",
            "#define OPTIONS_CRITICAL\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define OPTIONS_EXTENSIONS\t2\n#define OPTIONS_CRITICAL\t1\n\nstatic int\ncert_option_list(struct sshauthopt *opts, struct sshbuf *oblob,\n    u_int which, int crit)\n{\n\tchar *command, *allowed;\n\tchar *name = NULL;\n\tstruct sshbuf *c = NULL, *data = NULL;\n\tint r, ret = -1, found;\n\n\tif ((c = sshbuf_fromb(oblob)) == NULL) {\n\t\terror(\"%s: sshbuf_fromb failed\", __func__);\n\t\tgoto out;\n\t}\n\n\twhile (sshbuf_len(c) > 0) {\n\t\tsshbuf_free(data);\n\t\tdata = NULL;\n\t\tif ((r = sshbuf_get_cstring(c, &name, NULL)) != 0 ||\n\t\t    (r = sshbuf_froms(c, &data)) != 0) {\n\t\t\terror(\"Unable to parse certificate options: %s\",\n\t\t\t    ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\tdebug3(\"found certificate option \\\"%.100s\\\" len %zu\",\n\t\t    name, sshbuf_len(data));\n\t\tfound = 0;\n\t\tif ((which & OPTIONS_EXTENSIONS) != 0) {\n\t\t\tif (strcmp(name, \"permit-X11-forwarding\") == 0) {\n\t\t\t\topts->permit_x11_forwarding_flag = 1;\n\t\t\t\tfound = 1;\n\t\t\t} else if (strcmp(name,\n\t\t\t    \"permit-agent-forwarding\") == 0) {\n\t\t\t\topts->permit_agent_forwarding_flag = 1;\n\t\t\t\tfound = 1;\n\t\t\t} else if (strcmp(name,\n\t\t\t    \"permit-port-forwarding\") == 0) {\n\t\t\t\topts->permit_port_forwarding_flag = 1;\n\t\t\t\tfound = 1;\n\t\t\t} else if (strcmp(name, \"permit-pty\") == 0) {\n\t\t\t\topts->permit_pty_flag = 1;\n\t\t\t\tfound = 1;\n\t\t\t} else if (strcmp(name, \"permit-user-rc\") == 0) {\n\t\t\t\topts->permit_user_rc = 1;\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t}\n\t\tif (!found && (which & OPTIONS_CRITICAL) != 0) {\n\t\t\tif (strcmp(name, \"force-command\") == 0) {\n\t\t\t\tif ((r = sshbuf_get_cstring(data, &command,\n\t\t\t\t    NULL)) != 0) {\n\t\t\t\t\terror(\"Unable to parse \\\"%s\\\" \"\n\t\t\t\t\t    \"section: %s\", name, ssh_err(r));\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (opts->force_command != NULL) {\n\t\t\t\t\terror(\"Certificate has multiple \"\n\t\t\t\t\t    \"force-command options\");\n\t\t\t\t\tfree(command);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\topts->force_command = command;\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t\tif (strcmp(name, \"source-address\") == 0) {\n\t\t\t\tif ((r = sshbuf_get_cstring(data, &allowed,\n\t\t\t\t    NULL)) != 0) {\n\t\t\t\t\terror(\"Unable to parse \\\"%s\\\" \"\n\t\t\t\t\t    \"section: %s\", name, ssh_err(r));\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (opts->required_from_host_cert != NULL) {\n\t\t\t\t\terror(\"Certificate has multiple \"\n\t\t\t\t\t    \"source-address options\");\n\t\t\t\t\tfree(allowed);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\t/* Check syntax */\n\t\t\t\tif (addr_match_cidr_list(NULL, allowed) == -1) {\n\t\t\t\t\terror(\"Certificate source-address \"\n\t\t\t\t\t    \"contents invalid\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\topts->required_from_host_cert = allowed;\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (!found) {\n\t\t\tif (crit) {\n\t\t\t\terror(\"Certificate critical option \\\"%s\\\" \"\n\t\t\t\t    \"is not supported\", name);\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tlogit(\"Certificate extension \\\"%s\\\" \"\n\t\t\t\t    \"is not supported\", name);\n\t\t\t}\n\t\t} else if (sshbuf_len(data) != 0) {\n\t\t\terror(\"Certificate option \\\"%s\\\" corrupt \"\n\t\t\t    \"(extra data)\", name);\n\t\t\tgoto out;\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\t/* successfully parsed all options */\n\tret = 0;\n\n out:\n\tfree(name);\n\tsshbuf_free(data);\n\tsshbuf_free(c);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshauthopt_new",
          "args": [],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_new_with_keys_defaults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "294-309",
          "snippet": "struct sshauthopt *\nsshauthopt_new_with_keys_defaults(void)\n{\n\tstruct sshauthopt *ret = NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\treturn NULL;\n\n\t/* Defaults for authorized_keys flags */\n\tret->permit_port_forwarding_flag = 1;\n\tret->permit_agent_forwarding_flag = 1;\n\tret->permit_x11_forwarding_flag = 1;\n\tret->permit_pty_flag = 1;\n\tret->permit_user_rc = 1;\n\treturn ret;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshauthopt *\nsshauthopt_new_with_keys_defaults(void)\n{\n\tstruct sshauthopt *ret = NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\treturn NULL;\n\n\t/* Defaults for authorized_keys flags */\n\tret->permit_port_forwarding_flag = 1;\n\tret->permit_agent_forwarding_flag = 1;\n\tret->permit_x11_forwarding_flag = 1;\n\tret->permit_pty_flag = 1;\n\tret->permit_user_rc = 1;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_is_cert",
          "args": [
            "k->type"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "165-175",
          "snippet": "int\nsshkey_type_is_cert(int type)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type == type)\n\t\t\treturn kt->cert;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_type_is_cert(int type)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->type == type)\n\t\t\treturn kt->cert;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define OPTIONS_EXTENSIONS\t2\n#define OPTIONS_CRITICAL\t1\n\nstruct sshauthopt *\nsshauthopt_from_cert(struct sshkey *k)\n{\n\tstruct sshauthopt *ret;\n\n\tif (k == NULL || !sshkey_type_is_cert(k->type) || k->cert == NULL ||\n\t    k->cert->type != SSH2_CERT_TYPE_USER)\n\t\treturn NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\treturn NULL;\n\n\t/* Handle options and critical extensions separately */\n\tif (cert_option_list(ret, k->cert->critical,\n\t    OPTIONS_CRITICAL, 1) == -1) {\n\t\tsshauthopt_free(ret);\n\t\treturn NULL;\n\t}\n\tif (cert_option_list(ret, k->cert->extensions,\n\t    OPTIONS_EXTENSIONS, 0) == -1) {\n\t\tsshauthopt_free(ret);\n\t\treturn NULL;\n\t}\n\t/* success */\n\treturn ret;\n}"
  },
  {
    "function_name": "sshauthopt_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
    "lines": "383-539",
    "snippet": "struct sshauthopt *\nsshauthopt_parse(const char *opts, const char **errstrp)\n{\n\tchar **oarray, *opt, *cp, *tmp;\n\tint r;\n\tstruct sshauthopt *ret = NULL;\n\tconst char *errstr = \"unknown error\";\n\tuint64_t valid_before;\n\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\tif ((ret = sshauthopt_new_with_keys_defaults()) == NULL)\n\t\tgoto alloc_fail;\n\n\tif (opts == NULL)\n\t\treturn ret;\n\n\twhile (*opts && *opts != ' ' && *opts != '\\t') {\n\t\t/* flag options */\n\t\tif ((r = opt_flag(\"restrict\", 0, &opts)) != -1) {\n\t\t\tret->restricted = 1;\n\t\t\tret->permit_port_forwarding_flag = 0;\n\t\t\tret->permit_agent_forwarding_flag = 0;\n\t\t\tret->permit_x11_forwarding_flag = 0;\n\t\t\tret->permit_pty_flag = 0;\n\t\t\tret->permit_user_rc = 0;\n\t\t} else if ((r = opt_flag(\"cert-authority\", 0, &opts)) != -1) {\n\t\t\tret->cert_authority = r;\n\t\t} else if ((r = opt_flag(\"port-forwarding\", 1, &opts)) != -1) {\n\t\t\tret->permit_port_forwarding_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"agent-forwarding\", 1, &opts)) != -1) {\n\t\t\tret->permit_agent_forwarding_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"x11-forwarding\", 1, &opts)) != -1) {\n\t\t\tret->permit_x11_forwarding_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"pty\", 1, &opts)) != -1) {\n\t\t\tret->permit_pty_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"user-rc\", 1, &opts)) != -1) {\n\t\t\tret->permit_user_rc = r == 1;\n\t\t} else if (opt_match(&opts, \"command\")) {\n\t\t\tif (ret->force_command != NULL) {\n\t\t\t\terrstr = \"multiple \\\"command\\\" clauses\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tret->force_command = opt_dequote(&opts, &errstr);\n\t\t\tif (ret->force_command == NULL)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"principals\")) {\n\t\t\tif (ret->cert_principals != NULL) {\n\t\t\t\terrstr = \"multiple \\\"principals\\\" clauses\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tret->cert_principals = opt_dequote(&opts, &errstr);\n\t\t\tif (ret->cert_principals == NULL)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"from\")) {\n\t\t\tif (ret->required_from_host_keys != NULL) {\n\t\t\t\terrstr = \"multiple \\\"from\\\" clauses\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tret->required_from_host_keys = opt_dequote(&opts,\n\t\t\t    &errstr);\n\t\t\tif (ret->required_from_host_keys == NULL)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"expiry-time\")) {\n\t\t\tif ((opt = opt_dequote(&opts, &errstr)) == NULL)\n\t\t\t\tgoto fail;\n\t\t\tif (parse_absolute_time(opt, &valid_before) != 0 ||\n\t\t\t    valid_before == 0) {\n\t\t\t\tfree(opt);\n\t\t\t\terrstr = \"invalid expires time\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tfree(opt);\n\t\t\tif (ret->valid_before == 0 ||\n\t\t\t    valid_before < ret->valid_before)\n\t\t\t\tret->valid_before = valid_before;\n\t\t} else if (opt_match(&opts, \"environment\")) {\n\t\t\tif (ret->nenv > INT_MAX) {\n\t\t\t\terrstr = \"too many environment strings\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif ((opt = opt_dequote(&opts, &errstr)) == NULL)\n\t\t\t\tgoto fail;\n\t\t\t/* env name must be alphanumeric and followed by '=' */\n\t\t\tif ((tmp = strchr(opt, '=')) == NULL) {\n\t\t\t\tfree(opt);\n\t\t\t\terrstr = \"invalid environment string\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif ((cp = strdup(opt)) == NULL)\n\t\t\t\tgoto alloc_fail;\n\t\t\tcp[tmp - opt] = '\\0'; /* truncate at '=' */\n\t\t\tif (!valid_env_name(cp)) {\n\t\t\t\tfree(cp);\n\t\t\t\tfree(opt);\n\t\t\t\terrstr = \"invalid environment string\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tfree(cp);\n\t\t\t/* Append it. */\n\t\t\toarray = ret->env;\n\t\t\tif ((ret->env = recallocarray(ret->env, ret->nenv,\n\t\t\t    ret->nenv + 1, sizeof(*ret->env))) == NULL) {\n\t\t\t\tfree(opt);\n\t\t\t\tret->env = oarray; /* put it back for cleanup */\n\t\t\t\tgoto alloc_fail;\n\t\t\t}\n\t\t\tret->env[ret->nenv++] = opt;\n\t\t} else if (opt_match(&opts, \"permitopen\")) {\n\t\t\tif (handle_permit(&opts, 0, &ret->permitopen,\n\t\t\t    &ret->npermitopen, &errstr) != 0)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"permitlisten\")) {\n\t\t\tif (handle_permit(&opts, 1, &ret->permitlisten,\n\t\t\t    &ret->npermitlisten, &errstr) != 0)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"tunnel\")) {\n\t\t\tif ((opt = opt_dequote(&opts, &errstr)) == NULL)\n\t\t\t\tgoto fail;\n\t\t\tret->force_tun_device = a2tun(opt, NULL);\n\t\t\tfree(opt);\n\t\t\tif (ret->force_tun_device == SSH_TUNID_ERR) {\n\t\t\t\terrstr = \"invalid tun device\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Skip the comma, and move to the next option\n\t\t * (or break out if there are no more).\n\t\t */\n\t\tif (*opts == '\\0' || *opts == ' ' || *opts == '\\t')\n\t\t\tbreak;\t\t/* End of options. */\n\t\t/* Anything other than a comma is an unknown option */\n\t\tif (*opts != ',') {\n\t\t\terrstr = \"unknown key option\";\n\t\t\tgoto fail;\n\t\t}\n\t\topts++;\n\t\tif (*opts == '\\0') {\n\t\t\terrstr = \"unexpected end-of-options\";\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* success */\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\treturn ret;\n\nalloc_fail:\n\terrstr = \"memory allocation failed\";\nfail:\n\tsshauthopt_free(ret);\n\tif (errstrp != NULL)\n\t\t*errstrp = errstr;\n\treturn NULL;\n}",
    "includes": [
      "#include \"auth-options.h\"",
      "#include \"ssh2.h\"",
      "#include \"match.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshauthopt_free",
          "args": [
            "ret"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "265-292",
          "snippet": "void\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "a2tun",
          "args": [
            "opt",
            "NULL"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "a2tun",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "348-377",
          "snippet": "int\na2tun(const char *s, int *remote)\n{\n\tconst char *errstr = NULL;\n\tchar *sp, *ep;\n\tint tun;\n\n\tif (remote != NULL) {\n\t\t*remote = SSH_TUNID_ANY;\n\t\tsp = xstrdup(s);\n\t\tif ((ep = strchr(sp, ':')) == NULL) {\n\t\t\tfree(sp);\n\t\t\treturn (a2tun(s, NULL));\n\t\t}\n\t\tep[0] = '\\0'; ep++;\n\t\t*remote = a2tun(ep, NULL);\n\t\ttun = a2tun(sp, NULL);\n\t\tfree(sp);\n\t\treturn (*remote == SSH_TUNID_ERR ? *remote : tun);\n\t}\n\n\tif (strcasecmp(s, \"any\") == 0)\n\t\treturn (SSH_TUNID_ANY);\n\n\ttun = strtonum(s, 0, SSH_TUNID_MAX, &errstr);\n\tif (errstr != NULL)\n\t\treturn (SSH_TUNID_ERR);\n\n\treturn (tun);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\na2tun(const char *s, int *remote)\n{\n\tconst char *errstr = NULL;\n\tchar *sp, *ep;\n\tint tun;\n\n\tif (remote != NULL) {\n\t\t*remote = SSH_TUNID_ANY;\n\t\tsp = xstrdup(s);\n\t\tif ((ep = strchr(sp, ':')) == NULL) {\n\t\t\tfree(sp);\n\t\t\treturn (a2tun(s, NULL));\n\t\t}\n\t\tep[0] = '\\0'; ep++;\n\t\t*remote = a2tun(ep, NULL);\n\t\ttun = a2tun(sp, NULL);\n\t\tfree(sp);\n\t\treturn (*remote == SSH_TUNID_ERR ? *remote : tun);\n\t}\n\n\tif (strcasecmp(s, \"any\") == 0)\n\t\treturn (SSH_TUNID_ANY);\n\n\ttun = strtonum(s, 0, SSH_TUNID_MAX, &errstr);\n\tif (errstr != NULL)\n\t\treturn (SSH_TUNID_ERR);\n\n\treturn (tun);\n}"
        }
      },
      {
        "call_info": {
          "callee": "opt_dequote",
          "args": [
            "&opts",
            "&errstr"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "opt_dequote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "67-98",
          "snippet": "static char *\nopt_dequote(const char **sp, const char **errstrp)\n{\n\tconst char *s = *sp;\n\tchar *ret;\n\tsize_t i;\n\n\t*errstrp = NULL;\n\tif (*s != '\"') {\n\t\t*errstrp = \"missing start quote\";\n\t\treturn NULL;\n\t}\n\ts++;\n\tif ((ret = malloc(strlen((s)) + 1)) == NULL) {\n\t\t*errstrp = \"memory allocation failed\";\n\t\treturn NULL;\n\t}\n\tfor (i = 0; *s != '\\0' && *s != '\"';) {\n\t\tif (s[0] == '\\\\' && s[1] == '\"')\n\t\t\ts++;\n\t\tret[i++] = *s++;\n\t}\n\tif (*s == '\\0') {\n\t\t*errstrp = \"missing end quote\";\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tret[i] = '\\0';\n\ts++;\n\t*sp = s;\n\treturn ret;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nopt_dequote(const char **sp, const char **errstrp)\n{\n\tconst char *s = *sp;\n\tchar *ret;\n\tsize_t i;\n\n\t*errstrp = NULL;\n\tif (*s != '\"') {\n\t\t*errstrp = \"missing start quote\";\n\t\treturn NULL;\n\t}\n\ts++;\n\tif ((ret = malloc(strlen((s)) + 1)) == NULL) {\n\t\t*errstrp = \"memory allocation failed\";\n\t\treturn NULL;\n\t}\n\tfor (i = 0; *s != '\\0' && *s != '\"';) {\n\t\tif (s[0] == '\\\\' && s[1] == '\"')\n\t\t\ts++;\n\t\tret[i++] = *s++;\n\t}\n\tif (*s == '\\0') {\n\t\t*errstrp = \"missing end quote\";\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tret[i] = '\\0';\n\ts++;\n\t*sp = s;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "opt_match",
          "args": [
            "&opts",
            "\"tunnel\""
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "opt_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "100-109",
          "snippet": "static int\nopt_match(const char **opts, const char *term)\n{\n\tif (strncasecmp((*opts), term, strlen(term)) == 0 &&\n\t    (*opts)[strlen(term)] == '=') {\n\t\t*opts += strlen(term) + 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nopt_match(const char **opts, const char *term)\n{\n\tif (strncasecmp((*opts), term, strlen(term)) == 0 &&\n\t    (*opts)[strlen(term)] == '=') {\n\t\t*opts += strlen(term) + 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_permit",
          "args": [
            "&opts",
            "1",
            "&ret->permitlisten",
            "&ret->npermitlisten",
            "&errstr"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "handle_permit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "315-381",
          "snippet": "static int\nhandle_permit(const char **optsp, int allow_bare_port,\n    char ***permitsp, size_t *npermitsp, const char **errstrp)\n{\n\tchar *opt, *tmp, *cp, *host, **permits = *permitsp;\n\tsize_t npermits = *npermitsp;\n\tconst char *errstr = \"unknown error\";\n\n\tif (npermits > INT_MAX) {\n\t\t*errstrp = \"too many permission directives\";\n\t\treturn -1;\n\t}\n\tif ((opt = opt_dequote(optsp, &errstr)) == NULL) {\n\t\treturn -1;\n\t}\n\tif (allow_bare_port && strchr(opt, ':') == NULL) {\n\t\t/*\n\t\t * Allow a bare port number in permitlisten to indicate a\n\t\t * listen_host wildcard.\n\t\t */\n\t\tif (asprintf(&tmp, \"*:%s\", opt) < 0) {\n\t\t\t*errstrp = \"memory allocation failed\";\n\t\t\treturn -1;\n\t\t}\n\t\tfree(opt);\n\t\topt = tmp;\n\t}\n\tif ((tmp = strdup(opt)) == NULL) {\n\t\tfree(opt);\n\t\t*errstrp = \"memory allocation failed\";\n\t\treturn -1;\n\t}\n\tcp = tmp;\n\t/* validate syntax before recording it. */\n\thost = hpdelim(&cp);\n\tif (host == NULL || strlen(host) >= NI_MAXHOST) {\n\t\tfree(tmp);\n\t\tfree(opt);\n\t\t*errstrp = \"invalid permission hostname\";\n\t\treturn -1;\n\t}\n\t/*\n\t * don't want to use permitopen_port to avoid\n\t * dependency on channels.[ch] here.\n\t */\n\tif (cp == NULL ||\n\t    (strcmp(cp, \"*\") != 0 && a2port(cp) <= 0)) {\n\t\tfree(tmp);\n\t\tfree(opt);\n\t\t*errstrp = \"invalid permission port\";\n\t\treturn -1;\n\t}\n\t/* XXX - add streamlocal support */\n\tfree(tmp);\n\t/* Record it */\n\tif ((permits = recallocarray(permits, npermits, npermits + 1,\n\t    sizeof(*permits))) == NULL) {\n\t\tfree(opt);\n\t\t/* NB. don't update *permitsp if alloc fails */\n\t\t*errstrp = \"memory allocation failed\";\n\t\treturn -1;\n\t}\n\tpermits[npermits++] = opt;\n\t*permitsp = permits;\n\t*npermitsp = npermits;\n\treturn 0;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nhandle_permit(const char **optsp, int allow_bare_port,\n    char ***permitsp, size_t *npermitsp, const char **errstrp)\n{\n\tchar *opt, *tmp, *cp, *host, **permits = *permitsp;\n\tsize_t npermits = *npermitsp;\n\tconst char *errstr = \"unknown error\";\n\n\tif (npermits > INT_MAX) {\n\t\t*errstrp = \"too many permission directives\";\n\t\treturn -1;\n\t}\n\tif ((opt = opt_dequote(optsp, &errstr)) == NULL) {\n\t\treturn -1;\n\t}\n\tif (allow_bare_port && strchr(opt, ':') == NULL) {\n\t\t/*\n\t\t * Allow a bare port number in permitlisten to indicate a\n\t\t * listen_host wildcard.\n\t\t */\n\t\tif (asprintf(&tmp, \"*:%s\", opt) < 0) {\n\t\t\t*errstrp = \"memory allocation failed\";\n\t\t\treturn -1;\n\t\t}\n\t\tfree(opt);\n\t\topt = tmp;\n\t}\n\tif ((tmp = strdup(opt)) == NULL) {\n\t\tfree(opt);\n\t\t*errstrp = \"memory allocation failed\";\n\t\treturn -1;\n\t}\n\tcp = tmp;\n\t/* validate syntax before recording it. */\n\thost = hpdelim(&cp);\n\tif (host == NULL || strlen(host) >= NI_MAXHOST) {\n\t\tfree(tmp);\n\t\tfree(opt);\n\t\t*errstrp = \"invalid permission hostname\";\n\t\treturn -1;\n\t}\n\t/*\n\t * don't want to use permitopen_port to avoid\n\t * dependency on channels.[ch] here.\n\t */\n\tif (cp == NULL ||\n\t    (strcmp(cp, \"*\") != 0 && a2port(cp) <= 0)) {\n\t\tfree(tmp);\n\t\tfree(opt);\n\t\t*errstrp = \"invalid permission port\";\n\t\treturn -1;\n\t}\n\t/* XXX - add streamlocal support */\n\tfree(tmp);\n\t/* Record it */\n\tif ((permits = recallocarray(permits, npermits, npermits + 1,\n\t    sizeof(*permits))) == NULL) {\n\t\tfree(opt);\n\t\t/* NB. don't update *permitsp if alloc fails */\n\t\t*errstrp = \"memory allocation failed\";\n\t\treturn -1;\n\t}\n\tpermits[npermits++] = opt;\n\t*permitsp = permits;\n\t*npermitsp = npermits;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recallocarray",
          "args": [
            "ret->env",
            "ret->nenv",
            "ret->nenv + 1",
            "sizeof(*ret->env)"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "xrecallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "80-90",
          "snippet": "void *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_env_name",
          "args": [
            "cp"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "valid_env_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1960-1972",
          "snippet": "int\nvalid_env_name(const char *name)\n{\n\tconst char *cp;\n\n\tif (name[0] == '\\0')\n\t\treturn 0;\n\tfor (cp = name; *cp != '\\0'; cp++) {\n\t\tif (!isalnum((u_char)*cp) && *cp != '_')\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nvalid_env_name(const char *name)\n{\n\tconst char *cp;\n\n\tif (name[0] == '\\0')\n\t\treturn 0;\n\tfor (cp = name; *cp != '\\0'; cp++) {\n\t\tif (!isalnum((u_char)*cp) && *cp != '_')\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "opt"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "opt",
            "'='"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_absolute_time",
          "args": [
            "opt",
            "&valid_before"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "parse_absolute_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1988-2029",
          "snippet": "int\nparse_absolute_time(const char *s, uint64_t *tp)\n{\n\tstruct tm tm;\n\ttime_t tt;\n\tchar buf[32], *fmt;\n\n\t*tp = 0;\n\n\t/*\n\t * POSIX strptime says \"The application shall ensure that there\n\t * is white-space or other non-alphanumeric characters between\n\t * any two conversion specifications\" so arrange things this way.\n\t */\n\tswitch (strlen(s)) {\n\tcase 8: /* YYYYMMDD */\n\t\tfmt = \"%Y-%m-%d\";\n\t\tsnprintf(buf, sizeof(buf), \"%.4s-%.2s-%.2s\", s, s + 4, s + 6);\n\t\tbreak;\n\tcase 12: /* YYYYMMDDHHMM */\n\t\tfmt = \"%Y-%m-%dT%H:%M\";\n\t\tsnprintf(buf, sizeof(buf), \"%.4s-%.2s-%.2sT%.2s:%.2s\",\n\t\t    s, s + 4, s + 6, s + 8, s + 10);\n\t\tbreak;\n\tcase 14: /* YYYYMMDDHHMMSS */\n\t\tfmt = \"%Y-%m-%dT%H:%M:%S\";\n\t\tsnprintf(buf, sizeof(buf), \"%.4s-%.2s-%.2sT%.2s:%.2s:%.2s\",\n\t\t    s, s + 4, s + 6, s + 8, s + 10, s + 12);\n\t\tbreak;\n\tdefault:\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\n\tmemset(&tm, 0, sizeof(tm));\n\tif (strptime(buf, fmt, &tm) == NULL)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif ((tt = mktime(&tm)) < 0)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t/* success */\n\t*tp = (uint64_t)tt;\n\treturn 0;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nparse_absolute_time(const char *s, uint64_t *tp)\n{\n\tstruct tm tm;\n\ttime_t tt;\n\tchar buf[32], *fmt;\n\n\t*tp = 0;\n\n\t/*\n\t * POSIX strptime says \"The application shall ensure that there\n\t * is white-space or other non-alphanumeric characters between\n\t * any two conversion specifications\" so arrange things this way.\n\t */\n\tswitch (strlen(s)) {\n\tcase 8: /* YYYYMMDD */\n\t\tfmt = \"%Y-%m-%d\";\n\t\tsnprintf(buf, sizeof(buf), \"%.4s-%.2s-%.2s\", s, s + 4, s + 6);\n\t\tbreak;\n\tcase 12: /* YYYYMMDDHHMM */\n\t\tfmt = \"%Y-%m-%dT%H:%M\";\n\t\tsnprintf(buf, sizeof(buf), \"%.4s-%.2s-%.2sT%.2s:%.2s\",\n\t\t    s, s + 4, s + 6, s + 8, s + 10);\n\t\tbreak;\n\tcase 14: /* YYYYMMDDHHMMSS */\n\t\tfmt = \"%Y-%m-%dT%H:%M:%S\";\n\t\tsnprintf(buf, sizeof(buf), \"%.4s-%.2s-%.2sT%.2s:%.2s:%.2s\",\n\t\t    s, s + 4, s + 6, s + 8, s + 10, s + 12);\n\t\tbreak;\n\tdefault:\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\n\tmemset(&tm, 0, sizeof(tm));\n\tif (strptime(buf, fmt, &tm) == NULL)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif ((tt = mktime(&tm)) < 0)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t/* success */\n\t*tp = (uint64_t)tt;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "opt_flag",
          "args": [
            "\"user-rc\"",
            "1",
            "&opts"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "opt_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "49-65",
          "snippet": "static int\nopt_flag(const char *opt, int allow_negate, const char **optsp)\n{\n\tsize_t opt_len = strlen(opt);\n\tconst char *opts = *optsp;\n\tint negate = 0;\n\n\tif (allow_negate && strncasecmp(opts, \"no-\", 3) == 0) {\n\t\topts += 3;\n\t\tnegate = 1;\n\t}\n\tif (strncasecmp(opts, opt, opt_len) == 0) {\n\t\t*optsp = opts + opt_len;\n\t\treturn negate ? 0 : 1;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nopt_flag(const char *opt, int allow_negate, const char **optsp)\n{\n\tsize_t opt_len = strlen(opt);\n\tconst char *opts = *optsp;\n\tint negate = 0;\n\n\tif (allow_negate && strncasecmp(opts, \"no-\", 3) == 0) {\n\t\topts += 3;\n\t\tnegate = 1;\n\t}\n\tif (strncasecmp(opts, opt, opt_len) == 0) {\n\t\t*optsp = opts + opt_len;\n\t\treturn negate ? 0 : 1;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshauthopt_new_with_keys_defaults",
          "args": [],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_new_with_keys_defaults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "294-309",
          "snippet": "struct sshauthopt *\nsshauthopt_new_with_keys_defaults(void)\n{\n\tstruct sshauthopt *ret = NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\treturn NULL;\n\n\t/* Defaults for authorized_keys flags */\n\tret->permit_port_forwarding_flag = 1;\n\tret->permit_agent_forwarding_flag = 1;\n\tret->permit_x11_forwarding_flag = 1;\n\tret->permit_pty_flag = 1;\n\tret->permit_user_rc = 1;\n\treturn ret;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshauthopt *\nsshauthopt_new_with_keys_defaults(void)\n{\n\tstruct sshauthopt *ret = NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\treturn NULL;\n\n\t/* Defaults for authorized_keys flags */\n\tret->permit_port_forwarding_flag = 1;\n\tret->permit_agent_forwarding_flag = 1;\n\tret->permit_x11_forwarding_flag = 1;\n\tret->permit_pty_flag = 1;\n\tret->permit_user_rc = 1;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshauthopt *\nsshauthopt_parse(const char *opts, const char **errstrp)\n{\n\tchar **oarray, *opt, *cp, *tmp;\n\tint r;\n\tstruct sshauthopt *ret = NULL;\n\tconst char *errstr = \"unknown error\";\n\tuint64_t valid_before;\n\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\tif ((ret = sshauthopt_new_with_keys_defaults()) == NULL)\n\t\tgoto alloc_fail;\n\n\tif (opts == NULL)\n\t\treturn ret;\n\n\twhile (*opts && *opts != ' ' && *opts != '\\t') {\n\t\t/* flag options */\n\t\tif ((r = opt_flag(\"restrict\", 0, &opts)) != -1) {\n\t\t\tret->restricted = 1;\n\t\t\tret->permit_port_forwarding_flag = 0;\n\t\t\tret->permit_agent_forwarding_flag = 0;\n\t\t\tret->permit_x11_forwarding_flag = 0;\n\t\t\tret->permit_pty_flag = 0;\n\t\t\tret->permit_user_rc = 0;\n\t\t} else if ((r = opt_flag(\"cert-authority\", 0, &opts)) != -1) {\n\t\t\tret->cert_authority = r;\n\t\t} else if ((r = opt_flag(\"port-forwarding\", 1, &opts)) != -1) {\n\t\t\tret->permit_port_forwarding_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"agent-forwarding\", 1, &opts)) != -1) {\n\t\t\tret->permit_agent_forwarding_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"x11-forwarding\", 1, &opts)) != -1) {\n\t\t\tret->permit_x11_forwarding_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"pty\", 1, &opts)) != -1) {\n\t\t\tret->permit_pty_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"user-rc\", 1, &opts)) != -1) {\n\t\t\tret->permit_user_rc = r == 1;\n\t\t} else if (opt_match(&opts, \"command\")) {\n\t\t\tif (ret->force_command != NULL) {\n\t\t\t\terrstr = \"multiple \\\"command\\\" clauses\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tret->force_command = opt_dequote(&opts, &errstr);\n\t\t\tif (ret->force_command == NULL)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"principals\")) {\n\t\t\tif (ret->cert_principals != NULL) {\n\t\t\t\terrstr = \"multiple \\\"principals\\\" clauses\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tret->cert_principals = opt_dequote(&opts, &errstr);\n\t\t\tif (ret->cert_principals == NULL)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"from\")) {\n\t\t\tif (ret->required_from_host_keys != NULL) {\n\t\t\t\terrstr = \"multiple \\\"from\\\" clauses\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tret->required_from_host_keys = opt_dequote(&opts,\n\t\t\t    &errstr);\n\t\t\tif (ret->required_from_host_keys == NULL)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"expiry-time\")) {\n\t\t\tif ((opt = opt_dequote(&opts, &errstr)) == NULL)\n\t\t\t\tgoto fail;\n\t\t\tif (parse_absolute_time(opt, &valid_before) != 0 ||\n\t\t\t    valid_before == 0) {\n\t\t\t\tfree(opt);\n\t\t\t\terrstr = \"invalid expires time\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tfree(opt);\n\t\t\tif (ret->valid_before == 0 ||\n\t\t\t    valid_before < ret->valid_before)\n\t\t\t\tret->valid_before = valid_before;\n\t\t} else if (opt_match(&opts, \"environment\")) {\n\t\t\tif (ret->nenv > INT_MAX) {\n\t\t\t\terrstr = \"too many environment strings\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif ((opt = opt_dequote(&opts, &errstr)) == NULL)\n\t\t\t\tgoto fail;\n\t\t\t/* env name must be alphanumeric and followed by '=' */\n\t\t\tif ((tmp = strchr(opt, '=')) == NULL) {\n\t\t\t\tfree(opt);\n\t\t\t\terrstr = \"invalid environment string\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif ((cp = strdup(opt)) == NULL)\n\t\t\t\tgoto alloc_fail;\n\t\t\tcp[tmp - opt] = '\\0'; /* truncate at '=' */\n\t\t\tif (!valid_env_name(cp)) {\n\t\t\t\tfree(cp);\n\t\t\t\tfree(opt);\n\t\t\t\terrstr = \"invalid environment string\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tfree(cp);\n\t\t\t/* Append it. */\n\t\t\toarray = ret->env;\n\t\t\tif ((ret->env = recallocarray(ret->env, ret->nenv,\n\t\t\t    ret->nenv + 1, sizeof(*ret->env))) == NULL) {\n\t\t\t\tfree(opt);\n\t\t\t\tret->env = oarray; /* put it back for cleanup */\n\t\t\t\tgoto alloc_fail;\n\t\t\t}\n\t\t\tret->env[ret->nenv++] = opt;\n\t\t} else if (opt_match(&opts, \"permitopen\")) {\n\t\t\tif (handle_permit(&opts, 0, &ret->permitopen,\n\t\t\t    &ret->npermitopen, &errstr) != 0)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"permitlisten\")) {\n\t\t\tif (handle_permit(&opts, 1, &ret->permitlisten,\n\t\t\t    &ret->npermitlisten, &errstr) != 0)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"tunnel\")) {\n\t\t\tif ((opt = opt_dequote(&opts, &errstr)) == NULL)\n\t\t\t\tgoto fail;\n\t\t\tret->force_tun_device = a2tun(opt, NULL);\n\t\t\tfree(opt);\n\t\t\tif (ret->force_tun_device == SSH_TUNID_ERR) {\n\t\t\t\terrstr = \"invalid tun device\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Skip the comma, and move to the next option\n\t\t * (or break out if there are no more).\n\t\t */\n\t\tif (*opts == '\\0' || *opts == ' ' || *opts == '\\t')\n\t\t\tbreak;\t\t/* End of options. */\n\t\t/* Anything other than a comma is an unknown option */\n\t\tif (*opts != ',') {\n\t\t\terrstr = \"unknown key option\";\n\t\t\tgoto fail;\n\t\t}\n\t\topts++;\n\t\tif (*opts == '\\0') {\n\t\t\terrstr = \"unexpected end-of-options\";\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* success */\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\treturn ret;\n\nalloc_fail:\n\terrstr = \"memory allocation failed\";\nfail:\n\tsshauthopt_free(ret);\n\tif (errstrp != NULL)\n\t\t*errstrp = errstr;\n\treturn NULL;\n}"
  },
  {
    "function_name": "handle_permit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
    "lines": "315-381",
    "snippet": "static int\nhandle_permit(const char **optsp, int allow_bare_port,\n    char ***permitsp, size_t *npermitsp, const char **errstrp)\n{\n\tchar *opt, *tmp, *cp, *host, **permits = *permitsp;\n\tsize_t npermits = *npermitsp;\n\tconst char *errstr = \"unknown error\";\n\n\tif (npermits > INT_MAX) {\n\t\t*errstrp = \"too many permission directives\";\n\t\treturn -1;\n\t}\n\tif ((opt = opt_dequote(optsp, &errstr)) == NULL) {\n\t\treturn -1;\n\t}\n\tif (allow_bare_port && strchr(opt, ':') == NULL) {\n\t\t/*\n\t\t * Allow a bare port number in permitlisten to indicate a\n\t\t * listen_host wildcard.\n\t\t */\n\t\tif (asprintf(&tmp, \"*:%s\", opt) < 0) {\n\t\t\t*errstrp = \"memory allocation failed\";\n\t\t\treturn -1;\n\t\t}\n\t\tfree(opt);\n\t\topt = tmp;\n\t}\n\tif ((tmp = strdup(opt)) == NULL) {\n\t\tfree(opt);\n\t\t*errstrp = \"memory allocation failed\";\n\t\treturn -1;\n\t}\n\tcp = tmp;\n\t/* validate syntax before recording it. */\n\thost = hpdelim(&cp);\n\tif (host == NULL || strlen(host) >= NI_MAXHOST) {\n\t\tfree(tmp);\n\t\tfree(opt);\n\t\t*errstrp = \"invalid permission hostname\";\n\t\treturn -1;\n\t}\n\t/*\n\t * don't want to use permitopen_port to avoid\n\t * dependency on channels.[ch] here.\n\t */\n\tif (cp == NULL ||\n\t    (strcmp(cp, \"*\") != 0 && a2port(cp) <= 0)) {\n\t\tfree(tmp);\n\t\tfree(opt);\n\t\t*errstrp = \"invalid permission port\";\n\t\treturn -1;\n\t}\n\t/* XXX - add streamlocal support */\n\tfree(tmp);\n\t/* Record it */\n\tif ((permits = recallocarray(permits, npermits, npermits + 1,\n\t    sizeof(*permits))) == NULL) {\n\t\tfree(opt);\n\t\t/* NB. don't update *permitsp if alloc fails */\n\t\t*errstrp = \"memory allocation failed\";\n\t\treturn -1;\n\t}\n\tpermits[npermits++] = opt;\n\t*permitsp = permits;\n\t*npermitsp = npermits;\n\treturn 0;\n}",
    "includes": [
      "#include \"auth-options.h\"",
      "#include \"ssh2.h\"",
      "#include \"match.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "opt"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "265-292",
          "snippet": "void\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recallocarray",
          "args": [
            "permits",
            "npermits",
            "npermits + 1",
            "sizeof(*permits)"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "xrecallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "80-90",
          "snippet": "void *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxrecallocarray(void *ptr, size_t onmemb, size_t nmemb, size_t size)\n{\n\tvoid *new_ptr;\n\n\tnew_ptr = recallocarray(ptr, onmemb, nmemb, size);\n\tif (new_ptr == NULL)\n\t\tfatal(\"xrecallocarray: out of memory (%zu elements of %zu bytes)\",\n\t\t    nmemb, size);\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "a2port",
          "args": [
            "cp"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "a2port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "333-346",
          "snippet": "int\na2port(const char *s)\n{\n\tstruct servent *se;\n\tlong long port;\n\tconst char *errstr;\n\n\tport = strtonum(s, 0, 65535, &errstr);\n\tif (errstr == NULL)\n\t\treturn (int)port;\n\tif ((se = getservbyname(s, \"tcp\")) != NULL)\n\t\treturn ntohs(se->s_port);\n\treturn -1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\na2port(const char *s)\n{\n\tstruct servent *se;\n\tlong long port;\n\tconst char *errstr;\n\n\tport = strtonum(s, 0, 65535, &errstr);\n\tif (errstr == NULL)\n\t\treturn (int)port;\n\tif ((se = getservbyname(s, \"tcp\")) != NULL)\n\t\treturn ntohs(se->s_port);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cp",
            "\"*\""
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "host"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpdelim",
          "args": [
            "&cp"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "hpdelim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "529-533",
          "snippet": "char *\nhpdelim(char **cp)\n{\n\treturn hpdelim2(cp, NULL);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nhpdelim(char **cp)\n{\n\treturn hpdelim2(cp, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "opt"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&tmp",
            "\"*:%s\"",
            "opt"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "opt",
            "':'"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "opt_dequote",
          "args": [
            "optsp",
            "&errstr"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "opt_dequote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "67-98",
          "snippet": "static char *\nopt_dequote(const char **sp, const char **errstrp)\n{\n\tconst char *s = *sp;\n\tchar *ret;\n\tsize_t i;\n\n\t*errstrp = NULL;\n\tif (*s != '\"') {\n\t\t*errstrp = \"missing start quote\";\n\t\treturn NULL;\n\t}\n\ts++;\n\tif ((ret = malloc(strlen((s)) + 1)) == NULL) {\n\t\t*errstrp = \"memory allocation failed\";\n\t\treturn NULL;\n\t}\n\tfor (i = 0; *s != '\\0' && *s != '\"';) {\n\t\tif (s[0] == '\\\\' && s[1] == '\"')\n\t\t\ts++;\n\t\tret[i++] = *s++;\n\t}\n\tif (*s == '\\0') {\n\t\t*errstrp = \"missing end quote\";\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tret[i] = '\\0';\n\ts++;\n\t*sp = s;\n\treturn ret;\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nopt_dequote(const char **sp, const char **errstrp)\n{\n\tconst char *s = *sp;\n\tchar *ret;\n\tsize_t i;\n\n\t*errstrp = NULL;\n\tif (*s != '\"') {\n\t\t*errstrp = \"missing start quote\";\n\t\treturn NULL;\n\t}\n\ts++;\n\tif ((ret = malloc(strlen((s)) + 1)) == NULL) {\n\t\t*errstrp = \"memory allocation failed\";\n\t\treturn NULL;\n\t}\n\tfor (i = 0; *s != '\\0' && *s != '\"';) {\n\t\tif (s[0] == '\\\\' && s[1] == '\"')\n\t\t\ts++;\n\t\tret[i++] = *s++;\n\t}\n\tif (*s == '\\0') {\n\t\t*errstrp = \"missing end quote\";\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tret[i] = '\\0';\n\ts++;\n\t*sp = s;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nhandle_permit(const char **optsp, int allow_bare_port,\n    char ***permitsp, size_t *npermitsp, const char **errstrp)\n{\n\tchar *opt, *tmp, *cp, *host, **permits = *permitsp;\n\tsize_t npermits = *npermitsp;\n\tconst char *errstr = \"unknown error\";\n\n\tif (npermits > INT_MAX) {\n\t\t*errstrp = \"too many permission directives\";\n\t\treturn -1;\n\t}\n\tif ((opt = opt_dequote(optsp, &errstr)) == NULL) {\n\t\treturn -1;\n\t}\n\tif (allow_bare_port && strchr(opt, ':') == NULL) {\n\t\t/*\n\t\t * Allow a bare port number in permitlisten to indicate a\n\t\t * listen_host wildcard.\n\t\t */\n\t\tif (asprintf(&tmp, \"*:%s\", opt) < 0) {\n\t\t\t*errstrp = \"memory allocation failed\";\n\t\t\treturn -1;\n\t\t}\n\t\tfree(opt);\n\t\topt = tmp;\n\t}\n\tif ((tmp = strdup(opt)) == NULL) {\n\t\tfree(opt);\n\t\t*errstrp = \"memory allocation failed\";\n\t\treturn -1;\n\t}\n\tcp = tmp;\n\t/* validate syntax before recording it. */\n\thost = hpdelim(&cp);\n\tif (host == NULL || strlen(host) >= NI_MAXHOST) {\n\t\tfree(tmp);\n\t\tfree(opt);\n\t\t*errstrp = \"invalid permission hostname\";\n\t\treturn -1;\n\t}\n\t/*\n\t * don't want to use permitopen_port to avoid\n\t * dependency on channels.[ch] here.\n\t */\n\tif (cp == NULL ||\n\t    (strcmp(cp, \"*\") != 0 && a2port(cp) <= 0)) {\n\t\tfree(tmp);\n\t\tfree(opt);\n\t\t*errstrp = \"invalid permission port\";\n\t\treturn -1;\n\t}\n\t/* XXX - add streamlocal support */\n\tfree(tmp);\n\t/* Record it */\n\tif ((permits = recallocarray(permits, npermits, npermits + 1,\n\t    sizeof(*permits))) == NULL) {\n\t\tfree(opt);\n\t\t/* NB. don't update *permitsp if alloc fails */\n\t\t*errstrp = \"memory allocation failed\";\n\t\treturn -1;\n\t}\n\tpermits[npermits++] = opt;\n\t*permitsp = permits;\n\t*npermitsp = npermits;\n\treturn 0;\n}"
  },
  {
    "function_name": "sshauthopt_new_with_keys_defaults",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
    "lines": "294-309",
    "snippet": "struct sshauthopt *\nsshauthopt_new_with_keys_defaults(void)\n{\n\tstruct sshauthopt *ret = NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\treturn NULL;\n\n\t/* Defaults for authorized_keys flags */\n\tret->permit_port_forwarding_flag = 1;\n\tret->permit_agent_forwarding_flag = 1;\n\tret->permit_x11_forwarding_flag = 1;\n\tret->permit_pty_flag = 1;\n\tret->permit_user_rc = 1;\n\treturn ret;\n}",
    "includes": [
      "#include \"auth-options.h\"",
      "#include \"ssh2.h\"",
      "#include \"match.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshauthopt_new",
          "args": [],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_new_with_keys_defaults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "294-309",
          "snippet": "struct sshauthopt *\nsshauthopt_new_with_keys_defaults(void)\n{\n\tstruct sshauthopt *ret = NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\treturn NULL;\n\n\t/* Defaults for authorized_keys flags */\n\tret->permit_port_forwarding_flag = 1;\n\tret->permit_agent_forwarding_flag = 1;\n\tret->permit_x11_forwarding_flag = 1;\n\tret->permit_pty_flag = 1;\n\tret->permit_user_rc = 1;\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshauthopt *\nsshauthopt_new_with_keys_defaults(void)\n{\n\tstruct sshauthopt *ret = NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\treturn NULL;\n\n\t/* Defaults for authorized_keys flags */\n\tret->permit_port_forwarding_flag = 1;\n\tret->permit_agent_forwarding_flag = 1;\n\tret->permit_x11_forwarding_flag = 1;\n\tret->permit_pty_flag = 1;\n\tret->permit_user_rc = 1;\n\treturn ret;\n}"
  },
  {
    "function_name": "sshauthopt_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
    "lines": "265-292",
    "snippet": "void\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}",
    "includes": [
      "#include \"auth-options.h\"",
      "#include \"ssh2.h\"",
      "#include \"match.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "opts"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "265-292",
          "snippet": "void\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "opts",
            "sizeof(*opts)"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}"
  },
  {
    "function_name": "sshauthopt_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
    "lines": "254-263",
    "snippet": "struct sshauthopt *\nsshauthopt_new(void)\n{\n\tstruct sshauthopt *ret;\n\n\tif ((ret = calloc(1, sizeof(*ret))) == NULL)\n\t\treturn NULL;\n\tret->force_tun_device = -1;\n\treturn ret;\n}",
    "includes": [
      "#include \"auth-options.h\"",
      "#include \"ssh2.h\"",
      "#include \"match.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(*ret)"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshauthopt *\nsshauthopt_new(void)\n{\n\tstruct sshauthopt *ret;\n\n\tif ((ret = calloc(1, sizeof(*ret))) == NULL)\n\t\treturn NULL;\n\tret->force_tun_device = -1;\n\treturn ret;\n}"
  },
  {
    "function_name": "cert_option_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
    "lines": "140-252",
    "snippet": "static int\ncert_option_list(struct sshauthopt *opts, struct sshbuf *oblob,\n    u_int which, int crit)\n{\n\tchar *command, *allowed;\n\tchar *name = NULL;\n\tstruct sshbuf *c = NULL, *data = NULL;\n\tint r, ret = -1, found;\n\n\tif ((c = sshbuf_fromb(oblob)) == NULL) {\n\t\terror(\"%s: sshbuf_fromb failed\", __func__);\n\t\tgoto out;\n\t}\n\n\twhile (sshbuf_len(c) > 0) {\n\t\tsshbuf_free(data);\n\t\tdata = NULL;\n\t\tif ((r = sshbuf_get_cstring(c, &name, NULL)) != 0 ||\n\t\t    (r = sshbuf_froms(c, &data)) != 0) {\n\t\t\terror(\"Unable to parse certificate options: %s\",\n\t\t\t    ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\tdebug3(\"found certificate option \\\"%.100s\\\" len %zu\",\n\t\t    name, sshbuf_len(data));\n\t\tfound = 0;\n\t\tif ((which & OPTIONS_EXTENSIONS) != 0) {\n\t\t\tif (strcmp(name, \"permit-X11-forwarding\") == 0) {\n\t\t\t\topts->permit_x11_forwarding_flag = 1;\n\t\t\t\tfound = 1;\n\t\t\t} else if (strcmp(name,\n\t\t\t    \"permit-agent-forwarding\") == 0) {\n\t\t\t\topts->permit_agent_forwarding_flag = 1;\n\t\t\t\tfound = 1;\n\t\t\t} else if (strcmp(name,\n\t\t\t    \"permit-port-forwarding\") == 0) {\n\t\t\t\topts->permit_port_forwarding_flag = 1;\n\t\t\t\tfound = 1;\n\t\t\t} else if (strcmp(name, \"permit-pty\") == 0) {\n\t\t\t\topts->permit_pty_flag = 1;\n\t\t\t\tfound = 1;\n\t\t\t} else if (strcmp(name, \"permit-user-rc\") == 0) {\n\t\t\t\topts->permit_user_rc = 1;\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t}\n\t\tif (!found && (which & OPTIONS_CRITICAL) != 0) {\n\t\t\tif (strcmp(name, \"force-command\") == 0) {\n\t\t\t\tif ((r = sshbuf_get_cstring(data, &command,\n\t\t\t\t    NULL)) != 0) {\n\t\t\t\t\terror(\"Unable to parse \\\"%s\\\" \"\n\t\t\t\t\t    \"section: %s\", name, ssh_err(r));\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (opts->force_command != NULL) {\n\t\t\t\t\terror(\"Certificate has multiple \"\n\t\t\t\t\t    \"force-command options\");\n\t\t\t\t\tfree(command);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\topts->force_command = command;\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t\tif (strcmp(name, \"source-address\") == 0) {\n\t\t\t\tif ((r = sshbuf_get_cstring(data, &allowed,\n\t\t\t\t    NULL)) != 0) {\n\t\t\t\t\terror(\"Unable to parse \\\"%s\\\" \"\n\t\t\t\t\t    \"section: %s\", name, ssh_err(r));\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (opts->required_from_host_cert != NULL) {\n\t\t\t\t\terror(\"Certificate has multiple \"\n\t\t\t\t\t    \"source-address options\");\n\t\t\t\t\tfree(allowed);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\t/* Check syntax */\n\t\t\t\tif (addr_match_cidr_list(NULL, allowed) == -1) {\n\t\t\t\t\terror(\"Certificate source-address \"\n\t\t\t\t\t    \"contents invalid\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\topts->required_from_host_cert = allowed;\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (!found) {\n\t\t\tif (crit) {\n\t\t\t\terror(\"Certificate critical option \\\"%s\\\" \"\n\t\t\t\t    \"is not supported\", name);\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tlogit(\"Certificate extension \\\"%s\\\" \"\n\t\t\t\t    \"is not supported\", name);\n\t\t\t}\n\t\t} else if (sshbuf_len(data) != 0) {\n\t\t\terror(\"Certificate option \\\"%s\\\" corrupt \"\n\t\t\t    \"(extra data)\", name);\n\t\t\tgoto out;\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\t/* successfully parsed all options */\n\tret = 0;\n\n out:\n\tfree(name);\n\tsshbuf_free(data);\n\tsshbuf_free(c);\n\treturn ret;\n}",
    "includes": [
      "#include \"auth-options.h\"",
      "#include \"ssh2.h\"",
      "#include \"match.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define OPTIONS_EXTENSIONS\t2",
      "#define OPTIONS_CRITICAL\t1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "c"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "name"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "265-292",
          "snippet": "void\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Certificate option \\\"%s\\\" corrupt \"\n\t\t\t    \"(extra data)\"",
            "name"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "data"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Certificate extension \\\"%s\\\" \"\n\t\t\t\t    \"is not supported\"",
            "name"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr_match_cidr_list",
          "args": [
            "NULL",
            "allowed"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "addr_match_cidr_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/addrmatch.c",
          "lines": "435-498",
          "snippet": "int\naddr_match_cidr_list(const char *addr, const char *_list)\n{\n\tchar *list, *cp, *o;\n\tstruct xaddr try_addr, match_addr;\n\tu_int masklen;\n\tint ret = 0, r;\n\n\tif (addr != NULL && addr_pton(addr, &try_addr) != 0) {\n\t\tdebug2(\"%s: couldn't parse address %.100s\", __func__, addr);\n\t\treturn 0;\n\t}\n\tif ((o = list = strdup(_list)) == NULL)\n\t\treturn -1;\n\twhile ((cp = strsep(&list, \",\")) != NULL) {\n\t\tif (*cp == '\\0') {\n\t\t\terror(\"%s: empty entry in list \\\"%.100s\\\"\",\n\t\t\t    __func__, o);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * NB. This function is called in pre-auth with untrusted data,\n\t\t * so be extra paranoid about junk reaching getaddrino (via\n\t\t * addr_pton_cidr).\n\t\t */\n\n\t\t/* Stop junk from reaching getaddrinfo. +3 is for masklen */\n\t\tif (strlen(cp) > INET6_ADDRSTRLEN + 3) {\n\t\t\terror(\"%s: list entry \\\"%.100s\\\" too long\",\n\t\t\t    __func__, cp);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n#define VALID_CIDR_CHARS \"0123456789abcdefABCDEF.:/\"\n\t\tif (strspn(cp, VALID_CIDR_CHARS) != strlen(cp)) {\n\t\t\terror(\"%s: list entry \\\"%.100s\\\" contains invalid \"\n\t\t\t    \"characters\", __func__, cp);\n\t\t\tret = -1;\n\t\t}\n\n\t\t/* Prefer CIDR address matching */\n\t\tr = addr_pton_cidr(cp, &match_addr, &masklen);\n\t\tif (r == -1) {\n\t\t\terror(\"Invalid network entry \\\"%.100s\\\"\", cp);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t} else if (r == -2) {\n\t\t\terror(\"Inconsistent mask length for \"\n\t\t\t    \"network \\\"%.100s\\\"\", cp);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t} else if (r == 0 && addr != NULL) {\n\t\t\tif (addr_netmatch(&try_addr, &match_addr,\n\t\t\t    masklen) == 0)\n\t\t\t\tret = 1;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tfree(o);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"match.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define VALID_CIDR_CHARS \"0123456789abcdefABCDEF.:/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"match.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define VALID_CIDR_CHARS \"0123456789abcdefABCDEF.:/\"\n\nint\naddr_match_cidr_list(const char *addr, const char *_list)\n{\n\tchar *list, *cp, *o;\n\tstruct xaddr try_addr, match_addr;\n\tu_int masklen;\n\tint ret = 0, r;\n\n\tif (addr != NULL && addr_pton(addr, &try_addr) != 0) {\n\t\tdebug2(\"%s: couldn't parse address %.100s\", __func__, addr);\n\t\treturn 0;\n\t}\n\tif ((o = list = strdup(_list)) == NULL)\n\t\treturn -1;\n\twhile ((cp = strsep(&list, \",\")) != NULL) {\n\t\tif (*cp == '\\0') {\n\t\t\terror(\"%s: empty entry in list \\\"%.100s\\\"\",\n\t\t\t    __func__, o);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * NB. This function is called in pre-auth with untrusted data,\n\t\t * so be extra paranoid about junk reaching getaddrino (via\n\t\t * addr_pton_cidr).\n\t\t */\n\n\t\t/* Stop junk from reaching getaddrinfo. +3 is for masklen */\n\t\tif (strlen(cp) > INET6_ADDRSTRLEN + 3) {\n\t\t\terror(\"%s: list entry \\\"%.100s\\\" too long\",\n\t\t\t    __func__, cp);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n#define VALID_CIDR_CHARS \"0123456789abcdefABCDEF.:/\"\n\t\tif (strspn(cp, VALID_CIDR_CHARS) != strlen(cp)) {\n\t\t\terror(\"%s: list entry \\\"%.100s\\\" contains invalid \"\n\t\t\t    \"characters\", __func__, cp);\n\t\t\tret = -1;\n\t\t}\n\n\t\t/* Prefer CIDR address matching */\n\t\tr = addr_pton_cidr(cp, &match_addr, &masklen);\n\t\tif (r == -1) {\n\t\t\terror(\"Invalid network entry \\\"%.100s\\\"\", cp);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t} else if (r == -2) {\n\t\t\terror(\"Inconsistent mask length for \"\n\t\t\t    \"network \\\"%.100s\\\"\", cp);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t} else if (r == 0 && addr != NULL) {\n\t\t\tif (addr_netmatch(&try_addr, &match_addr,\n\t\t\t    masklen) == 0)\n\t\t\t\tret = 1;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tfree(o);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "data",
            "&allowed",
            "NULL"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"source-address\""
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"found certificate option \\\"%.100s\\\" len %zu\"",
            "name",
            "sshbuf_len(data)"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_froms",
          "args": [
            "c",
            "&data"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_froms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "377-399",
          "snippet": "int\nsshbuf_froms(struct sshbuf *buf, struct sshbuf **bufp)\n{\n\tconst u_char *p;\n\tsize_t len;\n\tstruct sshbuf *ret;\n\tint r;\n\n\tif (buf == NULL || bufp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*bufp = NULL;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\tif ((ret = sshbuf_from(p, len)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_consume(buf, len + 4)) != 0 ||  /* Shouldn't happen */\n\t    (r = sshbuf_set_parent(ret, buf)) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn r;\n\t}\n\t*bufp = ret;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_froms(struct sshbuf *buf, struct sshbuf **bufp)\n{\n\tconst u_char *p;\n\tsize_t len;\n\tstruct sshbuf *ret;\n\tint r;\n\n\tif (buf == NULL || bufp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*bufp = NULL;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\tif ((ret = sshbuf_from(p, len)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_consume(buf, len + 4)) != 0 ||  /* Shouldn't happen */\n\t    (r = sshbuf_set_parent(ret, buf)) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn r;\n\t}\n\t*bufp = ret;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_fromb",
          "args": [
            "oblob"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_fromb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "117-131",
          "snippet": "struct sshbuf *\nsshbuf_fromb(struct sshbuf *buf)\n{\n\tstruct sshbuf *ret;\n\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\tif ((ret = sshbuf_from(sshbuf_ptr(buf), sshbuf_len(buf))) == NULL)\n\t\treturn NULL;\n\tif (sshbuf_set_parent(ret, buf) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_fromb(struct sshbuf *buf)\n{\n\tstruct sshbuf *ret;\n\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\tif ((ret = sshbuf_from(sshbuf_ptr(buf), sshbuf_len(buf))) == NULL)\n\t\treturn NULL;\n\tif (sshbuf_set_parent(ret, buf) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define OPTIONS_EXTENSIONS\t2\n#define OPTIONS_CRITICAL\t1\n\nstatic int\ncert_option_list(struct sshauthopt *opts, struct sshbuf *oblob,\n    u_int which, int crit)\n{\n\tchar *command, *allowed;\n\tchar *name = NULL;\n\tstruct sshbuf *c = NULL, *data = NULL;\n\tint r, ret = -1, found;\n\n\tif ((c = sshbuf_fromb(oblob)) == NULL) {\n\t\terror(\"%s: sshbuf_fromb failed\", __func__);\n\t\tgoto out;\n\t}\n\n\twhile (sshbuf_len(c) > 0) {\n\t\tsshbuf_free(data);\n\t\tdata = NULL;\n\t\tif ((r = sshbuf_get_cstring(c, &name, NULL)) != 0 ||\n\t\t    (r = sshbuf_froms(c, &data)) != 0) {\n\t\t\terror(\"Unable to parse certificate options: %s\",\n\t\t\t    ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\tdebug3(\"found certificate option \\\"%.100s\\\" len %zu\",\n\t\t    name, sshbuf_len(data));\n\t\tfound = 0;\n\t\tif ((which & OPTIONS_EXTENSIONS) != 0) {\n\t\t\tif (strcmp(name, \"permit-X11-forwarding\") == 0) {\n\t\t\t\topts->permit_x11_forwarding_flag = 1;\n\t\t\t\tfound = 1;\n\t\t\t} else if (strcmp(name,\n\t\t\t    \"permit-agent-forwarding\") == 0) {\n\t\t\t\topts->permit_agent_forwarding_flag = 1;\n\t\t\t\tfound = 1;\n\t\t\t} else if (strcmp(name,\n\t\t\t    \"permit-port-forwarding\") == 0) {\n\t\t\t\topts->permit_port_forwarding_flag = 1;\n\t\t\t\tfound = 1;\n\t\t\t} else if (strcmp(name, \"permit-pty\") == 0) {\n\t\t\t\topts->permit_pty_flag = 1;\n\t\t\t\tfound = 1;\n\t\t\t} else if (strcmp(name, \"permit-user-rc\") == 0) {\n\t\t\t\topts->permit_user_rc = 1;\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t}\n\t\tif (!found && (which & OPTIONS_CRITICAL) != 0) {\n\t\t\tif (strcmp(name, \"force-command\") == 0) {\n\t\t\t\tif ((r = sshbuf_get_cstring(data, &command,\n\t\t\t\t    NULL)) != 0) {\n\t\t\t\t\terror(\"Unable to parse \\\"%s\\\" \"\n\t\t\t\t\t    \"section: %s\", name, ssh_err(r));\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (opts->force_command != NULL) {\n\t\t\t\t\terror(\"Certificate has multiple \"\n\t\t\t\t\t    \"force-command options\");\n\t\t\t\t\tfree(command);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\topts->force_command = command;\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t\tif (strcmp(name, \"source-address\") == 0) {\n\t\t\t\tif ((r = sshbuf_get_cstring(data, &allowed,\n\t\t\t\t    NULL)) != 0) {\n\t\t\t\t\terror(\"Unable to parse \\\"%s\\\" \"\n\t\t\t\t\t    \"section: %s\", name, ssh_err(r));\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (opts->required_from_host_cert != NULL) {\n\t\t\t\t\terror(\"Certificate has multiple \"\n\t\t\t\t\t    \"source-address options\");\n\t\t\t\t\tfree(allowed);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\t/* Check syntax */\n\t\t\t\tif (addr_match_cidr_list(NULL, allowed) == -1) {\n\t\t\t\t\terror(\"Certificate source-address \"\n\t\t\t\t\t    \"contents invalid\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\topts->required_from_host_cert = allowed;\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (!found) {\n\t\t\tif (crit) {\n\t\t\t\terror(\"Certificate critical option \\\"%s\\\" \"\n\t\t\t\t    \"is not supported\", name);\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tlogit(\"Certificate extension \\\"%s\\\" \"\n\t\t\t\t    \"is not supported\", name);\n\t\t\t}\n\t\t} else if (sshbuf_len(data) != 0) {\n\t\t\terror(\"Certificate option \\\"%s\\\" corrupt \"\n\t\t\t    \"(extra data)\", name);\n\t\t\tgoto out;\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\t/* successfully parsed all options */\n\tret = 0;\n\n out:\n\tfree(name);\n\tsshbuf_free(data);\n\tsshbuf_free(c);\n\treturn ret;\n}"
  },
  {
    "function_name": "dup_strings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
    "lines": "111-136",
    "snippet": "static int\ndup_strings(char ***dstp, size_t *ndstp, char **src, size_t nsrc)\n{\n\tchar **dst;\n\tsize_t i, j;\n\n\t*dstp = NULL;\n\t*ndstp = 0;\n\tif (nsrc == 0)\n\t\treturn 0;\n\n\tif ((dst = calloc(nsrc, sizeof(*src))) == NULL)\n\t\treturn -1;\n\tfor (i = 0; i < nsrc; i++) {\n\t\tif ((dst[i] = strdup(src[i])) == NULL) {\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tfree(dst[j]);\n\t\t\tfree(dst);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* success */\n\t*dstp = dst;\n\t*ndstp = nsrc;\n\treturn 0;\n}",
    "includes": [
      "#include \"auth-options.h\"",
      "#include \"ssh2.h\"",
      "#include \"match.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dst"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "265-292",
          "snippet": "void\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "src[i]"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "nsrc",
            "sizeof(*src)"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\ndup_strings(char ***dstp, size_t *ndstp, char **src, size_t nsrc)\n{\n\tchar **dst;\n\tsize_t i, j;\n\n\t*dstp = NULL;\n\t*ndstp = 0;\n\tif (nsrc == 0)\n\t\treturn 0;\n\n\tif ((dst = calloc(nsrc, sizeof(*src))) == NULL)\n\t\treturn -1;\n\tfor (i = 0; i < nsrc; i++) {\n\t\tif ((dst[i] = strdup(src[i])) == NULL) {\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tfree(dst[j]);\n\t\t\tfree(dst);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* success */\n\t*dstp = dst;\n\t*ndstp = nsrc;\n\treturn 0;\n}"
  },
  {
    "function_name": "opt_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
    "lines": "100-109",
    "snippet": "static int\nopt_match(const char **opts, const char *term)\n{\n\tif (strncasecmp((*opts), term, strlen(term)) == 0 &&\n\t    (*opts)[strlen(term)] == '=') {\n\t\t*opts += strlen(term) + 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"auth-options.h\"",
      "#include \"ssh2.h\"",
      "#include \"match.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "term"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "term"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "(*opts)",
            "term",
            "strlen(term)"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "term"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nopt_match(const char **opts, const char *term)\n{\n\tif (strncasecmp((*opts), term, strlen(term)) == 0 &&\n\t    (*opts)[strlen(term)] == '=') {\n\t\t*opts += strlen(term) + 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "opt_dequote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
    "lines": "67-98",
    "snippet": "static char *\nopt_dequote(const char **sp, const char **errstrp)\n{\n\tconst char *s = *sp;\n\tchar *ret;\n\tsize_t i;\n\n\t*errstrp = NULL;\n\tif (*s != '\"') {\n\t\t*errstrp = \"missing start quote\";\n\t\treturn NULL;\n\t}\n\ts++;\n\tif ((ret = malloc(strlen((s)) + 1)) == NULL) {\n\t\t*errstrp = \"memory allocation failed\";\n\t\treturn NULL;\n\t}\n\tfor (i = 0; *s != '\\0' && *s != '\"';) {\n\t\tif (s[0] == '\\\\' && s[1] == '\"')\n\t\t\ts++;\n\t\tret[i++] = *s++;\n\t}\n\tif (*s == '\\0') {\n\t\t*errstrp = \"missing end quote\";\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tret[i] = '\\0';\n\ts++;\n\t*sp = s;\n\treturn ret;\n}",
    "includes": [
      "#include \"auth-options.h\"",
      "#include \"ssh2.h\"",
      "#include \"match.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ret"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "sshauthopt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
          "lines": "265-292",
          "snippet": "void\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}",
          "includes": [
            "#include \"auth-options.h\"",
            "#include \"ssh2.h\"",
            "#include \"match.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\texplicit_bzero(opts, sizeof(*opts));\n\tfree(opts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen((s)) + 1"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "(s)"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nopt_dequote(const char **sp, const char **errstrp)\n{\n\tconst char *s = *sp;\n\tchar *ret;\n\tsize_t i;\n\n\t*errstrp = NULL;\n\tif (*s != '\"') {\n\t\t*errstrp = \"missing start quote\";\n\t\treturn NULL;\n\t}\n\ts++;\n\tif ((ret = malloc(strlen((s)) + 1)) == NULL) {\n\t\t*errstrp = \"memory allocation failed\";\n\t\treturn NULL;\n\t}\n\tfor (i = 0; *s != '\\0' && *s != '\"';) {\n\t\tif (s[0] == '\\\\' && s[1] == '\"')\n\t\t\ts++;\n\t\tret[i++] = *s++;\n\t}\n\tif (*s == '\\0') {\n\t\t*errstrp = \"missing end quote\";\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tret[i] = '\\0';\n\ts++;\n\t*sp = s;\n\treturn ret;\n}"
  },
  {
    "function_name": "opt_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-options.c",
    "lines": "49-65",
    "snippet": "static int\nopt_flag(const char *opt, int allow_negate, const char **optsp)\n{\n\tsize_t opt_len = strlen(opt);\n\tconst char *opts = *optsp;\n\tint negate = 0;\n\n\tif (allow_negate && strncasecmp(opts, \"no-\", 3) == 0) {\n\t\topts += 3;\n\t\tnegate = 1;\n\t}\n\tif (strncasecmp(opts, opt, opt_len) == 0) {\n\t\t*optsp = opts + opt_len;\n\t\treturn negate ? 0 : 1;\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include \"auth-options.h\"",
      "#include \"ssh2.h\"",
      "#include \"match.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "opts",
            "opt",
            "opt_len"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "opts",
            "\"no-\"",
            "3"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "opt"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth-options.h\"\n#include \"ssh2.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nopt_flag(const char *opt, int allow_negate, const char **optsp)\n{\n\tsize_t opt_len = strlen(opt);\n\tconst char *opts = *optsp;\n\tint negate = 0;\n\n\tif (allow_negate && strncasecmp(opts, \"no-\", 3) == 0) {\n\t\topts += 3;\n\t\tnegate = 1;\n\t}\n\tif (strncasecmp(opts, opt, opt_len) == 0) {\n\t\t*optsp = opts + opt_len;\n\t\treturn negate ? 0 : 1;\n\t}\n\treturn -1;\n}"
  }
]