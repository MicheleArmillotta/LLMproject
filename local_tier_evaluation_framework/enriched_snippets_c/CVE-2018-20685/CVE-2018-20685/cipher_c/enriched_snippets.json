[
  {
    "function_name": "cipher_set_keyiv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
    "lines": "493-527",
    "snippet": "int\ncipher_set_keyiv(struct sshcipher_ctx *cc, const u_char *iv, size_t len)\n{\n#ifdef WITH_OPENSSL\n\tconst struct sshcipher *c = cc->cipher;\n\tint evplen = 0;\n#endif\n\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)\n\t\treturn 0;\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0)\n\t\treturn 0;\n\n#ifdef WITH_OPENSSL\n\tevplen = EVP_CIPHER_CTX_iv_length(cc->evp);\n\tif (evplen <= 0)\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\tif ((size_t)evplen != len)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n#ifndef OPENSSL_HAVE_EVPCTR\n\t/* XXX iv arg is const, but ssh_aes_ctr_iv isn't */\n\tif (c->evptype == evp_aes_128_ctr)\n\t\tssh_aes_ctr_iv(cc->evp, 1, (u_char *)iv, evplen);\n\telse\n#endif\n\tif (cipher_authlen(c)) {\n\t\t/* XXX iv arg is const, but EVP_CIPHER_CTX_ctrl isn't */\n\t\tif (!EVP_CIPHER_CTX_ctrl(cc->evp,\n\t\t    EVP_CTRL_GCM_SET_IV_FIXED, -1, (void *)iv))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t} else if (!EVP_CIPHER_CTX_set_iv(cc->evp, iv, evplen))\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"digest.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"cipher.h\"",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define CFLAG_NONE\t\t(1<<3)",
      "#define CFLAG_CHACHAPOLY\t(1<<1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_set_iv",
          "args": [
            "cc->evp",
            "iv",
            "evplen"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "EVP_CIPHER_CTX_set_iv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "367-392",
          "snippet": "int\nEVP_CIPHER_CTX_set_iv(EVP_CIPHER_CTX *ctx, const unsigned char *iv, size_t len)\n{\n\tif (ctx == NULL)\n\t\treturn 0;\n\tif (EVP_CIPHER_CTX_iv_length(ctx) < 0)\n\t\treturn 0;\n\tif (len != (size_t)EVP_CIPHER_CTX_iv_length(ctx))\n\t\treturn 0;\n\tif (len > EVP_MAX_IV_LENGTH)\n\t\treturn 0; /* sanity check; shouldn't happen */\n\t/*\n\t * Skip the memcpy entirely when the requested IV length is zero,\n\t * since the iv pointer may be NULL or invalid.\n\t */\n\tif (len != 0) {\n\t\tif (iv == NULL)\n\t\t\treturn 0;\n# ifdef HAVE_EVP_CIPHER_CTX_IV_NOCONST\n\t\tmemcpy(EVP_CIPHER_CTX_iv_noconst(ctx), iv, len);\n# else\n\t\tmemcpy(ctx->iv, iv, len);\n# endif /* HAVE_EVP_CIPHER_CTX_IV_NOCONST */\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nEVP_CIPHER_CTX_set_iv(EVP_CIPHER_CTX *ctx, const unsigned char *iv, size_t len)\n{\n\tif (ctx == NULL)\n\t\treturn 0;\n\tif (EVP_CIPHER_CTX_iv_length(ctx) < 0)\n\t\treturn 0;\n\tif (len != (size_t)EVP_CIPHER_CTX_iv_length(ctx))\n\t\treturn 0;\n\tif (len > EVP_MAX_IV_LENGTH)\n\t\treturn 0; /* sanity check; shouldn't happen */\n\t/*\n\t * Skip the memcpy entirely when the requested IV length is zero,\n\t * since the iv pointer may be NULL or invalid.\n\t */\n\tif (len != 0) {\n\t\tif (iv == NULL)\n\t\t\treturn 0;\n# ifdef HAVE_EVP_CIPHER_CTX_IV_NOCONST\n\t\tmemcpy(EVP_CIPHER_CTX_iv_noconst(ctx), iv, len);\n# else\n\t\tmemcpy(ctx->iv, iv, len);\n# endif /* HAVE_EVP_CIPHER_CTX_IV_NOCONST */\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_ctrl",
          "args": [
            "cc->evp",
            "EVP_CTRL_GCM_SET_IV_FIXED",
            "-1",
            "(void *)iv"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cipher_authlen",
          "args": [
            "c"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_authlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "163-167",
          "snippet": "u_int\ncipher_authlen(const struct sshcipher *c)\n{\n\treturn (c->auth_len);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\ncipher_authlen(const struct sshcipher *c)\n{\n\treturn (c->auth_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_aes_ctr_iv",
          "args": [
            "cc->evp",
            "1",
            "(u_char *)iv",
            "evplen"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_aes_ctr_iv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher-ctr.c",
          "lines": "113-124",
          "snippet": "void\nssh_aes_ctr_iv(EVP_CIPHER_CTX *evp, int doset, u_char * iv, size_t len)\n{\n\tstruct ssh_aes_ctr_ctx *c;\n\n\tif ((c = EVP_CIPHER_CTX_get_app_data(evp)) == NULL)\n\t\tfatal(\"ssh_aes_ctr_iv: no context\");\n\tif (doset)\n\t\tmemcpy(c->aes_counter, iv, len);\n\telse\n\t\tmemcpy(iv, c->aes_counter, len);\n}",
          "includes": [
            "#include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <openssl/evp.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include <openssl/evp.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_aes_ctr_iv(EVP_CIPHER_CTX *evp, int doset, u_char * iv, size_t len)\n{\n\tstruct ssh_aes_ctr_ctx *c;\n\n\tif ((c = EVP_CIPHER_CTX_get_app_data(evp)) == NULL)\n\t\tfatal(\"ssh_aes_ctr_iv: no context\");\n\tif (doset)\n\t\tmemcpy(c->aes_counter, iv, len);\n\telse\n\t\tmemcpy(iv, c->aes_counter, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_iv_length",
          "args": [
            "cc->evp"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_NONE\t\t(1<<3)\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nint\ncipher_set_keyiv(struct sshcipher_ctx *cc, const u_char *iv, size_t len)\n{\n#ifdef WITH_OPENSSL\n\tconst struct sshcipher *c = cc->cipher;\n\tint evplen = 0;\n#endif\n\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)\n\t\treturn 0;\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0)\n\t\treturn 0;\n\n#ifdef WITH_OPENSSL\n\tevplen = EVP_CIPHER_CTX_iv_length(cc->evp);\n\tif (evplen <= 0)\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\tif ((size_t)evplen != len)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n#ifndef OPENSSL_HAVE_EVPCTR\n\t/* XXX iv arg is const, but ssh_aes_ctr_iv isn't */\n\tif (c->evptype == evp_aes_128_ctr)\n\t\tssh_aes_ctr_iv(cc->evp, 1, (u_char *)iv, evplen);\n\telse\n#endif\n\tif (cipher_authlen(c)) {\n\t\t/* XXX iv arg is const, but EVP_CIPHER_CTX_ctrl isn't */\n\t\tif (!EVP_CIPHER_CTX_ctrl(cc->evp,\n\t\t    EVP_CTRL_GCM_SET_IV_FIXED, -1, (void *)iv))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t} else if (!EVP_CIPHER_CTX_set_iv(cc->evp, iv, evplen))\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "cipher_get_keyiv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
    "lines": "448-491",
    "snippet": "int\ncipher_get_keyiv(struct sshcipher_ctx *cc, u_char *iv, size_t len)\n{\n#ifdef WITH_OPENSSL\n\tconst struct sshcipher *c = cc->cipher;\n\tint evplen;\n#endif\n\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {\n\t\tif (len != 0)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\treturn 0;\n\t}\n\tif ((cc->cipher->flags & CFLAG_AESCTR) != 0) {\n\t\tif (len != sizeof(cc->ac_ctx.ctr))\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tmemcpy(iv, cc->ac_ctx.ctr, len);\n\t\treturn 0;\n\t}\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0)\n\t\treturn 0;\n\n#ifdef WITH_OPENSSL\n\tevplen = EVP_CIPHER_CTX_iv_length(cc->evp);\n\tif (evplen == 0)\n\t\treturn 0;\n\telse if (evplen < 0)\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\tif ((size_t)evplen != len)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n#ifndef OPENSSL_HAVE_EVPCTR\n\tif (c->evptype == evp_aes_128_ctr)\n\t\tssh_aes_ctr_iv(cc->evp, 0, iv, len);\n\telse\n#endif\n\tif (cipher_authlen(c)) {\n\t\tif (!EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_IV_GEN,\n\t\t   len, iv))\n\t\t       return SSH_ERR_LIBCRYPTO_ERROR;\n\t} else if (!EVP_CIPHER_CTX_get_iv(cc->evp, iv, len))\n\t       return SSH_ERR_LIBCRYPTO_ERROR;\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"digest.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"cipher.h\"",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define CFLAG_NONE\t\t(1<<3)",
      "#define CFLAG_AESCTR\t\t(1<<2)",
      "#define CFLAG_CHACHAPOLY\t(1<<1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_get_iv",
          "args": [
            "cc->evp",
            "iv",
            "len"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "EVP_CIPHER_CTX_get_iv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "338-363",
          "snippet": "int\nEVP_CIPHER_CTX_get_iv(const EVP_CIPHER_CTX *ctx, unsigned char *iv, size_t len)\n{\n\tif (ctx == NULL)\n\t\treturn 0;\n\tif (EVP_CIPHER_CTX_iv_length(ctx) < 0)\n\t\treturn 0;\n\tif (len != (size_t)EVP_CIPHER_CTX_iv_length(ctx))\n\t\treturn 0;\n\tif (len > EVP_MAX_IV_LENGTH)\n\t\treturn 0; /* sanity check; shouldn't happen */\n\t/*\n\t * Skip the memcpy entirely when the requested IV length is zero,\n\t * since the iv pointer may be NULL or invalid.\n\t */\n\tif (len != 0) {\n\t\tif (iv == NULL)\n\t\t\treturn 0;\n# ifdef HAVE_EVP_CIPHER_CTX_IV\n\t\tmemcpy(iv, EVP_CIPHER_CTX_iv(ctx), len);\n# else\n\t\tmemcpy(iv, ctx->iv, len);\n# endif /* HAVE_EVP_CIPHER_CTX_IV */\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nEVP_CIPHER_CTX_get_iv(const EVP_CIPHER_CTX *ctx, unsigned char *iv, size_t len)\n{\n\tif (ctx == NULL)\n\t\treturn 0;\n\tif (EVP_CIPHER_CTX_iv_length(ctx) < 0)\n\t\treturn 0;\n\tif (len != (size_t)EVP_CIPHER_CTX_iv_length(ctx))\n\t\treturn 0;\n\tif (len > EVP_MAX_IV_LENGTH)\n\t\treturn 0; /* sanity check; shouldn't happen */\n\t/*\n\t * Skip the memcpy entirely when the requested IV length is zero,\n\t * since the iv pointer may be NULL or invalid.\n\t */\n\tif (len != 0) {\n\t\tif (iv == NULL)\n\t\t\treturn 0;\n# ifdef HAVE_EVP_CIPHER_CTX_IV\n\t\tmemcpy(iv, EVP_CIPHER_CTX_iv(ctx), len);\n# else\n\t\tmemcpy(iv, ctx->iv, len);\n# endif /* HAVE_EVP_CIPHER_CTX_IV */\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_ctrl",
          "args": [
            "cc->evp",
            "EVP_CTRL_GCM_IV_GEN",
            "len",
            "iv"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cipher_authlen",
          "args": [
            "c"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_authlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "163-167",
          "snippet": "u_int\ncipher_authlen(const struct sshcipher *c)\n{\n\treturn (c->auth_len);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\ncipher_authlen(const struct sshcipher *c)\n{\n\treturn (c->auth_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_aes_ctr_iv",
          "args": [
            "cc->evp",
            "0",
            "iv",
            "len"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_aes_ctr_iv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher-ctr.c",
          "lines": "113-124",
          "snippet": "void\nssh_aes_ctr_iv(EVP_CIPHER_CTX *evp, int doset, u_char * iv, size_t len)\n{\n\tstruct ssh_aes_ctr_ctx *c;\n\n\tif ((c = EVP_CIPHER_CTX_get_app_data(evp)) == NULL)\n\t\tfatal(\"ssh_aes_ctr_iv: no context\");\n\tif (doset)\n\t\tmemcpy(c->aes_counter, iv, len);\n\telse\n\t\tmemcpy(iv, c->aes_counter, len);\n}",
          "includes": [
            "#include <openssl/aes.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <openssl/evp.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/aes.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include <openssl/evp.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_aes_ctr_iv(EVP_CIPHER_CTX *evp, int doset, u_char * iv, size_t len)\n{\n\tstruct ssh_aes_ctr_ctx *c;\n\n\tif ((c = EVP_CIPHER_CTX_get_app_data(evp)) == NULL)\n\t\tfatal(\"ssh_aes_ctr_iv: no context\");\n\tif (doset)\n\t\tmemcpy(c->aes_counter, iv, len);\n\telse\n\t\tmemcpy(iv, c->aes_counter, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_iv_length",
          "args": [
            "cc->evp"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "iv",
            "cc->ac_ctx.ctr",
            "len"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_NONE\t\t(1<<3)\n#define CFLAG_AESCTR\t\t(1<<2)\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nint\ncipher_get_keyiv(struct sshcipher_ctx *cc, u_char *iv, size_t len)\n{\n#ifdef WITH_OPENSSL\n\tconst struct sshcipher *c = cc->cipher;\n\tint evplen;\n#endif\n\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {\n\t\tif (len != 0)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\treturn 0;\n\t}\n\tif ((cc->cipher->flags & CFLAG_AESCTR) != 0) {\n\t\tif (len != sizeof(cc->ac_ctx.ctr))\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tmemcpy(iv, cc->ac_ctx.ctr, len);\n\t\treturn 0;\n\t}\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0)\n\t\treturn 0;\n\n#ifdef WITH_OPENSSL\n\tevplen = EVP_CIPHER_CTX_iv_length(cc->evp);\n\tif (evplen == 0)\n\t\treturn 0;\n\telse if (evplen < 0)\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\tif ((size_t)evplen != len)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n#ifndef OPENSSL_HAVE_EVPCTR\n\tif (c->evptype == evp_aes_128_ctr)\n\t\tssh_aes_ctr_iv(cc->evp, 0, iv, len);\n\telse\n#endif\n\tif (cipher_authlen(c)) {\n\t\tif (!EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_IV_GEN,\n\t\t   len, iv))\n\t\t       return SSH_ERR_LIBCRYPTO_ERROR;\n\t} else if (!EVP_CIPHER_CTX_get_iv(cc->evp, iv, len))\n\t       return SSH_ERR_LIBCRYPTO_ERROR;\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "cipher_get_keyiv_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
    "lines": "432-446",
    "snippet": "int\ncipher_get_keyiv_len(const struct sshcipher_ctx *cc)\n{\n\tconst struct sshcipher *c = cc->cipher;\n\n\tif ((c->flags & CFLAG_CHACHAPOLY) != 0)\n\t\treturn 0;\n\telse if ((c->flags & CFLAG_AESCTR) != 0)\n\t\treturn sizeof(cc->ac_ctx.ctr);\n#ifdef WITH_OPENSSL\n\treturn EVP_CIPHER_CTX_iv_length(cc->evp);\n#else\n\treturn 0;\n#endif\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"digest.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"cipher.h\"",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define CFLAG_AESCTR\t\t(1<<2)",
      "#define CFLAG_CHACHAPOLY\t(1<<1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_iv_length",
          "args": [
            "cc->evp"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_AESCTR\t\t(1<<2)\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nint\ncipher_get_keyiv_len(const struct sshcipher_ctx *cc)\n{\n\tconst struct sshcipher *c = cc->cipher;\n\n\tif ((c->flags & CFLAG_CHACHAPOLY) != 0)\n\t\treturn 0;\n\telse if ((c->flags & CFLAG_AESCTR) != 0)\n\t\treturn sizeof(cc->ac_ctx.ctr);\n#ifdef WITH_OPENSSL\n\treturn EVP_CIPHER_CTX_iv_length(cc->evp);\n#else\n\treturn 0;\n#endif\n}"
  },
  {
    "function_name": "cipher_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
    "lines": "410-425",
    "snippet": "void\ncipher_free(struct sshcipher_ctx *cc)\n{\n\tif (cc == NULL)\n\t\treturn;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)\n\t\texplicit_bzero(&cc->cp_ctx, sizeof(cc->cp_ctx));\n\telse if ((cc->cipher->flags & CFLAG_AESCTR) != 0)\n\t\texplicit_bzero(&cc->ac_ctx, sizeof(cc->ac_ctx));\n#ifdef WITH_OPENSSL\n\tEVP_CIPHER_CTX_free(cc->evp);\n\tcc->evp = NULL;\n#endif\n\texplicit_bzero(cc, sizeof(*cc));\n\tfree(cc);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"digest.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"cipher.h\"",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define CFLAG_AESCTR\t\t(1<<2)",
      "#define CFLAG_CHACHAPOLY\t(1<<1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cc"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "410-425",
          "snippet": "void\ncipher_free(struct sshcipher_ctx *cc)\n{\n\tif (cc == NULL)\n\t\treturn;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)\n\t\texplicit_bzero(&cc->cp_ctx, sizeof(cc->cp_ctx));\n\telse if ((cc->cipher->flags & CFLAG_AESCTR) != 0)\n\t\texplicit_bzero(&cc->ac_ctx, sizeof(cc->ac_ctx));\n#ifdef WITH_OPENSSL\n\tEVP_CIPHER_CTX_free(cc->evp);\n\tcc->evp = NULL;\n#endif\n\texplicit_bzero(cc, sizeof(*cc));\n\tfree(cc);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "cc",
            "sizeof(*cc)"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_free",
          "args": [
            "cc->evp"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_AESCTR\t\t(1<<2)\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nvoid\ncipher_free(struct sshcipher_ctx *cc)\n{\n\tif (cc == NULL)\n\t\treturn;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)\n\t\texplicit_bzero(&cc->cp_ctx, sizeof(cc->cp_ctx));\n\telse if ((cc->cipher->flags & CFLAG_AESCTR) != 0)\n\t\texplicit_bzero(&cc->ac_ctx, sizeof(cc->ac_ctx));\n#ifdef WITH_OPENSSL\n\tEVP_CIPHER_CTX_free(cc->evp);\n\tcc->evp = NULL;\n#endif\n\texplicit_bzero(cc, sizeof(*cc));\n\tfree(cc);\n}"
  },
  {
    "function_name": "cipher_get_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
    "lines": "397-408",
    "snippet": "int\ncipher_get_length(struct sshcipher_ctx *cc, u_int *plenp, u_int seqnr,\n    const u_char *cp, u_int len)\n{\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)\n\t\treturn chachapoly_get_length(&cc->cp_ctx, plenp, seqnr,\n\t\t    cp, len);\n\tif (len < 4)\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\t*plenp = PEEK_U32(cp);\n\treturn 0;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"digest.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"cipher.h\"",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define CFLAG_CHACHAPOLY\t(1<<1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PEEK_U32",
          "args": [
            "cp"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chachapoly_get_length",
          "args": [
            "&cc->cp_ctx",
            "plenp",
            "seqnr",
            "cp",
            "len"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "chachapoly_get_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher-chachapoly.c",
          "lines": "106-119",
          "snippet": "int\nchachapoly_get_length(struct chachapoly_ctx *ctx,\n    u_int *plenp, u_int seqnr, const u_char *cp, u_int len)\n{\n\tu_char buf[4], seqbuf[8];\n\n\tif (len < 4)\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tPOKE_U64(seqbuf, seqnr);\n\tchacha_ivsetup(&ctx->header_ctx, seqbuf, NULL);\n\tchacha_encrypt_bytes(&ctx->header_ctx, cp, buf, 4);\n\t*plenp = PEEK_U32(buf);\n\treturn 0;\n}",
          "includes": [
            "#include \"cipher-chachapoly.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include <stdio.h>  /* needed for misc.h */",
            "#include <string.h>",
            "#include <stdarg.h> /* needed for log.h */",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cipher-chachapoly.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include <stdio.h>  /* needed for misc.h */\n#include <string.h>\n#include <stdarg.h> /* needed for log.h */\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nchachapoly_get_length(struct chachapoly_ctx *ctx,\n    u_int *plenp, u_int seqnr, const u_char *cp, u_int len)\n{\n\tu_char buf[4], seqbuf[8];\n\n\tif (len < 4)\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tPOKE_U64(seqbuf, seqnr);\n\tchacha_ivsetup(&ctx->header_ctx, seqbuf, NULL);\n\tchacha_encrypt_bytes(&ctx->header_ctx, cp, buf, 4);\n\t*plenp = PEEK_U32(buf);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nint\ncipher_get_length(struct sshcipher_ctx *cc, u_int *plenp, u_int seqnr,\n    const u_char *cp, u_int len)\n{\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)\n\t\treturn chachapoly_get_length(&cc->cp_ctx, plenp, seqnr,\n\t\t    cp, len);\n\tif (len < 4)\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\t*plenp = PEEK_U32(cp);\n\treturn 0;\n}"
  },
  {
    "function_name": "cipher_crypt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
    "lines": "334-394",
    "snippet": "int\ncipher_crypt(struct sshcipher_ctx *cc, u_int seqnr, u_char *dest,\n   const u_char *src, u_int len, u_int aadlen, u_int authlen)\n{\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {\n\t\treturn chachapoly_crypt(&cc->cp_ctx, seqnr, dest, src,\n\t\t    len, aadlen, authlen, cc->encrypt);\n\t}\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0) {\n\t\tmemcpy(dest, src, aadlen + len);\n\t\treturn 0;\n\t}\n#ifndef WITH_OPENSSL\n\tif ((cc->cipher->flags & CFLAG_AESCTR) != 0) {\n\t\tif (aadlen)\n\t\t\tmemcpy(dest, src, aadlen);\n\t\taesctr_encrypt_bytes(&cc->ac_ctx, src + aadlen,\n\t\t    dest + aadlen, len);\n\t\treturn 0;\n\t}\n\treturn SSH_ERR_INVALID_ARGUMENT;\n#else\n\tif (authlen) {\n\t\tu_char lastiv[1];\n\n\t\tif (authlen != cipher_authlen(cc->cipher))\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\t/* increment IV */\n\t\tif (!EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_IV_GEN,\n\t\t    1, lastiv))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\t/* set tag on decyption */\n\t\tif (!cc->encrypt &&\n\t\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_SET_TAG,\n\t\t    authlen, (u_char *)src + aadlen + len))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t}\n\tif (aadlen) {\n\t\tif (authlen &&\n\t\t    EVP_Cipher(cc->evp, NULL, (u_char *)src, aadlen) < 0)\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\tmemcpy(dest, src, aadlen);\n\t}\n\tif (len % cc->cipher->block_size)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (EVP_Cipher(cc->evp, dest + aadlen, (u_char *)src + aadlen,\n\t    len) < 0)\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\tif (authlen) {\n\t\t/* compute tag (on encrypt) or verify tag (on decrypt) */\n\t\tif (EVP_Cipher(cc->evp, NULL, NULL, 0) < 0)\n\t\t\treturn cc->encrypt ?\n\t\t\t    SSH_ERR_LIBCRYPTO_ERROR : SSH_ERR_MAC_INVALID;\n\t\tif (cc->encrypt &&\n\t\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_GET_TAG,\n\t\t    authlen, dest + aadlen + len))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t}\n\treturn 0;\n#endif\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"digest.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"cipher.h\"",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define CFLAG_NONE\t\t(1<<3)",
      "#define CFLAG_AESCTR\t\t(1<<2)",
      "#define CFLAG_CHACHAPOLY\t(1<<1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_ctrl",
          "args": [
            "cc->evp",
            "EVP_CTRL_GCM_GET_TAG",
            "authlen",
            "dest + aadlen + len"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_Cipher",
          "args": [
            "cc->evp",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_Cipher",
          "args": [
            "cc->evp",
            "dest + aadlen",
            "(u_char *)src + aadlen",
            "len"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest",
            "src",
            "aadlen"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_Cipher",
          "args": [
            "cc->evp",
            "NULL",
            "(u_char *)src",
            "aadlen"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_ctrl",
          "args": [
            "cc->evp",
            "EVP_CTRL_GCM_SET_TAG",
            "authlen",
            "(u_char *)src + aadlen + len"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_ctrl",
          "args": [
            "cc->evp",
            "EVP_CTRL_GCM_IV_GEN",
            "1",
            "lastiv"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cipher_authlen",
          "args": [
            "cc->cipher"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_authlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "163-167",
          "snippet": "u_int\ncipher_authlen(const struct sshcipher *c)\n{\n\treturn (c->auth_len);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\ncipher_authlen(const struct sshcipher *c)\n{\n\treturn (c->auth_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aesctr_encrypt_bytes",
          "args": [
            "&cc->ac_ctx",
            "src + aadlen",
            "dest + aadlen",
            "len"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "aesctr_encrypt_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher-aesctr.c",
          "lines": "68-82",
          "snippet": "void\naesctr_encrypt_bytes(aesctr_ctx *x,const u8 *m,u8 *c,u32 bytes)\n{\n\tu32 n = 0;\n\tu8 buf[AES_BLOCK_SIZE];\n\n\twhile ((bytes--) > 0) {\n\t\tif (n == 0) {\n\t\t\trijndaelEncrypt(x->ek, x->rounds, x->ctr, buf);\n\t\t\taesctr_inc(x->ctr, AES_BLOCK_SIZE);\n\t\t}\n\t\t*(c++) = *(m++) ^ buf[n];\n\t\tn = (n + 1) % AES_BLOCK_SIZE;\n\t}\n}",
          "includes": [
            "#include \"cipher-aesctr.h\"",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cipher-aesctr.h\"\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\naesctr_encrypt_bytes(aesctr_ctx *x,const u8 *m,u8 *c,u32 bytes)\n{\n\tu32 n = 0;\n\tu8 buf[AES_BLOCK_SIZE];\n\n\twhile ((bytes--) > 0) {\n\t\tif (n == 0) {\n\t\t\trijndaelEncrypt(x->ek, x->rounds, x->ctr, buf);\n\t\t\taesctr_inc(x->ctr, AES_BLOCK_SIZE);\n\t\t}\n\t\t*(c++) = *(m++) ^ buf[n];\n\t\tn = (n + 1) % AES_BLOCK_SIZE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest",
            "src",
            "aadlen"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest",
            "src",
            "aadlen + len"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chachapoly_crypt",
          "args": [
            "&cc->cp_ctx",
            "seqnr",
            "dest",
            "src",
            "len",
            "aadlen",
            "authlen",
            "cc->encrypt"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "chachapoly_crypt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher-chachapoly.c",
          "lines": "51-103",
          "snippet": "int\nchachapoly_crypt(struct chachapoly_ctx *ctx, u_int seqnr, u_char *dest,\n    const u_char *src, u_int len, u_int aadlen, u_int authlen, int do_encrypt)\n{\n\tu_char seqbuf[8];\n\tconst u_char one[8] = { 1, 0, 0, 0, 0, 0, 0, 0 }; /* NB little-endian */\n\tu_char expected_tag[POLY1305_TAGLEN], poly_key[POLY1305_KEYLEN];\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t/*\n\t * Run ChaCha20 once to generate the Poly1305 key. The IV is the\n\t * packet sequence number.\n\t */\n\tmemset(poly_key, 0, sizeof(poly_key));\n\tPOKE_U64(seqbuf, seqnr);\n\tchacha_ivsetup(&ctx->main_ctx, seqbuf, NULL);\n\tchacha_encrypt_bytes(&ctx->main_ctx,\n\t    poly_key, poly_key, sizeof(poly_key));\n\n\t/* If decrypting, check tag before anything else */\n\tif (!do_encrypt) {\n\t\tconst u_char *tag = src + aadlen + len;\n\n\t\tpoly1305_auth(expected_tag, src, aadlen + len, poly_key);\n\t\tif (timingsafe_bcmp(expected_tag, tag, POLY1305_TAGLEN) != 0) {\n\t\t\tr = SSH_ERR_MAC_INVALID;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Crypt additional data */\n\tif (aadlen) {\n\t\tchacha_ivsetup(&ctx->header_ctx, seqbuf, NULL);\n\t\tchacha_encrypt_bytes(&ctx->header_ctx, src, dest, aadlen);\n\t}\n\n\t/* Set Chacha's block counter to 1 */\n\tchacha_ivsetup(&ctx->main_ctx, seqbuf, one);\n\tchacha_encrypt_bytes(&ctx->main_ctx, src + aadlen,\n\t    dest + aadlen, len);\n\n\t/* If encrypting, calculate and append tag */\n\tif (do_encrypt) {\n\t\tpoly1305_auth(dest + aadlen + len, dest, aadlen + len,\n\t\t    poly_key);\n\t}\n\tr = 0;\n out:\n\texplicit_bzero(expected_tag, sizeof(expected_tag));\n\texplicit_bzero(seqbuf, sizeof(seqbuf));\n\texplicit_bzero(poly_key, sizeof(poly_key));\n\treturn r;\n}",
          "includes": [
            "#include \"cipher-chachapoly.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include <stdio.h>  /* needed for misc.h */",
            "#include <string.h>",
            "#include <stdarg.h> /* needed for log.h */",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cipher-chachapoly.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include <stdio.h>  /* needed for misc.h */\n#include <string.h>\n#include <stdarg.h> /* needed for log.h */\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nchachapoly_crypt(struct chachapoly_ctx *ctx, u_int seqnr, u_char *dest,\n    const u_char *src, u_int len, u_int aadlen, u_int authlen, int do_encrypt)\n{\n\tu_char seqbuf[8];\n\tconst u_char one[8] = { 1, 0, 0, 0, 0, 0, 0, 0 }; /* NB little-endian */\n\tu_char expected_tag[POLY1305_TAGLEN], poly_key[POLY1305_KEYLEN];\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t/*\n\t * Run ChaCha20 once to generate the Poly1305 key. The IV is the\n\t * packet sequence number.\n\t */\n\tmemset(poly_key, 0, sizeof(poly_key));\n\tPOKE_U64(seqbuf, seqnr);\n\tchacha_ivsetup(&ctx->main_ctx, seqbuf, NULL);\n\tchacha_encrypt_bytes(&ctx->main_ctx,\n\t    poly_key, poly_key, sizeof(poly_key));\n\n\t/* If decrypting, check tag before anything else */\n\tif (!do_encrypt) {\n\t\tconst u_char *tag = src + aadlen + len;\n\n\t\tpoly1305_auth(expected_tag, src, aadlen + len, poly_key);\n\t\tif (timingsafe_bcmp(expected_tag, tag, POLY1305_TAGLEN) != 0) {\n\t\t\tr = SSH_ERR_MAC_INVALID;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Crypt additional data */\n\tif (aadlen) {\n\t\tchacha_ivsetup(&ctx->header_ctx, seqbuf, NULL);\n\t\tchacha_encrypt_bytes(&ctx->header_ctx, src, dest, aadlen);\n\t}\n\n\t/* Set Chacha's block counter to 1 */\n\tchacha_ivsetup(&ctx->main_ctx, seqbuf, one);\n\tchacha_encrypt_bytes(&ctx->main_ctx, src + aadlen,\n\t    dest + aadlen, len);\n\n\t/* If encrypting, calculate and append tag */\n\tif (do_encrypt) {\n\t\tpoly1305_auth(dest + aadlen + len, dest, aadlen + len,\n\t\t    poly_key);\n\t}\n\tr = 0;\n out:\n\texplicit_bzero(expected_tag, sizeof(expected_tag));\n\texplicit_bzero(seqbuf, sizeof(seqbuf));\n\texplicit_bzero(poly_key, sizeof(poly_key));\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_NONE\t\t(1<<3)\n#define CFLAG_AESCTR\t\t(1<<2)\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nint\ncipher_crypt(struct sshcipher_ctx *cc, u_int seqnr, u_char *dest,\n   const u_char *src, u_int len, u_int aadlen, u_int authlen)\n{\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {\n\t\treturn chachapoly_crypt(&cc->cp_ctx, seqnr, dest, src,\n\t\t    len, aadlen, authlen, cc->encrypt);\n\t}\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0) {\n\t\tmemcpy(dest, src, aadlen + len);\n\t\treturn 0;\n\t}\n#ifndef WITH_OPENSSL\n\tif ((cc->cipher->flags & CFLAG_AESCTR) != 0) {\n\t\tif (aadlen)\n\t\t\tmemcpy(dest, src, aadlen);\n\t\taesctr_encrypt_bytes(&cc->ac_ctx, src + aadlen,\n\t\t    dest + aadlen, len);\n\t\treturn 0;\n\t}\n\treturn SSH_ERR_INVALID_ARGUMENT;\n#else\n\tif (authlen) {\n\t\tu_char lastiv[1];\n\n\t\tif (authlen != cipher_authlen(cc->cipher))\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\t/* increment IV */\n\t\tif (!EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_IV_GEN,\n\t\t    1, lastiv))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\t/* set tag on decyption */\n\t\tif (!cc->encrypt &&\n\t\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_SET_TAG,\n\t\t    authlen, (u_char *)src + aadlen + len))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t}\n\tif (aadlen) {\n\t\tif (authlen &&\n\t\t    EVP_Cipher(cc->evp, NULL, (u_char *)src, aadlen) < 0)\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\tmemcpy(dest, src, aadlen);\n\t}\n\tif (len % cc->cipher->block_size)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (EVP_Cipher(cc->evp, dest + aadlen, (u_char *)src + aadlen,\n\t    len) < 0)\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\tif (authlen) {\n\t\t/* compute tag (on encrypt) or verify tag (on decrypt) */\n\t\tif (EVP_Cipher(cc->evp, NULL, NULL, 0) < 0)\n\t\t\treturn cc->encrypt ?\n\t\t\t    SSH_ERR_LIBCRYPTO_ERROR : SSH_ERR_MAC_INVALID;\n\t\tif (cc->encrypt &&\n\t\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_GET_TAG,\n\t\t    authlen, dest + aadlen + len))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t}\n\treturn 0;\n#endif\n}"
  },
  {
    "function_name": "cipher_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
    "lines": "235-322",
    "snippet": "int\ncipher_init(struct sshcipher_ctx **ccp, const struct sshcipher *cipher,\n    const u_char *key, u_int keylen, const u_char *iv, u_int ivlen,\n    int do_encrypt)\n{\n\tstruct sshcipher_ctx *cc = NULL;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst EVP_CIPHER *type;\n\tint klen;\n#endif\n\n\t*ccp = NULL;\n\tif ((cc = calloc(sizeof(*cc), 1)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tcc->plaintext = (cipher->flags & CFLAG_NONE) != 0;\n\tcc->encrypt = do_encrypt;\n\n\tif (keylen < cipher->key_len ||\n\t    (iv != NULL && ivlen < cipher_ivlen(cipher))) {\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\n\tcc->cipher = cipher;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {\n\t\tret = chachapoly_init(&cc->cp_ctx, key, keylen);\n\t\tgoto out;\n\t}\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n#ifndef WITH_OPENSSL\n\tif ((cc->cipher->flags & CFLAG_AESCTR) != 0) {\n\t\taesctr_keysetup(&cc->ac_ctx, key, 8 * keylen, 8 * ivlen);\n\t\taesctr_ivsetup(&cc->ac_ctx, iv);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tret = SSH_ERR_INVALID_ARGUMENT;\n\tgoto out;\n#else /* WITH_OPENSSL */\n\ttype = (*cipher->evptype)();\n\tif ((cc->evp = EVP_CIPHER_CTX_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (EVP_CipherInit(cc->evp, type, NULL, (u_char *)iv,\n\t    (do_encrypt == CIPHER_ENCRYPT)) == 0) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (cipher_authlen(cipher) &&\n\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_SET_IV_FIXED,\n\t    -1, (u_char *)iv)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tklen = EVP_CIPHER_CTX_key_length(cc->evp);\n\tif (klen > 0 && keylen != (u_int)klen) {\n\t\tif (EVP_CIPHER_CTX_set_key_length(cc->evp, keylen) == 0) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (EVP_CipherInit(cc->evp, NULL, (u_char *)key, NULL, -1) == 0) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tret = 0;\n#endif /* WITH_OPENSSL */\n out:\n\tif (ret == 0) {\n\t\t/* success */\n\t\t*ccp = cc;\n\t} else {\n\t\tif (cc != NULL) {\n#ifdef WITH_OPENSSL\n\t\t\tEVP_CIPHER_CTX_free(cc->evp);\n#endif /* WITH_OPENSSL */\n\t\t\texplicit_bzero(cc, sizeof(*cc));\n\t\t\tfree(cc);\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"digest.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"cipher.h\"",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define CFLAG_NONE\t\t(1<<3)",
      "#define CFLAG_AESCTR\t\t(1<<2)",
      "#define CFLAG_CHACHAPOLY\t(1<<1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cc"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "410-425",
          "snippet": "void\ncipher_free(struct sshcipher_ctx *cc)\n{\n\tif (cc == NULL)\n\t\treturn;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)\n\t\texplicit_bzero(&cc->cp_ctx, sizeof(cc->cp_ctx));\n\telse if ((cc->cipher->flags & CFLAG_AESCTR) != 0)\n\t\texplicit_bzero(&cc->ac_ctx, sizeof(cc->ac_ctx));\n#ifdef WITH_OPENSSL\n\tEVP_CIPHER_CTX_free(cc->evp);\n\tcc->evp = NULL;\n#endif\n\texplicit_bzero(cc, sizeof(*cc));\n\tfree(cc);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define CFLAG_AESCTR\t\t(1<<2)",
            "#define CFLAG_CHACHAPOLY\t(1<<1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_AESCTR\t\t(1<<2)\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nvoid\ncipher_free(struct sshcipher_ctx *cc)\n{\n\tif (cc == NULL)\n\t\treturn;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)\n\t\texplicit_bzero(&cc->cp_ctx, sizeof(cc->cp_ctx));\n\telse if ((cc->cipher->flags & CFLAG_AESCTR) != 0)\n\t\texplicit_bzero(&cc->ac_ctx, sizeof(cc->ac_ctx));\n#ifdef WITH_OPENSSL\n\tEVP_CIPHER_CTX_free(cc->evp);\n\tcc->evp = NULL;\n#endif\n\texplicit_bzero(cc, sizeof(*cc));\n\tfree(cc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "cc",
            "sizeof(*cc)"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_free",
          "args": [
            "cc->evp"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CipherInit",
          "args": [
            "cc->evp",
            "NULL",
            "(u_char *)key",
            "NULL",
            "-1"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_set_key_length",
          "args": [
            "cc->evp",
            "keylen"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_key_length",
          "args": [
            "cc->evp"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_ctrl",
          "args": [
            "cc->evp",
            "EVP_CTRL_GCM_SET_IV_FIXED",
            "-1",
            "(u_char *)iv"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cipher_authlen",
          "args": [
            "cipher"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_authlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "163-167",
          "snippet": "u_int\ncipher_authlen(const struct sshcipher *c)\n{\n\treturn (c->auth_len);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\ncipher_authlen(const struct sshcipher *c)\n{\n\treturn (c->auth_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EVP_CipherInit",
          "args": [
            "cc->evp",
            "type",
            "NULL",
            "(u_char *)iv",
            "(do_encrypt == CIPHER_ENCRYPT)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_new",
          "args": [],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aesctr_ivsetup",
          "args": [
            "&cc->ac_ctx",
            "iv"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "aesctr_ivsetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher-aesctr.c",
          "lines": "62-66",
          "snippet": "void\naesctr_ivsetup(aesctr_ctx *x,const u8 *iv)\n{\n\tmemcpy(x->ctr, iv, AES_BLOCK_SIZE);\n}",
          "includes": [
            "#include \"cipher-aesctr.h\"",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cipher-aesctr.h\"\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\naesctr_ivsetup(aesctr_ctx *x,const u8 *iv)\n{\n\tmemcpy(x->ctr, iv, AES_BLOCK_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aesctr_keysetup",
          "args": [
            "&cc->ac_ctx",
            "key",
            "8 * keylen",
            "8 * ivlen"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "aesctr_keysetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher-aesctr.c",
          "lines": "56-60",
          "snippet": "void\naesctr_keysetup(aesctr_ctx *x,const u8 *k,u32 kbits,u32 ivbits)\n{\n\tx->rounds = rijndaelKeySetupEnc(x->ek, k, kbits);\n}",
          "includes": [
            "#include \"cipher-aesctr.h\"",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cipher-aesctr.h\"\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\naesctr_keysetup(aesctr_ctx *x,const u8 *k,u32 kbits,u32 ivbits)\n{\n\tx->rounds = rijndaelKeySetupEnc(x->ek, k, kbits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chachapoly_init",
          "args": [
            "&cc->cp_ctx",
            "key",
            "keylen"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "chachapoly_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher-chachapoly.c",
          "lines": "31-40",
          "snippet": "int\nchachapoly_init(struct chachapoly_ctx *ctx,\n    const u_char *key, u_int keylen)\n{\n\tif (keylen != (32 + 32)) /* 2 x 256 bit keys */\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tchacha_keysetup(&ctx->main_ctx, key, 256);\n\tchacha_keysetup(&ctx->header_ctx, key + 32, 256);\n\treturn 0;\n}",
          "includes": [
            "#include \"cipher-chachapoly.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include <stdio.h>  /* needed for misc.h */",
            "#include <string.h>",
            "#include <stdarg.h> /* needed for log.h */",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cipher-chachapoly.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include <stdio.h>  /* needed for misc.h */\n#include <string.h>\n#include <stdarg.h> /* needed for log.h */\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nchachapoly_init(struct chachapoly_ctx *ctx,\n    const u_char *key, u_int keylen)\n{\n\tif (keylen != (32 + 32)) /* 2 x 256 bit keys */\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tchacha_keysetup(&ctx->main_ctx, key, 256);\n\tchacha_keysetup(&ctx->header_ctx, key + 32, 256);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_ivlen",
          "args": [
            "cipher"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_ivlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "169-178",
          "snippet": "u_int\ncipher_ivlen(const struct sshcipher *c)\n{\n\t/*\n\t * Default is cipher block size, except for chacha20+poly1305 that\n\t * needs no IV. XXX make iv_len == -1 default?\n\t */\n\treturn (c->iv_len != 0 || (c->flags & CFLAG_CHACHAPOLY) != 0) ?\n\t    c->iv_len : c->block_size;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define CFLAG_CHACHAPOLY\t(1<<1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nu_int\ncipher_ivlen(const struct sshcipher *c)\n{\n\t/*\n\t * Default is cipher block size, except for chacha20+poly1305 that\n\t * needs no IV. XXX make iv_len == -1 default?\n\t */\n\treturn (c->iv_len != 0 || (c->flags & CFLAG_CHACHAPOLY) != 0) ?\n\t    c->iv_len : c->block_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "sizeof(*cc)",
            "1"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_NONE\t\t(1<<3)\n#define CFLAG_AESCTR\t\t(1<<2)\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nint\ncipher_init(struct sshcipher_ctx **ccp, const struct sshcipher *cipher,\n    const u_char *key, u_int keylen, const u_char *iv, u_int ivlen,\n    int do_encrypt)\n{\n\tstruct sshcipher_ctx *cc = NULL;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst EVP_CIPHER *type;\n\tint klen;\n#endif\n\n\t*ccp = NULL;\n\tif ((cc = calloc(sizeof(*cc), 1)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tcc->plaintext = (cipher->flags & CFLAG_NONE) != 0;\n\tcc->encrypt = do_encrypt;\n\n\tif (keylen < cipher->key_len ||\n\t    (iv != NULL && ivlen < cipher_ivlen(cipher))) {\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\n\tcc->cipher = cipher;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {\n\t\tret = chachapoly_init(&cc->cp_ctx, key, keylen);\n\t\tgoto out;\n\t}\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n#ifndef WITH_OPENSSL\n\tif ((cc->cipher->flags & CFLAG_AESCTR) != 0) {\n\t\taesctr_keysetup(&cc->ac_ctx, key, 8 * keylen, 8 * ivlen);\n\t\taesctr_ivsetup(&cc->ac_ctx, iv);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tret = SSH_ERR_INVALID_ARGUMENT;\n\tgoto out;\n#else /* WITH_OPENSSL */\n\ttype = (*cipher->evptype)();\n\tif ((cc->evp = EVP_CIPHER_CTX_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (EVP_CipherInit(cc->evp, type, NULL, (u_char *)iv,\n\t    (do_encrypt == CIPHER_ENCRYPT)) == 0) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (cipher_authlen(cipher) &&\n\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_SET_IV_FIXED,\n\t    -1, (u_char *)iv)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tklen = EVP_CIPHER_CTX_key_length(cc->evp);\n\tif (klen > 0 && keylen != (u_int)klen) {\n\t\tif (EVP_CIPHER_CTX_set_key_length(cc->evp, keylen) == 0) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (EVP_CipherInit(cc->evp, NULL, (u_char *)key, NULL, -1) == 0) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tret = 0;\n#endif /* WITH_OPENSSL */\n out:\n\tif (ret == 0) {\n\t\t/* success */\n\t\t*ccp = cc;\n\t} else {\n\t\tif (cc != NULL) {\n#ifdef WITH_OPENSSL\n\t\t\tEVP_CIPHER_CTX_free(cc->evp);\n#endif /* WITH_OPENSSL */\n\t\t\texplicit_bzero(cc, sizeof(*cc));\n\t\t\tfree(cc);\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "cipher_warning_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
    "lines": "226-233",
    "snippet": "const char *\ncipher_warning_message(const struct sshcipher_ctx *cc)\n{\n\tif (cc == NULL || cc->cipher == NULL)\n\t\treturn NULL;\n\t/* XXX repurpose for CBC warning */\n\treturn NULL;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"digest.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"cipher.h\"",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\ncipher_warning_message(const struct sshcipher_ctx *cc)\n{\n\tif (cc == NULL || cc->cipher == NULL)\n\t\treturn NULL;\n\t/* XXX repurpose for CBC warning */\n\treturn NULL;\n}"
  },
  {
    "function_name": "ciphers_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
    "lines": "203-224",
    "snippet": "int\nciphers_valid(const char *names)\n{\n\tconst struct sshcipher *c;\n\tchar *cipher_list, *cp;\n\tchar *p;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((cipher_list = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, CIPHER_SEP)); p && *p != '\\0';\n\t    (p = strsep(&cp, CIPHER_SEP))) {\n\t\tc = cipher_by_name(p);\n\t\tif (c == NULL || (c->flags & CFLAG_INTERNAL) != 0) {\n\t\t\tfree(cipher_list);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfree(cipher_list);\n\treturn 1;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"digest.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"cipher.h\"",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define\tCIPHER_SEP\t\",\"",
      "#define CFLAG_INTERNAL\t\tCFLAG_NONE /* Don't use \"none\" for packets */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cipher_list"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "410-425",
          "snippet": "void\ncipher_free(struct sshcipher_ctx *cc)\n{\n\tif (cc == NULL)\n\t\treturn;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)\n\t\texplicit_bzero(&cc->cp_ctx, sizeof(cc->cp_ctx));\n\telse if ((cc->cipher->flags & CFLAG_AESCTR) != 0)\n\t\texplicit_bzero(&cc->ac_ctx, sizeof(cc->ac_ctx));\n#ifdef WITH_OPENSSL\n\tEVP_CIPHER_CTX_free(cc->evp);\n\tcc->evp = NULL;\n#endif\n\texplicit_bzero(cc, sizeof(*cc));\n\tfree(cc);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define CFLAG_AESCTR\t\t(1<<2)",
            "#define CFLAG_CHACHAPOLY\t(1<<1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_AESCTR\t\t(1<<2)\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nvoid\ncipher_free(struct sshcipher_ctx *cc)\n{\n\tif (cc == NULL)\n\t\treturn;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)\n\t\texplicit_bzero(&cc->cp_ctx, sizeof(cc->cp_ctx));\n\telse if ((cc->cipher->flags & CFLAG_AESCTR) != 0)\n\t\texplicit_bzero(&cc->ac_ctx, sizeof(cc->ac_ctx));\n#ifdef WITH_OPENSSL\n\tEVP_CIPHER_CTX_free(cc->evp);\n\tcc->evp = NULL;\n#endif\n\texplicit_bzero(cc, sizeof(*cc));\n\tfree(cc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher_by_name",
          "args": [
            "p"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "192-200",
          "snippet": "const struct sshcipher *\ncipher_by_name(const char *name)\n{\n\tconst struct sshcipher *c;\n\tfor (c = ciphers; c->name != NULL; c++)\n\t\tif (strcmp(c->name, name) == 0)\n\t\t\treturn c;\n\treturn NULL;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct sshcipher ciphers[] = {\n#ifdef WITH_OPENSSL\n#ifndef OPENSSL_NO_DES\n\t{ \"3des-cbc\",\t\t8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },\n#endif\n\t{ \"aes128-cbc\",\t\t16, 16, 0, 0, CFLAG_CBC, EVP_aes_128_cbc },\n\t{ \"aes192-cbc\",\t\t16, 24, 0, 0, CFLAG_CBC, EVP_aes_192_cbc },\n\t{ \"aes256-cbc\",\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"rijndael-cbc@lysator.liu.se\",\n\t\t\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, 0, EVP_aes_128_ctr },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, 0, EVP_aes_192_ctr },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, 0, EVP_aes_256_ctr },\n# ifdef OPENSSL_HAVE_EVPGCM\n\t{ \"aes128-gcm@openssh.com\",\n\t\t\t\t16, 16, 12, 16, 0, EVP_aes_128_gcm },\n\t{ \"aes256-gcm@openssh.com\",\n\t\t\t\t16, 32, 12, 16, 0, EVP_aes_256_gcm },\n# endif /* OPENSSL_HAVE_EVPGCM */\n#else\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, CFLAG_AESCTR, NULL },\n#endif\n\t{ \"chacha20-poly1305@openssh.com\",\n\t\t\t\t8, 64, 0, 16, CFLAG_CHACHAPOLY, NULL },\n\t{ \"none\",\t\t8, 0, 0, 0, CFLAG_NONE, NULL },\n\n\t{ NULL,\t\t\t0, 0, 0, 0, 0, NULL }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct sshcipher ciphers[] = {\n#ifdef WITH_OPENSSL\n#ifndef OPENSSL_NO_DES\n\t{ \"3des-cbc\",\t\t8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },\n#endif\n\t{ \"aes128-cbc\",\t\t16, 16, 0, 0, CFLAG_CBC, EVP_aes_128_cbc },\n\t{ \"aes192-cbc\",\t\t16, 24, 0, 0, CFLAG_CBC, EVP_aes_192_cbc },\n\t{ \"aes256-cbc\",\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"rijndael-cbc@lysator.liu.se\",\n\t\t\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, 0, EVP_aes_128_ctr },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, 0, EVP_aes_192_ctr },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, 0, EVP_aes_256_ctr },\n# ifdef OPENSSL_HAVE_EVPGCM\n\t{ \"aes128-gcm@openssh.com\",\n\t\t\t\t16, 16, 12, 16, 0, EVP_aes_128_gcm },\n\t{ \"aes256-gcm@openssh.com\",\n\t\t\t\t16, 32, 12, 16, 0, EVP_aes_256_gcm },\n# endif /* OPENSSL_HAVE_EVPGCM */\n#else\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, CFLAG_AESCTR, NULL },\n#endif\n\t{ \"chacha20-poly1305@openssh.com\",\n\t\t\t\t8, 64, 0, 16, CFLAG_CHACHAPOLY, NULL },\n\t{ \"none\",\t\t8, 0, 0, 0, CFLAG_NONE, NULL },\n\n\t{ NULL,\t\t\t0, 0, 0, 0, 0, NULL }\n};\n\nconst struct sshcipher *\ncipher_by_name(const char *name)\n{\n\tconst struct sshcipher *c;\n\tfor (c = ciphers; c->name != NULL; c++)\n\t\tif (strcmp(c->name, name) == 0)\n\t\t\treturn c;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&cp",
            "CIPHER_SEP"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "xstrsep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keyscan.c",
          "lines": "162-178",
          "snippet": "static char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}",
          "includes": [
            "#include \"dns.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"myproposal.h\"",
            "#include \"compat.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include <netdb.h>",
            "#include <openssl/bn.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/resource.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"myproposal.h\"\n#include \"compat.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <netdb.h>\n#include <openssl/bn.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/resource.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "names"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "names",
            "\"\""
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define\tCIPHER_SEP\t\",\"\n#define CFLAG_INTERNAL\t\tCFLAG_NONE /* Don't use \"none\" for packets */\n\nint\nciphers_valid(const char *names)\n{\n\tconst struct sshcipher *c;\n\tchar *cipher_list, *cp;\n\tchar *p;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((cipher_list = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, CIPHER_SEP)); p && *p != '\\0';\n\t    (p = strsep(&cp, CIPHER_SEP))) {\n\t\tc = cipher_by_name(p);\n\t\tif (c == NULL || (c->flags & CFLAG_INTERNAL) != 0) {\n\t\t\tfree(cipher_list);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfree(cipher_list);\n\treturn 1;\n}"
  },
  {
    "function_name": "cipher_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
    "lines": "192-200",
    "snippet": "const struct sshcipher *\ncipher_by_name(const char *name)\n{\n\tconst struct sshcipher *c;\n\tfor (c = ciphers; c->name != NULL; c++)\n\t\tif (strcmp(c->name, name) == 0)\n\t\t\treturn c;\n\treturn NULL;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"digest.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"cipher.h\"",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct sshcipher ciphers[] = {\n#ifdef WITH_OPENSSL\n#ifndef OPENSSL_NO_DES\n\t{ \"3des-cbc\",\t\t8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },\n#endif\n\t{ \"aes128-cbc\",\t\t16, 16, 0, 0, CFLAG_CBC, EVP_aes_128_cbc },\n\t{ \"aes192-cbc\",\t\t16, 24, 0, 0, CFLAG_CBC, EVP_aes_192_cbc },\n\t{ \"aes256-cbc\",\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"rijndael-cbc@lysator.liu.se\",\n\t\t\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, 0, EVP_aes_128_ctr },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, 0, EVP_aes_192_ctr },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, 0, EVP_aes_256_ctr },\n# ifdef OPENSSL_HAVE_EVPGCM\n\t{ \"aes128-gcm@openssh.com\",\n\t\t\t\t16, 16, 12, 16, 0, EVP_aes_128_gcm },\n\t{ \"aes256-gcm@openssh.com\",\n\t\t\t\t16, 32, 12, 16, 0, EVP_aes_256_gcm },\n# endif /* OPENSSL_HAVE_EVPGCM */\n#else\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, CFLAG_AESCTR, NULL },\n#endif\n\t{ \"chacha20-poly1305@openssh.com\",\n\t\t\t\t8, 64, 0, 16, CFLAG_CHACHAPOLY, NULL },\n\t{ \"none\",\t\t8, 0, 0, 0, CFLAG_NONE, NULL },\n\n\t{ NULL,\t\t\t0, 0, 0, 0, 0, NULL }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "c->name",
            "name"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct sshcipher ciphers[] = {\n#ifdef WITH_OPENSSL\n#ifndef OPENSSL_NO_DES\n\t{ \"3des-cbc\",\t\t8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },\n#endif\n\t{ \"aes128-cbc\",\t\t16, 16, 0, 0, CFLAG_CBC, EVP_aes_128_cbc },\n\t{ \"aes192-cbc\",\t\t16, 24, 0, 0, CFLAG_CBC, EVP_aes_192_cbc },\n\t{ \"aes256-cbc\",\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"rijndael-cbc@lysator.liu.se\",\n\t\t\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, 0, EVP_aes_128_ctr },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, 0, EVP_aes_192_ctr },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, 0, EVP_aes_256_ctr },\n# ifdef OPENSSL_HAVE_EVPGCM\n\t{ \"aes128-gcm@openssh.com\",\n\t\t\t\t16, 16, 12, 16, 0, EVP_aes_128_gcm },\n\t{ \"aes256-gcm@openssh.com\",\n\t\t\t\t16, 32, 12, 16, 0, EVP_aes_256_gcm },\n# endif /* OPENSSL_HAVE_EVPGCM */\n#else\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, CFLAG_AESCTR, NULL },\n#endif\n\t{ \"chacha20-poly1305@openssh.com\",\n\t\t\t\t8, 64, 0, 16, CFLAG_CHACHAPOLY, NULL },\n\t{ \"none\",\t\t8, 0, 0, 0, CFLAG_NONE, NULL },\n\n\t{ NULL,\t\t\t0, 0, 0, 0, 0, NULL }\n};\n\nconst struct sshcipher *\ncipher_by_name(const char *name)\n{\n\tconst struct sshcipher *c;\n\tfor (c = ciphers; c->name != NULL; c++)\n\t\tif (strcmp(c->name, name) == 0)\n\t\t\treturn c;\n\treturn NULL;\n}"
  },
  {
    "function_name": "cipher_ctx_is_plaintext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
    "lines": "186-190",
    "snippet": "u_int\ncipher_ctx_is_plaintext(struct sshcipher_ctx *cc)\n{\n\treturn cc->plaintext;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"digest.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"cipher.h\"",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\ncipher_ctx_is_plaintext(struct sshcipher_ctx *cc)\n{\n\treturn cc->plaintext;\n}"
  },
  {
    "function_name": "cipher_is_cbc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
    "lines": "180-184",
    "snippet": "u_int\ncipher_is_cbc(const struct sshcipher *c)\n{\n\treturn (c->flags & CFLAG_CBC) != 0;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"digest.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"cipher.h\"",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define CFLAG_CBC\t\t(1<<0)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_CBC\t\t(1<<0)\n\nu_int\ncipher_is_cbc(const struct sshcipher *c)\n{\n\treturn (c->flags & CFLAG_CBC) != 0;\n}"
  },
  {
    "function_name": "cipher_ivlen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
    "lines": "169-178",
    "snippet": "u_int\ncipher_ivlen(const struct sshcipher *c)\n{\n\t/*\n\t * Default is cipher block size, except for chacha20+poly1305 that\n\t * needs no IV. XXX make iv_len == -1 default?\n\t */\n\treturn (c->iv_len != 0 || (c->flags & CFLAG_CHACHAPOLY) != 0) ?\n\t    c->iv_len : c->block_size;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"digest.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"cipher.h\"",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define CFLAG_CHACHAPOLY\t(1<<1)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nu_int\ncipher_ivlen(const struct sshcipher *c)\n{\n\t/*\n\t * Default is cipher block size, except for chacha20+poly1305 that\n\t * needs no IV. XXX make iv_len == -1 default?\n\t */\n\treturn (c->iv_len != 0 || (c->flags & CFLAG_CHACHAPOLY) != 0) ?\n\t    c->iv_len : c->block_size;\n}"
  },
  {
    "function_name": "cipher_authlen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
    "lines": "163-167",
    "snippet": "u_int\ncipher_authlen(const struct sshcipher *c)\n{\n\treturn (c->auth_len);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"digest.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"cipher.h\"",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\ncipher_authlen(const struct sshcipher *c)\n{\n\treturn (c->auth_len);\n}"
  },
  {
    "function_name": "cipher_seclen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
    "lines": "155-161",
    "snippet": "u_int\ncipher_seclen(const struct sshcipher *c)\n{\n\tif (strcmp(\"3des-cbc\", c->name) == 0)\n\t\treturn 14;\n\treturn cipher_keylen(c);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"digest.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"cipher.h\"",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cipher_keylen",
          "args": [
            "c"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_keylen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "149-153",
          "snippet": "u_int\ncipher_keylen(const struct sshcipher *c)\n{\n\treturn (c->key_len);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\ncipher_keylen(const struct sshcipher *c)\n{\n\treturn (c->key_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"3des-cbc\"",
            "c->name"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\ncipher_seclen(const struct sshcipher *c)\n{\n\tif (strcmp(\"3des-cbc\", c->name) == 0)\n\t\treturn 14;\n\treturn cipher_keylen(c);\n}"
  },
  {
    "function_name": "cipher_keylen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
    "lines": "149-153",
    "snippet": "u_int\ncipher_keylen(const struct sshcipher *c)\n{\n\treturn (c->key_len);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"digest.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"cipher.h\"",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\ncipher_keylen(const struct sshcipher *c)\n{\n\treturn (c->key_len);\n}"
  },
  {
    "function_name": "cipher_blocksize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
    "lines": "143-147",
    "snippet": "u_int\ncipher_blocksize(const struct sshcipher *c)\n{\n\treturn (c->block_size);\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"digest.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"cipher.h\"",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int\ncipher_blocksize(const struct sshcipher *c)\n{\n\treturn (c->block_size);\n}"
  },
  {
    "function_name": "cipher_alg_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
    "lines": "117-141",
    "snippet": "char *\ncipher_alg_list(char sep, int auth_only)\n{\n\tchar *tmp, *ret = NULL;\n\tsize_t nlen, rlen = 0;\n\tconst struct sshcipher *c;\n\n\tfor (c = ciphers; c->name != NULL; c++) {\n\t\tif ((c->flags & CFLAG_INTERNAL) != 0)\n\t\t\tcontinue;\n\t\tif (auth_only && c->auth_len == 0)\n\t\t\tcontinue;\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(c->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, c->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include \"digest.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"cipher.h\"",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define CFLAG_INTERNAL\t\tCFLAG_NONE /* Don't use \"none\" for packets */"
    ],
    "globals_used": [
      "static const struct sshcipher ciphers[] = {\n#ifdef WITH_OPENSSL\n#ifndef OPENSSL_NO_DES\n\t{ \"3des-cbc\",\t\t8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },\n#endif\n\t{ \"aes128-cbc\",\t\t16, 16, 0, 0, CFLAG_CBC, EVP_aes_128_cbc },\n\t{ \"aes192-cbc\",\t\t16, 24, 0, 0, CFLAG_CBC, EVP_aes_192_cbc },\n\t{ \"aes256-cbc\",\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"rijndael-cbc@lysator.liu.se\",\n\t\t\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, 0, EVP_aes_128_ctr },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, 0, EVP_aes_192_ctr },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, 0, EVP_aes_256_ctr },\n# ifdef OPENSSL_HAVE_EVPGCM\n\t{ \"aes128-gcm@openssh.com\",\n\t\t\t\t16, 16, 12, 16, 0, EVP_aes_128_gcm },\n\t{ \"aes256-gcm@openssh.com\",\n\t\t\t\t16, 32, 12, 16, 0, EVP_aes_256_gcm },\n# endif /* OPENSSL_HAVE_EVPGCM */\n#else\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, CFLAG_AESCTR, NULL },\n#endif\n\t{ \"chacha20-poly1305@openssh.com\",\n\t\t\t\t8, 64, 0, 16, CFLAG_CHACHAPOLY, NULL },\n\t{ \"none\",\t\t8, 0, 0, 0, CFLAG_NONE, NULL },\n\n\t{ NULL,\t\t\t0, 0, 0, 0, 0, NULL }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ret + rlen",
            "c->name",
            "nlen + 1"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ret"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "cipher_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/cipher.c",
          "lines": "410-425",
          "snippet": "void\ncipher_free(struct sshcipher_ctx *cc)\n{\n\tif (cc == NULL)\n\t\treturn;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)\n\t\texplicit_bzero(&cc->cp_ctx, sizeof(cc->cp_ctx));\n\telse if ((cc->cipher->flags & CFLAG_AESCTR) != 0)\n\t\texplicit_bzero(&cc->ac_ctx, sizeof(cc->ac_ctx));\n#ifdef WITH_OPENSSL\n\tEVP_CIPHER_CTX_free(cc->evp);\n\tcc->evp = NULL;\n#endif\n\texplicit_bzero(cc, sizeof(*cc));\n\tfree(cc);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"cipher.h\"",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define CFLAG_AESCTR\t\t(1<<2)",
            "#define CFLAG_CHACHAPOLY\t(1<<1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_AESCTR\t\t(1<<2)\n#define CFLAG_CHACHAPOLY\t(1<<1)\n\nvoid\ncipher_free(struct sshcipher_ctx *cc)\n{\n\tif (cc == NULL)\n\t\treturn;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)\n\t\texplicit_bzero(&cc->cp_ctx, sizeof(cc->cp_ctx));\n\telse if ((cc->cipher->flags & CFLAG_AESCTR) != 0)\n\t\texplicit_bzero(&cc->ac_ctx, sizeof(cc->ac_ctx));\n#ifdef WITH_OPENSSL\n\tEVP_CIPHER_CTX_free(cc->evp);\n\tcc->evp = NULL;\n#endif\n\texplicit_bzero(cc, sizeof(*cc));\n\tfree(cc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "ret",
            "rlen + nlen + 2"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "rpl_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-malloc.c",
          "lines": "48-56",
          "snippet": "void *\nrpl_realloc(void *ptr, size_t size)\n{\n\tif (size == 0)\n\t\tsize = 1;\n\tif (ptr == 0)\n\t\treturn malloc(size);\n\treturn realloc(ptr, size);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nvoid *\nrpl_realloc(void *ptr, size_t size)\n{\n\tif (size == 0)\n\t\tsize = 1;\n\tif (ptr == 0)\n\t\treturn malloc(size);\n\treturn realloc(ptr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c->name"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"cipher.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define CFLAG_INTERNAL\t\tCFLAG_NONE /* Don't use \"none\" for packets */\n\nstatic const struct sshcipher ciphers[] = {\n#ifdef WITH_OPENSSL\n#ifndef OPENSSL_NO_DES\n\t{ \"3des-cbc\",\t\t8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },\n#endif\n\t{ \"aes128-cbc\",\t\t16, 16, 0, 0, CFLAG_CBC, EVP_aes_128_cbc },\n\t{ \"aes192-cbc\",\t\t16, 24, 0, 0, CFLAG_CBC, EVP_aes_192_cbc },\n\t{ \"aes256-cbc\",\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"rijndael-cbc@lysator.liu.se\",\n\t\t\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, 0, EVP_aes_128_ctr },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, 0, EVP_aes_192_ctr },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, 0, EVP_aes_256_ctr },\n# ifdef OPENSSL_HAVE_EVPGCM\n\t{ \"aes128-gcm@openssh.com\",\n\t\t\t\t16, 16, 12, 16, 0, EVP_aes_128_gcm },\n\t{ \"aes256-gcm@openssh.com\",\n\t\t\t\t16, 32, 12, 16, 0, EVP_aes_256_gcm },\n# endif /* OPENSSL_HAVE_EVPGCM */\n#else\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, CFLAG_AESCTR, NULL },\n#endif\n\t{ \"chacha20-poly1305@openssh.com\",\n\t\t\t\t8, 64, 0, 16, CFLAG_CHACHAPOLY, NULL },\n\t{ \"none\",\t\t8, 0, 0, 0, CFLAG_NONE, NULL },\n\n\t{ NULL,\t\t\t0, 0, 0, 0, 0, NULL }\n};\n\nchar *\ncipher_alg_list(char sep, int auth_only)\n{\n\tchar *tmp, *ret = NULL;\n\tsize_t nlen, rlen = 0;\n\tconst struct sshcipher *c;\n\n\tfor (c = ciphers; c->name != NULL; c++) {\n\t\tif ((c->flags & CFLAG_INTERNAL) != 0)\n\t\t\tcontinue;\n\t\tif (auth_only && c->auth_len == 0)\n\t\t\tcontinue;\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(c->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, c->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}"
  }
]