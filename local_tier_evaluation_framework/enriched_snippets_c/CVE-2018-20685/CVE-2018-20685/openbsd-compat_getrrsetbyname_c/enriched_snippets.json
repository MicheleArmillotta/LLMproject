[
  {
    "function_name": "count_dns_rr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
    "lines": "596-608",
    "snippet": "static int\ncount_dns_rr(struct dns_rr *p, u_int16_t class, u_int16_t type)\n{\n\tint n = 0;\n\n\twhile(p) {\n\t\tif (p->class == class && p->type == type)\n\t\t\tn++;\n\t\tp = p->next;\n\t}\n\n\treturn (n);\n}",
    "includes": [
      "#include \"getrrsetbyname.h\"",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic int\ncount_dns_rr(struct dns_rr *p, u_int16_t class, u_int16_t type)\n{\n\tint n = 0;\n\n\twhile(p) {\n\t\tif (p->class == class && p->type == type)\n\t\t\tn++;\n\t\tp = p->next;\n\t}\n\n\treturn (n);\n}"
  },
  {
    "function_name": "free_dns_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
    "lines": "583-594",
    "snippet": "static void\nfree_dns_response(struct dns_response *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tfree_dns_query(p->query);\n\tfree_dns_rr(p->answer);\n\tfree_dns_rr(p->authority);\n\tfree_dns_rr(p->additional);\n\tfree(p);\n}",
    "includes": [
      "#include \"getrrsetbyname.h\"",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "p"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "free_dns_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
          "lines": "583-594",
          "snippet": "static void\nfree_dns_response(struct dns_response *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tfree_dns_query(p->query);\n\tfree_dns_rr(p->answer);\n\tfree_dns_rr(p->authority);\n\tfree_dns_rr(p->additional);\n\tfree(p);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "free_dns_rr",
          "args": [
            "p->additional"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "free_dns_rr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
          "lines": "569-581",
          "snippet": "static void\nfree_dns_rr(struct dns_rr *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tif (p->name)\n\t\tfree(p->name);\n\tif (p->rdata)\n\t\tfree(p->rdata);\n\tfree_dns_rr(p->next);\n\tfree(p);\n}",
          "includes": [
            "#include \"getrrsetbyname.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void\nfree_dns_rr(struct dns_rr *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tif (p->name)\n\t\tfree(p->name);\n\tif (p->rdata)\n\t\tfree(p->rdata);\n\tfree_dns_rr(p->next);\n\tfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_dns_query",
          "args": [
            "p->query"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "free_dns_query",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
          "lines": "557-567",
          "snippet": "static void\nfree_dns_query(struct dns_query *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tif (p->name)\n\t\tfree(p->name);\n\tfree_dns_query(p->next);\n\tfree(p);\n}",
          "includes": [
            "#include \"getrrsetbyname.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void\nfree_dns_query(struct dns_query *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tif (p->name)\n\t\tfree(p->name);\n\tfree_dns_query(p->next);\n\tfree(p);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void\nfree_dns_response(struct dns_response *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tfree_dns_query(p->query);\n\tfree_dns_rr(p->answer);\n\tfree_dns_rr(p->authority);\n\tfree_dns_rr(p->additional);\n\tfree(p);\n}"
  },
  {
    "function_name": "free_dns_rr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
    "lines": "569-581",
    "snippet": "static void\nfree_dns_rr(struct dns_rr *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tif (p->name)\n\t\tfree(p->name);\n\tif (p->rdata)\n\t\tfree(p->rdata);\n\tfree_dns_rr(p->next);\n\tfree(p);\n}",
    "includes": [
      "#include \"getrrsetbyname.h\"",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "p"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "free_dns_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
          "lines": "583-594",
          "snippet": "static void\nfree_dns_response(struct dns_response *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tfree_dns_query(p->query);\n\tfree_dns_rr(p->answer);\n\tfree_dns_rr(p->authority);\n\tfree_dns_rr(p->additional);\n\tfree(p);\n}",
          "includes": [
            "#include \"getrrsetbyname.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void\nfree_dns_response(struct dns_response *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tfree_dns_query(p->query);\n\tfree_dns_rr(p->answer);\n\tfree_dns_rr(p->authority);\n\tfree_dns_rr(p->additional);\n\tfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_dns_rr",
          "args": [
            "p->next"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "free_dns_rr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
          "lines": "569-581",
          "snippet": "static void\nfree_dns_rr(struct dns_rr *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tif (p->name)\n\t\tfree(p->name);\n\tif (p->rdata)\n\t\tfree(p->rdata);\n\tfree_dns_rr(p->next);\n\tfree(p);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void\nfree_dns_rr(struct dns_rr *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tif (p->name)\n\t\tfree(p->name);\n\tif (p->rdata)\n\t\tfree(p->rdata);\n\tfree_dns_rr(p->next);\n\tfree(p);\n}"
  },
  {
    "function_name": "free_dns_query",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
    "lines": "557-567",
    "snippet": "static void\nfree_dns_query(struct dns_query *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tif (p->name)\n\t\tfree(p->name);\n\tfree_dns_query(p->next);\n\tfree(p);\n}",
    "includes": [
      "#include \"getrrsetbyname.h\"",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "p"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "free_dns_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
          "lines": "583-594",
          "snippet": "static void\nfree_dns_response(struct dns_response *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tfree_dns_query(p->query);\n\tfree_dns_rr(p->answer);\n\tfree_dns_rr(p->authority);\n\tfree_dns_rr(p->additional);\n\tfree(p);\n}",
          "includes": [
            "#include \"getrrsetbyname.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void\nfree_dns_response(struct dns_response *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tfree_dns_query(p->query);\n\tfree_dns_rr(p->answer);\n\tfree_dns_rr(p->authority);\n\tfree_dns_rr(p->additional);\n\tfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_dns_query",
          "args": [
            "p->next"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "free_dns_query",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
          "lines": "557-567",
          "snippet": "static void\nfree_dns_query(struct dns_query *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tif (p->name)\n\t\tfree(p->name);\n\tfree_dns_query(p->next);\n\tfree(p);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void\nfree_dns_query(struct dns_query *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tif (p->name)\n\t\tfree(p->name);\n\tfree_dns_query(p->next);\n\tfree(p);\n}"
  },
  {
    "function_name": "parse_dns_rrsection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
    "lines": "493-555",
    "snippet": "static struct dns_rr *\nparse_dns_rrsection(const u_char *answer, int size, const u_char **cp,\n    int count)\n{\n\tstruct dns_rr *head, *curr, *prev;\n\tint i, length;\n\tchar name[MAXDNAME];\n\n\tfor (i = 1, head = NULL, prev = NULL; i <= count; i++, prev = curr) {\n\n\t\t/* allocate and initialize struct */\n\t\tcurr = calloc(1, sizeof(struct dns_rr));\n\t\tif (curr == NULL) {\n\t\t\tfree_dns_rr(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\tif (head == NULL)\n\t\t\thead = curr;\n\t\tif (prev != NULL)\n\t\t\tprev->next = curr;\n\n\t\t/* name */\n\t\tlength = dn_expand(answer, answer + size, *cp, name,\n\t\t    sizeof(name));\n\t\tif (length < 0) {\n\t\t\tfree_dns_rr(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\tcurr->name = strdup(name);\n\t\tif (curr->name == NULL) {\n\t\t\tfree_dns_rr(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\t*cp += length;\n\n\t\t/* type */\n\t\tcurr->type = _getshort(*cp);\n\t\t*cp += INT16SZ;\n\n\t\t/* class */\n\t\tcurr->class = _getshort(*cp);\n\t\t*cp += INT16SZ;\n\n\t\t/* ttl */\n\t\tcurr->ttl = _getlong(*cp);\n\t\t*cp += INT32SZ;\n\n\t\t/* rdata size */\n\t\tcurr->size = _getshort(*cp);\n\t\t*cp += INT16SZ;\n\n\t\t/* rdata itself */\n\t\tcurr->rdata = malloc(curr->size);\n\t\tif (curr->rdata == NULL) {\n\t\t\tfree_dns_rr(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\tmemcpy(curr->rdata, *cp, curr->size);\n\t\t*cp += curr->size;\n\t}\n\n\treturn (head);\n}",
    "includes": [
      "#include \"getrrsetbyname.h\"",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "curr->rdata",
            "*cp",
            "curr->size"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_dns_rr",
          "args": [
            "head"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "free_dns_rr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
          "lines": "569-581",
          "snippet": "static void\nfree_dns_rr(struct dns_rr *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tif (p->name)\n\t\tfree(p->name);\n\tif (p->rdata)\n\t\tfree(p->rdata);\n\tfree_dns_rr(p->next);\n\tfree(p);\n}",
          "includes": [
            "#include \"getrrsetbyname.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void\nfree_dns_rr(struct dns_rr *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tif (p->name)\n\t\tfree(p->name);\n\tif (p->rdata)\n\t\tfree(p->rdata);\n\tfree_dns_rr(p->next);\n\tfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "curr->size"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "rpl_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-malloc.c",
          "lines": "26-32",
          "snippet": "void *\nrpl_malloc(size_t size)\n{\n\tif (size == 0)\n\t\tsize = 1;\n\treturn malloc(size);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nvoid *\nrpl_malloc(size_t size)\n{\n\tif (size == 0)\n\t\tsize = 1;\n\treturn malloc(size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_getshort",
          "args": [
            "*cp"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "_getshort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
          "lines": "117-125",
          "snippet": "static u_int16_t\n_getshort(msgp)\n\tregister const u_char *msgp;\n{\n\tregister u_int16_t u;\n\n\tGETSHORT(u, msgp);\n\treturn (u);\n}",
          "includes": [
            "#include \"getrrsetbyname.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic u_int16_t\n_getshort(msgp)\n\tregister const u_char *msgp;\n{\n\tregister u_int16_t u;\n\n\tGETSHORT(u, msgp);\n\treturn (u);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_getlong",
          "args": [
            "*cp"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "_getlong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
          "lines": "131-139",
          "snippet": "static u_int32_t\n_getlong(msgp)\n\tregister const u_char *msgp;\n{\n\tregister u_int32_t u;\n\n\tGETLONG(u, msgp);\n\treturn (u);\n}",
          "includes": [
            "#include \"getrrsetbyname.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic u_int32_t\n_getlong(msgp)\n\tregister const u_char *msgp;\n{\n\tregister u_int32_t u;\n\n\tGETLONG(u, msgp);\n\treturn (u);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "name"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "216-227",
          "snippet": "char *\nstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = malloc(len);\n\tif (cp != NULL)\n\t\treturn(memcpy(cp, str, len));\n\treturn NULL;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = malloc(len);\n\tif (cp != NULL)\n\t\treturn(memcpy(cp, str, len));\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dn_expand",
          "args": [
            "answer",
            "answer + size",
            "*cp",
            "name",
            "sizeof(name)"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(struct dns_rr)"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "rpl_calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-malloc.c",
          "lines": "36-44",
          "snippet": "void *\nrpl_calloc(size_t nmemb, size_t size)\n{\n\tif (nmemb == 0)\n\t\tnmemb = 1;\n\tif (size == 0)\n\t\tsize = 1;\n\treturn calloc(nmemb, size);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nvoid *\nrpl_calloc(size_t nmemb, size_t size)\n{\n\tif (nmemb == 0)\n\t\tnmemb = 1;\n\tif (size == 0)\n\t\tsize = 1;\n\treturn calloc(nmemb, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic struct dns_rr *\nparse_dns_rrsection(const u_char *answer, int size, const u_char **cp,\n    int count)\n{\n\tstruct dns_rr *head, *curr, *prev;\n\tint i, length;\n\tchar name[MAXDNAME];\n\n\tfor (i = 1, head = NULL, prev = NULL; i <= count; i++, prev = curr) {\n\n\t\t/* allocate and initialize struct */\n\t\tcurr = calloc(1, sizeof(struct dns_rr));\n\t\tif (curr == NULL) {\n\t\t\tfree_dns_rr(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\tif (head == NULL)\n\t\t\thead = curr;\n\t\tif (prev != NULL)\n\t\t\tprev->next = curr;\n\n\t\t/* name */\n\t\tlength = dn_expand(answer, answer + size, *cp, name,\n\t\t    sizeof(name));\n\t\tif (length < 0) {\n\t\t\tfree_dns_rr(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\tcurr->name = strdup(name);\n\t\tif (curr->name == NULL) {\n\t\t\tfree_dns_rr(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\t*cp += length;\n\n\t\t/* type */\n\t\tcurr->type = _getshort(*cp);\n\t\t*cp += INT16SZ;\n\n\t\t/* class */\n\t\tcurr->class = _getshort(*cp);\n\t\t*cp += INT16SZ;\n\n\t\t/* ttl */\n\t\tcurr->ttl = _getlong(*cp);\n\t\t*cp += INT32SZ;\n\n\t\t/* rdata size */\n\t\tcurr->size = _getshort(*cp);\n\t\t*cp += INT16SZ;\n\n\t\t/* rdata itself */\n\t\tcurr->rdata = malloc(curr->size);\n\t\tif (curr->rdata == NULL) {\n\t\t\tfree_dns_rr(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\tmemcpy(curr->rdata, *cp, curr->size);\n\t\t*cp += curr->size;\n\t}\n\n\treturn (head);\n}"
  },
  {
    "function_name": "parse_dns_qsection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
    "lines": "447-491",
    "snippet": "static struct dns_query *\nparse_dns_qsection(const u_char *answer, int size, const u_char **cp, int count)\n{\n\tstruct dns_query *head, *curr, *prev;\n\tint i, length;\n\tchar name[MAXDNAME];\n\n\tfor (i = 1, head = NULL, prev = NULL; i <= count; i++, prev = curr) {\n\n\t\t/* allocate and initialize struct */\n\t\tcurr = calloc(1, sizeof(struct dns_query));\n\t\tif (curr == NULL) {\n\t\t\tfree_dns_query(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\tif (head == NULL)\n\t\t\thead = curr;\n\t\tif (prev != NULL)\n\t\t\tprev->next = curr;\n\n\t\t/* name */\n\t\tlength = dn_expand(answer, answer + size, *cp, name,\n\t\t    sizeof(name));\n\t\tif (length < 0) {\n\t\t\tfree_dns_query(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\tcurr->name = strdup(name);\n\t\tif (curr->name == NULL) {\n\t\t\tfree_dns_query(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\t*cp += length;\n\n\t\t/* type */\n\t\tcurr->type = _getshort(*cp);\n\t\t*cp += INT16SZ;\n\n\t\t/* class */\n\t\tcurr->class = _getshort(*cp);\n\t\t*cp += INT16SZ;\n\t}\n\n\treturn (head);\n}",
    "includes": [
      "#include \"getrrsetbyname.h\"",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_getshort",
          "args": [
            "*cp"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "_getshort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
          "lines": "117-125",
          "snippet": "static u_int16_t\n_getshort(msgp)\n\tregister const u_char *msgp;\n{\n\tregister u_int16_t u;\n\n\tGETSHORT(u, msgp);\n\treturn (u);\n}",
          "includes": [
            "#include \"getrrsetbyname.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic u_int16_t\n_getshort(msgp)\n\tregister const u_char *msgp;\n{\n\tregister u_int16_t u;\n\n\tGETSHORT(u, msgp);\n\treturn (u);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_dns_query",
          "args": [
            "head"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "free_dns_query",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
          "lines": "557-567",
          "snippet": "static void\nfree_dns_query(struct dns_query *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tif (p->name)\n\t\tfree(p->name);\n\tfree_dns_query(p->next);\n\tfree(p);\n}",
          "includes": [
            "#include \"getrrsetbyname.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void\nfree_dns_query(struct dns_query *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tif (p->name)\n\t\tfree(p->name);\n\tfree_dns_query(p->next);\n\tfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "name"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "216-227",
          "snippet": "char *\nstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = malloc(len);\n\tif (cp != NULL)\n\t\treturn(memcpy(cp, str, len));\n\treturn NULL;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = malloc(len);\n\tif (cp != NULL)\n\t\treturn(memcpy(cp, str, len));\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dn_expand",
          "args": [
            "answer",
            "answer + size",
            "*cp",
            "name",
            "sizeof(name)"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(struct dns_query)"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "rpl_calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-malloc.c",
          "lines": "36-44",
          "snippet": "void *\nrpl_calloc(size_t nmemb, size_t size)\n{\n\tif (nmemb == 0)\n\t\tnmemb = 1;\n\tif (size == 0)\n\t\tsize = 1;\n\treturn calloc(nmemb, size);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nvoid *\nrpl_calloc(size_t nmemb, size_t size)\n{\n\tif (nmemb == 0)\n\t\tnmemb = 1;\n\tif (size == 0)\n\t\tsize = 1;\n\treturn calloc(nmemb, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic struct dns_query *\nparse_dns_qsection(const u_char *answer, int size, const u_char **cp, int count)\n{\n\tstruct dns_query *head, *curr, *prev;\n\tint i, length;\n\tchar name[MAXDNAME];\n\n\tfor (i = 1, head = NULL, prev = NULL; i <= count; i++, prev = curr) {\n\n\t\t/* allocate and initialize struct */\n\t\tcurr = calloc(1, sizeof(struct dns_query));\n\t\tif (curr == NULL) {\n\t\t\tfree_dns_query(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\tif (head == NULL)\n\t\t\thead = curr;\n\t\tif (prev != NULL)\n\t\t\tprev->next = curr;\n\n\t\t/* name */\n\t\tlength = dn_expand(answer, answer + size, *cp, name,\n\t\t    sizeof(name));\n\t\tif (length < 0) {\n\t\t\tfree_dns_query(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\tcurr->name = strdup(name);\n\t\tif (curr->name == NULL) {\n\t\t\tfree_dns_query(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\t*cp += length;\n\n\t\t/* type */\n\t\tcurr->type = _getshort(*cp);\n\t\t*cp += INT16SZ;\n\n\t\t/* class */\n\t\tcurr->class = _getshort(*cp);\n\t\t*cp += INT16SZ;\n\t}\n\n\treturn (head);\n}"
  },
  {
    "function_name": "parse_dns_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
    "lines": "382-445",
    "snippet": "static struct dns_response *\nparse_dns_response(const u_char *answer, int size)\n{\n\tstruct dns_response *resp;\n\tconst u_char *cp;\n\n\t/* allocate memory for the response */\n\tresp = calloc(1, sizeof(*resp));\n\tif (resp == NULL)\n\t\treturn (NULL);\n\n\t/* initialize current pointer */\n\tcp = answer;\n\n\t/* copy header */\n\tmemcpy(&resp->header, cp, HFIXEDSZ);\n\tcp += HFIXEDSZ;\n\n\t/* fix header byte order */\n\tresp->header.qdcount = ntohs(resp->header.qdcount);\n\tresp->header.ancount = ntohs(resp->header.ancount);\n\tresp->header.nscount = ntohs(resp->header.nscount);\n\tresp->header.arcount = ntohs(resp->header.arcount);\n\n\t/* there must be at least one query */\n\tif (resp->header.qdcount < 1) {\n\t\tfree_dns_response(resp);\n\t\treturn (NULL);\n\t}\n\n\t/* parse query section */\n\tresp->query = parse_dns_qsection(answer, size, &cp,\n\t    resp->header.qdcount);\n\tif (resp->header.qdcount && resp->query == NULL) {\n\t\tfree_dns_response(resp);\n\t\treturn (NULL);\n\t}\n\n\t/* parse answer section */\n\tresp->answer = parse_dns_rrsection(answer, size, &cp,\n\t    resp->header.ancount);\n\tif (resp->header.ancount && resp->answer == NULL) {\n\t\tfree_dns_response(resp);\n\t\treturn (NULL);\n\t}\n\n\t/* parse authority section */\n\tresp->authority = parse_dns_rrsection(answer, size, &cp,\n\t    resp->header.nscount);\n\tif (resp->header.nscount && resp->authority == NULL) {\n\t\tfree_dns_response(resp);\n\t\treturn (NULL);\n\t}\n\n\t/* parse additional section */\n\tresp->additional = parse_dns_rrsection(answer, size, &cp,\n\t    resp->header.arcount);\n\tif (resp->header.arcount && resp->additional == NULL) {\n\t\tfree_dns_response(resp);\n\t\treturn (NULL);\n\t}\n\n\treturn (resp);\n}",
    "includes": [
      "#include \"getrrsetbyname.h\"",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_dns_response",
          "args": [
            "resp"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "free_dns_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
          "lines": "583-594",
          "snippet": "static void\nfree_dns_response(struct dns_response *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tfree_dns_query(p->query);\n\tfree_dns_rr(p->answer);\n\tfree_dns_rr(p->authority);\n\tfree_dns_rr(p->additional);\n\tfree(p);\n}",
          "includes": [
            "#include \"getrrsetbyname.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void\nfree_dns_response(struct dns_response *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tfree_dns_query(p->query);\n\tfree_dns_rr(p->answer);\n\tfree_dns_rr(p->authority);\n\tfree_dns_rr(p->additional);\n\tfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_dns_rrsection",
          "args": [
            "answer",
            "size",
            "&cp",
            "resp->header.arcount"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "parse_dns_rrsection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
          "lines": "493-555",
          "snippet": "static struct dns_rr *\nparse_dns_rrsection(const u_char *answer, int size, const u_char **cp,\n    int count)\n{\n\tstruct dns_rr *head, *curr, *prev;\n\tint i, length;\n\tchar name[MAXDNAME];\n\n\tfor (i = 1, head = NULL, prev = NULL; i <= count; i++, prev = curr) {\n\n\t\t/* allocate and initialize struct */\n\t\tcurr = calloc(1, sizeof(struct dns_rr));\n\t\tif (curr == NULL) {\n\t\t\tfree_dns_rr(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\tif (head == NULL)\n\t\t\thead = curr;\n\t\tif (prev != NULL)\n\t\t\tprev->next = curr;\n\n\t\t/* name */\n\t\tlength = dn_expand(answer, answer + size, *cp, name,\n\t\t    sizeof(name));\n\t\tif (length < 0) {\n\t\t\tfree_dns_rr(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\tcurr->name = strdup(name);\n\t\tif (curr->name == NULL) {\n\t\t\tfree_dns_rr(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\t*cp += length;\n\n\t\t/* type */\n\t\tcurr->type = _getshort(*cp);\n\t\t*cp += INT16SZ;\n\n\t\t/* class */\n\t\tcurr->class = _getshort(*cp);\n\t\t*cp += INT16SZ;\n\n\t\t/* ttl */\n\t\tcurr->ttl = _getlong(*cp);\n\t\t*cp += INT32SZ;\n\n\t\t/* rdata size */\n\t\tcurr->size = _getshort(*cp);\n\t\t*cp += INT16SZ;\n\n\t\t/* rdata itself */\n\t\tcurr->rdata = malloc(curr->size);\n\t\tif (curr->rdata == NULL) {\n\t\t\tfree_dns_rr(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\tmemcpy(curr->rdata, *cp, curr->size);\n\t\t*cp += curr->size;\n\t}\n\n\treturn (head);\n}",
          "includes": [
            "#include \"getrrsetbyname.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic struct dns_rr *\nparse_dns_rrsection(const u_char *answer, int size, const u_char **cp,\n    int count)\n{\n\tstruct dns_rr *head, *curr, *prev;\n\tint i, length;\n\tchar name[MAXDNAME];\n\n\tfor (i = 1, head = NULL, prev = NULL; i <= count; i++, prev = curr) {\n\n\t\t/* allocate and initialize struct */\n\t\tcurr = calloc(1, sizeof(struct dns_rr));\n\t\tif (curr == NULL) {\n\t\t\tfree_dns_rr(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\tif (head == NULL)\n\t\t\thead = curr;\n\t\tif (prev != NULL)\n\t\t\tprev->next = curr;\n\n\t\t/* name */\n\t\tlength = dn_expand(answer, answer + size, *cp, name,\n\t\t    sizeof(name));\n\t\tif (length < 0) {\n\t\t\tfree_dns_rr(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\tcurr->name = strdup(name);\n\t\tif (curr->name == NULL) {\n\t\t\tfree_dns_rr(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\t*cp += length;\n\n\t\t/* type */\n\t\tcurr->type = _getshort(*cp);\n\t\t*cp += INT16SZ;\n\n\t\t/* class */\n\t\tcurr->class = _getshort(*cp);\n\t\t*cp += INT16SZ;\n\n\t\t/* ttl */\n\t\tcurr->ttl = _getlong(*cp);\n\t\t*cp += INT32SZ;\n\n\t\t/* rdata size */\n\t\tcurr->size = _getshort(*cp);\n\t\t*cp += INT16SZ;\n\n\t\t/* rdata itself */\n\t\tcurr->rdata = malloc(curr->size);\n\t\tif (curr->rdata == NULL) {\n\t\t\tfree_dns_rr(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\tmemcpy(curr->rdata, *cp, curr->size);\n\t\t*cp += curr->size;\n\t}\n\n\treturn (head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_dns_qsection",
          "args": [
            "answer",
            "size",
            "&cp",
            "resp->header.qdcount"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "parse_dns_qsection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
          "lines": "447-491",
          "snippet": "static struct dns_query *\nparse_dns_qsection(const u_char *answer, int size, const u_char **cp, int count)\n{\n\tstruct dns_query *head, *curr, *prev;\n\tint i, length;\n\tchar name[MAXDNAME];\n\n\tfor (i = 1, head = NULL, prev = NULL; i <= count; i++, prev = curr) {\n\n\t\t/* allocate and initialize struct */\n\t\tcurr = calloc(1, sizeof(struct dns_query));\n\t\tif (curr == NULL) {\n\t\t\tfree_dns_query(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\tif (head == NULL)\n\t\t\thead = curr;\n\t\tif (prev != NULL)\n\t\t\tprev->next = curr;\n\n\t\t/* name */\n\t\tlength = dn_expand(answer, answer + size, *cp, name,\n\t\t    sizeof(name));\n\t\tif (length < 0) {\n\t\t\tfree_dns_query(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\tcurr->name = strdup(name);\n\t\tif (curr->name == NULL) {\n\t\t\tfree_dns_query(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\t*cp += length;\n\n\t\t/* type */\n\t\tcurr->type = _getshort(*cp);\n\t\t*cp += INT16SZ;\n\n\t\t/* class */\n\t\tcurr->class = _getshort(*cp);\n\t\t*cp += INT16SZ;\n\t}\n\n\treturn (head);\n}",
          "includes": [
            "#include \"getrrsetbyname.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic struct dns_query *\nparse_dns_qsection(const u_char *answer, int size, const u_char **cp, int count)\n{\n\tstruct dns_query *head, *curr, *prev;\n\tint i, length;\n\tchar name[MAXDNAME];\n\n\tfor (i = 1, head = NULL, prev = NULL; i <= count; i++, prev = curr) {\n\n\t\t/* allocate and initialize struct */\n\t\tcurr = calloc(1, sizeof(struct dns_query));\n\t\tif (curr == NULL) {\n\t\t\tfree_dns_query(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\tif (head == NULL)\n\t\t\thead = curr;\n\t\tif (prev != NULL)\n\t\t\tprev->next = curr;\n\n\t\t/* name */\n\t\tlength = dn_expand(answer, answer + size, *cp, name,\n\t\t    sizeof(name));\n\t\tif (length < 0) {\n\t\t\tfree_dns_query(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\tcurr->name = strdup(name);\n\t\tif (curr->name == NULL) {\n\t\t\tfree_dns_query(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\t*cp += length;\n\n\t\t/* type */\n\t\tcurr->type = _getshort(*cp);\n\t\t*cp += INT16SZ;\n\n\t\t/* class */\n\t\tcurr->class = _getshort(*cp);\n\t\t*cp += INT16SZ;\n\t}\n\n\treturn (head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "resp->header.arcount"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "resp->header.nscount"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "resp->header.ancount"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "resp->header.qdcount"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&resp->header",
            "cp",
            "HFIXEDSZ"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(*resp)"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "rpl_calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-malloc.c",
          "lines": "36-44",
          "snippet": "void *\nrpl_calloc(size_t nmemb, size_t size)\n{\n\tif (nmemb == 0)\n\t\tnmemb = 1;\n\tif (size == 0)\n\t\tsize = 1;\n\treturn calloc(nmemb, size);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nvoid *\nrpl_calloc(size_t nmemb, size_t size)\n{\n\tif (nmemb == 0)\n\t\tnmemb = 1;\n\tif (size == 0)\n\t\tsize = 1;\n\treturn calloc(nmemb, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic struct dns_response *\nparse_dns_response(const u_char *answer, int size)\n{\n\tstruct dns_response *resp;\n\tconst u_char *cp;\n\n\t/* allocate memory for the response */\n\tresp = calloc(1, sizeof(*resp));\n\tif (resp == NULL)\n\t\treturn (NULL);\n\n\t/* initialize current pointer */\n\tcp = answer;\n\n\t/* copy header */\n\tmemcpy(&resp->header, cp, HFIXEDSZ);\n\tcp += HFIXEDSZ;\n\n\t/* fix header byte order */\n\tresp->header.qdcount = ntohs(resp->header.qdcount);\n\tresp->header.ancount = ntohs(resp->header.ancount);\n\tresp->header.nscount = ntohs(resp->header.nscount);\n\tresp->header.arcount = ntohs(resp->header.arcount);\n\n\t/* there must be at least one query */\n\tif (resp->header.qdcount < 1) {\n\t\tfree_dns_response(resp);\n\t\treturn (NULL);\n\t}\n\n\t/* parse query section */\n\tresp->query = parse_dns_qsection(answer, size, &cp,\n\t    resp->header.qdcount);\n\tif (resp->header.qdcount && resp->query == NULL) {\n\t\tfree_dns_response(resp);\n\t\treturn (NULL);\n\t}\n\n\t/* parse answer section */\n\tresp->answer = parse_dns_rrsection(answer, size, &cp,\n\t    resp->header.ancount);\n\tif (resp->header.ancount && resp->answer == NULL) {\n\t\tfree_dns_response(resp);\n\t\treturn (NULL);\n\t}\n\n\t/* parse authority section */\n\tresp->authority = parse_dns_rrsection(answer, size, &cp,\n\t    resp->header.nscount);\n\tif (resp->header.nscount && resp->authority == NULL) {\n\t\tfree_dns_response(resp);\n\t\treturn (NULL);\n\t}\n\n\t/* parse additional section */\n\tresp->additional = parse_dns_rrsection(answer, size, &cp,\n\t    resp->header.arcount);\n\tif (resp->header.arcount && resp->additional == NULL) {\n\t\tfree_dns_response(resp);\n\t\treturn (NULL);\n\t}\n\n\treturn (resp);\n}"
  },
  {
    "function_name": "freerrset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
    "lines": "348-377",
    "snippet": "void\nfreerrset(struct rrsetinfo *rrset)\n{\n\tu_int16_t i;\n\n\tif (rrset == NULL)\n\t\treturn;\n\n\tif (rrset->rri_rdatas) {\n\t\tfor (i = 0; i < rrset->rri_nrdatas; i++) {\n\t\t\tif (rrset->rri_rdatas[i].rdi_data == NULL)\n\t\t\t\tbreak;\n\t\t\tfree(rrset->rri_rdatas[i].rdi_data);\n\t\t}\n\t\tfree(rrset->rri_rdatas);\n\t}\n\n\tif (rrset->rri_sigs) {\n\t\tfor (i = 0; i < rrset->rri_nsigs; i++) {\n\t\t\tif (rrset->rri_sigs[i].rdi_data == NULL)\n\t\t\t\tbreak;\n\t\t\tfree(rrset->rri_sigs[i].rdi_data);\n\t\t}\n\t\tfree(rrset->rri_sigs);\n\t}\n\n\tif (rrset->rri_name)\n\t\tfree(rrset->rri_name);\n\tfree(rrset);\n}",
    "includes": [
      "#include \"getrrsetbyname.h\"",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "rrset"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "free_dns_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
          "lines": "583-594",
          "snippet": "static void\nfree_dns_response(struct dns_response *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tfree_dns_query(p->query);\n\tfree_dns_rr(p->answer);\n\tfree_dns_rr(p->authority);\n\tfree_dns_rr(p->additional);\n\tfree(p);\n}",
          "includes": [
            "#include \"getrrsetbyname.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void\nfree_dns_response(struct dns_response *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tfree_dns_query(p->query);\n\tfree_dns_rr(p->answer);\n\tfree_dns_rr(p->authority);\n\tfree_dns_rr(p->additional);\n\tfree(p);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreerrset(struct rrsetinfo *rrset)\n{\n\tu_int16_t i;\n\n\tif (rrset == NULL)\n\t\treturn;\n\n\tif (rrset->rri_rdatas) {\n\t\tfor (i = 0; i < rrset->rri_nrdatas; i++) {\n\t\t\tif (rrset->rri_rdatas[i].rdi_data == NULL)\n\t\t\t\tbreak;\n\t\t\tfree(rrset->rri_rdatas[i].rdi_data);\n\t\t}\n\t\tfree(rrset->rri_rdatas);\n\t}\n\n\tif (rrset->rri_sigs) {\n\t\tfor (i = 0; i < rrset->rri_nsigs; i++) {\n\t\t\tif (rrset->rri_sigs[i].rdi_data == NULL)\n\t\t\t\tbreak;\n\t\t\tfree(rrset->rri_sigs[i].rdi_data);\n\t\t}\n\t\tfree(rrset->rri_sigs);\n\t}\n\n\tif (rrset->rri_name)\n\t\tfree(rrset->rri_name);\n\tfree(rrset);\n}"
  },
  {
    "function_name": "getrrsetbyname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
    "lines": "185-346",
    "snippet": "int\ngetrrsetbyname(const char *hostname, unsigned int rdclass,\n    unsigned int rdtype, unsigned int flags,\n    struct rrsetinfo **res)\n{\n\tstruct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);\n\tint result;\n\tstruct rrsetinfo *rrset = NULL;\n\tstruct dns_response *response = NULL;\n\tstruct dns_rr *rr;\n\tstruct rdatainfo *rdata;\n\tint length;\n\tunsigned int index_ans, index_sig;\n\tu_char answer[ANSWER_BUFFER_SIZE];\n\n\t/* check for invalid class and type */\n\tif (rdclass > 0xffff || rdtype > 0xffff) {\n\t\tresult = ERRSET_INVAL;\n\t\tgoto fail;\n\t}\n\n\t/* don't allow queries of class or type ANY */\n\tif (rdclass == 0xff || rdtype == 0xff) {\n\t\tresult = ERRSET_INVAL;\n\t\tgoto fail;\n\t}\n\n\t/* don't allow flags yet, unimplemented */\n\tif (flags) {\n\t\tresult = ERRSET_INVAL;\n\t\tgoto fail;\n\t}\n\n\t/* initialize resolver */\n\tif ((_resp->options & RES_INIT) == 0 && res_init() == -1) {\n\t\tresult = ERRSET_FAIL;\n\t\tgoto fail;\n\t}\n\n#ifdef DEBUG\n\t_resp->options |= RES_DEBUG;\n#endif /* DEBUG */\n\n#ifdef RES_USE_DNSSEC\n\t/* turn on DNSSEC if EDNS0 is configured */\n\tif (_resp->options & RES_USE_EDNS0)\n\t\t_resp->options |= RES_USE_DNSSEC;\n#endif /* RES_USE_DNSEC */\n\n\t/* make query */\n\tlength = res_query(hostname, (signed int) rdclass, (signed int) rdtype,\n\t    answer, sizeof(answer));\n\tif (length < 0) {\n\t\tswitch(h_errno) {\n\t\tcase HOST_NOT_FOUND:\n\t\t\tresult = ERRSET_NONAME;\n\t\t\tgoto fail;\n\t\tcase NO_DATA:\n\t\t\tresult = ERRSET_NODATA;\n\t\t\tgoto fail;\n\t\tdefault:\n\t\t\tresult = ERRSET_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* parse result */\n\tresponse = parse_dns_response(answer, length);\n\tif (response == NULL) {\n\t\tresult = ERRSET_FAIL;\n\t\tgoto fail;\n\t}\n\n\tif (response->header.qdcount != 1) {\n\t\tresult = ERRSET_FAIL;\n\t\tgoto fail;\n\t}\n\n\t/* initialize rrset */\n\trrset = calloc(1, sizeof(struct rrsetinfo));\n\tif (rrset == NULL) {\n\t\tresult = ERRSET_NOMEMORY;\n\t\tgoto fail;\n\t}\n\trrset->rri_rdclass = response->query->class;\n\trrset->rri_rdtype = response->query->type;\n\trrset->rri_ttl = response->answer->ttl;\n\trrset->rri_nrdatas = response->header.ancount;\n\n#ifdef HAVE_HEADER_AD\n\t/* check for authenticated data */\n\tif (response->header.ad == 1)\n\t\trrset->rri_flags |= RRSET_VALIDATED;\n#endif\n\n\t/* copy name from answer section */\n\trrset->rri_name = strdup(response->answer->name);\n\tif (rrset->rri_name == NULL) {\n\t\tresult = ERRSET_NOMEMORY;\n\t\tgoto fail;\n\t}\n\n\t/* count answers */\n\trrset->rri_nrdatas = count_dns_rr(response->answer, rrset->rri_rdclass,\n\t    rrset->rri_rdtype);\n\trrset->rri_nsigs = count_dns_rr(response->answer, rrset->rri_rdclass,\n\t    T_RRSIG);\n\n\t/* allocate memory for answers */\n\trrset->rri_rdatas = calloc(rrset->rri_nrdatas,\n\t    sizeof(struct rdatainfo));\n\tif (rrset->rri_rdatas == NULL) {\n\t\tresult = ERRSET_NOMEMORY;\n\t\tgoto fail;\n\t}\n\n\t/* allocate memory for signatures */\n\tif (rrset->rri_nsigs > 0) {\n\t\trrset->rri_sigs = calloc(rrset->rri_nsigs, sizeof(struct rdatainfo));\n\t\tif (rrset->rri_sigs == NULL) {\n\t\t\tresult = ERRSET_NOMEMORY;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* copy answers & signatures */\n\tfor (rr = response->answer, index_ans = 0, index_sig = 0;\n\t    rr; rr = rr->next) {\n\n\t\trdata = NULL;\n\n\t\tif (rr->class == rrset->rri_rdclass &&\n\t\t    rr->type  == rrset->rri_rdtype)\n\t\t\trdata = &rrset->rri_rdatas[index_ans++];\n\n\t\tif (rr->class == rrset->rri_rdclass &&\n\t\t    rr->type  == T_RRSIG)\n\t\t\trdata = &rrset->rri_sigs[index_sig++];\n\n\t\tif (rdata) {\n\t\t\trdata->rdi_length = rr->size;\n\t\t\trdata->rdi_data   = malloc(rr->size);\n\n\t\t\tif (rdata->rdi_data == NULL) {\n\t\t\t\tresult = ERRSET_NOMEMORY;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tmemcpy(rdata->rdi_data, rr->rdata, rr->size);\n\t\t}\n\t}\n\tfree_dns_response(response);\n\n\t*res = rrset;\n\treturn (ERRSET_SUCCESS);\n\nfail:\n\tif (rrset != NULL)\n\t\tfreerrset(rrset);\n\tif (response != NULL)\n\t\tfree_dns_response(response);\n\treturn (result);\n}",
    "includes": [
      "#include \"getrrsetbyname.h\"",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define ANSWER_BUFFER_SIZE 0xffff"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_dns_response",
          "args": [
            "response"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "free_dns_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
          "lines": "583-594",
          "snippet": "static void\nfree_dns_response(struct dns_response *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tfree_dns_query(p->query);\n\tfree_dns_rr(p->answer);\n\tfree_dns_rr(p->authority);\n\tfree_dns_rr(p->additional);\n\tfree(p);\n}",
          "includes": [
            "#include \"getrrsetbyname.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic void\nfree_dns_response(struct dns_response *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tfree_dns_query(p->query);\n\tfree_dns_rr(p->answer);\n\tfree_dns_rr(p->authority);\n\tfree_dns_rr(p->additional);\n\tfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freerrset",
          "args": [
            "rrset"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "freerrset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
          "lines": "348-377",
          "snippet": "void\nfreerrset(struct rrsetinfo *rrset)\n{\n\tu_int16_t i;\n\n\tif (rrset == NULL)\n\t\treturn;\n\n\tif (rrset->rri_rdatas) {\n\t\tfor (i = 0; i < rrset->rri_nrdatas; i++) {\n\t\t\tif (rrset->rri_rdatas[i].rdi_data == NULL)\n\t\t\t\tbreak;\n\t\t\tfree(rrset->rri_rdatas[i].rdi_data);\n\t\t}\n\t\tfree(rrset->rri_rdatas);\n\t}\n\n\tif (rrset->rri_sigs) {\n\t\tfor (i = 0; i < rrset->rri_nsigs; i++) {\n\t\t\tif (rrset->rri_sigs[i].rdi_data == NULL)\n\t\t\t\tbreak;\n\t\t\tfree(rrset->rri_sigs[i].rdi_data);\n\t\t}\n\t\tfree(rrset->rri_sigs);\n\t}\n\n\tif (rrset->rri_name)\n\t\tfree(rrset->rri_name);\n\tfree(rrset);\n}",
          "includes": [
            "#include \"getrrsetbyname.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreerrset(struct rrsetinfo *rrset)\n{\n\tu_int16_t i;\n\n\tif (rrset == NULL)\n\t\treturn;\n\n\tif (rrset->rri_rdatas) {\n\t\tfor (i = 0; i < rrset->rri_nrdatas; i++) {\n\t\t\tif (rrset->rri_rdatas[i].rdi_data == NULL)\n\t\t\t\tbreak;\n\t\t\tfree(rrset->rri_rdatas[i].rdi_data);\n\t\t}\n\t\tfree(rrset->rri_rdatas);\n\t}\n\n\tif (rrset->rri_sigs) {\n\t\tfor (i = 0; i < rrset->rri_nsigs; i++) {\n\t\t\tif (rrset->rri_sigs[i].rdi_data == NULL)\n\t\t\t\tbreak;\n\t\t\tfree(rrset->rri_sigs[i].rdi_data);\n\t\t}\n\t\tfree(rrset->rri_sigs);\n\t}\n\n\tif (rrset->rri_name)\n\t\tfree(rrset->rri_name);\n\tfree(rrset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "rdata->rdi_data",
            "rr->rdata",
            "rr->size"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "rr->size"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "rpl_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-malloc.c",
          "lines": "26-32",
          "snippet": "void *\nrpl_malloc(size_t size)\n{\n\tif (size == 0)\n\t\tsize = 1;\n\treturn malloc(size);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nvoid *\nrpl_malloc(size_t size)\n{\n\tif (size == 0)\n\t\tsize = 1;\n\treturn malloc(size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "rrset->rri_nsigs",
            "sizeof(struct rdatainfo)"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "rpl_calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-malloc.c",
          "lines": "36-44",
          "snippet": "void *\nrpl_calloc(size_t nmemb, size_t size)\n{\n\tif (nmemb == 0)\n\t\tnmemb = 1;\n\tif (size == 0)\n\t\tsize = 1;\n\treturn calloc(nmemb, size);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nvoid *\nrpl_calloc(size_t nmemb, size_t size)\n{\n\tif (nmemb == 0)\n\t\tnmemb = 1;\n\tif (size == 0)\n\t\tsize = 1;\n\treturn calloc(nmemb, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_dns_rr",
          "args": [
            "response->answer",
            "rrset->rri_rdclass",
            "T_RRSIG"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "count_dns_rr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
          "lines": "596-608",
          "snippet": "static int\ncount_dns_rr(struct dns_rr *p, u_int16_t class, u_int16_t type)\n{\n\tint n = 0;\n\n\twhile(p) {\n\t\tif (p->class == class && p->type == type)\n\t\t\tn++;\n\t\tp = p->next;\n\t}\n\n\treturn (n);\n}",
          "includes": [
            "#include \"getrrsetbyname.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic int\ncount_dns_rr(struct dns_rr *p, u_int16_t class, u_int16_t type)\n{\n\tint n = 0;\n\n\twhile(p) {\n\t\tif (p->class == class && p->type == type)\n\t\t\tn++;\n\t\tp = p->next;\n\t}\n\n\treturn (n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "response->answer->name"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "216-227",
          "snippet": "char *\nstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = malloc(len);\n\tif (cp != NULL)\n\t\treturn(memcpy(cp, str, len));\n\treturn NULL;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = malloc(len);\n\tif (cp != NULL)\n\t\treturn(memcpy(cp, str, len));\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_dns_response",
          "args": [
            "answer",
            "length"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "parse_dns_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
          "lines": "382-445",
          "snippet": "static struct dns_response *\nparse_dns_response(const u_char *answer, int size)\n{\n\tstruct dns_response *resp;\n\tconst u_char *cp;\n\n\t/* allocate memory for the response */\n\tresp = calloc(1, sizeof(*resp));\n\tif (resp == NULL)\n\t\treturn (NULL);\n\n\t/* initialize current pointer */\n\tcp = answer;\n\n\t/* copy header */\n\tmemcpy(&resp->header, cp, HFIXEDSZ);\n\tcp += HFIXEDSZ;\n\n\t/* fix header byte order */\n\tresp->header.qdcount = ntohs(resp->header.qdcount);\n\tresp->header.ancount = ntohs(resp->header.ancount);\n\tresp->header.nscount = ntohs(resp->header.nscount);\n\tresp->header.arcount = ntohs(resp->header.arcount);\n\n\t/* there must be at least one query */\n\tif (resp->header.qdcount < 1) {\n\t\tfree_dns_response(resp);\n\t\treturn (NULL);\n\t}\n\n\t/* parse query section */\n\tresp->query = parse_dns_qsection(answer, size, &cp,\n\t    resp->header.qdcount);\n\tif (resp->header.qdcount && resp->query == NULL) {\n\t\tfree_dns_response(resp);\n\t\treturn (NULL);\n\t}\n\n\t/* parse answer section */\n\tresp->answer = parse_dns_rrsection(answer, size, &cp,\n\t    resp->header.ancount);\n\tif (resp->header.ancount && resp->answer == NULL) {\n\t\tfree_dns_response(resp);\n\t\treturn (NULL);\n\t}\n\n\t/* parse authority section */\n\tresp->authority = parse_dns_rrsection(answer, size, &cp,\n\t    resp->header.nscount);\n\tif (resp->header.nscount && resp->authority == NULL) {\n\t\tfree_dns_response(resp);\n\t\treturn (NULL);\n\t}\n\n\t/* parse additional section */\n\tresp->additional = parse_dns_rrsection(answer, size, &cp,\n\t    resp->header.arcount);\n\tif (resp->header.arcount && resp->additional == NULL) {\n\t\tfree_dns_response(resp);\n\t\treturn (NULL);\n\t}\n\n\treturn (resp);\n}",
          "includes": [
            "#include \"getrrsetbyname.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic struct dns_response *\nparse_dns_response(const u_char *answer, int size)\n{\n\tstruct dns_response *resp;\n\tconst u_char *cp;\n\n\t/* allocate memory for the response */\n\tresp = calloc(1, sizeof(*resp));\n\tif (resp == NULL)\n\t\treturn (NULL);\n\n\t/* initialize current pointer */\n\tcp = answer;\n\n\t/* copy header */\n\tmemcpy(&resp->header, cp, HFIXEDSZ);\n\tcp += HFIXEDSZ;\n\n\t/* fix header byte order */\n\tresp->header.qdcount = ntohs(resp->header.qdcount);\n\tresp->header.ancount = ntohs(resp->header.ancount);\n\tresp->header.nscount = ntohs(resp->header.nscount);\n\tresp->header.arcount = ntohs(resp->header.arcount);\n\n\t/* there must be at least one query */\n\tif (resp->header.qdcount < 1) {\n\t\tfree_dns_response(resp);\n\t\treturn (NULL);\n\t}\n\n\t/* parse query section */\n\tresp->query = parse_dns_qsection(answer, size, &cp,\n\t    resp->header.qdcount);\n\tif (resp->header.qdcount && resp->query == NULL) {\n\t\tfree_dns_response(resp);\n\t\treturn (NULL);\n\t}\n\n\t/* parse answer section */\n\tresp->answer = parse_dns_rrsection(answer, size, &cp,\n\t    resp->header.ancount);\n\tif (resp->header.ancount && resp->answer == NULL) {\n\t\tfree_dns_response(resp);\n\t\treturn (NULL);\n\t}\n\n\t/* parse authority section */\n\tresp->authority = parse_dns_rrsection(answer, size, &cp,\n\t    resp->header.nscount);\n\tif (resp->header.nscount && resp->authority == NULL) {\n\t\tfree_dns_response(resp);\n\t\treturn (NULL);\n\t}\n\n\t/* parse additional section */\n\tresp->additional = parse_dns_rrsection(answer, size, &cp,\n\t    resp->header.arcount);\n\tif (resp->header.arcount && resp->additional == NULL) {\n\t\tfree_dns_response(resp);\n\t\treturn (NULL);\n\t}\n\n\treturn (resp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "res_query",
          "args": [
            "hostname",
            "(signed int) rdclass",
            "(signed int) rdtype",
            "answer",
            "sizeof(answer)"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "res_init",
          "args": [],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_THREAD_PRIVATE",
          "args": [
            "_res",
            "_res",
            "&_res"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\n#define ANSWER_BUFFER_SIZE 0xffff\n\nint\ngetrrsetbyname(const char *hostname, unsigned int rdclass,\n    unsigned int rdtype, unsigned int flags,\n    struct rrsetinfo **res)\n{\n\tstruct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);\n\tint result;\n\tstruct rrsetinfo *rrset = NULL;\n\tstruct dns_response *response = NULL;\n\tstruct dns_rr *rr;\n\tstruct rdatainfo *rdata;\n\tint length;\n\tunsigned int index_ans, index_sig;\n\tu_char answer[ANSWER_BUFFER_SIZE];\n\n\t/* check for invalid class and type */\n\tif (rdclass > 0xffff || rdtype > 0xffff) {\n\t\tresult = ERRSET_INVAL;\n\t\tgoto fail;\n\t}\n\n\t/* don't allow queries of class or type ANY */\n\tif (rdclass == 0xff || rdtype == 0xff) {\n\t\tresult = ERRSET_INVAL;\n\t\tgoto fail;\n\t}\n\n\t/* don't allow flags yet, unimplemented */\n\tif (flags) {\n\t\tresult = ERRSET_INVAL;\n\t\tgoto fail;\n\t}\n\n\t/* initialize resolver */\n\tif ((_resp->options & RES_INIT) == 0 && res_init() == -1) {\n\t\tresult = ERRSET_FAIL;\n\t\tgoto fail;\n\t}\n\n#ifdef DEBUG\n\t_resp->options |= RES_DEBUG;\n#endif /* DEBUG */\n\n#ifdef RES_USE_DNSSEC\n\t/* turn on DNSSEC if EDNS0 is configured */\n\tif (_resp->options & RES_USE_EDNS0)\n\t\t_resp->options |= RES_USE_DNSSEC;\n#endif /* RES_USE_DNSEC */\n\n\t/* make query */\n\tlength = res_query(hostname, (signed int) rdclass, (signed int) rdtype,\n\t    answer, sizeof(answer));\n\tif (length < 0) {\n\t\tswitch(h_errno) {\n\t\tcase HOST_NOT_FOUND:\n\t\t\tresult = ERRSET_NONAME;\n\t\t\tgoto fail;\n\t\tcase NO_DATA:\n\t\t\tresult = ERRSET_NODATA;\n\t\t\tgoto fail;\n\t\tdefault:\n\t\t\tresult = ERRSET_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* parse result */\n\tresponse = parse_dns_response(answer, length);\n\tif (response == NULL) {\n\t\tresult = ERRSET_FAIL;\n\t\tgoto fail;\n\t}\n\n\tif (response->header.qdcount != 1) {\n\t\tresult = ERRSET_FAIL;\n\t\tgoto fail;\n\t}\n\n\t/* initialize rrset */\n\trrset = calloc(1, sizeof(struct rrsetinfo));\n\tif (rrset == NULL) {\n\t\tresult = ERRSET_NOMEMORY;\n\t\tgoto fail;\n\t}\n\trrset->rri_rdclass = response->query->class;\n\trrset->rri_rdtype = response->query->type;\n\trrset->rri_ttl = response->answer->ttl;\n\trrset->rri_nrdatas = response->header.ancount;\n\n#ifdef HAVE_HEADER_AD\n\t/* check for authenticated data */\n\tif (response->header.ad == 1)\n\t\trrset->rri_flags |= RRSET_VALIDATED;\n#endif\n\n\t/* copy name from answer section */\n\trrset->rri_name = strdup(response->answer->name);\n\tif (rrset->rri_name == NULL) {\n\t\tresult = ERRSET_NOMEMORY;\n\t\tgoto fail;\n\t}\n\n\t/* count answers */\n\trrset->rri_nrdatas = count_dns_rr(response->answer, rrset->rri_rdclass,\n\t    rrset->rri_rdtype);\n\trrset->rri_nsigs = count_dns_rr(response->answer, rrset->rri_rdclass,\n\t    T_RRSIG);\n\n\t/* allocate memory for answers */\n\trrset->rri_rdatas = calloc(rrset->rri_nrdatas,\n\t    sizeof(struct rdatainfo));\n\tif (rrset->rri_rdatas == NULL) {\n\t\tresult = ERRSET_NOMEMORY;\n\t\tgoto fail;\n\t}\n\n\t/* allocate memory for signatures */\n\tif (rrset->rri_nsigs > 0) {\n\t\trrset->rri_sigs = calloc(rrset->rri_nsigs, sizeof(struct rdatainfo));\n\t\tif (rrset->rri_sigs == NULL) {\n\t\t\tresult = ERRSET_NOMEMORY;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* copy answers & signatures */\n\tfor (rr = response->answer, index_ans = 0, index_sig = 0;\n\t    rr; rr = rr->next) {\n\n\t\trdata = NULL;\n\n\t\tif (rr->class == rrset->rri_rdclass &&\n\t\t    rr->type  == rrset->rri_rdtype)\n\t\t\trdata = &rrset->rri_rdatas[index_ans++];\n\n\t\tif (rr->class == rrset->rri_rdclass &&\n\t\t    rr->type  == T_RRSIG)\n\t\t\trdata = &rrset->rri_sigs[index_sig++];\n\n\t\tif (rdata) {\n\t\t\trdata->rdi_length = rr->size;\n\t\t\trdata->rdi_data   = malloc(rr->size);\n\n\t\t\tif (rdata->rdi_data == NULL) {\n\t\t\t\tresult = ERRSET_NOMEMORY;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tmemcpy(rdata->rdi_data, rr->rdata, rr->size);\n\t\t}\n\t}\n\tfree_dns_response(response);\n\n\t*res = rrset;\n\treturn (ERRSET_SUCCESS);\n\nfail:\n\tif (rrset != NULL)\n\t\tfreerrset(rrset);\n\tif (response != NULL)\n\t\tfree_dns_response(response);\n\treturn (result);\n}"
  },
  {
    "function_name": "_getlong",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
    "lines": "131-139",
    "snippet": "static u_int32_t\n_getlong(msgp)\n\tregister const u_char *msgp;\n{\n\tregister u_int32_t u;\n\n\tGETLONG(u, msgp);\n\treturn (u);\n}",
    "includes": [
      "#include \"getrrsetbyname.h\"",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GETLONG",
          "args": [
            "u",
            "msgp"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic u_int32_t\n_getlong(msgp)\n\tregister const u_char *msgp;\n{\n\tregister u_int32_t u;\n\n\tGETLONG(u, msgp);\n\treturn (u);\n}"
  },
  {
    "function_name": "_getshort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getrrsetbyname.c",
    "lines": "117-125",
    "snippet": "static u_int16_t\n_getshort(msgp)\n\tregister const u_char *msgp;\n{\n\tregister u_int16_t u;\n\n\tGETSHORT(u, msgp);\n\treturn (u);\n}",
    "includes": [
      "#include \"getrrsetbyname.h\"",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GETSHORT",
          "args": [
            "u",
            "msgp"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"getrrsetbyname.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nstatic u_int16_t\n_getshort(msgp)\n\tregister const u_char *msgp;\n{\n\tregister u_int16_t u;\n\n\tGETSHORT(u, msgp);\n\treturn (u);\n}"
  }
]