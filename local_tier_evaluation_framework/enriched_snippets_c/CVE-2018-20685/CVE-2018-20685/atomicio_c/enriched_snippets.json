[
  {
    "function_name": "atomiciov",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
    "lines": "165-170",
    "snippet": "size_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}",
    "includes": [
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <sys/param.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomiciov6",
          "args": [
            "f",
            "fd",
            "_iov",
            "iovcnt",
            "NULL",
            "NULL"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "atomiciov6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "100-163",
          "snippet": "size_t\natomiciov6(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt,\n    int (*cb)(void *, size_t), void *cb_arg)\n{\n\tsize_t pos = 0, rem;\n\tssize_t res;\n\tstruct iovec iov_array[IOV_MAX], *iov = iov_array;\n\tstruct pollfd pfd;\n\n\tif (iovcnt < 0 || iovcnt > IOV_MAX) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\t/* Make a copy of the iov array because we may modify it below */\n\tmemcpy(iov, _iov, (size_t)iovcnt * sizeof(*_iov));\n\n#ifndef BROKEN_READV_COMPARISON\n\tpfd.fd = fd;\n\tpfd.events = f == readv ? POLLIN : POLLOUT;\n#endif\n\tfor (; iovcnt > 0 && iov[0].iov_len > 0;) {\n\t\tres = (f) (fd, iov, iovcnt);\n\t\tswitch (res) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tif (errno == EAGAIN || errno == EWOULDBLOCK) {\n#ifndef BROKEN_READV_COMPARISON\n\t\t\t\t(void)poll(&pfd, 1, -1);\n#endif\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase 0:\n\t\t\terrno = EPIPE;\n\t\t\treturn pos;\n\t\tdefault:\n\t\t\trem = (size_t)res;\n\t\t\tpos += rem;\n\t\t\t/* skip completed iov entries */\n\t\t\twhile (iovcnt > 0 && rem >= iov[0].iov_len) {\n\t\t\t\trem -= iov[0].iov_len;\n\t\t\t\tiov++;\n\t\t\t\tiovcnt--;\n\t\t\t}\n\t\t\t/* This shouldn't happen... */\n\t\t\tif (rem > 0 && (iovcnt <= 0 || rem > iov[0].iov_len)) {\n\t\t\t\terrno = EFAULT;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (iovcnt == 0)\n\t\t\t\tbreak;\n\t\t\t/* update pointer in partially complete iov */\n\t\t\tiov[0].iov_base = ((char *)iov[0].iov_base) + rem;\n\t\t\tiov[0].iov_len -= rem;\n\t\t}\n\t\tif (cb != NULL && cb(cb_arg, (size_t)res) == -1) {\n\t\t\terrno = EINTR;\n\t\t\treturn pos;\n\t\t}\n\t}\n\treturn pos;\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomiciov6(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt,\n    int (*cb)(void *, size_t), void *cb_arg)\n{\n\tsize_t pos = 0, rem;\n\tssize_t res;\n\tstruct iovec iov_array[IOV_MAX], *iov = iov_array;\n\tstruct pollfd pfd;\n\n\tif (iovcnt < 0 || iovcnt > IOV_MAX) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\t/* Make a copy of the iov array because we may modify it below */\n\tmemcpy(iov, _iov, (size_t)iovcnt * sizeof(*_iov));\n\n#ifndef BROKEN_READV_COMPARISON\n\tpfd.fd = fd;\n\tpfd.events = f == readv ? POLLIN : POLLOUT;\n#endif\n\tfor (; iovcnt > 0 && iov[0].iov_len > 0;) {\n\t\tres = (f) (fd, iov, iovcnt);\n\t\tswitch (res) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tif (errno == EAGAIN || errno == EWOULDBLOCK) {\n#ifndef BROKEN_READV_COMPARISON\n\t\t\t\t(void)poll(&pfd, 1, -1);\n#endif\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase 0:\n\t\t\terrno = EPIPE;\n\t\t\treturn pos;\n\t\tdefault:\n\t\t\trem = (size_t)res;\n\t\t\tpos += rem;\n\t\t\t/* skip completed iov entries */\n\t\t\twhile (iovcnt > 0 && rem >= iov[0].iov_len) {\n\t\t\t\trem -= iov[0].iov_len;\n\t\t\t\tiov++;\n\t\t\t\tiovcnt--;\n\t\t\t}\n\t\t\t/* This shouldn't happen... */\n\t\t\tif (rem > 0 && (iovcnt <= 0 || rem > iov[0].iov_len)) {\n\t\t\t\terrno = EFAULT;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (iovcnt == 0)\n\t\t\t\tbreak;\n\t\t\t/* update pointer in partially complete iov */\n\t\t\tiov[0].iov_base = ((char *)iov[0].iov_base) + rem;\n\t\t\tiov[0].iov_len -= rem;\n\t\t}\n\t\tif (cb != NULL && cb(cb_arg, (size_t)res) == -1) {\n\t\t\terrno = EINTR;\n\t\t\treturn pos;\n\t\t}\n\t}\n\treturn pos;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}"
  },
  {
    "function_name": "atomiciov6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
    "lines": "100-163",
    "snippet": "size_t\natomiciov6(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt,\n    int (*cb)(void *, size_t), void *cb_arg)\n{\n\tsize_t pos = 0, rem;\n\tssize_t res;\n\tstruct iovec iov_array[IOV_MAX], *iov = iov_array;\n\tstruct pollfd pfd;\n\n\tif (iovcnt < 0 || iovcnt > IOV_MAX) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\t/* Make a copy of the iov array because we may modify it below */\n\tmemcpy(iov, _iov, (size_t)iovcnt * sizeof(*_iov));\n\n#ifndef BROKEN_READV_COMPARISON\n\tpfd.fd = fd;\n\tpfd.events = f == readv ? POLLIN : POLLOUT;\n#endif\n\tfor (; iovcnt > 0 && iov[0].iov_len > 0;) {\n\t\tres = (f) (fd, iov, iovcnt);\n\t\tswitch (res) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tif (errno == EAGAIN || errno == EWOULDBLOCK) {\n#ifndef BROKEN_READV_COMPARISON\n\t\t\t\t(void)poll(&pfd, 1, -1);\n#endif\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase 0:\n\t\t\terrno = EPIPE;\n\t\t\treturn pos;\n\t\tdefault:\n\t\t\trem = (size_t)res;\n\t\t\tpos += rem;\n\t\t\t/* skip completed iov entries */\n\t\t\twhile (iovcnt > 0 && rem >= iov[0].iov_len) {\n\t\t\t\trem -= iov[0].iov_len;\n\t\t\t\tiov++;\n\t\t\t\tiovcnt--;\n\t\t\t}\n\t\t\t/* This shouldn't happen... */\n\t\t\tif (rem > 0 && (iovcnt <= 0 || rem > iov[0].iov_len)) {\n\t\t\t\terrno = EFAULT;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (iovcnt == 0)\n\t\t\t\tbreak;\n\t\t\t/* update pointer in partially complete iov */\n\t\t\tiov[0].iov_base = ((char *)iov[0].iov_base) + rem;\n\t\t\tiov[0].iov_len -= rem;\n\t\t}\n\t\tif (cb != NULL && cb(cb_arg, (size_t)res) == -1) {\n\t\t\terrno = EINTR;\n\t\t\treturn pos;\n\t\t}\n\t}\n\treturn pos;\n}",
    "includes": [
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <sys/param.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cb",
          "args": [
            "cb_arg",
            "(size_t)res"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "mux_master_read_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1149-1226",
          "snippet": "static int\nmux_master_read_cb(struct ssh *ssh, Channel *c)\n{\n\tstruct mux_master_state *state = (struct mux_master_state *)c->mux_ctx;\n\tstruct sshbuf *in = NULL, *out = NULL;\n\tu_int type, rid, i;\n\tint r, ret = -1;\n\n\tif ((out = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\t/* Setup ctx and  */\n\tif (c->mux_ctx == NULL) {\n\t\tstate = xcalloc(1, sizeof(*state));\n\t\tc->mux_ctx = state;\n\t\tchannel_register_cleanup(ssh, c->self,\n\t\t    mux_master_control_cleanup_cb, 0);\n\n\t\t/* Send hello */\n\t\tif ((r = sshbuf_put_u32(out, MUX_MSG_HELLO)) != 0 ||\n\t\t    (r = sshbuf_put_u32(out, SSHMUX_VER)) != 0)\n\t\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n\t\t/* no extensions */\n\t\tif ((r = sshbuf_put_stringb(c->output, out)) != 0)\n\t\t\tfatal(\"%s: sshbuf_put_stringb: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\tdebug3(\"%s: channel %d: hello sent\", __func__, c->self);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Channel code ensures that we receive whole packets */\n\tif ((r = sshbuf_froms(c->input, &in)) != 0) {\n malf:\n\t\terror(\"%s: malformed message\", __func__);\n\t\tgoto out;\n\t}\n\n\tif ((r = sshbuf_get_u32(in, &type)) != 0)\n\t\tgoto malf;\n\tdebug3(\"%s: channel %d packet type 0x%08x len %zu\",\n\t    __func__, c->self, type, sshbuf_len(in));\n\n\tif (type == MUX_MSG_HELLO)\n\t\trid = 0;\n\telse {\n\t\tif (!state->hello_rcvd) {\n\t\t\terror(\"%s: expected MUX_MSG_HELLO(0x%08x), \"\n\t\t\t    \"received 0x%08x\", __func__, MUX_MSG_HELLO, type);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_u32(in, &rid)) != 0)\n\t\t\tgoto malf;\n\t}\n\n\tfor (i = 0; mux_master_handlers[i].handler != NULL; i++) {\n\t\tif (type == mux_master_handlers[i].type) {\n\t\t\tret = mux_master_handlers[i].handler(ssh, rid,\n\t\t\t    c, in, out);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mux_master_handlers[i].handler == NULL) {\n\t\terror(\"%s: unsupported mux message 0x%08x\", __func__, type);\n\t\treply_error(out, MUX_S_FAILURE, rid, \"unsupported request\");\n\t\tret = 0;\n\t}\n\t/* Enqueue reply packet */\n\tif (sshbuf_len(out) != 0) {\n\t\tif ((r = sshbuf_put_stringb(c->output, out)) != 0)\n\t\t\tfatal(\"%s: sshbuf_put_stringb: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t}\n out:\n\tsshbuf_free(in);\n\tsshbuf_free(out);\n\treturn ret;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MUX_S_FAILURE\t\t0x80000003",
            "#define MUX_MSG_HELLO\t\t0x00000001"
          ],
          "globals_used": [
            "static void mux_session_confirm(struct ssh *, int, int, void *);",
            "static void mux_stdio_confirm(struct ssh *, int, int, void *);",
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static const struct {\n\tu_int type;\n\tint (*handler)(struct ssh *, u_int, Channel *,\n\t    struct sshbuf *, struct sshbuf *);\n} mux_master_handlers[] = {\n\t{ MUX_MSG_HELLO, mux_master_process_hello },\n\t{ MUX_C_NEW_SESSION, mux_master_process_new_session },\n\t{ MUX_C_ALIVE_CHECK, mux_master_process_alive_check },\n\t{ MUX_C_TERMINATE, mux_master_process_terminate },\n\t{ MUX_C_OPEN_FWD, mux_master_process_open_fwd },\n\t{ MUX_C_CLOSE_FWD, mux_master_process_close_fwd },\n\t{ MUX_C_NEW_STDIO_FWD, mux_master_process_stdio_fwd },\n\t{ MUX_C_STOP_LISTENING, mux_master_process_stop_listening },\n\t{ MUX_C_PROXY, mux_master_process_proxy },\n\t{ 0, NULL }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_FAILURE\t\t0x80000003\n#define MUX_MSG_HELLO\t\t0x00000001\n\nstatic void mux_session_confirm(struct ssh *, int, int, void *);\nstatic void mux_stdio_confirm(struct ssh *, int, int, void *);\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic const struct {\n\tu_int type;\n\tint (*handler)(struct ssh *, u_int, Channel *,\n\t    struct sshbuf *, struct sshbuf *);\n} mux_master_handlers[] = {\n\t{ MUX_MSG_HELLO, mux_master_process_hello },\n\t{ MUX_C_NEW_SESSION, mux_master_process_new_session },\n\t{ MUX_C_ALIVE_CHECK, mux_master_process_alive_check },\n\t{ MUX_C_TERMINATE, mux_master_process_terminate },\n\t{ MUX_C_OPEN_FWD, mux_master_process_open_fwd },\n\t{ MUX_C_CLOSE_FWD, mux_master_process_close_fwd },\n\t{ MUX_C_NEW_STDIO_FWD, mux_master_process_stdio_fwd },\n\t{ MUX_C_STOP_LISTENING, mux_master_process_stop_listening },\n\t{ MUX_C_PROXY, mux_master_process_proxy },\n\t{ 0, NULL }\n};\n\nstatic int\nmux_master_read_cb(struct ssh *ssh, Channel *c)\n{\n\tstruct mux_master_state *state = (struct mux_master_state *)c->mux_ctx;\n\tstruct sshbuf *in = NULL, *out = NULL;\n\tu_int type, rid, i;\n\tint r, ret = -1;\n\n\tif ((out = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\t/* Setup ctx and  */\n\tif (c->mux_ctx == NULL) {\n\t\tstate = xcalloc(1, sizeof(*state));\n\t\tc->mux_ctx = state;\n\t\tchannel_register_cleanup(ssh, c->self,\n\t\t    mux_master_control_cleanup_cb, 0);\n\n\t\t/* Send hello */\n\t\tif ((r = sshbuf_put_u32(out, MUX_MSG_HELLO)) != 0 ||\n\t\t    (r = sshbuf_put_u32(out, SSHMUX_VER)) != 0)\n\t\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n\t\t/* no extensions */\n\t\tif ((r = sshbuf_put_stringb(c->output, out)) != 0)\n\t\t\tfatal(\"%s: sshbuf_put_stringb: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\tdebug3(\"%s: channel %d: hello sent\", __func__, c->self);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Channel code ensures that we receive whole packets */\n\tif ((r = sshbuf_froms(c->input, &in)) != 0) {\n malf:\n\t\terror(\"%s: malformed message\", __func__);\n\t\tgoto out;\n\t}\n\n\tif ((r = sshbuf_get_u32(in, &type)) != 0)\n\t\tgoto malf;\n\tdebug3(\"%s: channel %d packet type 0x%08x len %zu\",\n\t    __func__, c->self, type, sshbuf_len(in));\n\n\tif (type == MUX_MSG_HELLO)\n\t\trid = 0;\n\telse {\n\t\tif (!state->hello_rcvd) {\n\t\t\terror(\"%s: expected MUX_MSG_HELLO(0x%08x), \"\n\t\t\t    \"received 0x%08x\", __func__, MUX_MSG_HELLO, type);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_u32(in, &rid)) != 0)\n\t\t\tgoto malf;\n\t}\n\n\tfor (i = 0; mux_master_handlers[i].handler != NULL; i++) {\n\t\tif (type == mux_master_handlers[i].type) {\n\t\t\tret = mux_master_handlers[i].handler(ssh, rid,\n\t\t\t    c, in, out);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mux_master_handlers[i].handler == NULL) {\n\t\terror(\"%s: unsupported mux message 0x%08x\", __func__, type);\n\t\treply_error(out, MUX_S_FAILURE, rid, \"unsupported request\");\n\t\tret = 0;\n\t}\n\t/* Enqueue reply packet */\n\tif (sshbuf_len(out) != 0) {\n\t\tif ((r = sshbuf_put_stringb(c->output, out)) != 0)\n\t\t\tfatal(\"%s: sshbuf_put_stringb: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t}\n out:\n\tsshbuf_free(in);\n\tsshbuf_free(out);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll",
          "args": [
            "&pfd",
            "1",
            "-1"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "after_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "888-941",
          "snippet": "static void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t/* Find sockets entry */\n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror(\"%s: no socket for fd %d\", __func__, pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Process events */\n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0) {\n\t\t\t\tgoto close_sock;\n\t\t\t}\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int sockets_alloc = 0;",
            "SocketEntry *sockets = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int sockets_alloc = 0;\nSocketEntry *sockets = NULL;\n\nstatic void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t/* Find sockets entry */\n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror(\"%s: no socket for fd %d\", __func__, pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Process events */\n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0) {\n\t\t\t\tgoto close_sock;\n\t\t\t}\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "fd",
            "iov",
            "iovcnt"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "iov",
            "_iov",
            "(size_t)iovcnt * sizeof(*_iov)"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomiciov6(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt,\n    int (*cb)(void *, size_t), void *cb_arg)\n{\n\tsize_t pos = 0, rem;\n\tssize_t res;\n\tstruct iovec iov_array[IOV_MAX], *iov = iov_array;\n\tstruct pollfd pfd;\n\n\tif (iovcnt < 0 || iovcnt > IOV_MAX) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\t/* Make a copy of the iov array because we may modify it below */\n\tmemcpy(iov, _iov, (size_t)iovcnt * sizeof(*_iov));\n\n#ifndef BROKEN_READV_COMPARISON\n\tpfd.fd = fd;\n\tpfd.events = f == readv ? POLLIN : POLLOUT;\n#endif\n\tfor (; iovcnt > 0 && iov[0].iov_len > 0;) {\n\t\tres = (f) (fd, iov, iovcnt);\n\t\tswitch (res) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tif (errno == EAGAIN || errno == EWOULDBLOCK) {\n#ifndef BROKEN_READV_COMPARISON\n\t\t\t\t(void)poll(&pfd, 1, -1);\n#endif\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase 0:\n\t\t\terrno = EPIPE;\n\t\t\treturn pos;\n\t\tdefault:\n\t\t\trem = (size_t)res;\n\t\t\tpos += rem;\n\t\t\t/* skip completed iov entries */\n\t\t\twhile (iovcnt > 0 && rem >= iov[0].iov_len) {\n\t\t\t\trem -= iov[0].iov_len;\n\t\t\t\tiov++;\n\t\t\t\tiovcnt--;\n\t\t\t}\n\t\t\t/* This shouldn't happen... */\n\t\t\tif (rem > 0 && (iovcnt <= 0 || rem > iov[0].iov_len)) {\n\t\t\t\terrno = EFAULT;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (iovcnt == 0)\n\t\t\t\tbreak;\n\t\t\t/* update pointer in partially complete iov */\n\t\t\tiov[0].iov_base = ((char *)iov[0].iov_base) + rem;\n\t\t\tiov[0].iov_len -= rem;\n\t\t}\n\t\tif (cb != NULL && cb(cb_arg, (size_t)res) == -1) {\n\t\t\terrno = EINTR;\n\t\t\treturn pos;\n\t\t}\n\t}\n\treturn pos;\n}"
  },
  {
    "function_name": "atomicio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
    "lines": "91-95",
    "snippet": "size_t\natomicio(ssize_t (*f) (int, void *, size_t), int fd, void *_s, size_t n)\n{\n\treturn atomicio6(f, fd, _s, n, NULL, NULL);\n}",
    "includes": [
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <sys/param.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomicio6",
          "args": [
            "f",
            "fd",
            "_s",
            "n",
            "NULL",
            "NULL"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "atomicio6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "51-89",
          "snippet": "size_t\natomicio6(ssize_t (*f) (int, void *, size_t), int fd, void *_s, size_t n,\n    int (*cb)(void *, size_t), void *cb_arg)\n{\n\tchar *s = _s;\n\tsize_t pos = 0;\n\tssize_t res;\n\tstruct pollfd pfd;\n\n#ifndef BROKEN_READ_COMPARISON\n\tpfd.fd = fd;\n\tpfd.events = f == read ? POLLIN : POLLOUT;\n#endif\n\twhile (n > pos) {\n\t\tres = (f) (fd, s + pos, n - pos);\n\t\tswitch (res) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tif (errno == EAGAIN || errno == EWOULDBLOCK) {\n#ifndef BROKEN_READ_COMPARISON\n\t\t\t\t(void)poll(&pfd, 1, -1);\n#endif\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase 0:\n\t\t\terrno = EPIPE;\n\t\t\treturn pos;\n\t\tdefault:\n\t\t\tpos += (size_t)res;\n\t\t\tif (cb != NULL && cb(cb_arg, (size_t)res) == -1) {\n\t\t\t\terrno = EINTR;\n\t\t\t\treturn pos;\n\t\t\t}\n\t\t}\n\t}\n\treturn pos;\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomicio6(ssize_t (*f) (int, void *, size_t), int fd, void *_s, size_t n,\n    int (*cb)(void *, size_t), void *cb_arg)\n{\n\tchar *s = _s;\n\tsize_t pos = 0;\n\tssize_t res;\n\tstruct pollfd pfd;\n\n#ifndef BROKEN_READ_COMPARISON\n\tpfd.fd = fd;\n\tpfd.events = f == read ? POLLIN : POLLOUT;\n#endif\n\twhile (n > pos) {\n\t\tres = (f) (fd, s + pos, n - pos);\n\t\tswitch (res) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tif (errno == EAGAIN || errno == EWOULDBLOCK) {\n#ifndef BROKEN_READ_COMPARISON\n\t\t\t\t(void)poll(&pfd, 1, -1);\n#endif\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase 0:\n\t\t\terrno = EPIPE;\n\t\t\treturn pos;\n\t\tdefault:\n\t\t\tpos += (size_t)res;\n\t\t\tif (cb != NULL && cb(cb_arg, (size_t)res) == -1) {\n\t\t\t\terrno = EINTR;\n\t\t\t\treturn pos;\n\t\t\t}\n\t\t}\n\t}\n\treturn pos;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomicio(ssize_t (*f) (int, void *, size_t), int fd, void *_s, size_t n)\n{\n\treturn atomicio6(f, fd, _s, n, NULL, NULL);\n}"
  },
  {
    "function_name": "atomicio6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
    "lines": "51-89",
    "snippet": "size_t\natomicio6(ssize_t (*f) (int, void *, size_t), int fd, void *_s, size_t n,\n    int (*cb)(void *, size_t), void *cb_arg)\n{\n\tchar *s = _s;\n\tsize_t pos = 0;\n\tssize_t res;\n\tstruct pollfd pfd;\n\n#ifndef BROKEN_READ_COMPARISON\n\tpfd.fd = fd;\n\tpfd.events = f == read ? POLLIN : POLLOUT;\n#endif\n\twhile (n > pos) {\n\t\tres = (f) (fd, s + pos, n - pos);\n\t\tswitch (res) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tif (errno == EAGAIN || errno == EWOULDBLOCK) {\n#ifndef BROKEN_READ_COMPARISON\n\t\t\t\t(void)poll(&pfd, 1, -1);\n#endif\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase 0:\n\t\t\terrno = EPIPE;\n\t\t\treturn pos;\n\t\tdefault:\n\t\t\tpos += (size_t)res;\n\t\t\tif (cb != NULL && cb(cb_arg, (size_t)res) == -1) {\n\t\t\t\terrno = EINTR;\n\t\t\t\treturn pos;\n\t\t\t}\n\t\t}\n\t}\n\treturn pos;\n}",
    "includes": [
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <sys/param.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cb",
          "args": [
            "cb_arg",
            "(size_t)res"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "mux_master_read_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/mux.c",
          "lines": "1149-1226",
          "snippet": "static int\nmux_master_read_cb(struct ssh *ssh, Channel *c)\n{\n\tstruct mux_master_state *state = (struct mux_master_state *)c->mux_ctx;\n\tstruct sshbuf *in = NULL, *out = NULL;\n\tu_int type, rid, i;\n\tint r, ret = -1;\n\n\tif ((out = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\t/* Setup ctx and  */\n\tif (c->mux_ctx == NULL) {\n\t\tstate = xcalloc(1, sizeof(*state));\n\t\tc->mux_ctx = state;\n\t\tchannel_register_cleanup(ssh, c->self,\n\t\t    mux_master_control_cleanup_cb, 0);\n\n\t\t/* Send hello */\n\t\tif ((r = sshbuf_put_u32(out, MUX_MSG_HELLO)) != 0 ||\n\t\t    (r = sshbuf_put_u32(out, SSHMUX_VER)) != 0)\n\t\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n\t\t/* no extensions */\n\t\tif ((r = sshbuf_put_stringb(c->output, out)) != 0)\n\t\t\tfatal(\"%s: sshbuf_put_stringb: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\tdebug3(\"%s: channel %d: hello sent\", __func__, c->self);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Channel code ensures that we receive whole packets */\n\tif ((r = sshbuf_froms(c->input, &in)) != 0) {\n malf:\n\t\terror(\"%s: malformed message\", __func__);\n\t\tgoto out;\n\t}\n\n\tif ((r = sshbuf_get_u32(in, &type)) != 0)\n\t\tgoto malf;\n\tdebug3(\"%s: channel %d packet type 0x%08x len %zu\",\n\t    __func__, c->self, type, sshbuf_len(in));\n\n\tif (type == MUX_MSG_HELLO)\n\t\trid = 0;\n\telse {\n\t\tif (!state->hello_rcvd) {\n\t\t\terror(\"%s: expected MUX_MSG_HELLO(0x%08x), \"\n\t\t\t    \"received 0x%08x\", __func__, MUX_MSG_HELLO, type);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_u32(in, &rid)) != 0)\n\t\t\tgoto malf;\n\t}\n\n\tfor (i = 0; mux_master_handlers[i].handler != NULL; i++) {\n\t\tif (type == mux_master_handlers[i].type) {\n\t\t\tret = mux_master_handlers[i].handler(ssh, rid,\n\t\t\t    c, in, out);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mux_master_handlers[i].handler == NULL) {\n\t\terror(\"%s: unsupported mux message 0x%08x\", __func__, type);\n\t\treply_error(out, MUX_S_FAILURE, rid, \"unsupported request\");\n\t\tret = 0;\n\t}\n\t/* Enqueue reply packet */\n\tif (sshbuf_len(out) != 0) {\n\t\tif ((r = sshbuf_put_stringb(c->output, out)) != 0)\n\t\t\tfatal(\"%s: sshbuf_put_stringb: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t}\n out:\n\tsshbuf_free(in);\n\tsshbuf_free(out);\n\treturn ret;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"clientloop.h\"",
            "#include \"readconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshpty.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"packet.h\"",
            "#include \"msg.h\"",
            "#include \"channels.h\"",
            "#include \"sshbuf.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"pathnames.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <util.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <paths.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MUX_S_FAILURE\t\t0x80000003",
            "#define MUX_MSG_HELLO\t\t0x00000001"
          ],
          "globals_used": [
            "static void mux_session_confirm(struct ssh *, int, int, void *);",
            "static void mux_stdio_confirm(struct ssh *, int, int, void *);",
            "static int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);",
            "static const struct {\n\tu_int type;\n\tint (*handler)(struct ssh *, u_int, Channel *,\n\t    struct sshbuf *, struct sshbuf *);\n} mux_master_handlers[] = {\n\t{ MUX_MSG_HELLO, mux_master_process_hello },\n\t{ MUX_C_NEW_SESSION, mux_master_process_new_session },\n\t{ MUX_C_ALIVE_CHECK, mux_master_process_alive_check },\n\t{ MUX_C_TERMINATE, mux_master_process_terminate },\n\t{ MUX_C_OPEN_FWD, mux_master_process_open_fwd },\n\t{ MUX_C_CLOSE_FWD, mux_master_process_close_fwd },\n\t{ MUX_C_NEW_STDIO_FWD, mux_master_process_stdio_fwd },\n\t{ MUX_C_STOP_LISTENING, mux_master_process_stop_listening },\n\t{ MUX_C_PROXY, mux_master_process_proxy },\n\t{ 0, NULL }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"clientloop.h\"\n#include \"readconf.h\"\n#include \"sshkey.h\"\n#include \"sshpty.h\"\n#include \"monitor_fdpass.h\"\n#include \"packet.h\"\n#include \"msg.h\"\n#include \"channels.h\"\n#include \"sshbuf.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n# include <util.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <paths.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MUX_S_FAILURE\t\t0x80000003\n#define MUX_MSG_HELLO\t\t0x00000001\n\nstatic void mux_session_confirm(struct ssh *, int, int, void *);\nstatic void mux_stdio_confirm(struct ssh *, int, int, void *);\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic const struct {\n\tu_int type;\n\tint (*handler)(struct ssh *, u_int, Channel *,\n\t    struct sshbuf *, struct sshbuf *);\n} mux_master_handlers[] = {\n\t{ MUX_MSG_HELLO, mux_master_process_hello },\n\t{ MUX_C_NEW_SESSION, mux_master_process_new_session },\n\t{ MUX_C_ALIVE_CHECK, mux_master_process_alive_check },\n\t{ MUX_C_TERMINATE, mux_master_process_terminate },\n\t{ MUX_C_OPEN_FWD, mux_master_process_open_fwd },\n\t{ MUX_C_CLOSE_FWD, mux_master_process_close_fwd },\n\t{ MUX_C_NEW_STDIO_FWD, mux_master_process_stdio_fwd },\n\t{ MUX_C_STOP_LISTENING, mux_master_process_stop_listening },\n\t{ MUX_C_PROXY, mux_master_process_proxy },\n\t{ 0, NULL }\n};\n\nstatic int\nmux_master_read_cb(struct ssh *ssh, Channel *c)\n{\n\tstruct mux_master_state *state = (struct mux_master_state *)c->mux_ctx;\n\tstruct sshbuf *in = NULL, *out = NULL;\n\tu_int type, rid, i;\n\tint r, ret = -1;\n\n\tif ((out = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\t/* Setup ctx and  */\n\tif (c->mux_ctx == NULL) {\n\t\tstate = xcalloc(1, sizeof(*state));\n\t\tc->mux_ctx = state;\n\t\tchannel_register_cleanup(ssh, c->self,\n\t\t    mux_master_control_cleanup_cb, 0);\n\n\t\t/* Send hello */\n\t\tif ((r = sshbuf_put_u32(out, MUX_MSG_HELLO)) != 0 ||\n\t\t    (r = sshbuf_put_u32(out, SSHMUX_VER)) != 0)\n\t\t\tfatal(\"%s: reply: %s\", __func__, ssh_err(r));\n\t\t/* no extensions */\n\t\tif ((r = sshbuf_put_stringb(c->output, out)) != 0)\n\t\t\tfatal(\"%s: sshbuf_put_stringb: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\tdebug3(\"%s: channel %d: hello sent\", __func__, c->self);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Channel code ensures that we receive whole packets */\n\tif ((r = sshbuf_froms(c->input, &in)) != 0) {\n malf:\n\t\terror(\"%s: malformed message\", __func__);\n\t\tgoto out;\n\t}\n\n\tif ((r = sshbuf_get_u32(in, &type)) != 0)\n\t\tgoto malf;\n\tdebug3(\"%s: channel %d packet type 0x%08x len %zu\",\n\t    __func__, c->self, type, sshbuf_len(in));\n\n\tif (type == MUX_MSG_HELLO)\n\t\trid = 0;\n\telse {\n\t\tif (!state->hello_rcvd) {\n\t\t\terror(\"%s: expected MUX_MSG_HELLO(0x%08x), \"\n\t\t\t    \"received 0x%08x\", __func__, MUX_MSG_HELLO, type);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_u32(in, &rid)) != 0)\n\t\t\tgoto malf;\n\t}\n\n\tfor (i = 0; mux_master_handlers[i].handler != NULL; i++) {\n\t\tif (type == mux_master_handlers[i].type) {\n\t\t\tret = mux_master_handlers[i].handler(ssh, rid,\n\t\t\t    c, in, out);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mux_master_handlers[i].handler == NULL) {\n\t\terror(\"%s: unsupported mux message 0x%08x\", __func__, type);\n\t\treply_error(out, MUX_S_FAILURE, rid, \"unsupported request\");\n\t\tret = 0;\n\t}\n\t/* Enqueue reply packet */\n\tif (sshbuf_len(out) != 0) {\n\t\tif ((r = sshbuf_put_stringb(c->output, out)) != 0)\n\t\t\tfatal(\"%s: sshbuf_put_stringb: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t}\n out:\n\tsshbuf_free(in);\n\tsshbuf_free(out);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll",
          "args": [
            "&pfd",
            "1",
            "-1"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "after_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "888-941",
          "snippet": "static void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t/* Find sockets entry */\n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror(\"%s: no socket for fd %d\", __func__, pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Process events */\n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0) {\n\t\t\t\tgoto close_sock;\n\t\t\t}\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int sockets_alloc = 0;",
            "SocketEntry *sockets = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int sockets_alloc = 0;\nSocketEntry *sockets = NULL;\n\nstatic void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t/* Find sockets entry */\n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror(\"%s: no socket for fd %d\", __func__, pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Process events */\n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0) {\n\t\t\t\tgoto close_sock;\n\t\t\t}\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "fd",
            "s + pos",
            "n - pos"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomicio6(ssize_t (*f) (int, void *, size_t), int fd, void *_s, size_t n,\n    int (*cb)(void *, size_t), void *cb_arg)\n{\n\tchar *s = _s;\n\tsize_t pos = 0;\n\tssize_t res;\n\tstruct pollfd pfd;\n\n#ifndef BROKEN_READ_COMPARISON\n\tpfd.fd = fd;\n\tpfd.events = f == read ? POLLIN : POLLOUT;\n#endif\n\twhile (n > pos) {\n\t\tres = (f) (fd, s + pos, n - pos);\n\t\tswitch (res) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tif (errno == EAGAIN || errno == EWOULDBLOCK) {\n#ifndef BROKEN_READ_COMPARISON\n\t\t\t\t(void)poll(&pfd, 1, -1);\n#endif\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase 0:\n\t\t\terrno = EPIPE;\n\t\t\treturn pos;\n\t\tdefault:\n\t\t\tpos += (size_t)res;\n\t\t\tif (cb != NULL && cb(cb_arg, (size_t)res) == -1) {\n\t\t\t\terrno = EINTR;\n\t\t\t\treturn pos;\n\t\t\t}\n\t\t}\n\t}\n\treturn pos;\n}"
  }
]