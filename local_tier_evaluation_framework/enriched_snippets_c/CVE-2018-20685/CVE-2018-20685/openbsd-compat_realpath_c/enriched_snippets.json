[
  {
    "function_name": "realpath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/realpath.c",
    "lines": "60-228",
    "snippet": "char *\nrealpath(const char *path, char *resolved)\n{\n\tstruct stat sb;\n\tchar *p, *q, *s;\n\tsize_t left_len, resolved_len;\n\tunsigned symlinks;\n\tint serrno, slen, mem_allocated;\n\tchar left[PATH_MAX], next_token[PATH_MAX], symlink[PATH_MAX];\n\n\tif (path[0] == '\\0') {\n\t\terrno = ENOENT;\n\t\treturn (NULL);\n\t}\n\n\tserrno = errno;\n\n\tif (resolved == NULL) {\n\t\tresolved = malloc(PATH_MAX);\n\t\tif (resolved == NULL)\n\t\t\treturn (NULL);\n\t\tmem_allocated = 1;\n\t} else\n\t\tmem_allocated = 0;\n\n\tsymlinks = 0;\n\tif (path[0] == '/') {\n\t\tresolved[0] = '/';\n\t\tresolved[1] = '\\0';\n\t\tif (path[1] == '\\0')\n\t\t\treturn (resolved);\n\t\tresolved_len = 1;\n\t\tleft_len = strlcpy(left, path + 1, sizeof(left));\n\t} else {\n\t\tif (getcwd(resolved, PATH_MAX) == NULL) {\n\t\t\tif (mem_allocated)\n\t\t\t\tfree(resolved);\n\t\t\telse\n\t\t\t\tstrlcpy(resolved, \".\", PATH_MAX);\n\t\t\treturn (NULL);\n\t\t}\n\t\tresolved_len = strlen(resolved);\n\t\tleft_len = strlcpy(left, path, sizeof(left));\n\t}\n\tif (left_len >= sizeof(left) || resolved_len >= PATH_MAX) {\n\t\terrno = ENAMETOOLONG;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * Iterate over path components in `left'.\n\t */\n\twhile (left_len != 0) {\n\t\t/*\n\t\t * Extract the next path component and adjust `left'\n\t\t * and its length.\n\t\t */\n\t\tp = strchr(left, '/');\n\t\ts = p ? p : left + left_len;\n\t\tif (s - left >= (ptrdiff_t)sizeof(next_token)) {\n\t\t\terrno = ENAMETOOLONG;\n\t\t\tgoto err;\n\t\t}\n\t\tmemcpy(next_token, left, s - left);\n\t\tnext_token[s - left] = '\\0';\n\t\tleft_len -= s - left;\n\t\tif (p != NULL)\n\t\t\tmemmove(left, s + 1, left_len + 1);\n\t\tif (resolved[resolved_len - 1] != '/') {\n\t\t\tif (resolved_len + 1 >= PATH_MAX) {\n\t\t\t\terrno = ENAMETOOLONG;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tresolved[resolved_len++] = '/';\n\t\t\tresolved[resolved_len] = '\\0';\n\t\t}\n\t\tif (next_token[0] == '\\0')\n\t\t\tcontinue;\n\t\telse if (strcmp(next_token, \".\") == 0)\n\t\t\tcontinue;\n\t\telse if (strcmp(next_token, \"..\") == 0) {\n\t\t\t/*\n\t\t\t * Strip the last path component except when we have\n\t\t\t * single \"/\"\n\t\t\t */\n\t\t\tif (resolved_len > 1) {\n\t\t\t\tresolved[resolved_len - 1] = '\\0';\n\t\t\t\tq = strrchr(resolved, '/') + 1;\n\t\t\t\t*q = '\\0';\n\t\t\t\tresolved_len = q - resolved;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Append the next path component and lstat() it. If\n\t\t * lstat() fails we still can return successfully if\n\t\t * there are no more path components left.\n\t\t */\n\t\tresolved_len = strlcat(resolved, next_token, PATH_MAX);\n\t\tif (resolved_len >= PATH_MAX) {\n\t\t\terrno = ENAMETOOLONG;\n\t\t\tgoto err;\n\t\t}\n\t\tif (lstat(resolved, &sb) != 0) {\n\t\t\tif (errno == ENOENT && p == NULL) {\n\t\t\t\terrno = serrno;\n\t\t\t\treturn (resolved);\n\t\t\t}\n\t\t\tgoto err;\n\t\t}\n\t\tif (S_ISLNK(sb.st_mode)) {\n\t\t\tif (symlinks++ > SYMLOOP_MAX) {\n\t\t\t\terrno = ELOOP;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tslen = readlink(resolved, symlink, sizeof(symlink) - 1);\n\t\t\tif (slen < 0)\n\t\t\t\tgoto err;\n\t\t\tsymlink[slen] = '\\0';\n\t\t\tif (symlink[0] == '/') {\n\t\t\t\tresolved[1] = 0;\n\t\t\t\tresolved_len = 1;\n\t\t\t} else if (resolved_len > 1) {\n\t\t\t\t/* Strip the last path component. */\n\t\t\t\tresolved[resolved_len - 1] = '\\0';\n\t\t\t\tq = strrchr(resolved, '/') + 1;\n\t\t\t\t*q = '\\0';\n\t\t\t\tresolved_len = q - resolved;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If there are any path components left, then\n\t\t\t * append them to symlink. The result is placed\n\t\t\t * in `left'.\n\t\t\t */\n\t\t\tif (p != NULL) {\n\t\t\t\tif (symlink[slen - 1] != '/') {\n\t\t\t\t\tif (slen + 1 >=\n\t\t\t\t\t    (ptrdiff_t)sizeof(symlink)) {\n\t\t\t\t\t\terrno = ENAMETOOLONG;\n\t\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t\t\tsymlink[slen] = '/';\n\t\t\t\t\tsymlink[slen + 1] = 0;\n\t\t\t\t}\n\t\t\t\tleft_len = strlcat(symlink, left, sizeof(symlink));\n\t\t\t\tif (left_len >= sizeof(symlink)) {\n\t\t\t\t\terrno = ENAMETOOLONG;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tleft_len = strlcpy(left, symlink, sizeof(left));\n\t\t}\n\t}\n\n\t/*\n\t * Remove trailing slash except when the resolved pathname\n\t * is a single \"/\".\n\t */\n\tif (resolved_len > 1 && resolved[resolved_len - 1] == '/')\n\t\tresolved[resolved_len - 1] = '\\0';\n\treturn (resolved);\n\nerr:\n\tif (mem_allocated)\n\t\tfree(resolved);\n\treturn (NULL);\n}",
    "includes": [
      "#include <limits.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stddef.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "resolved"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "left",
            "symlink",
            "sizeof(left)"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcat",
          "args": [
            "symlink",
            "left",
            "sizeof(symlink)"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "strlcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcat.c",
          "lines": "34-60",
          "snippet": "size_t\nstrlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcat(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end */\n\twhile (n-- != 0 && *d != '\\0')\n\t\td++;\n\tdlen = d - dst;\n\tn = siz - dlen;\n\n\tif (n == 0)\n\t\treturn(dlen + strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(dlen + (s - src));\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "resolved",
            "'/'"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readlink",
          "args": [
            "resolved",
            "symlink",
            "sizeof(symlink) - 1"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "sb.st_mode"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "resolved",
            "&sb"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "fudge_lstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-glob.c",
          "lines": "110-121",
          "snippet": "static int\nfudge_lstat(const char *path, struct stat *st)\n{\n\tAttrib *a;\n\n\tif (!(a = do_lstat(cur.conn, (char *)path, 1)))\n\t\treturn(-1);\n\n\tattrib_to_stat(a, st);\n\n\treturn(0);\n}",
          "includes": [
            "#include \"sftp-client.h\"",
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <dirent.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tstruct sftp_conn *conn;\n} cur;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-client.h\"\n#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"xmalloc.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <stdlib.h>\n#include <dirent.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct {\n\tstruct sftp_conn *conn;\n} cur;\n\nstatic int\nfudge_lstat(const char *path, struct stat *st)\n{\n\tAttrib *a;\n\n\tif (!(a = do_lstat(cur.conn, (char *)path, 1)))\n\t\treturn(-1);\n\n\tattrib_to_stat(a, st);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "resolved",
            "'/'"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "next_token",
            "\"..\""
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "left",
            "s + 1",
            "left_len + 1"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "next_token",
            "left",
            "s - left"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "left",
            "'/'"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "resolved"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getcwd",
          "args": [
            "resolved",
            "PATH_MAX"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "getcwd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getcwd.c",
          "lines": "51-238",
          "snippet": "char *\ngetcwd(char *pt, size_t size)\n{\n\tstruct dirent *dp;\n\tDIR *dir = NULL;\n\tdev_t dev;\n\tino_t ino;\n\tint first;\n\tchar *bpt, *bup;\n\tstruct stat s;\n\tdev_t root_dev;\n\tino_t root_ino;\n\tsize_t ptsize, upsize;\n\tint save_errno;\n\tchar *ept, *eup, *up;\n\n\t/*\n\t * If no buffer specified by the user, allocate one as necessary.\n\t * If a buffer is specified, the size has to be non-zero.  The path\n\t * is built from the end of the buffer backwards.\n\t */\n\tif (pt) {\n\t\tptsize = 0;\n\t\tif (!size) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (NULL);\n\t\t}\n\t\tept = pt + size;\n\t} else {\n\t\tif ((pt = malloc(ptsize = MAXPATHLEN)) == NULL)\n\t\t\treturn (NULL);\n\t\tept = pt + ptsize;\n\t}\n\tbpt = ept - 1;\n\t*bpt = '\\0';\n\n\t/*\n\t * Allocate bytes for the string of \"../\"'s.\n\t * Should always be enough (it's 340 levels).  If it's not, allocate\n\t * as necessary.  Special * case the first stat, it's \".\", not \"..\".\n\t */\n\tif ((up = malloc(upsize = MAXPATHLEN)) == NULL)\n\t\tgoto err;\n\teup = up + upsize;\n\tbup = up;\n\tup[0] = '.';\n\tup[1] = '\\0';\n\n\t/* Save root values, so know when to stop. */\n\tif (stat(\"/\", &s))\n\t\tgoto err;\n\troot_dev = s.st_dev;\n\troot_ino = s.st_ino;\n\n\terrno = 0;\t\t\t/* XXX readdir has no error return. */\n\n\tfor (first = 1;; first = 0) {\n\t\t/* Stat the current level. */\n\t\tif (lstat(up, &s))\n\t\t\tgoto err;\n\n\t\t/* Save current node values. */\n\t\tino = s.st_ino;\n\t\tdev = s.st_dev;\n\n\t\t/* Check for reaching root. */\n\t\tif (root_dev == dev && root_ino == ino) {\n\t\t\t*--bpt = '/';\n\t\t\t/*\n\t\t\t * It's unclear that it's a requirement to copy the\n\t\t\t * path to the beginning of the buffer, but it's always\n\t\t\t * been that way and stuff would probably break.\n\t\t\t */\n\t\t\tmemmove(pt, bpt, ept - bpt);\n\t\t\tfree(up);\n\t\t\treturn (pt);\n\t\t}\n\n\t\t/*\n\t\t * Build pointer to the parent directory, allocating memory\n\t\t * as necessary.  Max length is 3 for \"../\", the largest\n\t\t * possible component name, plus a trailing NUL.\n\t\t */\n\t\tif (bup + 3  + MAXNAMLEN + 1 >= eup) {\n\t\t\tchar *nup;\n\n\t\t\tif ((nup = realloc(up, upsize *= 2)) == NULL)\n\t\t\t\tgoto err;\n\t\t\tbup = nup + (bup - up);\n\t\t\tup = nup;\n\t\t\teup = up + upsize;\n\t\t}\n\t\t*bup++ = '.';\n\t\t*bup++ = '.';\n\t\t*bup = '\\0';\n\n\t\t/* Open and stat parent directory. */\n\t\tif (!(dir = opendir(up)) || fstat(dirfd(dir), &s))\n\t\t\tgoto err;\n\n\t\t/* Add trailing slash for next directory. */\n\t\t*bup++ = '/';\n\n\t\t/*\n\t\t * If it's a mount point, have to stat each element because\n\t\t * the inode number in the directory is for the entry in the\n\t\t * parent directory, not the inode number of the mounted file.\n\t\t */\n\t\tsave_errno = 0;\n\t\tif (s.st_dev == dev) {\n\t\t\tfor (;;) {\n\t\t\t\tif (!(dp = readdir(dir)))\n\t\t\t\t\tgoto notfound;\n\t\t\t\tif (dp->d_fileno == ino)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tfor (;;) {\n\t\t\t\tif (!(dp = readdir(dir)))\n\t\t\t\t\tgoto notfound;\n\t\t\t\tif (ISDOT(dp))\n\t\t\t\t\tcontinue;\n\t\t\t\tmemcpy(bup, dp->d_name, dp->d_namlen + 1);\n\n\t\t\t\t/* Save the first error for later. */\n\t\t\t\tif (lstat(up, &s)) {\n\t\t\t\t\tif (!save_errno)\n\t\t\t\t\t\tsave_errno = errno;\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (s.st_dev == dev && s.st_ino == ino)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t/*\n\t\t * Check for length of the current name, preceding slash,\n\t\t * leading slash.\n\t\t */\n\t\tif (bpt - pt < dp->d_namlen + (first ? 1 : 2)) {\n\t\t\tsize_t len;\n\t\t\tchar *npt;\n\n\t\t\tif (!ptsize) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tlen = ept - bpt;\n\t\t\tif ((npt = realloc(pt, ptsize *= 2)) == NULL)\n\t\t\t\tgoto err;\n\t\t\tbpt = npt + (bpt - pt);\n\t\t\tpt = npt;\n\t\t\tept = pt + ptsize;\n\t\t\tmemmove(ept - len, bpt, len);\n\t\t\tbpt = ept - len;\n\t\t}\n\t\tif (!first)\n\t\t\t*--bpt = '/';\n\t\tbpt -= dp->d_namlen;\n\t\tmemcpy(bpt, dp->d_name, dp->d_namlen);\n\t\t(void)closedir(dir);\n\n\t\t/* Truncate any file name. */\n\t\t*bup = '\\0';\n\t}\n\nnotfound:\n\t/*\n\t * If readdir set errno, use it, not any saved error; otherwise,\n\t * didn't find the current directory in its parent directory, set\n\t * errno to ENOENT.\n\t */\n\tif (!errno)\n\t\terrno = save_errno ? save_errno : ENOENT;\n\t/* FALLTHROUGH */\nerr:\n\tsave_errno = errno;\n\n\tif (ptsize)\n\t\tfree(pt);\n\tfree(up);\n\tif (dir)\n\t\t(void)closedir(dir);\n\n\terrno = save_errno;\n\n\treturn (NULL);\n}",
          "includes": [
            "#include \"includes.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/dir.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"includes.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/dir.h>\n#include <dirent.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nchar *\ngetcwd(char *pt, size_t size)\n{\n\tstruct dirent *dp;\n\tDIR *dir = NULL;\n\tdev_t dev;\n\tino_t ino;\n\tint first;\n\tchar *bpt, *bup;\n\tstruct stat s;\n\tdev_t root_dev;\n\tino_t root_ino;\n\tsize_t ptsize, upsize;\n\tint save_errno;\n\tchar *ept, *eup, *up;\n\n\t/*\n\t * If no buffer specified by the user, allocate one as necessary.\n\t * If a buffer is specified, the size has to be non-zero.  The path\n\t * is built from the end of the buffer backwards.\n\t */\n\tif (pt) {\n\t\tptsize = 0;\n\t\tif (!size) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (NULL);\n\t\t}\n\t\tept = pt + size;\n\t} else {\n\t\tif ((pt = malloc(ptsize = MAXPATHLEN)) == NULL)\n\t\t\treturn (NULL);\n\t\tept = pt + ptsize;\n\t}\n\tbpt = ept - 1;\n\t*bpt = '\\0';\n\n\t/*\n\t * Allocate bytes for the string of \"../\"'s.\n\t * Should always be enough (it's 340 levels).  If it's not, allocate\n\t * as necessary.  Special * case the first stat, it's \".\", not \"..\".\n\t */\n\tif ((up = malloc(upsize = MAXPATHLEN)) == NULL)\n\t\tgoto err;\n\teup = up + upsize;\n\tbup = up;\n\tup[0] = '.';\n\tup[1] = '\\0';\n\n\t/* Save root values, so know when to stop. */\n\tif (stat(\"/\", &s))\n\t\tgoto err;\n\troot_dev = s.st_dev;\n\troot_ino = s.st_ino;\n\n\terrno = 0;\t\t\t/* XXX readdir has no error return. */\n\n\tfor (first = 1;; first = 0) {\n\t\t/* Stat the current level. */\n\t\tif (lstat(up, &s))\n\t\t\tgoto err;\n\n\t\t/* Save current node values. */\n\t\tino = s.st_ino;\n\t\tdev = s.st_dev;\n\n\t\t/* Check for reaching root. */\n\t\tif (root_dev == dev && root_ino == ino) {\n\t\t\t*--bpt = '/';\n\t\t\t/*\n\t\t\t * It's unclear that it's a requirement to copy the\n\t\t\t * path to the beginning of the buffer, but it's always\n\t\t\t * been that way and stuff would probably break.\n\t\t\t */\n\t\t\tmemmove(pt, bpt, ept - bpt);\n\t\t\tfree(up);\n\t\t\treturn (pt);\n\t\t}\n\n\t\t/*\n\t\t * Build pointer to the parent directory, allocating memory\n\t\t * as necessary.  Max length is 3 for \"../\", the largest\n\t\t * possible component name, plus a trailing NUL.\n\t\t */\n\t\tif (bup + 3  + MAXNAMLEN + 1 >= eup) {\n\t\t\tchar *nup;\n\n\t\t\tif ((nup = realloc(up, upsize *= 2)) == NULL)\n\t\t\t\tgoto err;\n\t\t\tbup = nup + (bup - up);\n\t\t\tup = nup;\n\t\t\teup = up + upsize;\n\t\t}\n\t\t*bup++ = '.';\n\t\t*bup++ = '.';\n\t\t*bup = '\\0';\n\n\t\t/* Open and stat parent directory. */\n\t\tif (!(dir = opendir(up)) || fstat(dirfd(dir), &s))\n\t\t\tgoto err;\n\n\t\t/* Add trailing slash for next directory. */\n\t\t*bup++ = '/';\n\n\t\t/*\n\t\t * If it's a mount point, have to stat each element because\n\t\t * the inode number in the directory is for the entry in the\n\t\t * parent directory, not the inode number of the mounted file.\n\t\t */\n\t\tsave_errno = 0;\n\t\tif (s.st_dev == dev) {\n\t\t\tfor (;;) {\n\t\t\t\tif (!(dp = readdir(dir)))\n\t\t\t\t\tgoto notfound;\n\t\t\t\tif (dp->d_fileno == ino)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tfor (;;) {\n\t\t\t\tif (!(dp = readdir(dir)))\n\t\t\t\t\tgoto notfound;\n\t\t\t\tif (ISDOT(dp))\n\t\t\t\t\tcontinue;\n\t\t\t\tmemcpy(bup, dp->d_name, dp->d_namlen + 1);\n\n\t\t\t\t/* Save the first error for later. */\n\t\t\t\tif (lstat(up, &s)) {\n\t\t\t\t\tif (!save_errno)\n\t\t\t\t\t\tsave_errno = errno;\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (s.st_dev == dev && s.st_ino == ino)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t/*\n\t\t * Check for length of the current name, preceding slash,\n\t\t * leading slash.\n\t\t */\n\t\tif (bpt - pt < dp->d_namlen + (first ? 1 : 2)) {\n\t\t\tsize_t len;\n\t\t\tchar *npt;\n\n\t\t\tif (!ptsize) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tlen = ept - bpt;\n\t\t\tif ((npt = realloc(pt, ptsize *= 2)) == NULL)\n\t\t\t\tgoto err;\n\t\t\tbpt = npt + (bpt - pt);\n\t\t\tpt = npt;\n\t\t\tept = pt + ptsize;\n\t\t\tmemmove(ept - len, bpt, len);\n\t\t\tbpt = ept - len;\n\t\t}\n\t\tif (!first)\n\t\t\t*--bpt = '/';\n\t\tbpt -= dp->d_namlen;\n\t\tmemcpy(bpt, dp->d_name, dp->d_namlen);\n\t\t(void)closedir(dir);\n\n\t\t/* Truncate any file name. */\n\t\t*bup = '\\0';\n\t}\n\nnotfound:\n\t/*\n\t * If readdir set errno, use it, not any saved error; otherwise,\n\t * didn't find the current directory in its parent directory, set\n\t * errno to ENOENT.\n\t */\n\tif (!errno)\n\t\terrno = save_errno ? save_errno : ENOENT;\n\t/* FALLTHROUGH */\nerr:\n\tsave_errno = errno;\n\n\tif (ptsize)\n\t\tfree(pt);\n\tfree(up);\n\tif (dir)\n\t\t(void)closedir(dir);\n\n\terrno = save_errno;\n\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "PATH_MAX"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "rpl_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-malloc.c",
          "lines": "26-32",
          "snippet": "void *\nrpl_malloc(size_t size)\n{\n\tif (size == 0)\n\t\tsize = 1;\n\treturn malloc(size);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <sys/types.h>\n#include \"config.h\"\n\nvoid *\nrpl_malloc(size_t size)\n{\n\tif (size == 0)\n\t\tsize = 1;\n\treturn malloc(size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nrealpath(const char *path, char *resolved)\n{\n\tstruct stat sb;\n\tchar *p, *q, *s;\n\tsize_t left_len, resolved_len;\n\tunsigned symlinks;\n\tint serrno, slen, mem_allocated;\n\tchar left[PATH_MAX], next_token[PATH_MAX], symlink[PATH_MAX];\n\n\tif (path[0] == '\\0') {\n\t\terrno = ENOENT;\n\t\treturn (NULL);\n\t}\n\n\tserrno = errno;\n\n\tif (resolved == NULL) {\n\t\tresolved = malloc(PATH_MAX);\n\t\tif (resolved == NULL)\n\t\t\treturn (NULL);\n\t\tmem_allocated = 1;\n\t} else\n\t\tmem_allocated = 0;\n\n\tsymlinks = 0;\n\tif (path[0] == '/') {\n\t\tresolved[0] = '/';\n\t\tresolved[1] = '\\0';\n\t\tif (path[1] == '\\0')\n\t\t\treturn (resolved);\n\t\tresolved_len = 1;\n\t\tleft_len = strlcpy(left, path + 1, sizeof(left));\n\t} else {\n\t\tif (getcwd(resolved, PATH_MAX) == NULL) {\n\t\t\tif (mem_allocated)\n\t\t\t\tfree(resolved);\n\t\t\telse\n\t\t\t\tstrlcpy(resolved, \".\", PATH_MAX);\n\t\t\treturn (NULL);\n\t\t}\n\t\tresolved_len = strlen(resolved);\n\t\tleft_len = strlcpy(left, path, sizeof(left));\n\t}\n\tif (left_len >= sizeof(left) || resolved_len >= PATH_MAX) {\n\t\terrno = ENAMETOOLONG;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * Iterate over path components in `left'.\n\t */\n\twhile (left_len != 0) {\n\t\t/*\n\t\t * Extract the next path component and adjust `left'\n\t\t * and its length.\n\t\t */\n\t\tp = strchr(left, '/');\n\t\ts = p ? p : left + left_len;\n\t\tif (s - left >= (ptrdiff_t)sizeof(next_token)) {\n\t\t\terrno = ENAMETOOLONG;\n\t\t\tgoto err;\n\t\t}\n\t\tmemcpy(next_token, left, s - left);\n\t\tnext_token[s - left] = '\\0';\n\t\tleft_len -= s - left;\n\t\tif (p != NULL)\n\t\t\tmemmove(left, s + 1, left_len + 1);\n\t\tif (resolved[resolved_len - 1] != '/') {\n\t\t\tif (resolved_len + 1 >= PATH_MAX) {\n\t\t\t\terrno = ENAMETOOLONG;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tresolved[resolved_len++] = '/';\n\t\t\tresolved[resolved_len] = '\\0';\n\t\t}\n\t\tif (next_token[0] == '\\0')\n\t\t\tcontinue;\n\t\telse if (strcmp(next_token, \".\") == 0)\n\t\t\tcontinue;\n\t\telse if (strcmp(next_token, \"..\") == 0) {\n\t\t\t/*\n\t\t\t * Strip the last path component except when we have\n\t\t\t * single \"/\"\n\t\t\t */\n\t\t\tif (resolved_len > 1) {\n\t\t\t\tresolved[resolved_len - 1] = '\\0';\n\t\t\t\tq = strrchr(resolved, '/') + 1;\n\t\t\t\t*q = '\\0';\n\t\t\t\tresolved_len = q - resolved;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Append the next path component and lstat() it. If\n\t\t * lstat() fails we still can return successfully if\n\t\t * there are no more path components left.\n\t\t */\n\t\tresolved_len = strlcat(resolved, next_token, PATH_MAX);\n\t\tif (resolved_len >= PATH_MAX) {\n\t\t\terrno = ENAMETOOLONG;\n\t\t\tgoto err;\n\t\t}\n\t\tif (lstat(resolved, &sb) != 0) {\n\t\t\tif (errno == ENOENT && p == NULL) {\n\t\t\t\terrno = serrno;\n\t\t\t\treturn (resolved);\n\t\t\t}\n\t\t\tgoto err;\n\t\t}\n\t\tif (S_ISLNK(sb.st_mode)) {\n\t\t\tif (symlinks++ > SYMLOOP_MAX) {\n\t\t\t\terrno = ELOOP;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tslen = readlink(resolved, symlink, sizeof(symlink) - 1);\n\t\t\tif (slen < 0)\n\t\t\t\tgoto err;\n\t\t\tsymlink[slen] = '\\0';\n\t\t\tif (symlink[0] == '/') {\n\t\t\t\tresolved[1] = 0;\n\t\t\t\tresolved_len = 1;\n\t\t\t} else if (resolved_len > 1) {\n\t\t\t\t/* Strip the last path component. */\n\t\t\t\tresolved[resolved_len - 1] = '\\0';\n\t\t\t\tq = strrchr(resolved, '/') + 1;\n\t\t\t\t*q = '\\0';\n\t\t\t\tresolved_len = q - resolved;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If there are any path components left, then\n\t\t\t * append them to symlink. The result is placed\n\t\t\t * in `left'.\n\t\t\t */\n\t\t\tif (p != NULL) {\n\t\t\t\tif (symlink[slen - 1] != '/') {\n\t\t\t\t\tif (slen + 1 >=\n\t\t\t\t\t    (ptrdiff_t)sizeof(symlink)) {\n\t\t\t\t\t\terrno = ENAMETOOLONG;\n\t\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t\t\tsymlink[slen] = '/';\n\t\t\t\t\tsymlink[slen + 1] = 0;\n\t\t\t\t}\n\t\t\t\tleft_len = strlcat(symlink, left, sizeof(symlink));\n\t\t\t\tif (left_len >= sizeof(symlink)) {\n\t\t\t\t\terrno = ENAMETOOLONG;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tleft_len = strlcpy(left, symlink, sizeof(left));\n\t\t}\n\t}\n\n\t/*\n\t * Remove trailing slash except when the resolved pathname\n\t * is a single \"/\".\n\t */\n\tif (resolved_len > 1 && resolved[resolved_len - 1] == '/')\n\t\tresolved[resolved_len - 1] = '\\0';\n\treturn (resolved);\n\nerr:\n\tif (mem_allocated)\n\t\tfree(resolved);\n\treturn (NULL);\n}"
  }
]