[
  {
    "function_name": "pkcs11_del_provider",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
    "lines": "248-267",
    "snippet": "int\npkcs11_del_provider(char *name)\n{\n\tint r, ret = -1;\n\tstruct sshbuf *msg;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH_AGENTC_REMOVE_SMARTCARD_KEY)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, name)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, \"\")) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(msg);\n\tsshbuf_reset(msg);\n\n\tif (recv_msg(msg) == SSH_AGENT_SUCCESS)\n\t\tret = 0;\n\tsshbuf_free(msg);\n\treturn (ret);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"xmalloc.h\"",
      "#include \"pathnames.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rsa.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recv_msg",
          "args": [
            "msg"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "recv_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
          "lines": "69-100",
          "snippet": "static int\nrecv_msg(struct sshbuf *m)\n{\n\tu_int l, len;\n\tu_char c, buf[1024];\n\tint r;\n\n\tif ((len = atomicio(read, fd, buf, 4)) != 4) {\n\t\terror(\"read from helper failed: %u\", len);\n\t\treturn (0); /* XXX */\n\t}\n\tlen = PEEK_U32(buf);\n\tif (len > 256 * 1024)\n\t\tfatal(\"response too long: %u\", len);\n\t/* read len bytes into m */\n\tsshbuf_reset(m);\n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (l > sizeof(buf))\n\t\t\tl = sizeof(buf);\n\t\tif (atomicio(read, fd, buf, l) != l) {\n\t\t\terror(\"response from helper failed.\");\n\t\t\treturn (0); /* XXX */\n\t\t}\n\t\tif ((r = sshbuf_put(m, buf, l)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tlen -= l;\n\t}\n\tif ((r = sshbuf_get_u8(m, &c)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\treturn c;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"pathnames.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rsa.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nrecv_msg(struct sshbuf *m)\n{\n\tu_int l, len;\n\tu_char c, buf[1024];\n\tint r;\n\n\tif ((len = atomicio(read, fd, buf, 4)) != 4) {\n\t\terror(\"read from helper failed: %u\", len);\n\t\treturn (0); /* XXX */\n\t}\n\tlen = PEEK_U32(buf);\n\tif (len > 256 * 1024)\n\t\tfatal(\"response too long: %u\", len);\n\t/* read len bytes into m */\n\tsshbuf_reset(m);\n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (l > sizeof(buf))\n\t\t\tl = sizeof(buf);\n\t\tif (atomicio(read, fd, buf, l) != l) {\n\t\t\terror(\"response from helper failed.\");\n\t\t\treturn (0); /* XXX */\n\t\t}\n\t\tif ((r = sshbuf_put(m, buf, l)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tlen -= l;\n\t}\n\tif ((r = sshbuf_get_u8(m, &c)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "msg"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_msg",
          "args": [
            "msg"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "send_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
          "lines": "53-67",
          "snippet": "static void\nsend_msg(struct sshbuf *m)\n{\n\tu_char buf[4];\n\tsize_t mlen = sshbuf_len(m);\n\tint r;\n\n\tPOKE_U32(buf, mlen);\n\tif (atomicio(vwrite, fd, buf, 4) != 4 ||\n\t    atomicio(vwrite, fd, sshbuf_mutable_ptr(m),\n\t    sshbuf_len(m)) != sshbuf_len(m))\n\t\terror(\"write to helper failed\");\n\tif ((r = sshbuf_consume(m, mlen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"pathnames.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rsa.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_msg(struct sshbuf *m)\n{\n\tu_char buf[4];\n\tsize_t mlen = sshbuf_len(m);\n\tint r;\n\n\tPOKE_U32(buf, mlen);\n\tif (atomicio(vwrite, fd, buf, 4) != 4 ||\n\t    atomicio(vwrite, fd, sshbuf_mutable_ptr(m),\n\t    sshbuf_len(m)) != sshbuf_len(m))\n\t\terror(\"write to helper failed\");\n\tif ((r = sshbuf_consume(m, mlen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "msg",
            "\"\""
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "SSH_AGENTC_REMOVE_SMARTCARD_KEY"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\npkcs11_del_provider(char *name)\n{\n\tint r, ret = -1;\n\tstruct sshbuf *msg;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH_AGENTC_REMOVE_SMARTCARD_KEY)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, name)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, \"\")) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(msg);\n\tsshbuf_reset(msg);\n\n\tif (recv_msg(msg) == SSH_AGENT_SUCCESS)\n\t\tret = 0;\n\tsshbuf_free(msg);\n\treturn (ret);\n}"
  },
  {
    "function_name": "pkcs11_add_provider",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
    "lines": "203-246",
    "snippet": "int\npkcs11_add_provider(char *name, char *pin, struct sshkey ***keysp)\n{\n\tstruct sshkey *k;\n\tint r;\n\tu_char *blob;\n\tsize_t blen;\n\tu_int nkeys, i;\n\tstruct sshbuf *msg;\n\n\tif (fd < 0 && pkcs11_start_helper() < 0)\n\t\treturn (-1);\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH_AGENTC_ADD_SMARTCARD_KEY)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, name)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, pin)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(msg);\n\tsshbuf_reset(msg);\n\n\tif (recv_msg(msg) == SSH2_AGENT_IDENTITIES_ANSWER) {\n\t\tif ((r = sshbuf_get_u32(msg, &nkeys)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\t*keysp = xcalloc(nkeys, sizeof(struct sshkey *));\n\t\tfor (i = 0; i < nkeys; i++) {\n\t\t\t/* XXX clean up properly instead of fatal() */\n\t\t\tif ((r = sshbuf_get_string(msg, &blob, &blen)) != 0 ||\n\t\t\t    (r = sshbuf_skip_string(msg)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif ((r = sshkey_from_blob(blob, blen, &k)) != 0)\n\t\t\t\tfatal(\"%s: bad key: %s\", __func__, ssh_err(r));\n\t\t\twrap_key(k->rsa);\n\t\t\t(*keysp)[i] = k;\n\t\t\tfree(blob);\n\t\t}\n\t} else {\n\t\tnkeys = -1;\n\t}\n\tsshbuf_free(msg);\n\treturn (nkeys);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"xmalloc.h\"",
      "#include \"pathnames.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rsa.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "blob"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wrap_key",
          "args": [
            "k->rsa"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "wrap_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
          "lines": "158-170",
          "snippet": "static int\nwrap_key(RSA *rsa)\n{\n\tstatic RSA_METHOD *helper_rsa;\n\n\tif ((helper_rsa = RSA_meth_dup(RSA_get_default_method())) == NULL)\n\t\tfatal(\"%s: RSA_meth_dup failed\", __func__);\n\tif (!RSA_meth_set1_name(helper_rsa, \"ssh-pkcs11-helper\") ||\n\t    !RSA_meth_set_priv_enc(helper_rsa, pkcs11_rsa_private_encrypt))\n\t\tfatal(\"%s: failed to prepare method\", __func__);\n\tRSA_set_method(rsa, helper_rsa);\n\treturn (0);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"pathnames.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rsa.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nwrap_key(RSA *rsa)\n{\n\tstatic RSA_METHOD *helper_rsa;\n\n\tif ((helper_rsa = RSA_meth_dup(RSA_get_default_method())) == NULL)\n\t\tfatal(\"%s: RSA_meth_dup failed\", __func__);\n\tif (!RSA_meth_set1_name(helper_rsa, \"ssh-pkcs11-helper\") ||\n\t    !RSA_meth_set_priv_enc(helper_rsa, pkcs11_rsa_private_encrypt))\n\t\tfatal(\"%s: failed to prepare method\", __func__);\n\tRSA_set_method(rsa, helper_rsa);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: bad key: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_from_blob",
          "args": [
            "blob",
            "blen",
            "&k"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2263-2274",
          "snippet": "int\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_skip_string",
          "args": [
            "msg"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string",
          "args": [
            "msg",
            "&blob",
            "&blen"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "nkeys",
            "sizeof(struct sshkey *)"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u32",
          "args": [
            "msg",
            "&nkeys"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "57-68",
          "snippet": "int\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u32(struct sshbuf *buf, u_int32_t *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 4)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = PEEK_U32(p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recv_msg",
          "args": [
            "msg"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "recv_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
          "lines": "69-100",
          "snippet": "static int\nrecv_msg(struct sshbuf *m)\n{\n\tu_int l, len;\n\tu_char c, buf[1024];\n\tint r;\n\n\tif ((len = atomicio(read, fd, buf, 4)) != 4) {\n\t\terror(\"read from helper failed: %u\", len);\n\t\treturn (0); /* XXX */\n\t}\n\tlen = PEEK_U32(buf);\n\tif (len > 256 * 1024)\n\t\tfatal(\"response too long: %u\", len);\n\t/* read len bytes into m */\n\tsshbuf_reset(m);\n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (l > sizeof(buf))\n\t\t\tl = sizeof(buf);\n\t\tif (atomicio(read, fd, buf, l) != l) {\n\t\t\terror(\"response from helper failed.\");\n\t\t\treturn (0); /* XXX */\n\t\t}\n\t\tif ((r = sshbuf_put(m, buf, l)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tlen -= l;\n\t}\n\tif ((r = sshbuf_get_u8(m, &c)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\treturn c;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"pathnames.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rsa.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nrecv_msg(struct sshbuf *m)\n{\n\tu_int l, len;\n\tu_char c, buf[1024];\n\tint r;\n\n\tif ((len = atomicio(read, fd, buf, 4)) != 4) {\n\t\terror(\"read from helper failed: %u\", len);\n\t\treturn (0); /* XXX */\n\t}\n\tlen = PEEK_U32(buf);\n\tif (len > 256 * 1024)\n\t\tfatal(\"response too long: %u\", len);\n\t/* read len bytes into m */\n\tsshbuf_reset(m);\n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (l > sizeof(buf))\n\t\t\tl = sizeof(buf);\n\t\tif (atomicio(read, fd, buf, l) != l) {\n\t\t\terror(\"response from helper failed.\");\n\t\t\treturn (0); /* XXX */\n\t\t}\n\t\tif ((r = sshbuf_put(m, buf, l)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tlen -= l;\n\t}\n\tif ((r = sshbuf_get_u8(m, &c)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "msg"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_msg",
          "args": [
            "msg"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "send_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
          "lines": "53-67",
          "snippet": "static void\nsend_msg(struct sshbuf *m)\n{\n\tu_char buf[4];\n\tsize_t mlen = sshbuf_len(m);\n\tint r;\n\n\tPOKE_U32(buf, mlen);\n\tif (atomicio(vwrite, fd, buf, 4) != 4 ||\n\t    atomicio(vwrite, fd, sshbuf_mutable_ptr(m),\n\t    sshbuf_len(m)) != sshbuf_len(m))\n\t\terror(\"write to helper failed\");\n\tif ((r = sshbuf_consume(m, mlen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"pathnames.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rsa.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_msg(struct sshbuf *m)\n{\n\tu_char buf[4];\n\tsize_t mlen = sshbuf_len(m);\n\tint r;\n\n\tPOKE_U32(buf, mlen);\n\tif (atomicio(vwrite, fd, buf, 4) != 4 ||\n\t    atomicio(vwrite, fd, sshbuf_mutable_ptr(m),\n\t    sshbuf_len(m)) != sshbuf_len(m))\n\t\terror(\"write to helper failed\");\n\tif ((r = sshbuf_consume(m, mlen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "msg",
            "pin"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "SSH_AGENTC_ADD_SMARTCARD_KEY"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pkcs11_start_helper",
          "args": [],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "pkcs11_start_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
          "lines": "172-201",
          "snippet": "static int\npkcs11_start_helper(void)\n{\n\tint pair[2];\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, pair) == -1) {\n\t\terror(\"socketpair: %s\", strerror(errno));\n\t\treturn (-1);\n\t}\n\tif ((pid = fork()) == -1) {\n\t\terror(\"fork: %s\", strerror(errno));\n\t\treturn (-1);\n\t} else if (pid == 0) {\n\t\tif ((dup2(pair[1], STDIN_FILENO) == -1) ||\n\t\t    (dup2(pair[1], STDOUT_FILENO) == -1)) {\n\t\t\tfprintf(stderr, \"dup2: %s\\n\", strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tclose(pair[0]);\n\t\tclose(pair[1]);\n\t\texeclp(_PATH_SSH_PKCS11_HELPER, _PATH_SSH_PKCS11_HELPER,\n\t\t    (char *)NULL);\n\t\tfprintf(stderr, \"exec: %s: %s\\n\", _PATH_SSH_PKCS11_HELPER,\n\t\t    strerror(errno));\n\t\t_exit(1);\n\t}\n\tclose(pair[1]);\n\tfd = pair[0];\n\treturn (0);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"pathnames.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rsa.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\npkcs11_start_helper(void)\n{\n\tint pair[2];\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, pair) == -1) {\n\t\terror(\"socketpair: %s\", strerror(errno));\n\t\treturn (-1);\n\t}\n\tif ((pid = fork()) == -1) {\n\t\terror(\"fork: %s\", strerror(errno));\n\t\treturn (-1);\n\t} else if (pid == 0) {\n\t\tif ((dup2(pair[1], STDIN_FILENO) == -1) ||\n\t\t    (dup2(pair[1], STDOUT_FILENO) == -1)) {\n\t\t\tfprintf(stderr, \"dup2: %s\\n\", strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tclose(pair[0]);\n\t\tclose(pair[1]);\n\t\texeclp(_PATH_SSH_PKCS11_HELPER, _PATH_SSH_PKCS11_HELPER,\n\t\t    (char *)NULL);\n\t\tfprintf(stderr, \"exec: %s: %s\\n\", _PATH_SSH_PKCS11_HELPER,\n\t\t    strerror(errno));\n\t\t_exit(1);\n\t}\n\tclose(pair[1]);\n\tfd = pair[0];\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\npkcs11_add_provider(char *name, char *pin, struct sshkey ***keysp)\n{\n\tstruct sshkey *k;\n\tint r;\n\tu_char *blob;\n\tsize_t blen;\n\tu_int nkeys, i;\n\tstruct sshbuf *msg;\n\n\tif (fd < 0 && pkcs11_start_helper() < 0)\n\t\treturn (-1);\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH_AGENTC_ADD_SMARTCARD_KEY)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, name)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, pin)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(msg);\n\tsshbuf_reset(msg);\n\n\tif (recv_msg(msg) == SSH2_AGENT_IDENTITIES_ANSWER) {\n\t\tif ((r = sshbuf_get_u32(msg, &nkeys)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\t*keysp = xcalloc(nkeys, sizeof(struct sshkey *));\n\t\tfor (i = 0; i < nkeys; i++) {\n\t\t\t/* XXX clean up properly instead of fatal() */\n\t\t\tif ((r = sshbuf_get_string(msg, &blob, &blen)) != 0 ||\n\t\t\t    (r = sshbuf_skip_string(msg)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif ((r = sshkey_from_blob(blob, blen, &k)) != 0)\n\t\t\t\tfatal(\"%s: bad key: %s\", __func__, ssh_err(r));\n\t\t\twrap_key(k->rsa);\n\t\t\t(*keysp)[i] = k;\n\t\t\tfree(blob);\n\t\t}\n\t} else {\n\t\tnkeys = -1;\n\t}\n\tsshbuf_free(msg);\n\treturn (nkeys);\n}"
  },
  {
    "function_name": "pkcs11_start_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
    "lines": "172-201",
    "snippet": "static int\npkcs11_start_helper(void)\n{\n\tint pair[2];\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, pair) == -1) {\n\t\terror(\"socketpair: %s\", strerror(errno));\n\t\treturn (-1);\n\t}\n\tif ((pid = fork()) == -1) {\n\t\terror(\"fork: %s\", strerror(errno));\n\t\treturn (-1);\n\t} else if (pid == 0) {\n\t\tif ((dup2(pair[1], STDIN_FILENO) == -1) ||\n\t\t    (dup2(pair[1], STDOUT_FILENO) == -1)) {\n\t\t\tfprintf(stderr, \"dup2: %s\\n\", strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tclose(pair[0]);\n\t\tclose(pair[1]);\n\t\texeclp(_PATH_SSH_PKCS11_HELPER, _PATH_SSH_PKCS11_HELPER,\n\t\t    (char *)NULL);\n\t\tfprintf(stderr, \"exec: %s: %s\\n\", _PATH_SSH_PKCS11_HELPER,\n\t\t    strerror(errno));\n\t\t_exit(1);\n\t}\n\tclose(pair[1]);\n\tfd = pair[0];\n\treturn (0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"xmalloc.h\"",
      "#include \"pathnames.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rsa.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "pair[1]"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"exec: %s: %s\\n\"",
            "_PATH_SSH_PKCS11_HELPER",
            "strerror(errno)"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "_PATH_SSH_PKCS11_HELPER",
            "_PATH_SSH_PKCS11_HELPER",
            "(char *)NULL"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"dup2: %s\\n\"",
            "strerror(errno)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "pair[1]",
            "STDOUT_FILENO"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "pair[1]",
            "STDIN_FILENO"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"fork: %s\"",
            "strerror(errno)"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "platform_post_fork_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
          "lines": "69-78",
          "snippet": "void\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "socketpair",
          "args": [
            "AF_UNIX",
            "SOCK_STREAM",
            "0",
            "pair"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\npkcs11_start_helper(void)\n{\n\tint pair[2];\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, pair) == -1) {\n\t\terror(\"socketpair: %s\", strerror(errno));\n\t\treturn (-1);\n\t}\n\tif ((pid = fork()) == -1) {\n\t\terror(\"fork: %s\", strerror(errno));\n\t\treturn (-1);\n\t} else if (pid == 0) {\n\t\tif ((dup2(pair[1], STDIN_FILENO) == -1) ||\n\t\t    (dup2(pair[1], STDOUT_FILENO) == -1)) {\n\t\t\tfprintf(stderr, \"dup2: %s\\n\", strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tclose(pair[0]);\n\t\tclose(pair[1]);\n\t\texeclp(_PATH_SSH_PKCS11_HELPER, _PATH_SSH_PKCS11_HELPER,\n\t\t    (char *)NULL);\n\t\tfprintf(stderr, \"exec: %s: %s\\n\", _PATH_SSH_PKCS11_HELPER,\n\t\t    strerror(errno));\n\t\t_exit(1);\n\t}\n\tclose(pair[1]);\n\tfd = pair[0];\n\treturn (0);\n}"
  },
  {
    "function_name": "wrap_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
    "lines": "158-170",
    "snippet": "static int\nwrap_key(RSA *rsa)\n{\n\tstatic RSA_METHOD *helper_rsa;\n\n\tif ((helper_rsa = RSA_meth_dup(RSA_get_default_method())) == NULL)\n\t\tfatal(\"%s: RSA_meth_dup failed\", __func__);\n\tif (!RSA_meth_set1_name(helper_rsa, \"ssh-pkcs11-helper\") ||\n\t    !RSA_meth_set_priv_enc(helper_rsa, pkcs11_rsa_private_encrypt))\n\t\tfatal(\"%s: failed to prepare method\", __func__);\n\tRSA_set_method(rsa, helper_rsa);\n\treturn (0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"xmalloc.h\"",
      "#include \"pathnames.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rsa.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RSA_set_method",
          "args": [
            "rsa",
            "helper_rsa"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: failed to prepare method\"",
            "__func__"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RSA_meth_set_priv_enc",
          "args": [
            "helper_rsa",
            "pkcs11_rsa_private_encrypt"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "RSA_meth_set_priv_enc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "579-585",
          "snippet": "int\nRSA_meth_set_priv_enc(RSA_METHOD *meth, int (*priv_enc)(int flen,\n    const unsigned char *from, unsigned char *to, RSA *rsa, int padding))\n{\n\tmeth->rsa_priv_enc = priv_enc;\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nRSA_meth_set_priv_enc(RSA_METHOD *meth, int (*priv_enc)(int flen,\n    const unsigned char *from, unsigned char *to, RSA *rsa, int padding))\n{\n\tmeth->rsa_priv_enc = priv_enc;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RSA_meth_set1_name",
          "args": [
            "helper_rsa",
            "\"ssh-pkcs11-helper\""
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "RSA_meth_set1_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "557-567",
          "snippet": "int\nRSA_meth_set1_name(RSA_METHOD *meth, const char *name)\n{\n\tchar *copy;\n\n\tif ((copy = strdup(name)) == NULL)\n\t\treturn 0;\n\tfree((char *)meth->name);\n\tmeth->name = copy;\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nRSA_meth_set1_name(RSA_METHOD *meth, const char *name)\n{\n\tchar *copy;\n\n\tif ((copy = strdup(name)) == NULL)\n\t\treturn 0;\n\tfree((char *)meth->name);\n\tmeth->name = copy;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RSA_meth_dup",
          "args": [
            "RSA_get_default_method()"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "RSA_meth_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/libressl-api-compat.c",
          "lines": "539-553",
          "snippet": "RSA_METHOD *\nRSA_meth_dup(const RSA_METHOD *meth)\n{\n\tRSA_METHOD *copy;\n\n\tif ((copy = calloc(1, sizeof(*copy))) == NULL)\n\t\treturn NULL;\n\tmemcpy(copy, meth, sizeof(*copy));\n\tif ((copy->name = strdup(meth->name)) == NULL) {\n\t\tfree(copy);\n\t\treturn NULL;\n\t}\n\n\treturn copy;\n}",
          "includes": [
            "#include <openssl/dh.h>",
            "#include <openssl/ecdsa.h>",
            "#include <openssl/evp.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/bn.h>",
            "#include <openssl/err.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/dh.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nRSA_METHOD *\nRSA_meth_dup(const RSA_METHOD *meth)\n{\n\tRSA_METHOD *copy;\n\n\tif ((copy = calloc(1, sizeof(*copy))) == NULL)\n\t\treturn NULL;\n\tmemcpy(copy, meth, sizeof(*copy));\n\tif ((copy->name = strdup(meth->name)) == NULL) {\n\t\tfree(copy);\n\t\treturn NULL;\n\t}\n\n\treturn copy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RSA_get_default_method",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nwrap_key(RSA *rsa)\n{\n\tstatic RSA_METHOD *helper_rsa;\n\n\tif ((helper_rsa = RSA_meth_dup(RSA_get_default_method())) == NULL)\n\t\tfatal(\"%s: RSA_meth_dup failed\", __func__);\n\tif (!RSA_meth_set1_name(helper_rsa, \"ssh-pkcs11-helper\") ||\n\t    !RSA_meth_set_priv_enc(helper_rsa, pkcs11_rsa_private_encrypt))\n\t\tfatal(\"%s: failed to prepare method\", __func__);\n\tRSA_set_method(rsa, helper_rsa);\n\treturn (0);\n}"
  },
  {
    "function_name": "pkcs11_rsa_private_encrypt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
    "lines": "115-155",
    "snippet": "static int\npkcs11_rsa_private_encrypt(int flen, const u_char *from, u_char *to, RSA *rsa,\n    int padding)\n{\n\tstruct sshkey key;\t/* XXX */\n\tu_char *blob, *signature = NULL;\n\tsize_t blen, slen = 0;\n\tint r, ret = -1;\n\tstruct sshbuf *msg;\n\n\tif (padding != RSA_PKCS1_PADDING)\n\t\treturn (-1);\n\tkey.type = KEY_RSA;\n\tkey.rsa = rsa;\n\tif ((r = sshkey_to_blob(&key, &blob, &blen)) != 0) {\n\t\terror(\"%s: sshkey_to_blob: %s\", __func__, ssh_err(r));\n\t\treturn -1;\n\t}\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENTC_SIGN_REQUEST)) != 0 ||\n\t    (r = sshbuf_put_string(msg, blob, blen)) != 0 ||\n\t    (r = sshbuf_put_string(msg, from, flen)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, 0)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tfree(blob);\n\tsend_msg(msg);\n\tsshbuf_reset(msg);\n\n\tif (recv_msg(msg) == SSH2_AGENT_SIGN_RESPONSE) {\n\t\tif ((r = sshbuf_get_string(msg, &signature, &slen)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (slen <= (size_t)RSA_size(rsa)) {\n\t\t\tmemcpy(to, signature, slen);\n\t\t\tret = slen;\n\t\t}\n\t\tfree(signature);\n\t}\n\tsshbuf_free(msg);\n\treturn (ret);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"xmalloc.h\"",
      "#include \"pathnames.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rsa.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "msg"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "signature"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "to",
            "signature",
            "slen"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_size",
          "args": [
            "rsa"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string",
          "args": [
            "msg",
            "&signature",
            "&slen"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recv_msg",
          "args": [
            "msg"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "recv_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
          "lines": "69-100",
          "snippet": "static int\nrecv_msg(struct sshbuf *m)\n{\n\tu_int l, len;\n\tu_char c, buf[1024];\n\tint r;\n\n\tif ((len = atomicio(read, fd, buf, 4)) != 4) {\n\t\terror(\"read from helper failed: %u\", len);\n\t\treturn (0); /* XXX */\n\t}\n\tlen = PEEK_U32(buf);\n\tif (len > 256 * 1024)\n\t\tfatal(\"response too long: %u\", len);\n\t/* read len bytes into m */\n\tsshbuf_reset(m);\n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (l > sizeof(buf))\n\t\t\tl = sizeof(buf);\n\t\tif (atomicio(read, fd, buf, l) != l) {\n\t\t\terror(\"response from helper failed.\");\n\t\t\treturn (0); /* XXX */\n\t\t}\n\t\tif ((r = sshbuf_put(m, buf, l)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tlen -= l;\n\t}\n\tif ((r = sshbuf_get_u8(m, &c)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\treturn c;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"pathnames.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rsa.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nrecv_msg(struct sshbuf *m)\n{\n\tu_int l, len;\n\tu_char c, buf[1024];\n\tint r;\n\n\tif ((len = atomicio(read, fd, buf, 4)) != 4) {\n\t\terror(\"read from helper failed: %u\", len);\n\t\treturn (0); /* XXX */\n\t}\n\tlen = PEEK_U32(buf);\n\tif (len > 256 * 1024)\n\t\tfatal(\"response too long: %u\", len);\n\t/* read len bytes into m */\n\tsshbuf_reset(m);\n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (l > sizeof(buf))\n\t\t\tl = sizeof(buf);\n\t\tif (atomicio(read, fd, buf, l) != l) {\n\t\t\terror(\"response from helper failed.\");\n\t\t\treturn (0); /* XXX */\n\t\t}\n\t\tif ((r = sshbuf_put(m, buf, l)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tlen -= l;\n\t}\n\tif ((r = sshbuf_get_u8(m, &c)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "msg"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_msg",
          "args": [
            "msg"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "send_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
          "lines": "53-67",
          "snippet": "static void\nsend_msg(struct sshbuf *m)\n{\n\tu_char buf[4];\n\tsize_t mlen = sshbuf_len(m);\n\tint r;\n\n\tPOKE_U32(buf, mlen);\n\tif (atomicio(vwrite, fd, buf, 4) != 4 ||\n\t    atomicio(vwrite, fd, sshbuf_mutable_ptr(m),\n\t    sshbuf_len(m)) != sshbuf_len(m))\n\t\terror(\"write to helper failed\");\n\tif ((r = sshbuf_consume(m, mlen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"ssh-pkcs11.h\"",
            "#include \"atomicio.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"pathnames.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/rsa.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <sys/socket.h>",
            "# include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_msg(struct sshbuf *m)\n{\n\tu_char buf[4];\n\tsize_t mlen = sshbuf_len(m);\n\tint r;\n\n\tPOKE_U32(buf, mlen);\n\tif (atomicio(vwrite, fd, buf, 4) != 4 ||\n\t    atomicio(vwrite, fd, sshbuf_mutable_ptr(m),\n\t    sshbuf_len(m)) != sshbuf_len(m))\n\t\terror(\"write to helper failed\");\n\tif ((r = sshbuf_consume(m, mlen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "msg",
            "0"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "msg",
            "from",
            "flen"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "msg",
            "SSH2_AGENTC_SIGN_REQUEST"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: sshkey_to_blob: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_to_blob",
          "args": [
            "&key",
            "&blob",
            "&blen"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_to_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "880-884",
          "snippet": "int\nsshkey_to_blob(const struct sshkey *key, u_char **blobp, size_t *lenp)\n{\n\treturn to_blob(key, blobp, lenp, 0, SSHKEY_SERIALIZE_DEFAULT);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_to_blob(const struct sshkey *key, u_char **blobp, size_t *lenp)\n{\n\treturn to_blob(key, blobp, lenp, 0, SSHKEY_SERIALIZE_DEFAULT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\npkcs11_rsa_private_encrypt(int flen, const u_char *from, u_char *to, RSA *rsa,\n    int padding)\n{\n\tstruct sshkey key;\t/* XXX */\n\tu_char *blob, *signature = NULL;\n\tsize_t blen, slen = 0;\n\tint r, ret = -1;\n\tstruct sshbuf *msg;\n\n\tif (padding != RSA_PKCS1_PADDING)\n\t\treturn (-1);\n\tkey.type = KEY_RSA;\n\tkey.rsa = rsa;\n\tif ((r = sshkey_to_blob(&key, &blob, &blen)) != 0) {\n\t\terror(\"%s: sshkey_to_blob: %s\", __func__, ssh_err(r));\n\t\treturn -1;\n\t}\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENTC_SIGN_REQUEST)) != 0 ||\n\t    (r = sshbuf_put_string(msg, blob, blen)) != 0 ||\n\t    (r = sshbuf_put_string(msg, from, flen)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, 0)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tfree(blob);\n\tsend_msg(msg);\n\tsshbuf_reset(msg);\n\n\tif (recv_msg(msg) == SSH2_AGENT_SIGN_RESPONSE) {\n\t\tif ((r = sshbuf_get_string(msg, &signature, &slen)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif (slen <= (size_t)RSA_size(rsa)) {\n\t\t\tmemcpy(to, signature, slen);\n\t\t\tret = slen;\n\t\t}\n\t\tfree(signature);\n\t}\n\tsshbuf_free(msg);\n\treturn (ret);\n}"
  },
  {
    "function_name": "pkcs11_terminate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
    "lines": "108-113",
    "snippet": "void\npkcs11_terminate(void)\n{\n\tif (fd >= 0)\n\t\tclose(fd);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"xmalloc.h\"",
      "#include \"pathnames.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rsa.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\npkcs11_terminate(void)\n{\n\tif (fd >= 0)\n\t\tclose(fd);\n}"
  },
  {
    "function_name": "pkcs11_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
    "lines": "102-106",
    "snippet": "int\npkcs11_init(int interactive)\n{\n\treturn (0);\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"xmalloc.h\"",
      "#include \"pathnames.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rsa.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\npkcs11_init(int interactive)\n{\n\treturn (0);\n}"
  },
  {
    "function_name": "recv_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
    "lines": "69-100",
    "snippet": "static int\nrecv_msg(struct sshbuf *m)\n{\n\tu_int l, len;\n\tu_char c, buf[1024];\n\tint r;\n\n\tif ((len = atomicio(read, fd, buf, 4)) != 4) {\n\t\terror(\"read from helper failed: %u\", len);\n\t\treturn (0); /* XXX */\n\t}\n\tlen = PEEK_U32(buf);\n\tif (len > 256 * 1024)\n\t\tfatal(\"response too long: %u\", len);\n\t/* read len bytes into m */\n\tsshbuf_reset(m);\n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (l > sizeof(buf))\n\t\t\tl = sizeof(buf);\n\t\tif (atomicio(read, fd, buf, l) != l) {\n\t\t\terror(\"response from helper failed.\");\n\t\t\treturn (0); /* XXX */\n\t\t}\n\t\tif ((r = sshbuf_put(m, buf, l)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tlen -= l;\n\t}\n\tif ((r = sshbuf_get_u8(m, &c)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\treturn c;\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"xmalloc.h\"",
      "#include \"pathnames.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rsa.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "m",
            "&c"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "m",
            "buf",
            "l"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"response from helper failed.\""
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomicio",
          "args": [
            "read",
            "fd",
            "buf",
            "l"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "atomiciov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "165-170",
          "snippet": "size_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "m"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"response too long: %u\"",
            "len"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PEEK_U32",
          "args": [
            "buf"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nrecv_msg(struct sshbuf *m)\n{\n\tu_int l, len;\n\tu_char c, buf[1024];\n\tint r;\n\n\tif ((len = atomicio(read, fd, buf, 4)) != 4) {\n\t\terror(\"read from helper failed: %u\", len);\n\t\treturn (0); /* XXX */\n\t}\n\tlen = PEEK_U32(buf);\n\tif (len > 256 * 1024)\n\t\tfatal(\"response too long: %u\", len);\n\t/* read len bytes into m */\n\tsshbuf_reset(m);\n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (l > sizeof(buf))\n\t\t\tl = sizeof(buf);\n\t\tif (atomicio(read, fd, buf, l) != l) {\n\t\t\terror(\"response from helper failed.\");\n\t\t\treturn (0); /* XXX */\n\t\t}\n\t\tif ((r = sshbuf_put(m, buf, l)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tlen -= l;\n\t}\n\tif ((r = sshbuf_get_u8(m, &c)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\treturn c;\n}"
  },
  {
    "function_name": "send_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-pkcs11-client.c",
    "lines": "53-67",
    "snippet": "static void\nsend_msg(struct sshbuf *m)\n{\n\tu_char buf[4];\n\tsize_t mlen = sshbuf_len(m);\n\tint r;\n\n\tPOKE_U32(buf, mlen);\n\tif (atomicio(vwrite, fd, buf, 4) != 4 ||\n\t    atomicio(vwrite, fd, sshbuf_mutable_ptr(m),\n\t    sshbuf_len(m)) != sshbuf_len(m))\n\t\terror(\"write to helper failed\");\n\tif ((r = sshbuf_consume(m, mlen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}",
    "includes": [
      "#include \"ssherr.h\"",
      "#include \"ssh-pkcs11.h\"",
      "#include \"atomicio.h\"",
      "#include \"authfd.h\"",
      "#include \"sshkey.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"sshbuf.h\"",
      "#include \"xmalloc.h\"",
      "#include \"pathnames.h\"",
      "#include \"openbsd-compat/openssl-compat.h\"",
      "#include <openssl/rsa.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <sys/socket.h>",
      "# include <sys/time.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_consume",
          "args": [
            "m",
            "mlen"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_consume_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "383-398",
          "snippet": "int\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"write to helper failed\""
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "m"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomicio",
          "args": [
            "vwrite",
            "fd",
            "sshbuf_mutable_ptr(m)",
            "sshbuf_len(m)"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "atomiciov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "165-170",
          "snippet": "size_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_mutable_ptr",
          "args": [
            "m"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_mutable_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "276-282",
          "snippet": "u_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "POKE_U32",
          "args": [
            "buf",
            "mlen"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"pathnames.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/rsa.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/socket.h>\n# include <sys/time.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsend_msg(struct sshbuf *m)\n{\n\tu_char buf[4];\n\tsize_t mlen = sshbuf_len(m);\n\tint r;\n\n\tPOKE_U32(buf, mlen);\n\tif (atomicio(vwrite, fd, buf, 4) != 4 ||\n\t    atomicio(vwrite, fd, sshbuf_mutable_ptr(m),\n\t    sshbuf_len(m)) != sshbuf_len(m))\n\t\terror(\"write to helper failed\");\n\tif ((r = sshbuf_consume(m, mlen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}"
  }
]