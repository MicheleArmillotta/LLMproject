[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server-main.c",
    "lines": "37-53",
    "snippet": "int\nmain(int argc, char **argv)\n{\n\tstruct passwd *user_pw;\n\n\tssh_malloc_init();\t/* must be called before any mallocs */\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\tif ((user_pw = getpwuid(getuid())) == NULL) {\n\t\tfprintf(stderr, \"No user found for uid %lu\\n\",\n\t\t    (u_long)getuid());\n\t\treturn 1;\n\t}\n\n\treturn (sftp_server_main(argc, argv, user_pw));\n}",
    "includes": [
      "#include \"xmalloc.h\"",
      "#include \"misc.h\"",
      "#include \"sftp.h\"",
      "#include \"log.h\"",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sftp_server_main",
          "args": [
            "argc",
            "argv",
            "user_pw"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_main",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1499-1710",
          "snippet": "int\nsftp_server_main(int argc, char **argv, struct passwd *user_pw)\n{\n\tfd_set *rset, *wset;\n\tint i, r, in, out, max, ch, skipargs = 0, log_stderr = 0;\n\tssize_t len, olen, set_size;\n\tSyslogFacility log_facility = SYSLOG_FACILITY_AUTH;\n\tchar *cp, *homedir = NULL, uidstr[32], buf[4*4096];\n\tlong mask;\n\n\textern char *optarg;\n\textern char *__progname;\n\n\tssh_malloc_init();\t/* must be called before any mallocs */\n\t__progname = ssh_get_progname(argv[0]);\n\tlog_init(__progname, log_level, log_facility, log_stderr);\n\n\tpw = pwcopy(user_pw);\n\n\twhile (!skipargs && (ch = getopt(argc, argv,\n\t    \"d:f:l:P:p:Q:u:cehR\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'Q':\n\t\t\tif (strcasecmp(optarg, \"requests\") != 0) {\n\t\t\t\tfprintf(stderr, \"Invalid query type\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfor (i = 0; handlers[i].handler != NULL; i++)\n\t\t\t\tprintf(\"%s\\n\", handlers[i].name);\n\t\t\tfor (i = 0; extended_handlers[i].handler != NULL; i++)\n\t\t\t\tprintf(\"%s\\n\", extended_handlers[i].name);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\treadonly = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\t/*\n\t\t\t * Ignore all arguments if we are invoked as a\n\t\t\t * shell using \"sftp-server -c command\"\n\t\t\t */\n\t\t\tskipargs = 1;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tlog_stderr = 1;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlog_level = log_level_number(optarg);\n\t\t\tif (log_level == SYSLOG_LEVEL_NOT_SET)\n\t\t\t\terror(\"Invalid log level \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tlog_facility = log_facility_number(optarg);\n\t\t\tif (log_facility == SYSLOG_FACILITY_NOT_SET)\n\t\t\t\terror(\"Invalid log facility \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tcp = tilde_expand_filename(optarg, user_pw->pw_uid);\n\t\t\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t\t\t    (unsigned long long)pw->pw_uid);\n\t\t\thomedir = percent_expand(cp, \"d\", user_pw->pw_dir,\n\t\t\t    \"u\", user_pw->pw_name, \"U\", uidstr, (char *)NULL);\n\t\t\tfree(cp);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif (request_whitelist != NULL)\n\t\t\t\tfatal(\"Permitted requests already set\");\n\t\t\trequest_whitelist = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (request_blacklist != NULL)\n\t\t\t\tfatal(\"Refused requests already set\");\n\t\t\trequest_blacklist = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\terrno = 0;\n\t\t\tmask = strtol(optarg, &cp, 8);\n\t\t\tif (mask < 0 || mask > 0777 || *cp != '\\0' ||\n\t\t\t    cp == optarg || (mask == 0 && errno != 0))\n\t\t\t\tfatal(\"Invalid umask \\\"%s\\\"\", optarg);\n\t\t\t(void)umask((mode_t)mask);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\tsftp_server_usage();\n\t\t}\n\t}\n\n\tlog_init(__progname, log_level, log_facility, log_stderr);\n\n\t/*\n\t * On platforms where we can, avoid making /proc/self/{mem,maps}\n\t * available to the user so that sftp access doesn't automatically\n\t * imply arbitrary code execution access that will break\n\t * restricted configurations.\n\t */\n\tplatform_disable_tracing(1);\t/* strict */\n\n\t/* Drop any fine-grained privileges we don't need */\n\tplatform_pledge_sftp_server();\n\n\tif ((cp = getenv(\"SSH_CONNECTION\")) != NULL) {\n\t\tclient_addr = xstrdup(cp);\n\t\tif ((cp = strchr(client_addr, ' ')) == NULL) {\n\t\t\terror(\"Malformed SSH_CONNECTION variable: \\\"%s\\\"\",\n\t\t\t    getenv(\"SSH_CONNECTION\"));\n\t\t\tsftp_server_cleanup_exit(255);\n\t\t}\n\t\t*cp = '\\0';\n\t} else\n\t\tclient_addr = xstrdup(\"UNKNOWN\");\n\n\tlogit(\"session opened for local user %s from [%s]\",\n\t    pw->pw_name, client_addr);\n\n\tin = STDIN_FILENO;\n\tout = STDOUT_FILENO;\n\n#ifdef HAVE_CYGWIN\n\tsetmode(in, O_BINARY);\n\tsetmode(out, O_BINARY);\n#endif\n\n\tmax = 0;\n\tif (in > max)\n\t\tmax = in;\n\tif (out > max)\n\t\tmax = out;\n\n\tif ((iqueue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((oqueue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\trset = xcalloc(howmany(max + 1, NFDBITS), sizeof(fd_mask));\n\twset = xcalloc(howmany(max + 1, NFDBITS), sizeof(fd_mask));\n\n\tif (homedir != NULL) {\n\t\tif (chdir(homedir) != 0) {\n\t\t\terror(\"chdir to \\\"%s\\\" failed: %s\", homedir,\n\t\t\t    strerror(errno));\n\t\t}\n\t}\n\n\tset_size = howmany(max + 1, NFDBITS) * sizeof(fd_mask);\n\tfor (;;) {\n\t\tmemset(rset, 0, set_size);\n\t\tmemset(wset, 0, set_size);\n\n\t\t/*\n\t\t * Ensure that we can read a full buffer and handle\n\t\t * the worst-case length packet it can generate,\n\t\t * otherwise apply backpressure by stopping reads.\n\t\t */\n\t\tif ((r = sshbuf_check_reserve(iqueue, sizeof(buf))) == 0 &&\n\t\t    (r = sshbuf_check_reserve(oqueue,\n\t\t    SFTP_MAX_MSG_LENGTH)) == 0)\n\t\t\tFD_SET(in, rset);\n\t\telse if (r != SSH_ERR_NO_BUFFER_SPACE)\n\t\t\tfatal(\"%s: sshbuf_check_reserve failed: %s\",\n\t\t\t    __func__, ssh_err(r));\n\n\t\tolen = sshbuf_len(oqueue);\n\t\tif (olen > 0)\n\t\t\tFD_SET(out, wset);\n\n\t\tif (select(max+1, rset, wset, NULL, NULL) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\terror(\"select: %s\", strerror(errno));\n\t\t\tsftp_server_cleanup_exit(2);\n\t\t}\n\n\t\t/* copy stdin to iqueue */\n\t\tif (FD_ISSET(in, rset)) {\n\t\t\tlen = read(in, buf, sizeof buf);\n\t\t\tif (len == 0) {\n\t\t\t\tdebug(\"read eof\");\n\t\t\t\tsftp_server_cleanup_exit(0);\n\t\t\t} else if (len < 0) {\n\t\t\t\terror(\"read: %s\", strerror(errno));\n\t\t\t\tsftp_server_cleanup_exit(1);\n\t\t\t} else if ((r = sshbuf_put(iqueue, buf, len)) != 0) {\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t}\n\t\t/* send oqueue to stdout */\n\t\tif (FD_ISSET(out, wset)) {\n\t\t\tlen = write(out, sshbuf_ptr(oqueue), olen);\n\t\t\tif (len < 0) {\n\t\t\t\terror(\"write: %s\", strerror(errno));\n\t\t\t\tsftp_server_cleanup_exit(1);\n\t\t\t} else if ((r = sshbuf_consume(oqueue, len)) != 0) {\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Process requests from client if we can fit the results\n\t\t * into the output buffer, otherwise stop processing input\n\t\t * and let the output queue drain.\n\t\t */\n\t\tr = sshbuf_check_reserve(oqueue, SFTP_MAX_MSG_LENGTH);\n\t\tif (r == 0)\n\t\t\tprocess();\n\t\telse if (r != SSH_ERR_NO_BUFFER_SPACE)\n\t\t\tfatal(\"%s: sshbuf_check_reserve: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t}\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LogLevel log_level = SYSLOG_LEVEL_ERROR;",
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;",
            "struct sshbuf *iqueue;",
            "struct sshbuf *oqueue;",
            "static int readonly;",
            "static char *request_whitelist, *request_blacklist;",
            "struct sftp_handler handlers[] = {\n\t/* NB. SSH2_FXP_OPEN does the readonly check in the handler itself */\n\t{ \"open\", NULL, SSH2_FXP_OPEN, process_open, 0 },\n\t{ \"close\", NULL, SSH2_FXP_CLOSE, process_close, 0 },\n\t{ \"read\", NULL, SSH2_FXP_READ, process_read, 0 },\n\t{ \"write\", NULL, SSH2_FXP_WRITE, process_write, 1 },\n\t{ \"lstat\", NULL, SSH2_FXP_LSTAT, process_lstat, 0 },\n\t{ \"fstat\", NULL, SSH2_FXP_FSTAT, process_fstat, 0 },\n\t{ \"setstat\", NULL, SSH2_FXP_SETSTAT, process_setstat, 1 },\n\t{ \"fsetstat\", NULL, SSH2_FXP_FSETSTAT, process_fsetstat, 1 },\n\t{ \"opendir\", NULL, SSH2_FXP_OPENDIR, process_opendir, 0 },\n\t{ \"readdir\", NULL, SSH2_FXP_READDIR, process_readdir, 0 },\n\t{ \"remove\", NULL, SSH2_FXP_REMOVE, process_remove, 1 },\n\t{ \"mkdir\", NULL, SSH2_FXP_MKDIR, process_mkdir, 1 },\n\t{ \"rmdir\", NULL, SSH2_FXP_RMDIR, process_rmdir, 1 },\n\t{ \"realpath\", NULL, SSH2_FXP_REALPATH, process_realpath, 0 },\n\t{ \"stat\", NULL, SSH2_FXP_STAT, process_stat, 0 },\n\t{ \"rename\", NULL, SSH2_FXP_RENAME, process_rename, 1 },\n\t{ \"readlink\", NULL, SSH2_FXP_READLINK, process_readlink, 0 },\n\t{ \"symlink\", NULL, SSH2_FXP_SYMLINK, process_symlink, 1 },\n\t{ NULL, NULL, 0, NULL, 0 }\n};",
            "struct sftp_handler extended_handlers[] = {\n\t{ \"posix-rename\", \"posix-rename@openssh.com\", 0,\n\t   process_extended_posix_rename, 1 },\n\t{ \"statvfs\", \"statvfs@openssh.com\", 0, process_extended_statvfs, 0 },\n\t{ \"fstatvfs\", \"fstatvfs@openssh.com\", 0, process_extended_fstatvfs, 0 },\n\t{ \"hardlink\", \"hardlink@openssh.com\", 0, process_extended_hardlink, 1 },\n\t{ \"fsync\", \"fsync@openssh.com\", 0, process_extended_fsync, 1 },\n\t{ NULL, NULL, 0, NULL, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic LogLevel log_level = SYSLOG_LEVEL_ERROR;\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\nstruct sshbuf *iqueue;\nstruct sshbuf *oqueue;\nstatic int readonly;\nstatic char *request_whitelist, *request_blacklist;\nstruct sftp_handler handlers[] = {\n\t/* NB. SSH2_FXP_OPEN does the readonly check in the handler itself */\n\t{ \"open\", NULL, SSH2_FXP_OPEN, process_open, 0 },\n\t{ \"close\", NULL, SSH2_FXP_CLOSE, process_close, 0 },\n\t{ \"read\", NULL, SSH2_FXP_READ, process_read, 0 },\n\t{ \"write\", NULL, SSH2_FXP_WRITE, process_write, 1 },\n\t{ \"lstat\", NULL, SSH2_FXP_LSTAT, process_lstat, 0 },\n\t{ \"fstat\", NULL, SSH2_FXP_FSTAT, process_fstat, 0 },\n\t{ \"setstat\", NULL, SSH2_FXP_SETSTAT, process_setstat, 1 },\n\t{ \"fsetstat\", NULL, SSH2_FXP_FSETSTAT, process_fsetstat, 1 },\n\t{ \"opendir\", NULL, SSH2_FXP_OPENDIR, process_opendir, 0 },\n\t{ \"readdir\", NULL, SSH2_FXP_READDIR, process_readdir, 0 },\n\t{ \"remove\", NULL, SSH2_FXP_REMOVE, process_remove, 1 },\n\t{ \"mkdir\", NULL, SSH2_FXP_MKDIR, process_mkdir, 1 },\n\t{ \"rmdir\", NULL, SSH2_FXP_RMDIR, process_rmdir, 1 },\n\t{ \"realpath\", NULL, SSH2_FXP_REALPATH, process_realpath, 0 },\n\t{ \"stat\", NULL, SSH2_FXP_STAT, process_stat, 0 },\n\t{ \"rename\", NULL, SSH2_FXP_RENAME, process_rename, 1 },\n\t{ \"readlink\", NULL, SSH2_FXP_READLINK, process_readlink, 0 },\n\t{ \"symlink\", NULL, SSH2_FXP_SYMLINK, process_symlink, 1 },\n\t{ NULL, NULL, 0, NULL, 0 }\n};\nstruct sftp_handler extended_handlers[] = {\n\t{ \"posix-rename\", \"posix-rename@openssh.com\", 0,\n\t   process_extended_posix_rename, 1 },\n\t{ \"statvfs\", \"statvfs@openssh.com\", 0, process_extended_statvfs, 0 },\n\t{ \"fstatvfs\", \"fstatvfs@openssh.com\", 0, process_extended_fstatvfs, 0 },\n\t{ \"hardlink\", \"hardlink@openssh.com\", 0, process_extended_hardlink, 1 },\n\t{ \"fsync\", \"fsync@openssh.com\", 0, process_extended_fsync, 1 },\n\t{ NULL, NULL, 0, NULL, 0 }\n};\n\nint\nsftp_server_main(int argc, char **argv, struct passwd *user_pw)\n{\n\tfd_set *rset, *wset;\n\tint i, r, in, out, max, ch, skipargs = 0, log_stderr = 0;\n\tssize_t len, olen, set_size;\n\tSyslogFacility log_facility = SYSLOG_FACILITY_AUTH;\n\tchar *cp, *homedir = NULL, uidstr[32], buf[4*4096];\n\tlong mask;\n\n\textern char *optarg;\n\textern char *__progname;\n\n\tssh_malloc_init();\t/* must be called before any mallocs */\n\t__progname = ssh_get_progname(argv[0]);\n\tlog_init(__progname, log_level, log_facility, log_stderr);\n\n\tpw = pwcopy(user_pw);\n\n\twhile (!skipargs && (ch = getopt(argc, argv,\n\t    \"d:f:l:P:p:Q:u:cehR\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'Q':\n\t\t\tif (strcasecmp(optarg, \"requests\") != 0) {\n\t\t\t\tfprintf(stderr, \"Invalid query type\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfor (i = 0; handlers[i].handler != NULL; i++)\n\t\t\t\tprintf(\"%s\\n\", handlers[i].name);\n\t\t\tfor (i = 0; extended_handlers[i].handler != NULL; i++)\n\t\t\t\tprintf(\"%s\\n\", extended_handlers[i].name);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\treadonly = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\t/*\n\t\t\t * Ignore all arguments if we are invoked as a\n\t\t\t * shell using \"sftp-server -c command\"\n\t\t\t */\n\t\t\tskipargs = 1;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tlog_stderr = 1;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlog_level = log_level_number(optarg);\n\t\t\tif (log_level == SYSLOG_LEVEL_NOT_SET)\n\t\t\t\terror(\"Invalid log level \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tlog_facility = log_facility_number(optarg);\n\t\t\tif (log_facility == SYSLOG_FACILITY_NOT_SET)\n\t\t\t\terror(\"Invalid log facility \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tcp = tilde_expand_filename(optarg, user_pw->pw_uid);\n\t\t\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t\t\t    (unsigned long long)pw->pw_uid);\n\t\t\thomedir = percent_expand(cp, \"d\", user_pw->pw_dir,\n\t\t\t    \"u\", user_pw->pw_name, \"U\", uidstr, (char *)NULL);\n\t\t\tfree(cp);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif (request_whitelist != NULL)\n\t\t\t\tfatal(\"Permitted requests already set\");\n\t\t\trequest_whitelist = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (request_blacklist != NULL)\n\t\t\t\tfatal(\"Refused requests already set\");\n\t\t\trequest_blacklist = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\terrno = 0;\n\t\t\tmask = strtol(optarg, &cp, 8);\n\t\t\tif (mask < 0 || mask > 0777 || *cp != '\\0' ||\n\t\t\t    cp == optarg || (mask == 0 && errno != 0))\n\t\t\t\tfatal(\"Invalid umask \\\"%s\\\"\", optarg);\n\t\t\t(void)umask((mode_t)mask);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\tsftp_server_usage();\n\t\t}\n\t}\n\n\tlog_init(__progname, log_level, log_facility, log_stderr);\n\n\t/*\n\t * On platforms where we can, avoid making /proc/self/{mem,maps}\n\t * available to the user so that sftp access doesn't automatically\n\t * imply arbitrary code execution access that will break\n\t * restricted configurations.\n\t */\n\tplatform_disable_tracing(1);\t/* strict */\n\n\t/* Drop any fine-grained privileges we don't need */\n\tplatform_pledge_sftp_server();\n\n\tif ((cp = getenv(\"SSH_CONNECTION\")) != NULL) {\n\t\tclient_addr = xstrdup(cp);\n\t\tif ((cp = strchr(client_addr, ' ')) == NULL) {\n\t\t\terror(\"Malformed SSH_CONNECTION variable: \\\"%s\\\"\",\n\t\t\t    getenv(\"SSH_CONNECTION\"));\n\t\t\tsftp_server_cleanup_exit(255);\n\t\t}\n\t\t*cp = '\\0';\n\t} else\n\t\tclient_addr = xstrdup(\"UNKNOWN\");\n\n\tlogit(\"session opened for local user %s from [%s]\",\n\t    pw->pw_name, client_addr);\n\n\tin = STDIN_FILENO;\n\tout = STDOUT_FILENO;\n\n#ifdef HAVE_CYGWIN\n\tsetmode(in, O_BINARY);\n\tsetmode(out, O_BINARY);\n#endif\n\n\tmax = 0;\n\tif (in > max)\n\t\tmax = in;\n\tif (out > max)\n\t\tmax = out;\n\n\tif ((iqueue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((oqueue = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\trset = xcalloc(howmany(max + 1, NFDBITS), sizeof(fd_mask));\n\twset = xcalloc(howmany(max + 1, NFDBITS), sizeof(fd_mask));\n\n\tif (homedir != NULL) {\n\t\tif (chdir(homedir) != 0) {\n\t\t\terror(\"chdir to \\\"%s\\\" failed: %s\", homedir,\n\t\t\t    strerror(errno));\n\t\t}\n\t}\n\n\tset_size = howmany(max + 1, NFDBITS) * sizeof(fd_mask);\n\tfor (;;) {\n\t\tmemset(rset, 0, set_size);\n\t\tmemset(wset, 0, set_size);\n\n\t\t/*\n\t\t * Ensure that we can read a full buffer and handle\n\t\t * the worst-case length packet it can generate,\n\t\t * otherwise apply backpressure by stopping reads.\n\t\t */\n\t\tif ((r = sshbuf_check_reserve(iqueue, sizeof(buf))) == 0 &&\n\t\t    (r = sshbuf_check_reserve(oqueue,\n\t\t    SFTP_MAX_MSG_LENGTH)) == 0)\n\t\t\tFD_SET(in, rset);\n\t\telse if (r != SSH_ERR_NO_BUFFER_SPACE)\n\t\t\tfatal(\"%s: sshbuf_check_reserve failed: %s\",\n\t\t\t    __func__, ssh_err(r));\n\n\t\tolen = sshbuf_len(oqueue);\n\t\tif (olen > 0)\n\t\t\tFD_SET(out, wset);\n\n\t\tif (select(max+1, rset, wset, NULL, NULL) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\terror(\"select: %s\", strerror(errno));\n\t\t\tsftp_server_cleanup_exit(2);\n\t\t}\n\n\t\t/* copy stdin to iqueue */\n\t\tif (FD_ISSET(in, rset)) {\n\t\t\tlen = read(in, buf, sizeof buf);\n\t\t\tif (len == 0) {\n\t\t\t\tdebug(\"read eof\");\n\t\t\t\tsftp_server_cleanup_exit(0);\n\t\t\t} else if (len < 0) {\n\t\t\t\terror(\"read: %s\", strerror(errno));\n\t\t\t\tsftp_server_cleanup_exit(1);\n\t\t\t} else if ((r = sshbuf_put(iqueue, buf, len)) != 0) {\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t}\n\t\t/* send oqueue to stdout */\n\t\tif (FD_ISSET(out, wset)) {\n\t\t\tlen = write(out, sshbuf_ptr(oqueue), olen);\n\t\t\tif (len < 0) {\n\t\t\t\terror(\"write: %s\", strerror(errno));\n\t\t\t\tsftp_server_cleanup_exit(1);\n\t\t\t} else if ((r = sshbuf_consume(oqueue, len)) != 0) {\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Process requests from client if we can fit the results\n\t\t * into the output buffer, otherwise stop processing input\n\t\t * and let the output queue drain.\n\t\t */\n\t\tr = sshbuf_check_reserve(oqueue, SFTP_MAX_MSG_LENGTH);\n\t\tif (r == 0)\n\t\t\tprocess();\n\t\telse if (r != SSH_ERR_NO_BUFFER_SPACE)\n\t\t\tfatal(\"%s: sshbuf_check_reserve: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"No user found for uid %lu\\n\"",
            "(u_long)getuid()"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwuid",
          "args": [
            "getuid()"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sanitise_stdfd",
          "args": [],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "sanitise_stdfd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1109-1130",
          "snippet": "void\nsanitise_stdfd(void)\n{\n\tint nullfd, dupfd;\n\n\tif ((nullfd = dupfd = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\tfprintf(stderr, \"Couldn't open /dev/null: %s\\n\",\n\t\t    strerror(errno));\n\t\texit(1);\n\t}\n\twhile (++dupfd <= STDERR_FILENO) {\n\t\t/* Only populate closed fds. */\n\t\tif (fcntl(dupfd, F_GETFL) == -1 && errno == EBADF) {\n\t\t\tif (dup2(nullfd, dupfd) == -1) {\n\t\t\t\tfprintf(stderr, \"dup2: %s\\n\", strerror(errno));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\tif (nullfd > STDERR_FILENO)\n\t\tclose(nullfd);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsanitise_stdfd(void)\n{\n\tint nullfd, dupfd;\n\n\tif ((nullfd = dupfd = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\tfprintf(stderr, \"Couldn't open /dev/null: %s\\n\",\n\t\t    strerror(errno));\n\t\texit(1);\n\t}\n\twhile (++dupfd <= STDERR_FILENO) {\n\t\t/* Only populate closed fds. */\n\t\tif (fcntl(dupfd, F_GETFL) == -1 && errno == EBADF) {\n\t\t\tif (dup2(nullfd, dupfd) == -1) {\n\t\t\t\tfprintf(stderr, \"dup2: %s\\n\", strerror(errno));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\tif (nullfd > STDERR_FILENO)\n\t\tclose(nullfd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_malloc_init",
          "args": [],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_malloc_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "29-37",
          "snippet": "void\nssh_malloc_init(void)\n{\n#if defined(__OpenBSD__)\n\textern char *malloc_options;\n\n\tmalloc_options = \"S\";\n#endif /* __OpenBSD__ */\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nssh_malloc_init(void)\n{\n#if defined(__OpenBSD__)\n\textern char *malloc_options;\n\n\tmalloc_options = \"S\";\n#endif /* __OpenBSD__ */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xmalloc.h\"\n#include \"misc.h\"\n#include \"sftp.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmain(int argc, char **argv)\n{\n\tstruct passwd *user_pw;\n\n\tssh_malloc_init();\t/* must be called before any mallocs */\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\tif ((user_pw = getpwuid(getuid())) == NULL) {\n\t\tfprintf(stderr, \"No user found for uid %lu\\n\",\n\t\t    (u_long)getuid());\n\t\treturn 1;\n\t}\n\n\treturn (sftp_server_main(argc, argv, user_pw));\n}"
  },
  {
    "function_name": "cleanup_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server-main.c",
    "lines": "31-35",
    "snippet": "void\ncleanup_exit(int i)\n{\n\tsftp_server_cleanup_exit(i);\n}",
    "includes": [
      "#include \"xmalloc.h\"",
      "#include \"misc.h\"",
      "#include \"sftp.h\"",
      "#include \"log.h\"",
      "#include <unistd.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sftp_server_cleanup_exit",
          "args": [
            "i"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xmalloc.h\"\n#include \"misc.h\"\n#include \"sftp.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ncleanup_exit(int i)\n{\n\tsftp_server_cleanup_exit(i);\n}"
  }
]