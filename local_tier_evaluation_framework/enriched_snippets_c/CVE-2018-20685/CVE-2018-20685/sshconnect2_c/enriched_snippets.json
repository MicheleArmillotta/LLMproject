[
  {
    "function_name": "authmethods_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "2139-2161",
    "snippet": "static char *\nauthmethods_get(void)\n{\n\tAuthmethod *method = NULL;\n\tstruct sshbuf *b;\n\tchar *list;\n\tint r;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tfor (method = authmethods; method->name != NULL; method++) {\n\t\tif (authmethod_is_enabled(method)) {\n\t\t\tif ((r = sshbuf_putf(b, \"%s%s\",\n\t\t\t    sshbuf_len(b) ? \",\" : \"\", method->name)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t}\n\tif ((list = sshbuf_dup_string(b)) == NULL)\n\t\tfatal(\"%s: sshbuf_dup_string failed\", __func__);\n\tsshbuf_free(b);\n\treturn list;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Authmethod *authmethod_lookup(const char *name);",
      "static char *authmethods_get(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 2159
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_dup_string failed\"",
            "__func__"
          ],
          "line": 2158
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_dup_string",
          "args": [
            "b"
          ],
          "line": 2157
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_dup_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-misc.c",
          "lines": "139-160",
          "snippet": "char *\nsshbuf_dup_string(struct sshbuf *buf)\n{\n\tconst u_char *p = NULL, *s = sshbuf_ptr(buf);\n\tsize_t l = sshbuf_len(buf);\n\tchar *r;\n\n\tif (s == NULL || l > SIZE_MAX)\n\t\treturn NULL;\n\t/* accept a nul only as the last character in the buffer */\n\tif (l > 0 && (p = memchr(s, '\\0', l)) != NULL) {\n\t\tif (p != s + l - 1)\n\t\t\treturn NULL;\n\t\tl--; /* the nul is put back below */\n\t}\n\tif ((r = malloc(l + 1)) == NULL)\n\t\treturn NULL;\n\tif (l > 0)\n\t\tmemcpy(r, s, l);\n\tr[l] = '\\0';\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <ctype.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <ctype.h>\n#include <resolv.h>\n#include <string.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshbuf_dup_string(struct sshbuf *buf)\n{\n\tconst u_char *p = NULL, *s = sshbuf_ptr(buf);\n\tsize_t l = sshbuf_len(buf);\n\tchar *r;\n\n\tif (s == NULL || l > SIZE_MAX)\n\t\treturn NULL;\n\t/* accept a nul only as the last character in the buffer */\n\tif (l > 0 && (p = memchr(s, '\\0', l)) != NULL) {\n\t\tif (p != s + l - 1)\n\t\t\treturn NULL;\n\t\tl--; /* the nul is put back below */\n\t}\n\tif ((r = malloc(l + 1)) == NULL)\n\t\treturn NULL;\n\tif (l > 0)\n\t\tmemcpy(r, s, l);\n\tr[l] = '\\0';\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 2153
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_putf",
          "args": [
            "b",
            "\"%s%s\"",
            "sshbuf_len(b) ? \",\" : \"\"",
            "method->name"
          ],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "b"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "authmethod_is_enabled",
          "args": [
            "method"
          ],
          "line": 2150
        },
        "resolved": true,
        "details": {
          "function_name": "authmethod_is_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "2063-2075",
          "snippet": "static int\nauthmethod_is_enabled(Authmethod *method)\n{\n\tif (method == NULL)\n\t\treturn 0;\n\t/* return false if options indicate this method is disabled */\n\tif  (method->enabled == NULL || *method->enabled == 0)\n\t\treturn 0;\n\t/* return false if batch mode is enabled but method needs interactive mode */\n\tif  (method->batch_flag != NULL && *method->batch_flag != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nstatic int\nauthmethod_is_enabled(Authmethod *method)\n{\n\tif (method == NULL)\n\t\treturn 0;\n\t/* return false if options indicate this method is disabled */\n\tif  (method->enabled == NULL || *method->enabled == 0)\n\t\treturn 0;\n\t/* return false if batch mode is enabled but method needs interactive mode */\n\tif  (method->batch_flag != NULL && *method->batch_flag != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Authmethod *authmethod_lookup(const char *name);\nstatic char *authmethods_get(void);\n\nstatic char *\nauthmethods_get(void)\n{\n\tAuthmethod *method = NULL;\n\tstruct sshbuf *b;\n\tchar *list;\n\tint r;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tfor (method = authmethods; method->name != NULL; method++) {\n\t\tif (authmethod_is_enabled(method)) {\n\t\t\tif ((r = sshbuf_putf(b, \"%s%s\",\n\t\t\t    sshbuf_len(b) ? \",\" : \"\", method->name)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t}\n\tif ((list = sshbuf_dup_string(b)) == NULL)\n\t\tfatal(\"%s: sshbuf_dup_string failed\", __func__);\n\tsshbuf_free(b);\n\treturn list;\n}"
  },
  {
    "function_name": "authmethod_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "2099-2137",
    "snippet": "static Authmethod *\nauthmethod_get(char *authlist)\n{\n\tchar *name = NULL;\n\tu_int next;\n\n\t/* Use a suitable default if we're passed a nil list.  */\n\tif (authlist == NULL || strlen(authlist) == 0)\n\t\tauthlist = options.preferred_authentications;\n\n\tif (supported == NULL || strcmp(authlist, supported) != 0) {\n\t\tdebug3(\"start over, passed a different list %s\", authlist);\n\t\tfree(supported);\n\t\tsupported = xstrdup(authlist);\n\t\tpreferred = options.preferred_authentications;\n\t\tdebug3(\"preferred %s\", preferred);\n\t\tcurrent = NULL;\n\t} else if (current != NULL && authmethod_is_enabled(current))\n\t\treturn current;\n\n\tfor (;;) {\n\t\tif ((name = match_list(preferred, supported, &next)) == NULL) {\n\t\t\tdebug(\"No more authentication methods to try.\");\n\t\t\tcurrent = NULL;\n\t\t\treturn NULL;\n\t\t}\n\t\tpreferred += next;\n\t\tdebug3(\"authmethod_lookup %s\", name);\n\t\tdebug3(\"remaining preferred: %s\", preferred);\n\t\tif ((current = authmethod_lookup(name)) != NULL &&\n\t\t    authmethod_is_enabled(current)) {\n\t\t\tdebug3(\"authmethod_is_enabled %s\", name);\n\t\t\tdebug(\"Next authentication method: %s\", name);\n\t\t\tfree(name);\n\t\t\treturn current;\n\t\t}\n\t\tfree(name);\n\t}\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "static Authmethod *authmethod_get(char *authlist);",
      "static Authmethod *authmethod_lookup(const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "name"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Next authentication method: %s\"",
            "name"
          ],
          "line": 2131
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "authmethod_is_enabled",
          "args": [
            "current"
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "authmethod_is_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "2063-2075",
          "snippet": "static int\nauthmethod_is_enabled(Authmethod *method)\n{\n\tif (method == NULL)\n\t\treturn 0;\n\t/* return false if options indicate this method is disabled */\n\tif  (method->enabled == NULL || *method->enabled == 0)\n\t\treturn 0;\n\t/* return false if batch mode is enabled but method needs interactive mode */\n\tif  (method->batch_flag != NULL && *method->batch_flag != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nstatic int\nauthmethod_is_enabled(Authmethod *method)\n{\n\tif (method == NULL)\n\t\treturn 0;\n\t/* return false if options indicate this method is disabled */\n\tif  (method->enabled == NULL || *method->enabled == 0)\n\t\treturn 0;\n\t/* return false if batch mode is enabled but method needs interactive mode */\n\tif  (method->batch_flag != NULL && *method->batch_flag != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "authmethod_lookup",
          "args": [
            "name"
          ],
          "line": 2128
        },
        "resolved": true,
        "details": {
          "function_name": "authmethod_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "2077-2087",
          "snippet": "static Authmethod *\nauthmethod_lookup(const char *name)\n{\n\tAuthmethod *method = NULL;\n\tif (name != NULL)\n\t\tfor (method = authmethods; method->name != NULL; method++)\n\t\t\tif (strcmp(name, method->name) == 0)\n\t\t\t\treturn method;\n\tdebug2(\"Unrecognized authentication method name: %s\", name ? name : \"NULL\");\n\treturn NULL;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Authmethod *authmethod_lookup(const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Authmethod *authmethod_lookup(const char *name);\n\nstatic Authmethod *\nauthmethod_lookup(const char *name)\n{\n\tAuthmethod *method = NULL;\n\tif (name != NULL)\n\t\tfor (method = authmethods; method->name != NULL; method++)\n\t\t\tif (strcmp(name, method->name) == 0)\n\t\t\t\treturn method;\n\tdebug2(\"Unrecognized authentication method name: %s\", name ? name : \"NULL\");\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_list",
          "args": [
            "preferred",
            "supported",
            "&next"
          ],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "match_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "256-294",
          "snippet": "char *\nmatch_list(const char *client, const char *server, u_int *next)\n{\n\tchar *sproposals[MAX_PROP];\n\tchar *c, *s, *p, *ret, *cp, *sp;\n\tint i, j, nproposals;\n\n\tc = cp = xstrdup(client);\n\ts = sp = xstrdup(server);\n\n\tfor ((p = strsep(&sp, SEP)), i=0; p && *p != '\\0';\n\t    (p = strsep(&sp, SEP)), i++) {\n\t\tif (i < MAX_PROP)\n\t\t\tsproposals[i] = p;\n\t\telse\n\t\t\tbreak;\n\t}\n\tnproposals = i;\n\n\tfor ((p = strsep(&cp, SEP)), i=0; p && *p != '\\0';\n\t    (p = strsep(&cp, SEP)), i++) {\n\t\tfor (j = 0; j < nproposals; j++) {\n\t\t\tif (strcmp(p, sproposals[j]) == 0) {\n\t\t\t\tret = xstrdup(p);\n\t\t\t\tif (next != NULL)\n\t\t\t\t\t*next = (cp == NULL) ?\n\t\t\t\t\t    strlen(c) : (u_int)(cp - c);\n\t\t\t\tfree(c);\n\t\t\t\tfree(s);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\tif (next != NULL)\n\t\t*next = strlen(c);\n\tfree(c);\n\tfree(s);\n\treturn NULL;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tSEP\t\",\"",
            "#define\tMAX_PROP\t40"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define\tSEP\t\",\"\n#define\tMAX_PROP\t40\n\nchar *\nmatch_list(const char *client, const char *server, u_int *next)\n{\n\tchar *sproposals[MAX_PROP];\n\tchar *c, *s, *p, *ret, *cp, *sp;\n\tint i, j, nproposals;\n\n\tc = cp = xstrdup(client);\n\ts = sp = xstrdup(server);\n\n\tfor ((p = strsep(&sp, SEP)), i=0; p && *p != '\\0';\n\t    (p = strsep(&sp, SEP)), i++) {\n\t\tif (i < MAX_PROP)\n\t\t\tsproposals[i] = p;\n\t\telse\n\t\t\tbreak;\n\t}\n\tnproposals = i;\n\n\tfor ((p = strsep(&cp, SEP)), i=0; p && *p != '\\0';\n\t    (p = strsep(&cp, SEP)), i++) {\n\t\tfor (j = 0; j < nproposals; j++) {\n\t\t\tif (strcmp(p, sproposals[j]) == 0) {\n\t\t\t\tret = xstrdup(p);\n\t\t\t\tif (next != NULL)\n\t\t\t\t\t*next = (cp == NULL) ?\n\t\t\t\t\t    strlen(c) : (u_int)(cp - c);\n\t\t\t\tfree(c);\n\t\t\t\tfree(s);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\tif (next != NULL)\n\t\t*next = strlen(c);\n\tfree(c);\n\tfree(s);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "authlist"
          ],
          "line": 2112
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "authlist",
            "supported"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "authlist"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nstatic Authmethod *authmethod_get(char *authlist);\nstatic Authmethod *authmethod_lookup(const char *name);\n\nstatic Authmethod *\nauthmethod_get(char *authlist)\n{\n\tchar *name = NULL;\n\tu_int next;\n\n\t/* Use a suitable default if we're passed a nil list.  */\n\tif (authlist == NULL || strlen(authlist) == 0)\n\t\tauthlist = options.preferred_authentications;\n\n\tif (supported == NULL || strcmp(authlist, supported) != 0) {\n\t\tdebug3(\"start over, passed a different list %s\", authlist);\n\t\tfree(supported);\n\t\tsupported = xstrdup(authlist);\n\t\tpreferred = options.preferred_authentications;\n\t\tdebug3(\"preferred %s\", preferred);\n\t\tcurrent = NULL;\n\t} else if (current != NULL && authmethod_is_enabled(current))\n\t\treturn current;\n\n\tfor (;;) {\n\t\tif ((name = match_list(preferred, supported, &next)) == NULL) {\n\t\t\tdebug(\"No more authentication methods to try.\");\n\t\t\tcurrent = NULL;\n\t\t\treturn NULL;\n\t\t}\n\t\tpreferred += next;\n\t\tdebug3(\"authmethod_lookup %s\", name);\n\t\tdebug3(\"remaining preferred: %s\", preferred);\n\t\tif ((current = authmethod_lookup(name)) != NULL &&\n\t\t    authmethod_is_enabled(current)) {\n\t\t\tdebug3(\"authmethod_is_enabled %s\", name);\n\t\t\tdebug(\"Next authentication method: %s\", name);\n\t\t\tfree(name);\n\t\t\treturn current;\n\t\t}\n\t\tfree(name);\n\t}\n}"
  },
  {
    "function_name": "authmethod_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "2077-2087",
    "snippet": "static Authmethod *\nauthmethod_lookup(const char *name)\n{\n\tAuthmethod *method = NULL;\n\tif (name != NULL)\n\t\tfor (method = authmethods; method->name != NULL; method++)\n\t\t\tif (strcmp(name, method->name) == 0)\n\t\t\t\treturn method;\n\tdebug2(\"Unrecognized authentication method name: %s\", name ? name : \"NULL\");\n\treturn NULL;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Authmethod *authmethod_lookup(const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"Unrecognized authentication method name: %s\"",
            "name ? name : \"NULL\""
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "method->name"
          ],
          "line": 2083
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Authmethod *authmethod_lookup(const char *name);\n\nstatic Authmethod *\nauthmethod_lookup(const char *name)\n{\n\tAuthmethod *method = NULL;\n\tif (name != NULL)\n\t\tfor (method = authmethods; method->name != NULL; method++)\n\t\t\tif (strcmp(name, method->name) == 0)\n\t\t\t\treturn method;\n\tdebug2(\"Unrecognized authentication method name: %s\", name ? name : \"NULL\");\n\treturn NULL;\n}"
  },
  {
    "function_name": "authmethod_is_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "2063-2075",
    "snippet": "static int\nauthmethod_is_enabled(Authmethod *method)\n{\n\tif (method == NULL)\n\t\treturn 0;\n\t/* return false if options indicate this method is disabled */\n\tif  (method->enabled == NULL || *method->enabled == 0)\n\t\treturn 0;\n\t/* return false if batch mode is enabled but method needs interactive mode */\n\tif  (method->batch_flag != NULL && *method->batch_flag != 0)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nstatic int\nauthmethod_is_enabled(Authmethod *method)\n{\n\tif (method == NULL)\n\t\treturn 0;\n\t/* return false if options indicate this method is disabled */\n\tif  (method->enabled == NULL || *method->enabled == 0)\n\t\treturn 0;\n\t/* return false if batch mode is enabled but method needs interactive mode */\n\tif  (method->batch_flag != NULL && *method->batch_flag != 0)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "userauth_hostbased",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "1921-2055",
    "snippet": "int\nuserauth_hostbased(Authctxt *authctxt)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tstruct sshkey *private = NULL;\n\tstruct sshbuf *b = NULL;\n\tu_char *sig = NULL, *keyblob = NULL;\n\tchar *fp = NULL, *chost = NULL, *lname = NULL;\n\tsize_t siglen = 0, keylen = 0;\n\tint i, r, success = 0;\n\n\tif (authctxt->ktypes == NULL) {\n\t\tauthctxt->oktypes = xstrdup(options.hostbased_key_types);\n\t\tauthctxt->ktypes = authctxt->oktypes;\n\t}\n\n\t/*\n\t * Work through each listed type pattern in HostbasedKeyTypes,\n\t * trying each hostkey that matches the type in turn.\n\t */\n\tfor (;;) {\n\t\tif (authctxt->active_ktype == NULL)\n\t\t\tauthctxt->active_ktype = strsep(&authctxt->ktypes, \",\");\n\t\tif (authctxt->active_ktype == NULL ||\n\t\t    *authctxt->active_ktype == '\\0')\n\t\t\tbreak;\n\t\tdebug3(\"%s: trying key type %s\", __func__,\n\t\t    authctxt->active_ktype);\n\n\t\t/* check for a useful key */\n\t\tprivate = NULL;\n\t\tfor (i = 0; i < authctxt->sensitive->nkeys; i++) {\n\t\t\tif (authctxt->sensitive->keys[i] == NULL ||\n\t\t\t    authctxt->sensitive->keys[i]->type == KEY_UNSPEC)\n\t\t\t\tcontinue;\n\t\t\tif (match_pattern_list(\n\t\t\t    sshkey_ssh_name(authctxt->sensitive->keys[i]),\n\t\t\t    authctxt->active_ktype, 0) != 1)\n\t\t\t\tcontinue;\n\t\t\t/* we take and free the key */\n\t\t\tprivate = authctxt->sensitive->keys[i];\n\t\t\tauthctxt->sensitive->keys[i] = NULL;\n\t\t\tbreak;\n\t\t}\n\t\t/* Found one */\n\t\tif (private != NULL)\n\t\t\tbreak;\n\t\t/* No more keys of this type; advance */\n\t\tauthctxt->active_ktype = NULL;\n\t}\n\tif (private == NULL) {\n\t\tfree(authctxt->oktypes);\n\t\tauthctxt->oktypes = authctxt->ktypes = NULL;\n\t\tauthctxt->active_ktype = NULL;\n\t\tdebug(\"No more client hostkeys for hostbased authentication.\");\n\t\tgoto out;\n\t}\n\n\tif ((fp = sshkey_fingerprint(private, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT)) == NULL) {\n\t\terror(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tgoto out;\n\t}\n\tdebug(\"%s: trying hostkey %s %s\",\n\t    __func__, sshkey_ssh_name(private), fp);\n\n\t/* figure out a name for the client host */\n\tif ((lname = get_local_name(packet_get_connection_in())) == NULL) {\n\t\terror(\"%s: cannot get local ipaddr/name\", __func__);\n\t\tgoto out;\n\t}\n\n\t/* XXX sshbuf_put_stringf? */\n\txasprintf(&chost, \"%s.\", lname);\n\tdebug2(\"%s: chost %s\", __func__, chost);\n\n\t/* construct data */\n\tif ((b = sshbuf_new()) == NULL) {\n\t\terror(\"%s: sshbuf_new failed\", __func__);\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_to_blob(private, &keyblob, &keylen)) != 0) {\n\t\terror(\"%s: sshkey_to_blob: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_string(b, session_id2, session_id2_len)) != 0 ||\n\t    (r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, authctxt->server_user)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, authctxt->method->name)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, sshkey_ssh_name(private))) != 0 ||\n\t    (r = sshbuf_put_string(b, keyblob, keylen)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, chost)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, authctxt->local_user)) != 0) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\n#ifdef DEBUG_PK\n\tsshbuf_dump(b, stderr);\n#endif\n\tr = ssh_keysign(private, &sig, &siglen,\n\t    sshbuf_ptr(b), sshbuf_len(b));\n\tif (r != 0) {\n\t\terror(\"sign using hostkey %s %s failed\",\n\t\t    sshkey_ssh_name(private), fp);\n\t\tgoto out;\n\t}\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, sshkey_ssh_name(private))) != 0 ||\n\t    (r = sshpkt_put_string(ssh, keyblob, keylen)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, chost)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->local_user)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, sig, siglen)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0) {\n\t\terror(\"%s: packet error: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tsuccess = 1;\n\n out:\n\tif (sig != NULL)\n\t\tfreezero(sig, siglen);\n\tfree(keyblob);\n\tfree(lname);\n\tfree(fp);\n\tfree(chost);\n\tsshkey_free(private);\n\tsshbuf_free(b);\n\n\treturn success;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "u_char *session_id2 = NULL;",
      "u_int session_id2_len = 0;",
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
      "int\tuserauth_none(Authctxt *);",
      "int\tuserauth_pubkey(Authctxt *);",
      "int\tuserauth_passwd(Authctxt *);",
      "int\tuserauth_kbdint(Authctxt *);",
      "int\tuserauth_hostbased(Authctxt *);",
      "void\tuserauth(Authctxt *, char *);",
      "static void pubkey_prepare(Authctxt *);",
      "static void pubkey_cleanup(Authctxt *);",
      "static void pubkey_reset(Authctxt *);",
      "static Authmethod *authmethod_lookup(const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 2052
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "private"
          ],
          "line": 2051
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "chost"
          ],
          "line": 2050
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezero",
          "args": [
            "sig",
            "siglen"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "freezero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/freezero.c",
          "lines": "24-31",
          "snippet": "void\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: packet error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 2039
        },
        "resolved": true,
        "details": {
          "function_name": "input_gssapi_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "919-937",
          "snippet": "int\ninput_gssapi_error(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tchar *msg = NULL;\n\tchar *lang = NULL;\n\tint r;\n\n\tif ((r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* maj */\n\t    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* min */\n\t    (r = sshpkt_get_cstring(ssh, &msg, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &lang, NULL)) != 0)\n\t\tgoto out;\n\tr = sshpkt_get_end(ssh);\n\tdebug(\"Server GSSAPI Error:\\n%s\", msg);\n out:\n\tfree(msg);\n\tfree(lang);\n\treturn r;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\n\nint\ninput_gssapi_error(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tchar *msg = NULL;\n\tchar *lang = NULL;\n\tint r;\n\n\tif ((r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* maj */\n\t    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* min */\n\t    (r = sshpkt_get_cstring(ssh, &msg, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &lang, NULL)) != 0)\n\t\tgoto out;\n\tr = sshpkt_get_end(ssh);\n\tdebug(\"Server GSSAPI Error:\\n%s\", msg);\n out:\n\tfree(msg);\n\tfree(lang);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 2039
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 2038
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_string",
          "args": [
            "ssh",
            "sig",
            "siglen"
          ],
          "line": 2037
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2453-2457",
          "snippet": "int\nsshpkt_put_string(struct ssh *ssh, const void *v, size_t len)\n{\n\treturn sshbuf_put_string(ssh->state->outgoing_packet, v, len);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_string(struct ssh *ssh, const void *v, size_t len)\n{\n\treturn sshbuf_put_string(ssh->state->outgoing_packet, v, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_cstring",
          "args": [
            "ssh",
            "authctxt->local_user"
          ],
          "line": 2036
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2459-2463",
          "snippet": "int\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ssh_name",
          "args": [
            "private"
          ],
          "line": 2033
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "183-188",
          "snippet": "const char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_REQUEST"
          ],
          "line": 2029
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_keysign",
          "args": [
            "private",
            "&sig",
            "&siglen",
            "sshbuf_ptr(b)",
            "sshbuf_len(b)"
          ],
          "line": 2022
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_keysign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "1807-1919",
          "snippet": "static int\nssh_keysign(struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen)\n{\n\tstruct sshbuf *b;\n\tstruct stat st;\n\tpid_t pid;\n\tint i, r, to[2], from[2], status, sock = packet_get_connection_in();\n\tu_char rversion = 0, version = 2;\n\tvoid (*osigchld)(int);\n\n\t*sigp = NULL;\n\t*lenp = 0;\n\n\tif (stat(_PATH_SSH_KEY_SIGN, &st) < 0) {\n\t\terror(\"%s: not installed: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (fflush(stdout) != 0) {\n\t\terror(\"%s: fflush: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (pipe(to) < 0) {\n\t\terror(\"%s: pipe: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (pipe(from) < 0) {\n\t\terror(\"%s: pipe: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif ((pid = fork()) < 0) {\n\t\terror(\"%s: fork: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tosigchld = signal(SIGCHLD, SIG_DFL);\n\tif (pid == 0) {\n\t\t/* keep the socket on exec */\n\t\tfcntl(sock, F_SETFD, 0);\n\t\tclose(from[0]);\n\t\tif (dup2(from[1], STDOUT_FILENO) < 0)\n\t\t\tfatal(\"%s: dup2: %s\", __func__, strerror(errno));\n\t\tclose(to[1]);\n\t\tif (dup2(to[0], STDIN_FILENO) < 0)\n\t\t\tfatal(\"%s: dup2: %s\", __func__, strerror(errno));\n\t\tclose(from[1]);\n\t\tclose(to[0]);\n\t\t/* Close everything but stdio and the socket */\n\t\tfor (i = STDERR_FILENO + 1; i < sock; i++)\n\t\t\tclose(i);\n\t\tclosefrom(sock + 1);\n\t\tdebug3(\"%s: [child] pid=%ld, exec %s\",\n\t\t    __func__, (long)getpid(), _PATH_SSH_KEY_SIGN);\n\t\texecl(_PATH_SSH_KEY_SIGN, _PATH_SSH_KEY_SIGN, (char *)NULL);\n\t\tfatal(\"%s: exec(%s): %s\", __func__, _PATH_SSH_KEY_SIGN,\n\t\t    strerror(errno));\n\t}\n\tclose(from[1]);\n\tclose(to[0]);\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t/* send # of sock, data to be signed */\n\tif ((r = sshbuf_put_u32(b, sock)) != 0 ||\n\t    (r = sshbuf_put_string(b, data, datalen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (ssh_msg_send(to[1], version, b) == -1)\n\t\tfatal(\"%s: couldn't send request\", __func__);\n\tsshbuf_reset(b);\n\tr = ssh_msg_recv(from[0], b);\n\tclose(from[0]);\n\tclose(to[1]);\n\tif (r < 0) {\n\t\terror(\"%s: no reply\", __func__);\n\t\tgoto fail;\n\t}\n\n\terrno = 0;\n\twhile (waitpid(pid, &status, 0) < 0) {\n\t\tif (errno != EINTR) {\n\t\t\terror(\"%s: waitpid %ld: %s\",\n\t\t\t    __func__, (long)pid, strerror(errno));\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (!WIFEXITED(status)) {\n\t\terror(\"%s: exited abnormally\", __func__);\n\t\tgoto fail;\n\t}\n\tif (WEXITSTATUS(status) != 0) {\n\t\terror(\"%s: exited with status %d\",\n\t\t    __func__, WEXITSTATUS(status));\n\t\tgoto fail;\n\t}\n\tif ((r = sshbuf_get_u8(b, &rversion)) != 0) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tgoto fail;\n\t}\n\tif (rversion != version) {\n\t\terror(\"%s: bad version\", __func__);\n\t\tgoto fail;\n\t}\n\tif ((r = sshbuf_get_string(b, sigp, lenp)) != 0) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n fail:\n\t\tsignal(SIGCHLD, osigchld);\n\t\tsshbuf_free(b);\n\t\treturn -1;\n\t}\n\tsignal(SIGCHLD, osigchld);\n\tsshbuf_free(b);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nssh_keysign(struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen)\n{\n\tstruct sshbuf *b;\n\tstruct stat st;\n\tpid_t pid;\n\tint i, r, to[2], from[2], status, sock = packet_get_connection_in();\n\tu_char rversion = 0, version = 2;\n\tvoid (*osigchld)(int);\n\n\t*sigp = NULL;\n\t*lenp = 0;\n\n\tif (stat(_PATH_SSH_KEY_SIGN, &st) < 0) {\n\t\terror(\"%s: not installed: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (fflush(stdout) != 0) {\n\t\terror(\"%s: fflush: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (pipe(to) < 0) {\n\t\terror(\"%s: pipe: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (pipe(from) < 0) {\n\t\terror(\"%s: pipe: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif ((pid = fork()) < 0) {\n\t\terror(\"%s: fork: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tosigchld = signal(SIGCHLD, SIG_DFL);\n\tif (pid == 0) {\n\t\t/* keep the socket on exec */\n\t\tfcntl(sock, F_SETFD, 0);\n\t\tclose(from[0]);\n\t\tif (dup2(from[1], STDOUT_FILENO) < 0)\n\t\t\tfatal(\"%s: dup2: %s\", __func__, strerror(errno));\n\t\tclose(to[1]);\n\t\tif (dup2(to[0], STDIN_FILENO) < 0)\n\t\t\tfatal(\"%s: dup2: %s\", __func__, strerror(errno));\n\t\tclose(from[1]);\n\t\tclose(to[0]);\n\t\t/* Close everything but stdio and the socket */\n\t\tfor (i = STDERR_FILENO + 1; i < sock; i++)\n\t\t\tclose(i);\n\t\tclosefrom(sock + 1);\n\t\tdebug3(\"%s: [child] pid=%ld, exec %s\",\n\t\t    __func__, (long)getpid(), _PATH_SSH_KEY_SIGN);\n\t\texecl(_PATH_SSH_KEY_SIGN, _PATH_SSH_KEY_SIGN, (char *)NULL);\n\t\tfatal(\"%s: exec(%s): %s\", __func__, _PATH_SSH_KEY_SIGN,\n\t\t    strerror(errno));\n\t}\n\tclose(from[1]);\n\tclose(to[0]);\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t/* send # of sock, data to be signed */\n\tif ((r = sshbuf_put_u32(b, sock)) != 0 ||\n\t    (r = sshbuf_put_string(b, data, datalen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (ssh_msg_send(to[1], version, b) == -1)\n\t\tfatal(\"%s: couldn't send request\", __func__);\n\tsshbuf_reset(b);\n\tr = ssh_msg_recv(from[0], b);\n\tclose(from[0]);\n\tclose(to[1]);\n\tif (r < 0) {\n\t\terror(\"%s: no reply\", __func__);\n\t\tgoto fail;\n\t}\n\n\terrno = 0;\n\twhile (waitpid(pid, &status, 0) < 0) {\n\t\tif (errno != EINTR) {\n\t\t\terror(\"%s: waitpid %ld: %s\",\n\t\t\t    __func__, (long)pid, strerror(errno));\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (!WIFEXITED(status)) {\n\t\terror(\"%s: exited abnormally\", __func__);\n\t\tgoto fail;\n\t}\n\tif (WEXITSTATUS(status) != 0) {\n\t\terror(\"%s: exited with status %d\",\n\t\t    __func__, WEXITSTATUS(status));\n\t\tgoto fail;\n\t}\n\tif ((r = sshbuf_get_u8(b, &rversion)) != 0) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tgoto fail;\n\t}\n\tif (rversion != version) {\n\t\terror(\"%s: bad version\", __func__);\n\t\tgoto fail;\n\t}\n\tif ((r = sshbuf_get_string(b, sigp, lenp)) != 0) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n fail:\n\t\tsignal(SIGCHLD, osigchld);\n\t\tsshbuf_free(b);\n\t\treturn -1;\n\t}\n\tsignal(SIGCHLD, osigchld);\n\tsshbuf_free(b);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "b"
          ],
          "line": 2023
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "b"
          ],
          "line": 2023
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_dump",
          "args": [
            "b",
            "stderr"
          ],
          "line": 2020
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-misc.c",
          "lines": "65-70",
          "snippet": "void\nsshbuf_dump(struct sshbuf *buf, FILE *f)\n{\n\tfprintf(f, \"buffer %p len = %zu\\n\", buf, sshbuf_len(buf));\n\tsshbuf_dump_data(sshbuf_ptr(buf), sshbuf_len(buf), f);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <ctype.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <ctype.h>\n#include <resolv.h>\n#include <string.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_dump(struct sshbuf *buf, FILE *f)\n{\n\tfprintf(f, \"buffer %p len = %zu\\n\", buf, sshbuf_len(buf));\n\tsshbuf_dump_data(sshbuf_ptr(buf), sshbuf_len(buf), f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "b",
            "authctxt->local_user"
          ],
          "line": 2014
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "b",
            "keyblob",
            "keylen"
          ],
          "line": 2012
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "b",
            "SSH2_MSG_USERAUTH_REQUEST"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_to_blob",
          "args": [
            "private",
            "&keyblob",
            "&keylen"
          ],
          "line": 2002
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_to_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "880-884",
          "snippet": "int\nsshkey_to_blob(const struct sshkey *key, u_char **blobp, size_t *lenp)\n{\n\treturn to_blob(key, blobp, lenp, 0, SSHKEY_SERIALIZE_DEFAULT);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_to_blob(const struct sshkey *key, u_char **blobp, size_t *lenp)\n{\n\treturn to_blob(key, blobp, lenp, 0, SSHKEY_SERIALIZE_DEFAULT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: sshbuf_new failed\"",
            "__func__"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1998
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: chost %s\"",
            "__func__",
            "chost"
          ],
          "line": 1995
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&chost",
            "\"%s.\"",
            "lname"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_local_name",
          "args": [
            "packet_get_connection_in()"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "get_local_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "133-151",
          "snippet": "char *\nget_local_name(int fd)\n{\n\tchar *host, myname[NI_MAXHOST];\n\n\t/* Assume we were passed a socket */\n\tif ((host = get_socket_address(fd, 0, NI_NAMEREQD)) != NULL)\n\t\treturn host;\n\n\t/* Handle the case where we were passed a pipe */\n\tif (gethostname(myname, sizeof(myname)) == -1) {\n\t\tverbose(\"%s: gethostname: %s\", __func__, strerror(errno));\n\t\thost = xstrdup(\"UNKNOWN\");\n\t} else {\n\t\thost = xstrdup(myname);\n\t}\n\n\treturn host;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nget_local_name(int fd)\n{\n\tchar *host, myname[NI_MAXHOST];\n\n\t/* Assume we were passed a socket */\n\tif ((host = get_socket_address(fd, 0, NI_NAMEREQD)) != NULL)\n\t\treturn host;\n\n\t/* Handle the case where we were passed a pipe */\n\tif (gethostname(myname, sizeof(myname)) == -1) {\n\t\tverbose(\"%s: gethostname: %s\", __func__, strerror(errno));\n\t\thost = xstrdup(\"UNKNOWN\");\n\t} else {\n\t\thost = xstrdup(myname);\n\t}\n\n\treturn host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_connection_in",
          "args": [],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: trying hostkey %s %s\"",
            "__func__",
            "sshkey_ssh_name(private)",
            "fp"
          ],
          "line": 1984
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "private",
            "options.fingerprint_hash",
            "SSH_FP_DEFAULT"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_pattern_list",
          "args": [
            "sshkey_ssh_name(authctxt->sensitive->keys[i])",
            "authctxt->active_ktype",
            "0"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "match_pattern_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "120-171",
          "snippet": "int\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&authctxt->ktypes",
            "\",\""
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "xstrsep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keyscan.c",
          "lines": "162-178",
          "snippet": "static char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}",
          "includes": [
            "#include \"dns.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"myproposal.h\"",
            "#include \"compat.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include <netdb.h>",
            "#include <openssl/bn.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/resource.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"myproposal.h\"\n#include \"compat.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <netdb.h>\n#include <openssl/bn.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/resource.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "options.hostbased_key_types"
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nu_char *session_id2 = NULL;\nu_int session_id2_len = 0;\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic Authmethod *authmethod_lookup(const char *name);\n\nint\nuserauth_hostbased(Authctxt *authctxt)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tstruct sshkey *private = NULL;\n\tstruct sshbuf *b = NULL;\n\tu_char *sig = NULL, *keyblob = NULL;\n\tchar *fp = NULL, *chost = NULL, *lname = NULL;\n\tsize_t siglen = 0, keylen = 0;\n\tint i, r, success = 0;\n\n\tif (authctxt->ktypes == NULL) {\n\t\tauthctxt->oktypes = xstrdup(options.hostbased_key_types);\n\t\tauthctxt->ktypes = authctxt->oktypes;\n\t}\n\n\t/*\n\t * Work through each listed type pattern in HostbasedKeyTypes,\n\t * trying each hostkey that matches the type in turn.\n\t */\n\tfor (;;) {\n\t\tif (authctxt->active_ktype == NULL)\n\t\t\tauthctxt->active_ktype = strsep(&authctxt->ktypes, \",\");\n\t\tif (authctxt->active_ktype == NULL ||\n\t\t    *authctxt->active_ktype == '\\0')\n\t\t\tbreak;\n\t\tdebug3(\"%s: trying key type %s\", __func__,\n\t\t    authctxt->active_ktype);\n\n\t\t/* check for a useful key */\n\t\tprivate = NULL;\n\t\tfor (i = 0; i < authctxt->sensitive->nkeys; i++) {\n\t\t\tif (authctxt->sensitive->keys[i] == NULL ||\n\t\t\t    authctxt->sensitive->keys[i]->type == KEY_UNSPEC)\n\t\t\t\tcontinue;\n\t\t\tif (match_pattern_list(\n\t\t\t    sshkey_ssh_name(authctxt->sensitive->keys[i]),\n\t\t\t    authctxt->active_ktype, 0) != 1)\n\t\t\t\tcontinue;\n\t\t\t/* we take and free the key */\n\t\t\tprivate = authctxt->sensitive->keys[i];\n\t\t\tauthctxt->sensitive->keys[i] = NULL;\n\t\t\tbreak;\n\t\t}\n\t\t/* Found one */\n\t\tif (private != NULL)\n\t\t\tbreak;\n\t\t/* No more keys of this type; advance */\n\t\tauthctxt->active_ktype = NULL;\n\t}\n\tif (private == NULL) {\n\t\tfree(authctxt->oktypes);\n\t\tauthctxt->oktypes = authctxt->ktypes = NULL;\n\t\tauthctxt->active_ktype = NULL;\n\t\tdebug(\"No more client hostkeys for hostbased authentication.\");\n\t\tgoto out;\n\t}\n\n\tif ((fp = sshkey_fingerprint(private, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT)) == NULL) {\n\t\terror(\"%s: sshkey_fingerprint failed\", __func__);\n\t\tgoto out;\n\t}\n\tdebug(\"%s: trying hostkey %s %s\",\n\t    __func__, sshkey_ssh_name(private), fp);\n\n\t/* figure out a name for the client host */\n\tif ((lname = get_local_name(packet_get_connection_in())) == NULL) {\n\t\terror(\"%s: cannot get local ipaddr/name\", __func__);\n\t\tgoto out;\n\t}\n\n\t/* XXX sshbuf_put_stringf? */\n\txasprintf(&chost, \"%s.\", lname);\n\tdebug2(\"%s: chost %s\", __func__, chost);\n\n\t/* construct data */\n\tif ((b = sshbuf_new()) == NULL) {\n\t\terror(\"%s: sshbuf_new failed\", __func__);\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_to_blob(private, &keyblob, &keylen)) != 0) {\n\t\terror(\"%s: sshkey_to_blob: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_string(b, session_id2, session_id2_len)) != 0 ||\n\t    (r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, authctxt->server_user)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, authctxt->method->name)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, sshkey_ssh_name(private))) != 0 ||\n\t    (r = sshbuf_put_string(b, keyblob, keylen)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, chost)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, authctxt->local_user)) != 0) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\n#ifdef DEBUG_PK\n\tsshbuf_dump(b, stderr);\n#endif\n\tr = ssh_keysign(private, &sig, &siglen,\n\t    sshbuf_ptr(b), sshbuf_len(b));\n\tif (r != 0) {\n\t\terror(\"sign using hostkey %s %s failed\",\n\t\t    sshkey_ssh_name(private), fp);\n\t\tgoto out;\n\t}\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, sshkey_ssh_name(private))) != 0 ||\n\t    (r = sshpkt_put_string(ssh, keyblob, keylen)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, chost)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->local_user)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, sig, siglen)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0) {\n\t\terror(\"%s: packet error: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tsuccess = 1;\n\n out:\n\tif (sig != NULL)\n\t\tfreezero(sig, siglen);\n\tfree(keyblob);\n\tfree(lname);\n\tfree(fp);\n\tfree(chost);\n\tsshkey_free(private);\n\tsshbuf_free(b);\n\n\treturn success;\n}"
  },
  {
    "function_name": "ssh_keysign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "1807-1919",
    "snippet": "static int\nssh_keysign(struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen)\n{\n\tstruct sshbuf *b;\n\tstruct stat st;\n\tpid_t pid;\n\tint i, r, to[2], from[2], status, sock = packet_get_connection_in();\n\tu_char rversion = 0, version = 2;\n\tvoid (*osigchld)(int);\n\n\t*sigp = NULL;\n\t*lenp = 0;\n\n\tif (stat(_PATH_SSH_KEY_SIGN, &st) < 0) {\n\t\terror(\"%s: not installed: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (fflush(stdout) != 0) {\n\t\terror(\"%s: fflush: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (pipe(to) < 0) {\n\t\terror(\"%s: pipe: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (pipe(from) < 0) {\n\t\terror(\"%s: pipe: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif ((pid = fork()) < 0) {\n\t\terror(\"%s: fork: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tosigchld = signal(SIGCHLD, SIG_DFL);\n\tif (pid == 0) {\n\t\t/* keep the socket on exec */\n\t\tfcntl(sock, F_SETFD, 0);\n\t\tclose(from[0]);\n\t\tif (dup2(from[1], STDOUT_FILENO) < 0)\n\t\t\tfatal(\"%s: dup2: %s\", __func__, strerror(errno));\n\t\tclose(to[1]);\n\t\tif (dup2(to[0], STDIN_FILENO) < 0)\n\t\t\tfatal(\"%s: dup2: %s\", __func__, strerror(errno));\n\t\tclose(from[1]);\n\t\tclose(to[0]);\n\t\t/* Close everything but stdio and the socket */\n\t\tfor (i = STDERR_FILENO + 1; i < sock; i++)\n\t\t\tclose(i);\n\t\tclosefrom(sock + 1);\n\t\tdebug3(\"%s: [child] pid=%ld, exec %s\",\n\t\t    __func__, (long)getpid(), _PATH_SSH_KEY_SIGN);\n\t\texecl(_PATH_SSH_KEY_SIGN, _PATH_SSH_KEY_SIGN, (char *)NULL);\n\t\tfatal(\"%s: exec(%s): %s\", __func__, _PATH_SSH_KEY_SIGN,\n\t\t    strerror(errno));\n\t}\n\tclose(from[1]);\n\tclose(to[0]);\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t/* send # of sock, data to be signed */\n\tif ((r = sshbuf_put_u32(b, sock)) != 0 ||\n\t    (r = sshbuf_put_string(b, data, datalen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (ssh_msg_send(to[1], version, b) == -1)\n\t\tfatal(\"%s: couldn't send request\", __func__);\n\tsshbuf_reset(b);\n\tr = ssh_msg_recv(from[0], b);\n\tclose(from[0]);\n\tclose(to[1]);\n\tif (r < 0) {\n\t\terror(\"%s: no reply\", __func__);\n\t\tgoto fail;\n\t}\n\n\terrno = 0;\n\twhile (waitpid(pid, &status, 0) < 0) {\n\t\tif (errno != EINTR) {\n\t\t\terror(\"%s: waitpid %ld: %s\",\n\t\t\t    __func__, (long)pid, strerror(errno));\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (!WIFEXITED(status)) {\n\t\terror(\"%s: exited abnormally\", __func__);\n\t\tgoto fail;\n\t}\n\tif (WEXITSTATUS(status) != 0) {\n\t\terror(\"%s: exited with status %d\",\n\t\t    __func__, WEXITSTATUS(status));\n\t\tgoto fail;\n\t}\n\tif ((r = sshbuf_get_u8(b, &rversion)) != 0) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tgoto fail;\n\t}\n\tif (rversion != version) {\n\t\terror(\"%s: bad version\", __func__);\n\t\tgoto fail;\n\t}\n\tif ((r = sshbuf_get_string(b, sigp, lenp)) != 0) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n fail:\n\t\tsignal(SIGCHLD, osigchld);\n\t\tsshbuf_free(b);\n\t\treturn -1;\n\t}\n\tsignal(SIGCHLD, osigchld);\n\tsshbuf_free(b);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGCHLD",
            "osigchld"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "session_signal_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/session.c",
          "lines": "2130-2176",
          "snippet": "static int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}",
          "includes": [
            "#include <selinux/selinux.h>",
            "#include <kafs.h>",
            "#include \"atomicio.h\"",
            "#include \"sftp.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"kex.h\"",
            "#include \"session.h\"",
            "#include \"canohost.h\"",
            "#include \"serverloop.h\"",
            "#include \"sshlogin.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"packet.h\"",
            "#include \"sshpty.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "# include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);",
            "void\tsession_pty_cleanup(Session *);",
            "void\tsession_proctitle(Session *);",
            "int\tsession_setup_x11fwd(struct ssh *, Session *);",
            "int\tdo_exec_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec_no_pty(struct ssh *, Session *, const char *);",
            "int\tdo_exec(struct ssh *, Session *, const char *);",
            "void\tdo_login(struct ssh *, Session *, const char *);",
            "void\tdo_child(struct ssh *, Session *, const char *);",
            "int\tcheck_quietlogin(Session *, const char *);",
            "static int session_pty_req(struct ssh *, Session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <selinux/selinux.h>\n#include <kafs.h>\n#include \"atomicio.h\"\n#include \"sftp.h\"\n#include \"monitor_wrap.h\"\n#include \"kex.h\"\n#include \"session.h\"\n#include \"canohost.h\"\n#include \"serverloop.h\"\n#include \"sshlogin.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssh-gss.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshpty.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n# include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nint\tcheck_quietlogin(Session *, const char *);\nstatic int session_pty_req(struct ssh *, Session *);\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror(\"%s: parse packet: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror(\"%s: unsupported signal \\\"%s\\\"\", __func__, signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror(\"%s: no pid for session %d\", __func__, s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror(\"%s: refusing to send signal %s to %s session\", __func__,\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror(\"%s: session signalling requires privilege separation\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\n\tdebug(\"%s: signal %s, killpg(%ld, %d)\", __func__, signame,\n\t    (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror(\"%s: killpg(%ld, %d): %s\", __func__, (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t/* success */\n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "input_gssapi_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "919-937",
          "snippet": "int\ninput_gssapi_error(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tchar *msg = NULL;\n\tchar *lang = NULL;\n\tint r;\n\n\tif ((r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* maj */\n\t    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* min */\n\t    (r = sshpkt_get_cstring(ssh, &msg, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &lang, NULL)) != 0)\n\t\tgoto out;\n\tr = sshpkt_get_end(ssh);\n\tdebug(\"Server GSSAPI Error:\\n%s\", msg);\n out:\n\tfree(msg);\n\tfree(lang);\n\treturn r;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\n\nint\ninput_gssapi_error(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tchar *msg = NULL;\n\tchar *lang = NULL;\n\tint r;\n\n\tif ((r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* maj */\n\t    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* min */\n\t    (r = sshpkt_get_cstring(ssh, &msg, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &lang, NULL)) != 0)\n\t\tgoto out;\n\tr = sshpkt_get_end(ssh);\n\tdebug(\"Server GSSAPI Error:\\n%s\", msg);\n out:\n\tfree(msg);\n\tfree(lang);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string",
          "args": [
            "b",
            "sigp",
            "lenp"
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: bad version\"",
            "__func__"
          ],
          "line": 1905
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_u8",
          "args": [
            "b",
            "&rversion"
          ],
          "line": 1900
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "83-94",
          "snippet": "int\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_u8(struct sshbuf *buf, u_char *valp)\n{\n\tconst u_char *p = sshbuf_ptr(buf);\n\tint r;\n\n\tif ((r = sshbuf_consume(buf, 1)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = (u_int8_t)*p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "0"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "waitpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-waitpid.c",
          "lines": "32-51",
          "snippet": "pid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}",
          "includes": [
            "#include \"bsd-waitpid.h\"",
            "#include <sys/wait.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bsd-waitpid.h\"\n#include <sys/wait.h>\n#include <errno.h>\n#include \"includes.h\"\n\npid_t\nwaitpid(int pid, int *stat_loc, int options)\n{\n\tunion wait statusp;\n\tpid_t wait_pid;\n\n\tif (pid <= 0) {\n\t\tif (pid != -1) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\t\t/* wait4() wants pid=0 for indiscriminate wait. */\n\t\tpid = 0;\n\t}\n\twait_pid = wait4(pid, &statusp, options, NULL);\n\tif (stat_loc)\n\t\t*stat_loc = (int) statusp.w_status;\n\n\treturn (wait_pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "to[1]"
          ],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_msg_recv",
          "args": [
            "from[0]",
            "b"
          ],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_msg_recv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/msg.c",
          "lines": "65-94",
          "snippet": "int\nssh_msg_recv(int fd, struct sshbuf *m)\n{\n\tu_char buf[4], *p;\n\tu_int msg_len;\n\tint r;\n\n\tdebug3(\"ssh_msg_recv entering\");\n\n\tif (atomicio(read, fd, buf, sizeof(buf)) != sizeof(buf)) {\n\t\tif (errno != EPIPE)\n\t\t\terror(\"ssh_msg_recv: read: header\");\n\t\treturn (-1);\n\t}\n\tmsg_len = get_u32(buf);\n\tif (msg_len > 256 * 1024) {\n\t\terror(\"ssh_msg_recv: read: bad msg_len %u\", msg_len);\n\t\treturn (-1);\n\t}\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_reserve(m, msg_len, &p)) != 0) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\treturn -1;\n\t}\n\tif (atomicio(read, fd, p, msg_len) != msg_len) {\n\t\terror(\"ssh_msg_recv: read: %s\", strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"msg.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"msg.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_msg_recv(int fd, struct sshbuf *m)\n{\n\tu_char buf[4], *p;\n\tu_int msg_len;\n\tint r;\n\n\tdebug3(\"ssh_msg_recv entering\");\n\n\tif (atomicio(read, fd, buf, sizeof(buf)) != sizeof(buf)) {\n\t\tif (errno != EPIPE)\n\t\t\terror(\"ssh_msg_recv: read: header\");\n\t\treturn (-1);\n\t}\n\tmsg_len = get_u32(buf);\n\tif (msg_len > 256 * 1024) {\n\t\terror(\"ssh_msg_recv: read: bad msg_len %u\", msg_len);\n\t\treturn (-1);\n\t}\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_reserve(m, msg_len, &p)) != 0) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\treturn -1;\n\t}\n\tif (atomicio(read, fd, p, msg_len) != msg_len) {\n\t\terror(\"ssh_msg_recv: read: %s\", strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "b"
          ],
          "line": 1874
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: couldn't send request\"",
            "__func__"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_msg_send",
          "args": [
            "to[1]",
            "version",
            "b"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_msg_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/msg.c",
          "lines": "44-63",
          "snippet": "int\nssh_msg_send(int fd, u_char type, struct sshbuf *m)\n{\n\tu_char buf[5];\n\tu_int mlen = sshbuf_len(m);\n\n\tdebug3(\"ssh_msg_send: type %u\", (unsigned int)type & 0xff);\n\n\tput_u32(buf, mlen + 1);\n\tbuf[4] = type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, fd, buf, sizeof(buf)) != sizeof(buf)) {\n\t\terror(\"ssh_msg_send: write\");\n\t\treturn (-1);\n\t}\n\tif (atomicio(vwrite, fd, sshbuf_mutable_ptr(m), mlen) != mlen) {\n\t\terror(\"ssh_msg_send: write\");\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"msg.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"msg.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_msg_send(int fd, u_char type, struct sshbuf *m)\n{\n\tu_char buf[5];\n\tu_int mlen = sshbuf_len(m);\n\n\tdebug3(\"ssh_msg_send: type %u\", (unsigned int)type & 0xff);\n\n\tput_u32(buf, mlen + 1);\n\tbuf[4] = type;\t\t/* 1st byte of payload is mesg-type */\n\tif (atomicio(vwrite, fd, buf, sizeof(buf)) != sizeof(buf)) {\n\t\terror(\"ssh_msg_send: write\");\n\t\treturn (-1);\n\t}\n\tif (atomicio(vwrite, fd, sshbuf_mutable_ptr(m), mlen) != mlen) {\n\t\terror(\"ssh_msg_send: write\");\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "b",
            "data",
            "datalen"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "b",
            "sock"
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1866
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execl",
          "args": [
            "_PATH_SSH_KEY_SIGN",
            "_PATH_SSH_KEY_SIGN",
            "(char *)NULL"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: [child] pid=%ld, exec %s\"",
            "__func__",
            "(long)getpid()",
            "_PATH_SSH_KEY_SIGN"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closefrom",
          "args": [
            "sock + 1"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "closefrom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-closefrom.c",
          "lines": "68-107",
          "snippet": "void\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}",
          "includes": [
            "#  include <ndir.h>",
            "#  include <sys/dir.h>",
            "#  include <sys/ndir.h>",
            "# include <dirent.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "# include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <ndir.h>\n#  include <sys/dir.h>\n#  include <sys/ndir.h>\n# include <dirent.h>\n#include <unistd.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <limits.h>\n# include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nclosefrom(int lowfd)\n{\n    long fd, maxfd;\n#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n    /* Check for a /proc/$$/fd directory. */\n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n    } else\n#endif\n    {\n\t/*\n\t * Fall back on sysconf() or getdtablesize().  We avoid checking\n\t * resource limits since it is possible to open a file descriptor\n\t * and then drop the rlimit such that it is below the open fd.\n\t */\n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif /* HAVE_SYSCONF */\n\tif (maxfd < 0)\n\t    maxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t    (void) close((int) fd);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "to[0]",
            "STDIN_FILENO"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "from[1]",
            "STDOUT_FILENO"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "sock",
            "F_SETFD",
            "0"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "platform_post_fork_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/platform.c",
          "lines": "69-78",
          "snippet": "void\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}",
          "includes": [
            "#include \"openbsd-compat/openbsd-compat.h\"",
            "#include \"platform.h\"",
            "#include \"auth-pam.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openbsd-compat.h\"\n#include \"platform.h\"\n#include \"auth-pam.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid\nplatform_post_fork_child(void)\n{\n#ifdef USE_SOLARIS_PROCESS_CONTRACTS\n\tsolaris_contract_post_fork_child();\n#endif\n#ifdef LINUX_OOM_ADJUST\n\toom_adjust_restore();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "from"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "to"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "_ssh_compat_fflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "314-326",
          "snippet": "int _ssh_compat_fflush(FILE *f)\n{\n\tint r1, r2;\n\n\tif (f == NULL) {\n\t\tr1 = fflush(stdout);\n\t\tr2 = fflush(stderr);\n\t\tif (r1 == -1 || r2 == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\treturn fflush(f);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint _ssh_compat_fflush(FILE *f)\n{\n\tint r1, r2;\n\n\tif (f == NULL) {\n\t\tr1 = fflush(stdout);\n\t\tr2 = fflush(stderr);\n\t\tif (r1 == -1 || r2 == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\treturn fflush(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "_PATH_SSH_KEY_SIGN",
            "&st"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_connection_in",
          "args": [],
          "line": 1814
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nssh_keysign(struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen)\n{\n\tstruct sshbuf *b;\n\tstruct stat st;\n\tpid_t pid;\n\tint i, r, to[2], from[2], status, sock = packet_get_connection_in();\n\tu_char rversion = 0, version = 2;\n\tvoid (*osigchld)(int);\n\n\t*sigp = NULL;\n\t*lenp = 0;\n\n\tif (stat(_PATH_SSH_KEY_SIGN, &st) < 0) {\n\t\terror(\"%s: not installed: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (fflush(stdout) != 0) {\n\t\terror(\"%s: fflush: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (pipe(to) < 0) {\n\t\terror(\"%s: pipe: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (pipe(from) < 0) {\n\t\terror(\"%s: pipe: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tif ((pid = fork()) < 0) {\n\t\terror(\"%s: fork: %s\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\tosigchld = signal(SIGCHLD, SIG_DFL);\n\tif (pid == 0) {\n\t\t/* keep the socket on exec */\n\t\tfcntl(sock, F_SETFD, 0);\n\t\tclose(from[0]);\n\t\tif (dup2(from[1], STDOUT_FILENO) < 0)\n\t\t\tfatal(\"%s: dup2: %s\", __func__, strerror(errno));\n\t\tclose(to[1]);\n\t\tif (dup2(to[0], STDIN_FILENO) < 0)\n\t\t\tfatal(\"%s: dup2: %s\", __func__, strerror(errno));\n\t\tclose(from[1]);\n\t\tclose(to[0]);\n\t\t/* Close everything but stdio and the socket */\n\t\tfor (i = STDERR_FILENO + 1; i < sock; i++)\n\t\t\tclose(i);\n\t\tclosefrom(sock + 1);\n\t\tdebug3(\"%s: [child] pid=%ld, exec %s\",\n\t\t    __func__, (long)getpid(), _PATH_SSH_KEY_SIGN);\n\t\texecl(_PATH_SSH_KEY_SIGN, _PATH_SSH_KEY_SIGN, (char *)NULL);\n\t\tfatal(\"%s: exec(%s): %s\", __func__, _PATH_SSH_KEY_SIGN,\n\t\t    strerror(errno));\n\t}\n\tclose(from[1]);\n\tclose(to[0]);\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t/* send # of sock, data to be signed */\n\tif ((r = sshbuf_put_u32(b, sock)) != 0 ||\n\t    (r = sshbuf_put_string(b, data, datalen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (ssh_msg_send(to[1], version, b) == -1)\n\t\tfatal(\"%s: couldn't send request\", __func__);\n\tsshbuf_reset(b);\n\tr = ssh_msg_recv(from[0], b);\n\tclose(from[0]);\n\tclose(to[1]);\n\tif (r < 0) {\n\t\terror(\"%s: no reply\", __func__);\n\t\tgoto fail;\n\t}\n\n\terrno = 0;\n\twhile (waitpid(pid, &status, 0) < 0) {\n\t\tif (errno != EINTR) {\n\t\t\terror(\"%s: waitpid %ld: %s\",\n\t\t\t    __func__, (long)pid, strerror(errno));\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (!WIFEXITED(status)) {\n\t\terror(\"%s: exited abnormally\", __func__);\n\t\tgoto fail;\n\t}\n\tif (WEXITSTATUS(status) != 0) {\n\t\terror(\"%s: exited with status %d\",\n\t\t    __func__, WEXITSTATUS(status));\n\t\tgoto fail;\n\t}\n\tif ((r = sshbuf_get_u8(b, &rversion)) != 0) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tgoto fail;\n\t}\n\tif (rversion != version) {\n\t\terror(\"%s: bad version\", __func__);\n\t\tgoto fail;\n\t}\n\tif ((r = sshbuf_get_string(b, sigp, lenp)) != 0) {\n\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n fail:\n\t\tsignal(SIGCHLD, osigchld);\n\t\tsshbuf_free(b);\n\t\treturn -1;\n\t}\n\tsignal(SIGCHLD, osigchld);\n\tsshbuf_free(b);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "input_userauth_info_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "1742-1805",
    "snippet": "int\ninput_userauth_info_req(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tchar *name = NULL, *inst = NULL, *lang = NULL, *prompt = NULL;\n\tchar *response = NULL;\n\tu_char echo = 0;\n\tu_int num_prompts, i;\n\tint r;\n\n\tdebug2(\"input_userauth_info_req\");\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_userauth_info_req: no authentication context\");\n\n\tauthctxt->info_req_seen = 1;\n\n\tif ((r = sshpkt_get_cstring(ssh, &name, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &inst, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &lang, NULL)) != 0)\n\t\tgoto out;\n\tif (strlen(name) > 0)\n\t\tlogit(\"%s\", name);\n\tif (strlen(inst) > 0)\n\t\tlogit(\"%s\", inst);\n\n\tif ((r = sshpkt_get_u32(ssh, &num_prompts)) != 0)\n\t\tgoto out;\n\t/*\n\t * Begin to build info response packet based on prompts requested.\n\t * We commit to providing the correct number of responses, so if\n\t * further on we run into a problem that prevents this, we have to\n\t * be sure and clean this up and send a correct error response.\n\t */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_INFO_RESPONSE)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, num_prompts)) != 0)\n\t\tgoto out;\n\n\tdebug2(\"input_userauth_info_req: num_prompts %d\", num_prompts);\n\tfor (i = 0; i < num_prompts; i++) {\n\t\tif ((r = sshpkt_get_cstring(ssh, &prompt, NULL)) != 0 ||\n\t\t    (r = sshpkt_get_u8(ssh, &echo)) != 0)\n\t\t\tgoto out;\n\t\tresponse = read_passphrase(prompt, echo ? RP_ECHO : 0);\n\t\tif ((r = sshpkt_put_cstring(ssh, response)) != 0)\n\t\t\tgoto out;\n\t\tfreezero(response, strlen(response));\n\t\tfree(prompt);\n\t\tresponse = prompt = NULL;\n\t}\n\t/* done with parsing incoming message. */\n\tif ((r = sshpkt_get_end(ssh)) != 0 ||\n\t    (r = sshpkt_add_padding(ssh, 64)) != 0)\n\t\tgoto out;\n\tr = sshpkt_send(ssh);\n out:\n\tif (response)\n\t\tfreezero(response, strlen(response));\n\tfree(prompt);\n\tfree(name);\n\tfree(inst);\n\tfree(lang);\n\treturn r;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
      "int\tuserauth_none(Authctxt *);",
      "int\tuserauth_pubkey(Authctxt *);",
      "int\tuserauth_passwd(Authctxt *);",
      "int\tuserauth_kbdint(Authctxt *);",
      "int\tuserauth_hostbased(Authctxt *);",
      "void\tuserauth(Authctxt *, char *);",
      "static void pubkey_prepare(Authctxt *);",
      "static void pubkey_cleanup(Authctxt *);",
      "static void pubkey_reset(Authctxt *);",
      "static Authmethod *authmethod_lookup(const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "lang"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezero",
          "args": [
            "response",
            "strlen(response)"
          ],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "freezero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/freezero.c",
          "lines": "24-31",
          "snippet": "void\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "response"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_add_padding",
          "args": [
            "ssh",
            "64"
          ],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_add_padding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2677-2682",
          "snippet": "int\nsshpkt_add_padding(struct ssh *ssh, u_char pad)\n{\n\tssh->state->extra_pad = pad;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_add_padding(struct ssh *ssh, u_char pad)\n{\n\tssh->state->extra_pad = pad;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_end",
          "args": [
            "ssh"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2555-2561",
          "snippet": "int\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "response"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshpkt_put_cstring",
          "args": [
            "ssh",
            "response"
          ],
          "line": 1786
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2459-2463",
          "snippet": "int\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_passphrase",
          "args": [
            "prompt",
            "echo ? RP_ECHO : 0"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "read_passphrase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readpass.c",
          "lines": "117-166",
          "snippet": "char *\nread_passphrase(const char *prompt, int flags)\n{\n\tchar *askpass = NULL, *ret, buf[1024];\n\tint rppflags, use_askpass = 0, ttyfd;\n\n\trppflags = (flags & RP_ECHO) ? RPP_ECHO_ON : RPP_ECHO_OFF;\n\tif (flags & RP_USE_ASKPASS)\n\t\tuse_askpass = 1;\n\telse if (flags & RP_ALLOW_STDIN) {\n\t\tif (!isatty(STDIN_FILENO)) {\n\t\t\tdebug(\"read_passphrase: stdin is not a tty\");\n\t\t\tuse_askpass = 1;\n\t\t}\n\t} else {\n\t\trppflags |= RPP_REQUIRE_TTY;\n\t\tttyfd = open(_PATH_TTY, O_RDWR);\n\t\tif (ttyfd >= 0)\n\t\t\tclose(ttyfd);\n\t\telse {\n\t\t\tdebug(\"read_passphrase: can't open %s: %s\", _PATH_TTY,\n\t\t\t    strerror(errno));\n\t\t\tuse_askpass = 1;\n\t\t}\n\t}\n\n\tif ((flags & RP_USE_ASKPASS) && getenv(\"DISPLAY\") == NULL)\n\t\treturn (flags & RP_ALLOW_EOF) ? NULL : xstrdup(\"\");\n\n\tif (use_askpass && getenv(\"DISPLAY\")) {\n\t\tif (getenv(SSH_ASKPASS_ENV))\n\t\t\taskpass = getenv(SSH_ASKPASS_ENV);\n\t\telse\n\t\t\taskpass = _PATH_SSH_ASKPASS_DEFAULT;\n\t\tif ((ret = ssh_askpass(askpass, prompt)) == NULL)\n\t\t\tif (!(flags & RP_ALLOW_EOF))\n\t\t\t\treturn xstrdup(\"\");\n\t\treturn ret;\n\t}\n\n\tif (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {\n\t\tif (flags & RP_ALLOW_EOF)\n\t\t\treturn NULL;\n\t\treturn xstrdup(\"\");\n\t}\n\n\tret = xstrdup(buf);\n\texplicit_bzero(buf, sizeof(buf));\n\treturn ret;\n}",
          "includes": [
            "#include \"uidswap.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uidswap.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nread_passphrase(const char *prompt, int flags)\n{\n\tchar *askpass = NULL, *ret, buf[1024];\n\tint rppflags, use_askpass = 0, ttyfd;\n\n\trppflags = (flags & RP_ECHO) ? RPP_ECHO_ON : RPP_ECHO_OFF;\n\tif (flags & RP_USE_ASKPASS)\n\t\tuse_askpass = 1;\n\telse if (flags & RP_ALLOW_STDIN) {\n\t\tif (!isatty(STDIN_FILENO)) {\n\t\t\tdebug(\"read_passphrase: stdin is not a tty\");\n\t\t\tuse_askpass = 1;\n\t\t}\n\t} else {\n\t\trppflags |= RPP_REQUIRE_TTY;\n\t\tttyfd = open(_PATH_TTY, O_RDWR);\n\t\tif (ttyfd >= 0)\n\t\t\tclose(ttyfd);\n\t\telse {\n\t\t\tdebug(\"read_passphrase: can't open %s: %s\", _PATH_TTY,\n\t\t\t    strerror(errno));\n\t\t\tuse_askpass = 1;\n\t\t}\n\t}\n\n\tif ((flags & RP_USE_ASKPASS) && getenv(\"DISPLAY\") == NULL)\n\t\treturn (flags & RP_ALLOW_EOF) ? NULL : xstrdup(\"\");\n\n\tif (use_askpass && getenv(\"DISPLAY\")) {\n\t\tif (getenv(SSH_ASKPASS_ENV))\n\t\t\taskpass = getenv(SSH_ASKPASS_ENV);\n\t\telse\n\t\t\taskpass = _PATH_SSH_ASKPASS_DEFAULT;\n\t\tif ((ret = ssh_askpass(askpass, prompt)) == NULL)\n\t\t\tif (!(flags & RP_ALLOW_EOF))\n\t\t\t\treturn xstrdup(\"\");\n\t\treturn ret;\n\t}\n\n\tif (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {\n\t\tif (flags & RP_ALLOW_EOF)\n\t\t\treturn NULL;\n\t\treturn xstrdup(\"\");\n\t}\n\n\tret = xstrdup(buf);\n\texplicit_bzero(buf, sizeof(buf));\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_u8",
          "args": [
            "ssh",
            "&echo"
          ],
          "line": 1783
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2496-2500",
          "snippet": "int\nsshpkt_get_u8(struct ssh *ssh, u_char *valp)\n{\n\treturn sshbuf_get_u8(ssh->state->incoming_packet, valp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_u8(struct ssh *ssh, u_char *valp)\n{\n\treturn sshbuf_get_u8(ssh->state->incoming_packet, valp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_cstring",
          "args": [
            "ssh",
            "&prompt",
            "NULL"
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2532-2536",
          "snippet": "int\nsshpkt_get_cstring(struct ssh *ssh, char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_cstring(ssh->state->incoming_packet, valp, lenp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_cstring(struct ssh *ssh, char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_cstring(ssh->state->incoming_packet, valp, lenp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"input_userauth_info_req: num_prompts %d\"",
            "num_prompts"
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u32",
          "args": [
            "ssh",
            "num_prompts"
          ],
          "line": 1777
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2441-2445",
          "snippet": "int\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_INFO_RESPONSE"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_u32",
          "args": [
            "ssh",
            "&num_prompts"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2502-2506",
          "snippet": "int\nsshpkt_get_u32(struct ssh *ssh, u_int32_t *valp)\n{\n\treturn sshbuf_get_u32(ssh->state->incoming_packet, valp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_u32(struct ssh *ssh, u_int32_t *valp)\n{\n\treturn sshbuf_get_u32(ssh->state->incoming_packet, valp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"%s\"",
            "inst"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "inst"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"input_userauth_info_req: no authentication context\""
          ],
          "line": 1755
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic Authmethod *authmethod_lookup(const char *name);\n\nint\ninput_userauth_info_req(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tchar *name = NULL, *inst = NULL, *lang = NULL, *prompt = NULL;\n\tchar *response = NULL;\n\tu_char echo = 0;\n\tu_int num_prompts, i;\n\tint r;\n\n\tdebug2(\"input_userauth_info_req\");\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_userauth_info_req: no authentication context\");\n\n\tauthctxt->info_req_seen = 1;\n\n\tif ((r = sshpkt_get_cstring(ssh, &name, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &inst, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &lang, NULL)) != 0)\n\t\tgoto out;\n\tif (strlen(name) > 0)\n\t\tlogit(\"%s\", name);\n\tif (strlen(inst) > 0)\n\t\tlogit(\"%s\", inst);\n\n\tif ((r = sshpkt_get_u32(ssh, &num_prompts)) != 0)\n\t\tgoto out;\n\t/*\n\t * Begin to build info response packet based on prompts requested.\n\t * We commit to providing the correct number of responses, so if\n\t * further on we run into a problem that prevents this, we have to\n\t * be sure and clean this up and send a correct error response.\n\t */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_INFO_RESPONSE)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, num_prompts)) != 0)\n\t\tgoto out;\n\n\tdebug2(\"input_userauth_info_req: num_prompts %d\", num_prompts);\n\tfor (i = 0; i < num_prompts; i++) {\n\t\tif ((r = sshpkt_get_cstring(ssh, &prompt, NULL)) != 0 ||\n\t\t    (r = sshpkt_get_u8(ssh, &echo)) != 0)\n\t\t\tgoto out;\n\t\tresponse = read_passphrase(prompt, echo ? RP_ECHO : 0);\n\t\tif ((r = sshpkt_put_cstring(ssh, response)) != 0)\n\t\t\tgoto out;\n\t\tfreezero(response, strlen(response));\n\t\tfree(prompt);\n\t\tresponse = prompt = NULL;\n\t}\n\t/* done with parsing incoming message. */\n\tif ((r = sshpkt_get_end(ssh)) != 0 ||\n\t    (r = sshpkt_add_padding(ssh, 64)) != 0)\n\t\tgoto out;\n\tr = sshpkt_send(ssh);\n out:\n\tif (response)\n\t\tfreezero(response, strlen(response));\n\tfree(prompt);\n\tfree(name);\n\tfree(inst);\n\tfree(lang);\n\treturn r;\n}"
  },
  {
    "function_name": "userauth_kbdint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "1708-1737",
    "snippet": "int\nuserauth_kbdint(Authctxt *authctxt)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tstatic int attempt = 0;\n\tint r;\n\n\tif (attempt++ >= options.number_of_password_prompts)\n\t\treturn 0;\n\t/* disable if no SSH2_MSG_USERAUTH_INFO_REQUEST has been seen */\n\tif (attempt > 1 && !authctxt->info_req_seen) {\n\t\tdebug3(\"userauth_kbdint: disable: no info_req_seen\");\n\t\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_INFO_REQUEST, NULL);\n\t\treturn 0;\n\t}\n\n\tdebug2(\"userauth_kbdint\");\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"\")) != 0 ||\t\t/* lang */\n\t    (r = sshpkt_put_cstring(ssh, options.kbd_interactive_devices ?\n\t    options.kbd_interactive_devices : \"\")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_INFO_REQUEST, &input_userauth_info_req);\n\treturn 1;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
      "int\tuserauth_none(Authctxt *);",
      "int\tuserauth_pubkey(Authctxt *);",
      "int\tuserauth_passwd(Authctxt *);",
      "int\tuserauth_kbdint(Authctxt *);",
      "int\tuserauth_hostbased(Authctxt *);",
      "void\tuserauth(Authctxt *, char *);",
      "static void pubkey_prepare(Authctxt *);",
      "static void pubkey_cleanup(Authctxt *);",
      "static void pubkey_reset(Authctxt *);",
      "static Authmethod *authmethod_lookup(const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_dispatch_set",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_INFO_REQUEST",
            "&input_userauth_info_req"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_dispatch_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dispatch.c",
          "lines": "81-85",
          "snippet": "void\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"dispatch.h\"",
            "#include \"log.h\"",
            "#include \"ssh2.h\"",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include <stdarg.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_cstring",
          "args": [
            "ssh",
            "options.kbd_interactive_devices ?\n\t    options.kbd_interactive_devices : \"\""
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2459-2463",
          "snippet": "int\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_REQUEST"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"userauth_kbdint\""
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"userauth_kbdint: disable: no info_req_seen\""
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic Authmethod *authmethod_lookup(const char *name);\n\nint\nuserauth_kbdint(Authctxt *authctxt)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tstatic int attempt = 0;\n\tint r;\n\n\tif (attempt++ >= options.number_of_password_prompts)\n\t\treturn 0;\n\t/* disable if no SSH2_MSG_USERAUTH_INFO_REQUEST has been seen */\n\tif (attempt > 1 && !authctxt->info_req_seen) {\n\t\tdebug3(\"userauth_kbdint: disable: no info_req_seen\");\n\t\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_INFO_REQUEST, NULL);\n\t\treturn 0;\n\t}\n\n\tdebug2(\"userauth_kbdint\");\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"\")) != 0 ||\t\t/* lang */\n\t    (r = sshpkt_put_cstring(ssh, options.kbd_interactive_devices ?\n\t    options.kbd_interactive_devices : \"\")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_INFO_REQUEST, &input_userauth_info_req);\n\treturn 1;\n}"
  },
  {
    "function_name": "userauth_pubkey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "1659-1703",
    "snippet": "int\nuserauth_pubkey(Authctxt *authctxt)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tIdentity *id;\n\tint sent = 0;\n\tchar *ident;\n\n\twhile ((id = TAILQ_FIRST(&authctxt->keys))) {\n\t\tif (id->tried++)\n\t\t\treturn (0);\n\t\t/* move key to the end of the queue */\n\t\tTAILQ_REMOVE(&authctxt->keys, id, next);\n\t\tTAILQ_INSERT_TAIL(&authctxt->keys, id, next);\n\t\t/*\n\t\t * send a test message if we have the public key. for\n\t\t * encrypted keys we cannot do this and have to load the\n\t\t * private key instead\n\t\t */\n\t\tif (id->key != NULL) {\n\t\t\tif (try_identity(id)) {\n\t\t\t\tident = format_identity(id);\n\t\t\t\tdebug(\"Offering public key: %s\", ident);\n\t\t\t\tfree(ident);\n\t\t\t\tsent = send_pubkey_test(ssh, authctxt, id);\n\t\t\t}\n\t\t} else {\n\t\t\tdebug(\"Trying private key: %s\", id->filename);\n\t\t\tid->key = load_identity_file(id);\n\t\t\tif (id->key != NULL) {\n\t\t\t\tif (try_identity(id)) {\n\t\t\t\t\tid->isprivate = 1;\n\t\t\t\t\tsent = sign_and_send_pubkey(ssh,\n\t\t\t\t\t    authctxt, id);\n\t\t\t\t}\n\t\t\t\tsshkey_free(id->key);\n\t\t\t\tid->key = NULL;\n\t\t\t\tid->isprivate = 0;\n\t\t\t}\n\t\t}\n\t\tif (sent)\n\t\t\treturn (sent);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
      "int\tuserauth_none(Authctxt *);",
      "int\tuserauth_pubkey(Authctxt *);",
      "int\tuserauth_passwd(Authctxt *);",
      "int\tuserauth_kbdint(Authctxt *);",
      "int\tuserauth_hostbased(Authctxt *);",
      "void\tuserauth(Authctxt *, char *);",
      "static int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);",
      "static void pubkey_prepare(Authctxt *);",
      "static void pubkey_cleanup(Authctxt *);",
      "static void pubkey_reset(Authctxt *);",
      "static struct sshkey *load_identity_file(Identity *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "id->key"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sign_and_send_pubkey",
          "args": [
            "ssh",
            "authctxt",
            "id"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "sign_and_send_pubkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "1182-1339",
          "snippet": "static int\nsign_and_send_pubkey(struct ssh *ssh, Authctxt *authctxt, Identity *id)\n{\n\tstruct sshbuf *b = NULL;\n\tIdentity *private_id, *sign_id = NULL;\n\tu_char *signature = NULL;\n\tsize_t slen = 0, skip = 0;\n\tint r, fallback_sigtype, sent = 0;\n\tchar *alg = NULL, *fp = NULL;\n\tconst char *loc = \"\";\n\n\tif ((fp = sshkey_fingerprint(id->key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\treturn 0;\n\n\tdebug3(\"%s: %s %s\", __func__, sshkey_type(id->key), fp);\n\n\t/*\n\t * If the key is an certificate, try to find a matching private key\n\t * and use it to complete the signature.\n\t * If no such private key exists, fall back to trying the certificate\n\t * key itself in case it has a private half already loaded.\n\t * This will try to set sign_id to the private key that will perform\n\t * the signature.\n\t */\n\tif (sshkey_is_cert(id->key)) {\n\t\tTAILQ_FOREACH(private_id, &authctxt->keys, next) {\n\t\t\tif (sshkey_equal_public(id->key, private_id->key) &&\n\t\t\t    id->key->type != private_id->key->type) {\n\t\t\t\tsign_id = private_id;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Exact key matches are preferred, but also allow\n\t\t * filename matches for non-PKCS#11/agent keys that\n\t\t * didn't load public keys. This supports the case\n\t\t * of keeping just a private key file and public\n\t\t * certificate on disk.\n\t\t */\n\t\tif (sign_id == NULL &&\n\t\t    !id->isprivate && id->agent_fd == -1 &&\n\t\t    (id->key->flags & SSHKEY_FLAG_EXT) == 0) {\n\t\t\tTAILQ_FOREACH(private_id, &authctxt->keys, next) {\n\t\t\t\tif (private_id->key == NULL &&\n\t\t\t\t    id_filename_matches(id, private_id)) {\n\t\t\t\t\tsign_id = private_id;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (sign_id != NULL) {\n\t\t\tdebug2(\"%s: using private key \\\"%s\\\"%s for \"\n\t\t\t    \"certificate\", __func__, id->filename,\n\t\t\t    id->agent_fd != -1 ? \" from agent\" : \"\");\n\t\t} else {\n\t\t\tdebug(\"%s: no separate private key for certificate \"\n\t\t\t    \"\\\"%s\\\"\", __func__, id->filename);\n\t\t}\n\t}\n\n\t/*\n\t * If the above didn't select another identity to do the signing\n\t * then default to the one we started with.\n\t */\n\tif (sign_id == NULL)\n\t\tsign_id = id;\n\n\t/* assemble and sign data */\n\tfor (fallback_sigtype = 0; fallback_sigtype <= 1; fallback_sigtype++) {\n\t\tfree(alg);\n\t\tslen = 0;\n\t\tsignature = NULL;\n\t\tif ((alg = key_sig_algorithm(fallback_sigtype ? NULL : ssh,\n\t\t    id->key)) == NULL) {\n\t\t\terror(\"%s: no mutual signature supported\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t\tdebug3(\"%s: signing using %s\", __func__, alg);\n\n\t\tsshbuf_free(b);\n\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\tif (datafellows & SSH_OLD_SESSIONID) {\n\t\t\tif ((r = sshbuf_put(b, session_id2,\n\t\t\t    session_id2_len)) != 0) {\n\t\t\t\tfatal(\"%s: sshbuf_put: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t} else {\n\t\t\tif ((r = sshbuf_put_string(b, session_id2,\n\t\t\t    session_id2_len)) != 0) {\n\t\t\t\tfatal(\"%s: sshbuf_put_string: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t}\n\t\tskip = sshbuf_len(b);\n\t\tif ((r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->server_user)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->method->name)) != 0 ||\n\t\t    (r = sshbuf_put_u8(b, 1)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, alg)) != 0 ||\n\t\t    (r = sshkey_puts(id->key, b)) != 0) {\n\t\t\tfatal(\"%s: assemble signed data: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t}\n\n\t\t/* generate signature */\n\t\tr = identity_sign(sign_id, &signature, &slen,\n\t\t    sshbuf_ptr(b), sshbuf_len(b), datafellows, alg);\n\t\tif (r == 0)\n\t\t\tbreak;\n\t\telse if (r == SSH_ERR_KEY_NOT_FOUND)\n\t\t\tgoto out; /* soft failure */\n\t\telse if (r == SSH_ERR_SIGN_ALG_UNSUPPORTED &&\n\t\t    !fallback_sigtype) {\n\t\t\tif (sign_id->agent_fd != -1)\n\t\t\t\tloc = \"agent \";\n\t\t\telse if ((sign_id->key->flags & SSHKEY_FLAG_EXT) != 0)\n\t\t\t\tloc = \"token \";\n\t\t\tlogit(\"%skey %s %s returned incorrect signature type\",\n\t\t\t    loc, sshkey_type(id->key), fp);\n\t\t\tcontinue;\n\t\t}\n\t\terror(\"%s: signing failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif (slen == 0 || signature == NULL) /* shouldn't happen */\n\t\tfatal(\"%s: no signature\", __func__);\n\n\t/* append signature */\n\tif ((r = sshbuf_put_string(b, signature, slen)) != 0)\n\t\tfatal(\"%s: append signature: %s\", __func__, ssh_err(r));\n\n#ifdef DEBUG_PK\n\tsshbuf_dump(b, stderr);\n#endif\n\t/* skip session id and packet type */\n\tif ((r = sshbuf_consume(b, skip + 1)) != 0)\n\t\tfatal(\"%s: consume: %s\", __func__, ssh_err(r));\n\n\t/* put remaining data from buffer into packet */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_putb(ssh, b)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: enqueue request: %s\", __func__, ssh_err(r));\n\n\t/* success */\n\tsent = 1;\n\n out:\n\tfree(fp);\n\tfree(alg);\n\tsshbuf_free(b);\n\tfreezero(signature, slen);\n\treturn sent;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "u_char *session_id2 = NULL;",
            "u_int session_id2_len = 0;",
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
            "int\tuserauth_none(Authctxt *);",
            "int\tuserauth_pubkey(Authctxt *);",
            "int\tuserauth_passwd(Authctxt *);",
            "int\tuserauth_kbdint(Authctxt *);",
            "int\tuserauth_hostbased(Authctxt *);",
            "void\tuserauth(Authctxt *, char *);",
            "static int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);",
            "static void pubkey_prepare(Authctxt *);",
            "static void pubkey_cleanup(Authctxt *);",
            "static void pubkey_reset(Authctxt *);",
            "static struct sshkey *load_identity_file(Identity *);",
            "static Authmethod *authmethod_lookup(const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nu_char *session_id2 = NULL;\nu_int session_id2_len = 0;\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic struct sshkey *load_identity_file(Identity *);\nstatic Authmethod *authmethod_lookup(const char *name);\n\nstatic int\nsign_and_send_pubkey(struct ssh *ssh, Authctxt *authctxt, Identity *id)\n{\n\tstruct sshbuf *b = NULL;\n\tIdentity *private_id, *sign_id = NULL;\n\tu_char *signature = NULL;\n\tsize_t slen = 0, skip = 0;\n\tint r, fallback_sigtype, sent = 0;\n\tchar *alg = NULL, *fp = NULL;\n\tconst char *loc = \"\";\n\n\tif ((fp = sshkey_fingerprint(id->key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\treturn 0;\n\n\tdebug3(\"%s: %s %s\", __func__, sshkey_type(id->key), fp);\n\n\t/*\n\t * If the key is an certificate, try to find a matching private key\n\t * and use it to complete the signature.\n\t * If no such private key exists, fall back to trying the certificate\n\t * key itself in case it has a private half already loaded.\n\t * This will try to set sign_id to the private key that will perform\n\t * the signature.\n\t */\n\tif (sshkey_is_cert(id->key)) {\n\t\tTAILQ_FOREACH(private_id, &authctxt->keys, next) {\n\t\t\tif (sshkey_equal_public(id->key, private_id->key) &&\n\t\t\t    id->key->type != private_id->key->type) {\n\t\t\t\tsign_id = private_id;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Exact key matches are preferred, but also allow\n\t\t * filename matches for non-PKCS#11/agent keys that\n\t\t * didn't load public keys. This supports the case\n\t\t * of keeping just a private key file and public\n\t\t * certificate on disk.\n\t\t */\n\t\tif (sign_id == NULL &&\n\t\t    !id->isprivate && id->agent_fd == -1 &&\n\t\t    (id->key->flags & SSHKEY_FLAG_EXT) == 0) {\n\t\t\tTAILQ_FOREACH(private_id, &authctxt->keys, next) {\n\t\t\t\tif (private_id->key == NULL &&\n\t\t\t\t    id_filename_matches(id, private_id)) {\n\t\t\t\t\tsign_id = private_id;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (sign_id != NULL) {\n\t\t\tdebug2(\"%s: using private key \\\"%s\\\"%s for \"\n\t\t\t    \"certificate\", __func__, id->filename,\n\t\t\t    id->agent_fd != -1 ? \" from agent\" : \"\");\n\t\t} else {\n\t\t\tdebug(\"%s: no separate private key for certificate \"\n\t\t\t    \"\\\"%s\\\"\", __func__, id->filename);\n\t\t}\n\t}\n\n\t/*\n\t * If the above didn't select another identity to do the signing\n\t * then default to the one we started with.\n\t */\n\tif (sign_id == NULL)\n\t\tsign_id = id;\n\n\t/* assemble and sign data */\n\tfor (fallback_sigtype = 0; fallback_sigtype <= 1; fallback_sigtype++) {\n\t\tfree(alg);\n\t\tslen = 0;\n\t\tsignature = NULL;\n\t\tif ((alg = key_sig_algorithm(fallback_sigtype ? NULL : ssh,\n\t\t    id->key)) == NULL) {\n\t\t\terror(\"%s: no mutual signature supported\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t\tdebug3(\"%s: signing using %s\", __func__, alg);\n\n\t\tsshbuf_free(b);\n\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\tif (datafellows & SSH_OLD_SESSIONID) {\n\t\t\tif ((r = sshbuf_put(b, session_id2,\n\t\t\t    session_id2_len)) != 0) {\n\t\t\t\tfatal(\"%s: sshbuf_put: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t} else {\n\t\t\tif ((r = sshbuf_put_string(b, session_id2,\n\t\t\t    session_id2_len)) != 0) {\n\t\t\t\tfatal(\"%s: sshbuf_put_string: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t}\n\t\tskip = sshbuf_len(b);\n\t\tif ((r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->server_user)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->method->name)) != 0 ||\n\t\t    (r = sshbuf_put_u8(b, 1)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, alg)) != 0 ||\n\t\t    (r = sshkey_puts(id->key, b)) != 0) {\n\t\t\tfatal(\"%s: assemble signed data: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t}\n\n\t\t/* generate signature */\n\t\tr = identity_sign(sign_id, &signature, &slen,\n\t\t    sshbuf_ptr(b), sshbuf_len(b), datafellows, alg);\n\t\tif (r == 0)\n\t\t\tbreak;\n\t\telse if (r == SSH_ERR_KEY_NOT_FOUND)\n\t\t\tgoto out; /* soft failure */\n\t\telse if (r == SSH_ERR_SIGN_ALG_UNSUPPORTED &&\n\t\t    !fallback_sigtype) {\n\t\t\tif (sign_id->agent_fd != -1)\n\t\t\t\tloc = \"agent \";\n\t\t\telse if ((sign_id->key->flags & SSHKEY_FLAG_EXT) != 0)\n\t\t\t\tloc = \"token \";\n\t\t\tlogit(\"%skey %s %s returned incorrect signature type\",\n\t\t\t    loc, sshkey_type(id->key), fp);\n\t\t\tcontinue;\n\t\t}\n\t\terror(\"%s: signing failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif (slen == 0 || signature == NULL) /* shouldn't happen */\n\t\tfatal(\"%s: no signature\", __func__);\n\n\t/* append signature */\n\tif ((r = sshbuf_put_string(b, signature, slen)) != 0)\n\t\tfatal(\"%s: append signature: %s\", __func__, ssh_err(r));\n\n#ifdef DEBUG_PK\n\tsshbuf_dump(b, stderr);\n#endif\n\t/* skip session id and packet type */\n\tif ((r = sshbuf_consume(b, skip + 1)) != 0)\n\t\tfatal(\"%s: consume: %s\", __func__, ssh_err(r));\n\n\t/* put remaining data from buffer into packet */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_putb(ssh, b)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: enqueue request: %s\", __func__, ssh_err(r));\n\n\t/* success */\n\tsent = 1;\n\n out:\n\tfree(fp);\n\tfree(alg);\n\tsshbuf_free(b);\n\tfreezero(signature, slen);\n\treturn sent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_identity",
          "args": [
            "id"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "try_identity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "1645-1657",
          "snippet": "static int\ntry_identity(Identity *id)\n{\n\tif (!id->key)\n\t\treturn (0);\n\tif (sshkey_type_plain(id->key->type) == KEY_RSA &&\n\t    (datafellows & SSH_BUG_RSASIGMD5) != 0) {\n\t\tdebug(\"Skipped %s key %s for RSA/MD5 server\",\n\t\t    sshkey_type(id->key), id->filename);\n\t\treturn (0);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);",
            "static struct sshkey *load_identity_file(Identity *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);\nstatic struct sshkey *load_identity_file(Identity *);\n\nstatic int\ntry_identity(Identity *id)\n{\n\tif (!id->key)\n\t\treturn (0);\n\tif (sshkey_type_plain(id->key->type) == KEY_RSA &&\n\t    (datafellows & SSH_BUG_RSASIGMD5) != 0) {\n\t\tdebug(\"Skipped %s key %s for RSA/MD5 server\",\n\t\t    sshkey_type(id->key), id->filename);\n\t\treturn (0);\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_identity_file",
          "args": [
            "id"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "load_identity_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "1380-1442",
          "snippet": "static struct sshkey *\nload_identity_file(Identity *id)\n{\n\tstruct sshkey *private = NULL;\n\tchar prompt[300], *passphrase, *comment;\n\tint r, perm_ok = 0, quit = 0, i;\n\tstruct stat st;\n\n\tif (stat(id->filename, &st) < 0) {\n\t\t(id->userprovided ? logit : debug3)(\"no such identity: %s: %s\",\n\t\t    id->filename, strerror(errno));\n\t\treturn NULL;\n\t}\n\tsnprintf(prompt, sizeof prompt,\n\t    \"Enter passphrase for key '%.100s': \", id->filename);\n\tfor (i = 0; i <= options.number_of_password_prompts; i++) {\n\t\tif (i == 0)\n\t\t\tpassphrase = \"\";\n\t\telse {\n\t\t\tpassphrase = read_passphrase(prompt, 0);\n\t\t\tif (*passphrase == '\\0') {\n\t\t\t\tdebug2(\"no passphrase given, try next key\");\n\t\t\t\tfree(passphrase);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tswitch ((r = sshkey_load_private_type(KEY_UNSPEC, id->filename,\n\t\t    passphrase, &private, &comment, &perm_ok))) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\t\tif (options.batch_mode) {\n\t\t\t\tquit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i != 0)\n\t\t\t\tdebug2(\"bad passphrase given, try again...\");\n\t\t\tbreak;\n\t\tcase SSH_ERR_SYSTEM_ERROR:\n\t\t\tif (errno == ENOENT) {\n\t\t\t\tdebug2(\"Load key \\\"%s\\\": %s\",\n\t\t\t\t    id->filename, ssh_err(r));\n\t\t\t\tquit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tdefault:\n\t\t\terror(\"Load key \\\"%s\\\": %s\", id->filename, ssh_err(r));\n\t\t\tquit = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!quit && private != NULL && id->agent_fd == -1 &&\n\t\t    !(id->key && id->isprivate))\n\t\t\tmaybe_add_key_to_agent(id->filename, private, comment,\n\t\t\t    passphrase);\n\t\tif (i > 0)\n\t\t\tfreezero(passphrase, strlen(passphrase));\n\t\tfree(comment);\n\t\tif (private != NULL || quit)\n\t\t\tbreak;\n\t}\n\treturn private;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "static int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);",
            "static struct sshkey *load_identity_file(Identity *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nstatic int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);\nstatic struct sshkey *load_identity_file(Identity *);\n\nstatic struct sshkey *\nload_identity_file(Identity *id)\n{\n\tstruct sshkey *private = NULL;\n\tchar prompt[300], *passphrase, *comment;\n\tint r, perm_ok = 0, quit = 0, i;\n\tstruct stat st;\n\n\tif (stat(id->filename, &st) < 0) {\n\t\t(id->userprovided ? logit : debug3)(\"no such identity: %s: %s\",\n\t\t    id->filename, strerror(errno));\n\t\treturn NULL;\n\t}\n\tsnprintf(prompt, sizeof prompt,\n\t    \"Enter passphrase for key '%.100s': \", id->filename);\n\tfor (i = 0; i <= options.number_of_password_prompts; i++) {\n\t\tif (i == 0)\n\t\t\tpassphrase = \"\";\n\t\telse {\n\t\t\tpassphrase = read_passphrase(prompt, 0);\n\t\t\tif (*passphrase == '\\0') {\n\t\t\t\tdebug2(\"no passphrase given, try next key\");\n\t\t\t\tfree(passphrase);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tswitch ((r = sshkey_load_private_type(KEY_UNSPEC, id->filename,\n\t\t    passphrase, &private, &comment, &perm_ok))) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\t\tif (options.batch_mode) {\n\t\t\t\tquit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i != 0)\n\t\t\t\tdebug2(\"bad passphrase given, try again...\");\n\t\t\tbreak;\n\t\tcase SSH_ERR_SYSTEM_ERROR:\n\t\t\tif (errno == ENOENT) {\n\t\t\t\tdebug2(\"Load key \\\"%s\\\": %s\",\n\t\t\t\t    id->filename, ssh_err(r));\n\t\t\t\tquit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tdefault:\n\t\t\terror(\"Load key \\\"%s\\\": %s\", id->filename, ssh_err(r));\n\t\t\tquit = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!quit && private != NULL && id->agent_fd == -1 &&\n\t\t    !(id->key && id->isprivate))\n\t\t\tmaybe_add_key_to_agent(id->filename, private, comment,\n\t\t\t    passphrase);\n\t\tif (i > 0)\n\t\t\tfreezero(passphrase, strlen(passphrase));\n\t\tfree(comment);\n\t\tif (private != NULL || quit)\n\t\t\tbreak;\n\t}\n\treturn private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Trying private key: %s\"",
            "id->filename"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_pubkey_test",
          "args": [
            "ssh",
            "authctxt",
            "id"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "send_pubkey_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "1341-1378",
          "snippet": "static int\nsend_pubkey_test(struct ssh *ssh, Authctxt *authctxt, Identity *id)\n{\n\tu_char *blob = NULL;\n\tchar *alg = NULL;\n\tsize_t bloblen;\n\tu_int have_sig = 0;\n\tint sent = 0, r;\n\n\tif ((alg = key_sig_algorithm(ssh, id->key)) == NULL) {\n\t\tdebug(\"%s: no mutual signature algorithm\", __func__);\n\t\tgoto out;\n\t}\n\n\tif ((r = sshkey_to_blob(id->key, &blob, &bloblen)) != 0) {\n\t\t/* we cannot handle this key */\n\t\tdebug3(\"%s: cannot handle key\", __func__);\n\t\tgoto out;\n\t}\n\t/* register callback for USERAUTH_PK_OK message */\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_PK_OK, &input_userauth_pk_ok);\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, have_sig)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, alg)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, blob, bloblen)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tsent = 1;\n\n out:\n\tfree(alg);\n\tfree(blob);\n\treturn sent;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
            "int\tuserauth_none(Authctxt *);",
            "int\tuserauth_pubkey(Authctxt *);",
            "int\tuserauth_passwd(Authctxt *);",
            "int\tuserauth_kbdint(Authctxt *);",
            "int\tuserauth_hostbased(Authctxt *);",
            "void\tuserauth(Authctxt *, char *);",
            "static int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);",
            "static void pubkey_prepare(Authctxt *);",
            "static void pubkey_cleanup(Authctxt *);",
            "static void pubkey_reset(Authctxt *);",
            "static struct sshkey *load_identity_file(Identity *);",
            "static Authmethod *authmethod_lookup(const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic struct sshkey *load_identity_file(Identity *);\nstatic Authmethod *authmethod_lookup(const char *name);\n\nstatic int\nsend_pubkey_test(struct ssh *ssh, Authctxt *authctxt, Identity *id)\n{\n\tu_char *blob = NULL;\n\tchar *alg = NULL;\n\tsize_t bloblen;\n\tu_int have_sig = 0;\n\tint sent = 0, r;\n\n\tif ((alg = key_sig_algorithm(ssh, id->key)) == NULL) {\n\t\tdebug(\"%s: no mutual signature algorithm\", __func__);\n\t\tgoto out;\n\t}\n\n\tif ((r = sshkey_to_blob(id->key, &blob, &bloblen)) != 0) {\n\t\t/* we cannot handle this key */\n\t\tdebug3(\"%s: cannot handle key\", __func__);\n\t\tgoto out;\n\t}\n\t/* register callback for USERAUTH_PK_OK message */\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_PK_OK, &input_userauth_pk_ok);\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, have_sig)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, alg)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, blob, bloblen)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tsent = 1;\n\n out:\n\tfree(alg);\n\tfree(blob);\n\treturn sent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ident"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_identity",
          "args": [
            "id"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "format_identity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "588-606",
          "snippet": "static char *\nformat_identity(Identity *id)\n{\n\tchar *fp = NULL, *ret = NULL;\n\n\tif (id->key != NULL) {\n\t     fp = sshkey_fingerprint(id->key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t}\n\txasprintf(&ret, \"%s %s%s%s%s%s%s\",\n\t    id->filename,\n\t    id->key ? sshkey_type(id->key) : \"\", id->key ? \" \" : \"\",\n\t    fp ? fp : \"\",\n\t    id->userprovided ? \" explicit\" : \"\",\n\t    (id->key && (id->key->flags & SSHKEY_FLAG_EXT)) ? \" token\" : \"\",\n\t    id->agent_fd != -1 ? \" agent\" : \"\");\n\tfree(fp);\n\treturn ret;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "static int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);",
            "static struct sshkey *load_identity_file(Identity *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nstatic int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);\nstatic struct sshkey *load_identity_file(Identity *);\n\nstatic char *\nformat_identity(Identity *id)\n{\n\tchar *fp = NULL, *ret = NULL;\n\n\tif (id->key != NULL) {\n\t     fp = sshkey_fingerprint(id->key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t}\n\txasprintf(&ret, \"%s %s%s%s%s%s%s\",\n\t    id->filename,\n\t    id->key ? sshkey_type(id->key) : \"\", id->key ? \" \" : \"\",\n\t    fp ? fp : \"\",\n\t    id->userprovided ? \" explicit\" : \"\",\n\t    (id->key && (id->key->flags & SSHKEY_FLAG_EXT)) ? \" token\" : \"\",\n\t    id->agent_fd != -1 ? \" agent\" : \"\");\n\tfree(fp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&authctxt->keys",
            "id",
            "next"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&authctxt->keys",
            "id",
            "next"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&authctxt->keys"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic struct sshkey *load_identity_file(Identity *);\n\nint\nuserauth_pubkey(Authctxt *authctxt)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tIdentity *id;\n\tint sent = 0;\n\tchar *ident;\n\n\twhile ((id = TAILQ_FIRST(&authctxt->keys))) {\n\t\tif (id->tried++)\n\t\t\treturn (0);\n\t\t/* move key to the end of the queue */\n\t\tTAILQ_REMOVE(&authctxt->keys, id, next);\n\t\tTAILQ_INSERT_TAIL(&authctxt->keys, id, next);\n\t\t/*\n\t\t * send a test message if we have the public key. for\n\t\t * encrypted keys we cannot do this and have to load the\n\t\t * private key instead\n\t\t */\n\t\tif (id->key != NULL) {\n\t\t\tif (try_identity(id)) {\n\t\t\t\tident = format_identity(id);\n\t\t\t\tdebug(\"Offering public key: %s\", ident);\n\t\t\t\tfree(ident);\n\t\t\t\tsent = send_pubkey_test(ssh, authctxt, id);\n\t\t\t}\n\t\t} else {\n\t\t\tdebug(\"Trying private key: %s\", id->filename);\n\t\t\tid->key = load_identity_file(id);\n\t\t\tif (id->key != NULL) {\n\t\t\t\tif (try_identity(id)) {\n\t\t\t\t\tid->isprivate = 1;\n\t\t\t\t\tsent = sign_and_send_pubkey(ssh,\n\t\t\t\t\t    authctxt, id);\n\t\t\t\t}\n\t\t\t\tsshkey_free(id->key);\n\t\t\t\tid->key = NULL;\n\t\t\t\tid->isprivate = 0;\n\t\t\t}\n\t\t}\n\t\tif (sent)\n\t\t\treturn (sent);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "try_identity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "1645-1657",
    "snippet": "static int\ntry_identity(Identity *id)\n{\n\tif (!id->key)\n\t\treturn (0);\n\tif (sshkey_type_plain(id->key->type) == KEY_RSA &&\n\t    (datafellows & SSH_BUG_RSASIGMD5) != 0) {\n\t\tdebug(\"Skipped %s key %s for RSA/MD5 server\",\n\t\t    sshkey_type(id->key), id->filename);\n\t\treturn (0);\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);",
      "static struct sshkey *load_identity_file(Identity *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Skipped %s key %s for RSA/MD5 server\"",
            "sshkey_type(id->key)",
            "id->filename"
          ],
          "line": 1652
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "id->key"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);\nstatic struct sshkey *load_identity_file(Identity *);\n\nstatic int\ntry_identity(Identity *id)\n{\n\tif (!id->key)\n\t\treturn (0);\n\tif (sshkey_type_plain(id->key->type) == KEY_RSA &&\n\t    (datafellows & SSH_BUG_RSASIGMD5) != 0) {\n\t\tdebug(\"Skipped %s key %s for RSA/MD5 server\",\n\t\t    sshkey_type(id->key), id->filename);\n\t\treturn (0);\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "pubkey_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "1636-1643",
    "snippet": "static void\npubkey_reset(Authctxt *authctxt)\n{\n\tIdentity *id;\n\n\tTAILQ_FOREACH(id, &authctxt->keys, next)\n\t\tid->tried = 0;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tuserauth_none(Authctxt *);",
      "int\tuserauth_pubkey(Authctxt *);",
      "int\tuserauth_passwd(Authctxt *);",
      "int\tuserauth_kbdint(Authctxt *);",
      "int\tuserauth_hostbased(Authctxt *);",
      "void\tuserauth(Authctxt *, char *);",
      "static int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);",
      "static void pubkey_prepare(Authctxt *);",
      "static void pubkey_cleanup(Authctxt *);",
      "static void pubkey_reset(Authctxt *);",
      "static struct sshkey *load_identity_file(Identity *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TAILQ_FOREACH",
          "args": [
            "id",
            "&authctxt->keys",
            "next"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic struct sshkey *load_identity_file(Identity *);\n\nstatic void\npubkey_reset(Authctxt *authctxt)\n{\n\tIdentity *id;\n\n\tTAILQ_FOREACH(id, &authctxt->keys, next)\n\t\tid->tried = 0;\n}"
  },
  {
    "function_name": "pubkey_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "1618-1634",
    "snippet": "static void\npubkey_cleanup(Authctxt *authctxt)\n{\n\tIdentity *id;\n\n\tif (authctxt->agent_fd != -1) {\n\t\tssh_close_authentication_socket(authctxt->agent_fd);\n\t\tauthctxt->agent_fd = -1;\n\t}\n\tfor (id = TAILQ_FIRST(&authctxt->keys); id;\n\t    id = TAILQ_FIRST(&authctxt->keys)) {\n\t\tTAILQ_REMOVE(&authctxt->keys, id, next);\n\t\tsshkey_free(id->key);\n\t\tfree(id->filename);\n\t\tfree(id);\n\t}\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tuserauth_none(Authctxt *);",
      "int\tuserauth_pubkey(Authctxt *);",
      "int\tuserauth_passwd(Authctxt *);",
      "int\tuserauth_kbdint(Authctxt *);",
      "int\tuserauth_hostbased(Authctxt *);",
      "void\tuserauth(Authctxt *, char *);",
      "static int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);",
      "static void pubkey_prepare(Authctxt *);",
      "static void pubkey_cleanup(Authctxt *);",
      "static void pubkey_reset(Authctxt *);",
      "static struct sshkey *load_identity_file(Identity *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "id"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "id->key"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&authctxt->keys",
            "id",
            "next"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&authctxt->keys"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&authctxt->keys"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_close_authentication_socket",
          "args": [
            "authctxt->agent_fd"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic struct sshkey *load_identity_file(Identity *);\n\nstatic void\npubkey_cleanup(Authctxt *authctxt)\n{\n\tIdentity *id;\n\n\tif (authctxt->agent_fd != -1) {\n\t\tssh_close_authentication_socket(authctxt->agent_fd);\n\t\tauthctxt->agent_fd = -1;\n\t}\n\tfor (id = TAILQ_FIRST(&authctxt->keys); id;\n\t    id = TAILQ_FIRST(&authctxt->keys)) {\n\t\tTAILQ_REMOVE(&authctxt->keys, id, next);\n\t\tsshkey_free(id->key);\n\t\tfree(id->filename);\n\t\tfree(id);\n\t}\n}"
  },
  {
    "function_name": "pubkey_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "1482-1616",
    "snippet": "static void\npubkey_prepare(Authctxt *authctxt)\n{\n\tstruct identity *id, *id2, *tmp;\n\tstruct idlist agent, files, *preferred;\n\tstruct sshkey *key;\n\tint agent_fd = -1, i, r, found;\n\tsize_t j;\n\tstruct ssh_identitylist *idlist;\n\tchar *ident;\n\n\tTAILQ_INIT(&agent);\t/* keys from the agent */\n\tTAILQ_INIT(&files);\t/* keys from the config file */\n\tpreferred = &authctxt->keys;\n\tTAILQ_INIT(preferred);\t/* preferred order of keys */\n\n\t/* list of keys stored in the filesystem and PKCS#11 */\n\tfor (i = 0; i < options.num_identity_files; i++) {\n\t\tkey = options.identity_keys[i];\n\t\tif (key && key->cert && key->cert->type != SSH2_CERT_TYPE_USER)\n\t\t\tcontinue;\n\t\toptions.identity_keys[i] = NULL;\n\t\tid = xcalloc(1, sizeof(*id));\n\t\tid->agent_fd = -1;\n\t\tid->key = key;\n\t\tid->filename = xstrdup(options.identity_files[i]);\n\t\tid->userprovided = options.identity_file_userprovided[i];\n\t\tTAILQ_INSERT_TAIL(&files, id, next);\n\t}\n\t/* list of certificates specified by user */\n\tfor (i = 0; i < options.num_certificate_files; i++) {\n\t\tkey = options.certificates[i];\n\t\tif (!sshkey_is_cert(key) || key->cert == NULL ||\n\t\t    key->cert->type != SSH2_CERT_TYPE_USER)\n\t\t\tcontinue;\n\t\tid = xcalloc(1, sizeof(*id));\n\t\tid->agent_fd = -1;\n\t\tid->key = key;\n\t\tid->filename = xstrdup(options.certificate_files[i]);\n\t\tid->userprovided = options.certificate_file_userprovided[i];\n\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t}\n\t/* list of keys supported by the agent */\n\tif ((r = ssh_get_authentication_socket(&agent_fd)) != 0) {\n\t\tif (r != SSH_ERR_AGENT_NOT_PRESENT)\n\t\t\tdebug(\"%s: ssh_get_authentication_socket: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t} else if ((r = ssh_fetch_identitylist(agent_fd, &idlist)) != 0) {\n\t\tif (r != SSH_ERR_AGENT_NO_IDENTITIES)\n\t\t\tdebug(\"%s: ssh_fetch_identitylist: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\tclose(agent_fd);\n\t} else {\n\t\tfor (j = 0; j < idlist->nkeys; j++) {\n\t\t\tfound = 0;\n\t\t\tTAILQ_FOREACH(id, &files, next) {\n\t\t\t\t/*\n\t\t\t\t * agent keys from the config file are\n\t\t\t\t * preferred\n\t\t\t\t */\n\t\t\t\tif (sshkey_equal(idlist->keys[j], id->key)) {\n\t\t\t\t\tTAILQ_REMOVE(&files, id, next);\n\t\t\t\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t\t\t\t\tid->agent_fd = agent_fd;\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found && !options.identities_only) {\n\t\t\t\tid = xcalloc(1, sizeof(*id));\n\t\t\t\t/* XXX \"steals\" key/comment from idlist */\n\t\t\t\tid->key = idlist->keys[j];\n\t\t\t\tid->filename = idlist->comments[j];\n\t\t\t\tidlist->keys[j] = NULL;\n\t\t\t\tidlist->comments[j] = NULL;\n\t\t\t\tid->agent_fd = agent_fd;\n\t\t\t\tTAILQ_INSERT_TAIL(&agent, id, next);\n\t\t\t}\n\t\t}\n\t\tssh_free_identitylist(idlist);\n\t\t/* append remaining agent keys */\n\t\tfor (id = TAILQ_FIRST(&agent); id; id = TAILQ_FIRST(&agent)) {\n\t\t\tTAILQ_REMOVE(&agent, id, next);\n\t\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t\t}\n\t\tauthctxt->agent_fd = agent_fd;\n\t}\n\t/* Prefer PKCS11 keys that are explicitly listed */\n\tTAILQ_FOREACH_SAFE(id, &files, next, tmp) {\n\t\tif (id->key == NULL || (id->key->flags & SSHKEY_FLAG_EXT) == 0)\n\t\t\tcontinue;\n\t\tfound = 0;\n\t\tTAILQ_FOREACH(id2, &files, next) {\n\t\t\tif (id2->key == NULL ||\n\t\t\t    (id2->key->flags & SSHKEY_FLAG_EXT) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (sshkey_equal(id->key, id2->key)) {\n\t\t\t\tTAILQ_REMOVE(&files, id, next);\n\t\t\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* If IdentitiesOnly set and key not found then don't use it */\n\t\tif (!found && options.identities_only) {\n\t\t\tTAILQ_REMOVE(&files, id, next);\n\t\t\tfreezero(id, sizeof(*id));\n\t\t}\n\t}\n\t/* append remaining keys from the config file */\n\tfor (id = TAILQ_FIRST(&files); id; id = TAILQ_FIRST(&files)) {\n\t\tTAILQ_REMOVE(&files, id, next);\n\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t}\n\t/* finally, filter by PubkeyAcceptedKeyTypes */\n\tTAILQ_FOREACH_SAFE(id, preferred, next, id2) {\n\t\tif (id->key != NULL && !key_type_allowed_by_config(id->key)) {\n\t\t\tdebug(\"Skipping %s key %s - \"\n\t\t\t    \"not in PubkeyAcceptedKeyTypes\",\n\t\t\t    sshkey_ssh_name(id->key), id->filename);\n\t\t\tTAILQ_REMOVE(preferred, id, next);\n\t\t\tsshkey_free(id->key);\n\t\t\tfree(id->filename);\n\t\t\tmemset(id, 0, sizeof(*id));\n\t\t\tcontinue;\n\t\t}\n\t}\n\t/* List the keys we plan on using */\n\tTAILQ_FOREACH_SAFE(id, preferred, next, id2) {\n\t\tident = format_identity(id);\n\t\tdebug(\"Will attempt key: %s\", ident);\n\t\tfree(ident);\n\t}\n\tdebug2(\"%s: done\", __func__);\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "int\tuserauth_none(Authctxt *);",
      "int\tuserauth_pubkey(Authctxt *);",
      "int\tuserauth_passwd(Authctxt *);",
      "int\tuserauth_kbdint(Authctxt *);",
      "int\tuserauth_hostbased(Authctxt *);",
      "void\tuserauth(Authctxt *, char *);",
      "static void pubkey_prepare(Authctxt *);",
      "static void pubkey_cleanup(Authctxt *);",
      "static void pubkey_reset(Authctxt *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: done\"",
            "__func__"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ident"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Will attempt key: %s\"",
            "ident"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_identity",
          "args": [
            "id"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "format_identity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "588-606",
          "snippet": "static char *\nformat_identity(Identity *id)\n{\n\tchar *fp = NULL, *ret = NULL;\n\n\tif (id->key != NULL) {\n\t     fp = sshkey_fingerprint(id->key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t}\n\txasprintf(&ret, \"%s %s%s%s%s%s%s\",\n\t    id->filename,\n\t    id->key ? sshkey_type(id->key) : \"\", id->key ? \" \" : \"\",\n\t    fp ? fp : \"\",\n\t    id->userprovided ? \" explicit\" : \"\",\n\t    (id->key && (id->key->flags & SSHKEY_FLAG_EXT)) ? \" token\" : \"\",\n\t    id->agent_fd != -1 ? \" agent\" : \"\");\n\tfree(fp);\n\treturn ret;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "static int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);",
            "static struct sshkey *load_identity_file(Identity *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nstatic int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);\nstatic struct sshkey *load_identity_file(Identity *);\n\nstatic char *\nformat_identity(Identity *id)\n{\n\tchar *fp = NULL, *ret = NULL;\n\n\tif (id->key != NULL) {\n\t     fp = sshkey_fingerprint(id->key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t}\n\txasprintf(&ret, \"%s %s%s%s%s%s%s\",\n\t    id->filename,\n\t    id->key ? sshkey_type(id->key) : \"\", id->key ? \" \" : \"\",\n\t    fp ? fp : \"\",\n\t    id->userprovided ? \" explicit\" : \"\",\n\t    (id->key && (id->key->flags & SSHKEY_FLAG_EXT)) ? \" token\" : \"\",\n\t    id->agent_fd != -1 ? \" agent\" : \"\");\n\tfree(fp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_FOREACH_SAFE",
          "args": [
            "id",
            "preferred",
            "next",
            "id2"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "id",
            "0",
            "sizeof(*id)"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "id->key"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "preferred",
            "id",
            "next"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_ssh_name",
          "args": [
            "id->key"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "183-188",
          "snippet": "const char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_type_allowed_by_config",
          "args": [
            "id->key"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "key_type_allowed_by_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "1444-1471",
          "snippet": "static int\nkey_type_allowed_by_config(struct sshkey *key)\n{\n\tif (match_pattern_list(sshkey_ssh_name(key),\n\t    options.pubkey_key_types, 0) == 1)\n\t\treturn 1;\n\n\t/* RSA keys/certs might be allowed by alternate signature types */\n\tswitch (key->type) {\n\tcase KEY_RSA:\n\t\tif (match_pattern_list(\"rsa-sha2-512\",\n\t\t    options.pubkey_key_types, 0) == 1)\n\t\t\treturn 1;\n\t\tif (match_pattern_list(\"rsa-sha2-256\",\n\t\t    options.pubkey_key_types, 0) == 1)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase KEY_RSA_CERT:\n\t\tif (match_pattern_list(\"rsa-sha2-512-cert-v01@openssh.com\",\n\t\t    options.pubkey_key_types, 0) == 1)\n\t\t\treturn 1;\n\t\tif (match_pattern_list(\"rsa-sha2-256-cert-v01@openssh.com\",\n\t\t    options.pubkey_key_types, 0) == 1)\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nstatic int\nkey_type_allowed_by_config(struct sshkey *key)\n{\n\tif (match_pattern_list(sshkey_ssh_name(key),\n\t    options.pubkey_key_types, 0) == 1)\n\t\treturn 1;\n\n\t/* RSA keys/certs might be allowed by alternate signature types */\n\tswitch (key->type) {\n\tcase KEY_RSA:\n\t\tif (match_pattern_list(\"rsa-sha2-512\",\n\t\t    options.pubkey_key_types, 0) == 1)\n\t\t\treturn 1;\n\t\tif (match_pattern_list(\"rsa-sha2-256\",\n\t\t    options.pubkey_key_types, 0) == 1)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase KEY_RSA_CERT:\n\t\tif (match_pattern_list(\"rsa-sha2-512-cert-v01@openssh.com\",\n\t\t    options.pubkey_key_types, 0) == 1)\n\t\t\treturn 1;\n\t\tif (match_pattern_list(\"rsa-sha2-256-cert-v01@openssh.com\",\n\t\t    options.pubkey_key_types, 0) == 1)\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_FOREACH_SAFE",
          "args": [
            "id",
            "preferred",
            "next",
            "id2"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "preferred",
            "id",
            "next"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&files",
            "id",
            "next"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&files"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&files"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freezero",
          "args": [
            "id",
            "sizeof(*id)"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "freezero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/freezero.c",
          "lines": "24-31",
          "snippet": "void\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&files",
            "id",
            "next"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "preferred",
            "id",
            "next"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&files",
            "id",
            "next"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_equal",
          "args": [
            "id->key",
            "id2->key"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "704-714",
          "snippet": "int\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_FOREACH",
          "args": [
            "id2",
            "&files",
            "next"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FOREACH_SAFE",
          "args": [
            "id",
            "&files",
            "next",
            "tmp"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "preferred",
            "id",
            "next"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&agent",
            "id",
            "next"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&agent"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&agent"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_free_identitylist",
          "args": [
            "idlist"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_free_identitylist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "302-316",
          "snippet": "void\nssh_free_identitylist(struct ssh_identitylist *idl)\n{\n\tsize_t i;\n\n\tif (idl == NULL)\n\t\treturn;\n\tfor (i = 0; i < idl->nkeys; i++) {\n\t\tif (idl->keys != NULL)\n\t\t\tsshkey_free(idl->keys[i]);\n\t\tif (idl->comments != NULL)\n\t\t\tfree(idl->comments[i]);\n\t}\n\tfree(idl);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_free_identitylist(struct ssh_identitylist *idl)\n{\n\tsize_t i;\n\n\tif (idl == NULL)\n\t\treturn;\n\tfor (i = 0; i < idl->nkeys; i++) {\n\t\tif (idl->keys != NULL)\n\t\t\tsshkey_free(idl->keys[i]);\n\t\tif (idl->comments != NULL)\n\t\t\tfree(idl->comments[i]);\n\t}\n\tfree(idl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&agent",
            "id",
            "next"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "1",
            "sizeof(*id)"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "preferred",
            "id",
            "next"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&files",
            "id",
            "next"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FOREACH",
          "args": [
            "id",
            "&files",
            "next"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "agent_fd"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_fetch_identitylist",
          "args": [
            "agent_fd",
            "&idlist"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_fetch_identitylist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "228-300",
          "snippet": "int\nssh_fetch_identitylist(int sock, struct ssh_identitylist **idlp)\n{\n\tu_char type;\n\tu_int32_t num, i;\n\tstruct sshbuf *msg;\n\tstruct ssh_identitylist *idl = NULL;\n\tint r;\n\n\t/*\n\t * Send a message to the agent requesting for a list of the\n\t * identities it can represent.\n\t */\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENTC_REQUEST_IDENTITIES)) != 0)\n\t\tgoto out;\n\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\n\t/* Get message type, and verify that we got a proper answer. */\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tif (agent_failed(type)) {\n\t\tr = SSH_ERR_AGENT_FAILURE;\n\t\tgoto out;\n\t} else if (type != SSH2_AGENT_IDENTITIES_ANSWER) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* Get the number of entries in the response and check it for sanity. */\n\tif ((r = sshbuf_get_u32(msg, &num)) != 0)\n\t\tgoto out;\n\tif (num > MAX_AGENT_IDENTITIES) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (num == 0) {\n\t\tr = SSH_ERR_AGENT_NO_IDENTITIES;\n\t\tgoto out;\n\t}\n\n\t/* Deserialise the response into a list of keys/comments */\n\tif ((idl = calloc(1, sizeof(*idl))) == NULL ||\n\t    (idl->keys = calloc(num, sizeof(*idl->keys))) == NULL ||\n\t    (idl->comments = calloc(num, sizeof(*idl->comments))) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < num;) {\n\t\tif ((r = deserialise_identity2(msg, &(idl->keys[i]),\n\t\t    &(idl->comments[i]))) != 0) {\n\t\t\tif (r == SSH_ERR_KEY_TYPE_UNKNOWN) {\n\t\t\t\t/* Gracefully skip unknown key types */\n\t\t\t\tnum--;\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tgoto out;\n\t\t}\n\t\ti++;\n\t}\n\tidl->nkeys = num;\n\t*idlp = idl;\n\tidl = NULL;\n\tr = 0;\n out:\n\tsshbuf_free(msg);\n\tif (idl != NULL)\n\t\tssh_free_identitylist(idl);\n\treturn r;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MAX_AGENT_IDENTITIES\t2048\t\t/* Max keys in agent reply */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MAX_AGENT_IDENTITIES\t2048\t\t/* Max keys in agent reply */\n\nint\nssh_fetch_identitylist(int sock, struct ssh_identitylist **idlp)\n{\n\tu_char type;\n\tu_int32_t num, i;\n\tstruct sshbuf *msg;\n\tstruct ssh_identitylist *idl = NULL;\n\tint r;\n\n\t/*\n\t * Send a message to the agent requesting for a list of the\n\t * identities it can represent.\n\t */\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENTC_REQUEST_IDENTITIES)) != 0)\n\t\tgoto out;\n\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\n\t/* Get message type, and verify that we got a proper answer. */\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tif (agent_failed(type)) {\n\t\tr = SSH_ERR_AGENT_FAILURE;\n\t\tgoto out;\n\t} else if (type != SSH2_AGENT_IDENTITIES_ANSWER) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t/* Get the number of entries in the response and check it for sanity. */\n\tif ((r = sshbuf_get_u32(msg, &num)) != 0)\n\t\tgoto out;\n\tif (num > MAX_AGENT_IDENTITIES) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (num == 0) {\n\t\tr = SSH_ERR_AGENT_NO_IDENTITIES;\n\t\tgoto out;\n\t}\n\n\t/* Deserialise the response into a list of keys/comments */\n\tif ((idl = calloc(1, sizeof(*idl))) == NULL ||\n\t    (idl->keys = calloc(num, sizeof(*idl->keys))) == NULL ||\n\t    (idl->comments = calloc(num, sizeof(*idl->comments))) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < num;) {\n\t\tif ((r = deserialise_identity2(msg, &(idl->keys[i]),\n\t\t    &(idl->comments[i]))) != 0) {\n\t\t\tif (r == SSH_ERR_KEY_TYPE_UNKNOWN) {\n\t\t\t\t/* Gracefully skip unknown key types */\n\t\t\t\tnum--;\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tgoto out;\n\t\t}\n\t\ti++;\n\t}\n\tidl->nkeys = num;\n\t*idlp = idl;\n\tidl = NULL;\n\tr = 0;\n out:\n\tsshbuf_free(msg);\n\tif (idl != NULL)\n\t\tssh_free_identitylist(idl);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_get_authentication_socket",
          "args": [
            "&agent_fd"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_get_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "86-120",
          "snippet": "int\nssh_get_authentication_socket(int *fdp)\n{\n\tconst char *authsocket;\n\tint sock, oerrno;\n\tstruct sockaddr_un sunaddr;\n\n\tif (fdp != NULL)\n\t\t*fdp = -1;\n\n\tauthsocket = getenv(SSH_AUTHSOCKET_ENV_NAME);\n\tif (!authsocket)\n\t\treturn SSH_ERR_AGENT_NOT_PRESENT;\n\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tstrlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));\n\n\tif ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\t/* close on exec */\n\tif (fcntl(sock, F_SETFD, FD_CLOEXEC) == -1 ||\n\t    connect(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {\n\t\toerrno = errno;\n\t\tclose(sock);\n\t\terrno = oerrno;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\tif (fdp != NULL)\n\t\t*fdp = sock;\n\telse\n\t\tclose(sock);\n\treturn 0;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_get_authentication_socket(int *fdp)\n{\n\tconst char *authsocket;\n\tint sock, oerrno;\n\tstruct sockaddr_un sunaddr;\n\n\tif (fdp != NULL)\n\t\t*fdp = -1;\n\n\tauthsocket = getenv(SSH_AUTHSOCKET_ENV_NAME);\n\tif (!authsocket)\n\t\treturn SSH_ERR_AGENT_NOT_PRESENT;\n\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tstrlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));\n\n\tif ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\t/* close on exec */\n\tif (fcntl(sock, F_SETFD, FD_CLOEXEC) == -1 ||\n\t    connect(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {\n\t\toerrno = errno;\n\t\tclose(sock);\n\t\terrno = oerrno;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\tif (fdp != NULL)\n\t\t*fdp = sock;\n\telse\n\t\tclose(sock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "preferred",
            "id",
            "next"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "options.certificate_files[i]"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "key"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&files",
            "id",
            "next"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "preferred"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&files"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&agent"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\n\nstatic void\npubkey_prepare(Authctxt *authctxt)\n{\n\tstruct identity *id, *id2, *tmp;\n\tstruct idlist agent, files, *preferred;\n\tstruct sshkey *key;\n\tint agent_fd = -1, i, r, found;\n\tsize_t j;\n\tstruct ssh_identitylist *idlist;\n\tchar *ident;\n\n\tTAILQ_INIT(&agent);\t/* keys from the agent */\n\tTAILQ_INIT(&files);\t/* keys from the config file */\n\tpreferred = &authctxt->keys;\n\tTAILQ_INIT(preferred);\t/* preferred order of keys */\n\n\t/* list of keys stored in the filesystem and PKCS#11 */\n\tfor (i = 0; i < options.num_identity_files; i++) {\n\t\tkey = options.identity_keys[i];\n\t\tif (key && key->cert && key->cert->type != SSH2_CERT_TYPE_USER)\n\t\t\tcontinue;\n\t\toptions.identity_keys[i] = NULL;\n\t\tid = xcalloc(1, sizeof(*id));\n\t\tid->agent_fd = -1;\n\t\tid->key = key;\n\t\tid->filename = xstrdup(options.identity_files[i]);\n\t\tid->userprovided = options.identity_file_userprovided[i];\n\t\tTAILQ_INSERT_TAIL(&files, id, next);\n\t}\n\t/* list of certificates specified by user */\n\tfor (i = 0; i < options.num_certificate_files; i++) {\n\t\tkey = options.certificates[i];\n\t\tif (!sshkey_is_cert(key) || key->cert == NULL ||\n\t\t    key->cert->type != SSH2_CERT_TYPE_USER)\n\t\t\tcontinue;\n\t\tid = xcalloc(1, sizeof(*id));\n\t\tid->agent_fd = -1;\n\t\tid->key = key;\n\t\tid->filename = xstrdup(options.certificate_files[i]);\n\t\tid->userprovided = options.certificate_file_userprovided[i];\n\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t}\n\t/* list of keys supported by the agent */\n\tif ((r = ssh_get_authentication_socket(&agent_fd)) != 0) {\n\t\tif (r != SSH_ERR_AGENT_NOT_PRESENT)\n\t\t\tdebug(\"%s: ssh_get_authentication_socket: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t} else if ((r = ssh_fetch_identitylist(agent_fd, &idlist)) != 0) {\n\t\tif (r != SSH_ERR_AGENT_NO_IDENTITIES)\n\t\t\tdebug(\"%s: ssh_fetch_identitylist: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\tclose(agent_fd);\n\t} else {\n\t\tfor (j = 0; j < idlist->nkeys; j++) {\n\t\t\tfound = 0;\n\t\t\tTAILQ_FOREACH(id, &files, next) {\n\t\t\t\t/*\n\t\t\t\t * agent keys from the config file are\n\t\t\t\t * preferred\n\t\t\t\t */\n\t\t\t\tif (sshkey_equal(idlist->keys[j], id->key)) {\n\t\t\t\t\tTAILQ_REMOVE(&files, id, next);\n\t\t\t\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t\t\t\t\tid->agent_fd = agent_fd;\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found && !options.identities_only) {\n\t\t\t\tid = xcalloc(1, sizeof(*id));\n\t\t\t\t/* XXX \"steals\" key/comment from idlist */\n\t\t\t\tid->key = idlist->keys[j];\n\t\t\t\tid->filename = idlist->comments[j];\n\t\t\t\tidlist->keys[j] = NULL;\n\t\t\t\tidlist->comments[j] = NULL;\n\t\t\t\tid->agent_fd = agent_fd;\n\t\t\t\tTAILQ_INSERT_TAIL(&agent, id, next);\n\t\t\t}\n\t\t}\n\t\tssh_free_identitylist(idlist);\n\t\t/* append remaining agent keys */\n\t\tfor (id = TAILQ_FIRST(&agent); id; id = TAILQ_FIRST(&agent)) {\n\t\t\tTAILQ_REMOVE(&agent, id, next);\n\t\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t\t}\n\t\tauthctxt->agent_fd = agent_fd;\n\t}\n\t/* Prefer PKCS11 keys that are explicitly listed */\n\tTAILQ_FOREACH_SAFE(id, &files, next, tmp) {\n\t\tif (id->key == NULL || (id->key->flags & SSHKEY_FLAG_EXT) == 0)\n\t\t\tcontinue;\n\t\tfound = 0;\n\t\tTAILQ_FOREACH(id2, &files, next) {\n\t\t\tif (id2->key == NULL ||\n\t\t\t    (id2->key->flags & SSHKEY_FLAG_EXT) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (sshkey_equal(id->key, id2->key)) {\n\t\t\t\tTAILQ_REMOVE(&files, id, next);\n\t\t\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* If IdentitiesOnly set and key not found then don't use it */\n\t\tif (!found && options.identities_only) {\n\t\t\tTAILQ_REMOVE(&files, id, next);\n\t\t\tfreezero(id, sizeof(*id));\n\t\t}\n\t}\n\t/* append remaining keys from the config file */\n\tfor (id = TAILQ_FIRST(&files); id; id = TAILQ_FIRST(&files)) {\n\t\tTAILQ_REMOVE(&files, id, next);\n\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t}\n\t/* finally, filter by PubkeyAcceptedKeyTypes */\n\tTAILQ_FOREACH_SAFE(id, preferred, next, id2) {\n\t\tif (id->key != NULL && !key_type_allowed_by_config(id->key)) {\n\t\t\tdebug(\"Skipping %s key %s - \"\n\t\t\t    \"not in PubkeyAcceptedKeyTypes\",\n\t\t\t    sshkey_ssh_name(id->key), id->filename);\n\t\t\tTAILQ_REMOVE(preferred, id, next);\n\t\t\tsshkey_free(id->key);\n\t\t\tfree(id->filename);\n\t\t\tmemset(id, 0, sizeof(*id));\n\t\t\tcontinue;\n\t\t}\n\t}\n\t/* List the keys we plan on using */\n\tTAILQ_FOREACH_SAFE(id, preferred, next, id2) {\n\t\tident = format_identity(id);\n\t\tdebug(\"Will attempt key: %s\", ident);\n\t\tfree(ident);\n\t}\n\tdebug2(\"%s: done\", __func__);\n}"
  },
  {
    "function_name": "key_type_allowed_by_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "1444-1471",
    "snippet": "static int\nkey_type_allowed_by_config(struct sshkey *key)\n{\n\tif (match_pattern_list(sshkey_ssh_name(key),\n\t    options.pubkey_key_types, 0) == 1)\n\t\treturn 1;\n\n\t/* RSA keys/certs might be allowed by alternate signature types */\n\tswitch (key->type) {\n\tcase KEY_RSA:\n\t\tif (match_pattern_list(\"rsa-sha2-512\",\n\t\t    options.pubkey_key_types, 0) == 1)\n\t\t\treturn 1;\n\t\tif (match_pattern_list(\"rsa-sha2-256\",\n\t\t    options.pubkey_key_types, 0) == 1)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase KEY_RSA_CERT:\n\t\tif (match_pattern_list(\"rsa-sha2-512-cert-v01@openssh.com\",\n\t\t    options.pubkey_key_types, 0) == 1)\n\t\t\treturn 1;\n\t\tif (match_pattern_list(\"rsa-sha2-256-cert-v01@openssh.com\",\n\t\t    options.pubkey_key_types, 0) == 1)\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "match_pattern_list",
          "args": [
            "\"rsa-sha2-256-cert-v01@openssh.com\"",
            "options.pubkey_key_types",
            "0"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "match_pattern_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "120-171",
          "snippet": "int\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t/* Check if the subpattern is negated. */\n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t/*\n\t\t * Extract the subpattern up to a comma or end.  Convert the\n\t\t * subpattern to lowercase.\n\t\t */\n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t/* If subpattern too long, return failure (no match). */\n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t/* If the subpattern was terminated by a comma, then skip it. */\n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t/* Null-terminate the subpattern. */\n\t\tsub[subi] = '\\0';\n\n\t\t/* Try to match the subpattern against the string. */\n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t/* Negative */\n\t\t\telse\n\t\t\t\tgot_positive = 1;\t/* Positive */\n\t\t}\n\t}\n\n\t/*\n\t * Return success if got a positive match.  If there was a negative\n\t * match, we have already returned -1 and never get here.\n\t */\n\treturn got_positive;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ssh_name",
          "args": [
            "key"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "183-188",
          "snippet": "const char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nstatic int\nkey_type_allowed_by_config(struct sshkey *key)\n{\n\tif (match_pattern_list(sshkey_ssh_name(key),\n\t    options.pubkey_key_types, 0) == 1)\n\t\treturn 1;\n\n\t/* RSA keys/certs might be allowed by alternate signature types */\n\tswitch (key->type) {\n\tcase KEY_RSA:\n\t\tif (match_pattern_list(\"rsa-sha2-512\",\n\t\t    options.pubkey_key_types, 0) == 1)\n\t\t\treturn 1;\n\t\tif (match_pattern_list(\"rsa-sha2-256\",\n\t\t    options.pubkey_key_types, 0) == 1)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase KEY_RSA_CERT:\n\t\tif (match_pattern_list(\"rsa-sha2-512-cert-v01@openssh.com\",\n\t\t    options.pubkey_key_types, 0) == 1)\n\t\t\treturn 1;\n\t\tif (match_pattern_list(\"rsa-sha2-256-cert-v01@openssh.com\",\n\t\t    options.pubkey_key_types, 0) == 1)\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "load_identity_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "1380-1442",
    "snippet": "static struct sshkey *\nload_identity_file(Identity *id)\n{\n\tstruct sshkey *private = NULL;\n\tchar prompt[300], *passphrase, *comment;\n\tint r, perm_ok = 0, quit = 0, i;\n\tstruct stat st;\n\n\tif (stat(id->filename, &st) < 0) {\n\t\t(id->userprovided ? logit : debug3)(\"no such identity: %s: %s\",\n\t\t    id->filename, strerror(errno));\n\t\treturn NULL;\n\t}\n\tsnprintf(prompt, sizeof prompt,\n\t    \"Enter passphrase for key '%.100s': \", id->filename);\n\tfor (i = 0; i <= options.number_of_password_prompts; i++) {\n\t\tif (i == 0)\n\t\t\tpassphrase = \"\";\n\t\telse {\n\t\t\tpassphrase = read_passphrase(prompt, 0);\n\t\t\tif (*passphrase == '\\0') {\n\t\t\t\tdebug2(\"no passphrase given, try next key\");\n\t\t\t\tfree(passphrase);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tswitch ((r = sshkey_load_private_type(KEY_UNSPEC, id->filename,\n\t\t    passphrase, &private, &comment, &perm_ok))) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\t\tif (options.batch_mode) {\n\t\t\t\tquit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i != 0)\n\t\t\t\tdebug2(\"bad passphrase given, try again...\");\n\t\t\tbreak;\n\t\tcase SSH_ERR_SYSTEM_ERROR:\n\t\t\tif (errno == ENOENT) {\n\t\t\t\tdebug2(\"Load key \\\"%s\\\": %s\",\n\t\t\t\t    id->filename, ssh_err(r));\n\t\t\t\tquit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tdefault:\n\t\t\terror(\"Load key \\\"%s\\\": %s\", id->filename, ssh_err(r));\n\t\t\tquit = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!quit && private != NULL && id->agent_fd == -1 &&\n\t\t    !(id->key && id->isprivate))\n\t\t\tmaybe_add_key_to_agent(id->filename, private, comment,\n\t\t\t    passphrase);\n\t\tif (i > 0)\n\t\t\tfreezero(passphrase, strlen(passphrase));\n\t\tfree(comment);\n\t\tif (private != NULL || quit)\n\t\t\tbreak;\n\t}\n\treturn private;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "static int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);",
      "static struct sshkey *load_identity_file(Identity *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "comment"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezero",
          "args": [
            "passphrase",
            "strlen(passphrase)"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "freezero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/freezero.c",
          "lines": "24-31",
          "snippet": "void\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "passphrase"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "maybe_add_key_to_agent",
          "args": [
            "id->filename",
            "private",
            "comment",
            "passphrase"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_add_key_to_agent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "1550-1577",
          "snippet": "void\nmaybe_add_key_to_agent(char *authfile, const struct sshkey *private,\n    char *comment, char *passphrase)\n{\n\tint auth_sock = -1, r;\n\n\tif (options.add_keys_to_agent == 0)\n\t\treturn;\n\n\tif ((r = ssh_get_authentication_socket(&auth_sock)) != 0) {\n\t\tdebug3(\"no authentication agent, not adding key\");\n\t\treturn;\n\t}\n\n\tif (options.add_keys_to_agent == 2 &&\n\t    !ask_permission(\"Add key %s (%s) to agent?\", authfile, comment)) {\n\t\tdebug3(\"user denied adding this key\");\n\t\tclose(auth_sock);\n\t\treturn;\n\t}\n\n\tif ((r = ssh_add_identity_constrained(auth_sock, private, comment, 0,\n\t    (options.add_keys_to_agent == 3), 0)) == 0)\n\t\tdebug(\"identity added to agent: %s\", authfile);\n\telse\n\t\tdebug(\"could not add identity to agent: %s (%d)\", authfile, r);\n\tclose(auth_sock);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "static int show_other_keys(struct hostkeys *, struct sshkey *);",
            "static void warn_changed_key(struct sshkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nstatic int show_other_keys(struct hostkeys *, struct sshkey *);\nstatic void warn_changed_key(struct sshkey *);\n\nvoid\nmaybe_add_key_to_agent(char *authfile, const struct sshkey *private,\n    char *comment, char *passphrase)\n{\n\tint auth_sock = -1, r;\n\n\tif (options.add_keys_to_agent == 0)\n\t\treturn;\n\n\tif ((r = ssh_get_authentication_socket(&auth_sock)) != 0) {\n\t\tdebug3(\"no authentication agent, not adding key\");\n\t\treturn;\n\t}\n\n\tif (options.add_keys_to_agent == 2 &&\n\t    !ask_permission(\"Add key %s (%s) to agent?\", authfile, comment)) {\n\t\tdebug3(\"user denied adding this key\");\n\t\tclose(auth_sock);\n\t\treturn;\n\t}\n\n\tif ((r = ssh_add_identity_constrained(auth_sock, private, comment, 0,\n\t    (options.add_keys_to_agent == 3), 0)) == 0)\n\t\tdebug(\"identity added to agent: %s\", authfile);\n\telse\n\t\tdebug(\"could not add identity to agent: %s (%d)\", authfile, r);\n\tclose(auth_sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Load key \\\"%s\\\": %s\"",
            "id->filename",
            "ssh_err(r)"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "input_gssapi_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "919-937",
          "snippet": "int\ninput_gssapi_error(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tchar *msg = NULL;\n\tchar *lang = NULL;\n\tint r;\n\n\tif ((r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* maj */\n\t    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* min */\n\t    (r = sshpkt_get_cstring(ssh, &msg, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &lang, NULL)) != 0)\n\t\tgoto out;\n\tr = sshpkt_get_end(ssh);\n\tdebug(\"Server GSSAPI Error:\\n%s\", msg);\n out:\n\tfree(msg);\n\tfree(lang);\n\treturn r;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\n\nint\ninput_gssapi_error(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tchar *msg = NULL;\n\tchar *lang = NULL;\n\tint r;\n\n\tif ((r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* maj */\n\t    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* min */\n\t    (r = sshpkt_get_cstring(ssh, &msg, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &lang, NULL)) != 0)\n\t\tgoto out;\n\tr = sshpkt_get_end(ssh);\n\tdebug(\"Server GSSAPI Error:\\n%s\", msg);\n out:\n\tfree(msg);\n\tfree(lang);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"Load key \\\"%s\\\": %s\"",
            "id->filename",
            "ssh_err(r)"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_load_private_type",
          "args": [
            "KEY_UNSPEC",
            "id->filename",
            "passphrase",
            "&private",
            "&comment",
            "&perm_ok"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_load_private_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "168-199",
          "snippet": "int\nsshkey_load_private_type(int type, const char *filename, const char *passphrase,\n    struct sshkey **keyp, char **commentp, int *perm_ok)\n{\n\tint fd, r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((fd = open(filename, O_RDONLY)) < 0) {\n\t\tif (perm_ok != NULL)\n\t\t\t*perm_ok = 0;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\tif (sshkey_perm_ok(fd, filename) != 0) {\n\t\tif (perm_ok != NULL)\n\t\t\t*perm_ok = 0;\n\t\tr = SSH_ERR_KEY_BAD_PERMISSIONS;\n\t\tgoto out;\n\t}\n\tif (perm_ok != NULL)\n\t\t*perm_ok = 1;\n\n\tr = sshkey_load_private_type_fd(fd, type, passphrase, keyp, commentp);\n\tif (r == 0 && keyp && *keyp)\n\t\tr = sshkey_set_filename(*keyp, filename);\n out:\n\tclose(fd);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_load_private_type(int type, const char *filename, const char *passphrase,\n    struct sshkey **keyp, char **commentp, int *perm_ok)\n{\n\tint fd, r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((fd = open(filename, O_RDONLY)) < 0) {\n\t\tif (perm_ok != NULL)\n\t\t\t*perm_ok = 0;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\tif (sshkey_perm_ok(fd, filename) != 0) {\n\t\tif (perm_ok != NULL)\n\t\t\t*perm_ok = 0;\n\t\tr = SSH_ERR_KEY_BAD_PERMISSIONS;\n\t\tgoto out;\n\t}\n\tif (perm_ok != NULL)\n\t\t*perm_ok = 1;\n\n\tr = sshkey_load_private_type_fd(fd, type, passphrase, keyp, commentp);\n\tif (r == 0 && keyp && *keyp)\n\t\tr = sshkey_set_filename(*keyp, filename);\n out:\n\tclose(fd);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_passphrase",
          "args": [
            "prompt",
            "0"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "read_passphrase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readpass.c",
          "lines": "117-166",
          "snippet": "char *\nread_passphrase(const char *prompt, int flags)\n{\n\tchar *askpass = NULL, *ret, buf[1024];\n\tint rppflags, use_askpass = 0, ttyfd;\n\n\trppflags = (flags & RP_ECHO) ? RPP_ECHO_ON : RPP_ECHO_OFF;\n\tif (flags & RP_USE_ASKPASS)\n\t\tuse_askpass = 1;\n\telse if (flags & RP_ALLOW_STDIN) {\n\t\tif (!isatty(STDIN_FILENO)) {\n\t\t\tdebug(\"read_passphrase: stdin is not a tty\");\n\t\t\tuse_askpass = 1;\n\t\t}\n\t} else {\n\t\trppflags |= RPP_REQUIRE_TTY;\n\t\tttyfd = open(_PATH_TTY, O_RDWR);\n\t\tif (ttyfd >= 0)\n\t\t\tclose(ttyfd);\n\t\telse {\n\t\t\tdebug(\"read_passphrase: can't open %s: %s\", _PATH_TTY,\n\t\t\t    strerror(errno));\n\t\t\tuse_askpass = 1;\n\t\t}\n\t}\n\n\tif ((flags & RP_USE_ASKPASS) && getenv(\"DISPLAY\") == NULL)\n\t\treturn (flags & RP_ALLOW_EOF) ? NULL : xstrdup(\"\");\n\n\tif (use_askpass && getenv(\"DISPLAY\")) {\n\t\tif (getenv(SSH_ASKPASS_ENV))\n\t\t\taskpass = getenv(SSH_ASKPASS_ENV);\n\t\telse\n\t\t\taskpass = _PATH_SSH_ASKPASS_DEFAULT;\n\t\tif ((ret = ssh_askpass(askpass, prompt)) == NULL)\n\t\t\tif (!(flags & RP_ALLOW_EOF))\n\t\t\t\treturn xstrdup(\"\");\n\t\treturn ret;\n\t}\n\n\tif (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {\n\t\tif (flags & RP_ALLOW_EOF)\n\t\t\treturn NULL;\n\t\treturn xstrdup(\"\");\n\t}\n\n\tret = xstrdup(buf);\n\texplicit_bzero(buf, sizeof(buf));\n\treturn ret;\n}",
          "includes": [
            "#include \"uidswap.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uidswap.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nread_passphrase(const char *prompt, int flags)\n{\n\tchar *askpass = NULL, *ret, buf[1024];\n\tint rppflags, use_askpass = 0, ttyfd;\n\n\trppflags = (flags & RP_ECHO) ? RPP_ECHO_ON : RPP_ECHO_OFF;\n\tif (flags & RP_USE_ASKPASS)\n\t\tuse_askpass = 1;\n\telse if (flags & RP_ALLOW_STDIN) {\n\t\tif (!isatty(STDIN_FILENO)) {\n\t\t\tdebug(\"read_passphrase: stdin is not a tty\");\n\t\t\tuse_askpass = 1;\n\t\t}\n\t} else {\n\t\trppflags |= RPP_REQUIRE_TTY;\n\t\tttyfd = open(_PATH_TTY, O_RDWR);\n\t\tif (ttyfd >= 0)\n\t\t\tclose(ttyfd);\n\t\telse {\n\t\t\tdebug(\"read_passphrase: can't open %s: %s\", _PATH_TTY,\n\t\t\t    strerror(errno));\n\t\t\tuse_askpass = 1;\n\t\t}\n\t}\n\n\tif ((flags & RP_USE_ASKPASS) && getenv(\"DISPLAY\") == NULL)\n\t\treturn (flags & RP_ALLOW_EOF) ? NULL : xstrdup(\"\");\n\n\tif (use_askpass && getenv(\"DISPLAY\")) {\n\t\tif (getenv(SSH_ASKPASS_ENV))\n\t\t\taskpass = getenv(SSH_ASKPASS_ENV);\n\t\telse\n\t\t\taskpass = _PATH_SSH_ASKPASS_DEFAULT;\n\t\tif ((ret = ssh_askpass(askpass, prompt)) == NULL)\n\t\t\tif (!(flags & RP_ALLOW_EOF))\n\t\t\t\treturn xstrdup(\"\");\n\t\treturn ret;\n\t}\n\n\tif (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {\n\t\tif (flags & RP_ALLOW_EOF)\n\t\t\treturn NULL;\n\t\treturn xstrdup(\"\");\n\t}\n\n\tret = xstrdup(buf);\n\texplicit_bzero(buf, sizeof(buf));\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "prompt",
            "sizeof prompt",
            "\"Enter passphrase for key '%.100s': \"",
            "id->filename"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "\"no such identity: %s: %s\"",
            "id->filename",
            "strerror(errno)"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "id->filename",
            "&st"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nstatic int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);\nstatic struct sshkey *load_identity_file(Identity *);\n\nstatic struct sshkey *\nload_identity_file(Identity *id)\n{\n\tstruct sshkey *private = NULL;\n\tchar prompt[300], *passphrase, *comment;\n\tint r, perm_ok = 0, quit = 0, i;\n\tstruct stat st;\n\n\tif (stat(id->filename, &st) < 0) {\n\t\t(id->userprovided ? logit : debug3)(\"no such identity: %s: %s\",\n\t\t    id->filename, strerror(errno));\n\t\treturn NULL;\n\t}\n\tsnprintf(prompt, sizeof prompt,\n\t    \"Enter passphrase for key '%.100s': \", id->filename);\n\tfor (i = 0; i <= options.number_of_password_prompts; i++) {\n\t\tif (i == 0)\n\t\t\tpassphrase = \"\";\n\t\telse {\n\t\t\tpassphrase = read_passphrase(prompt, 0);\n\t\t\tif (*passphrase == '\\0') {\n\t\t\t\tdebug2(\"no passphrase given, try next key\");\n\t\t\t\tfree(passphrase);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tswitch ((r = sshkey_load_private_type(KEY_UNSPEC, id->filename,\n\t\t    passphrase, &private, &comment, &perm_ok))) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\t\tif (options.batch_mode) {\n\t\t\t\tquit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i != 0)\n\t\t\t\tdebug2(\"bad passphrase given, try again...\");\n\t\t\tbreak;\n\t\tcase SSH_ERR_SYSTEM_ERROR:\n\t\t\tif (errno == ENOENT) {\n\t\t\t\tdebug2(\"Load key \\\"%s\\\": %s\",\n\t\t\t\t    id->filename, ssh_err(r));\n\t\t\t\tquit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tdefault:\n\t\t\terror(\"Load key \\\"%s\\\": %s\", id->filename, ssh_err(r));\n\t\t\tquit = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!quit && private != NULL && id->agent_fd == -1 &&\n\t\t    !(id->key && id->isprivate))\n\t\t\tmaybe_add_key_to_agent(id->filename, private, comment,\n\t\t\t    passphrase);\n\t\tif (i > 0)\n\t\t\tfreezero(passphrase, strlen(passphrase));\n\t\tfree(comment);\n\t\tif (private != NULL || quit)\n\t\t\tbreak;\n\t}\n\treturn private;\n}"
  },
  {
    "function_name": "send_pubkey_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "1341-1378",
    "snippet": "static int\nsend_pubkey_test(struct ssh *ssh, Authctxt *authctxt, Identity *id)\n{\n\tu_char *blob = NULL;\n\tchar *alg = NULL;\n\tsize_t bloblen;\n\tu_int have_sig = 0;\n\tint sent = 0, r;\n\n\tif ((alg = key_sig_algorithm(ssh, id->key)) == NULL) {\n\t\tdebug(\"%s: no mutual signature algorithm\", __func__);\n\t\tgoto out;\n\t}\n\n\tif ((r = sshkey_to_blob(id->key, &blob, &bloblen)) != 0) {\n\t\t/* we cannot handle this key */\n\t\tdebug3(\"%s: cannot handle key\", __func__);\n\t\tgoto out;\n\t}\n\t/* register callback for USERAUTH_PK_OK message */\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_PK_OK, &input_userauth_pk_ok);\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, have_sig)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, alg)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, blob, bloblen)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tsent = 1;\n\n out:\n\tfree(alg);\n\tfree(blob);\n\treturn sent;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
      "int\tuserauth_none(Authctxt *);",
      "int\tuserauth_pubkey(Authctxt *);",
      "int\tuserauth_passwd(Authctxt *);",
      "int\tuserauth_kbdint(Authctxt *);",
      "int\tuserauth_hostbased(Authctxt *);",
      "void\tuserauth(Authctxt *, char *);",
      "static int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);",
      "static void pubkey_prepare(Authctxt *);",
      "static void pubkey_cleanup(Authctxt *);",
      "static void pubkey_reset(Authctxt *);",
      "static struct sshkey *load_identity_file(Identity *);",
      "static Authmethod *authmethod_lookup(const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "blob"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_string",
          "args": [
            "ssh",
            "blob",
            "bloblen"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2453-2457",
          "snippet": "int\nsshpkt_put_string(struct ssh *ssh, const void *v, size_t len)\n{\n\treturn sshbuf_put_string(ssh->state->outgoing_packet, v, len);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_string(struct ssh *ssh, const void *v, size_t len)\n{\n\treturn sshbuf_put_string(ssh->state->outgoing_packet, v, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_cstring",
          "args": [
            "ssh",
            "alg"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2459-2463",
          "snippet": "int\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u8",
          "args": [
            "ssh",
            "have_sig"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2435-2439",
          "snippet": "int\nsshpkt_put_u8(struct ssh *ssh, u_char val)\n{\n\treturn sshbuf_put_u8(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u8(struct ssh *ssh, u_char val)\n{\n\treturn sshbuf_put_u8(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_REQUEST"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_dispatch_set",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_PK_OK",
            "&input_userauth_pk_ok"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_dispatch_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dispatch.c",
          "lines": "81-85",
          "snippet": "void\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"dispatch.h\"",
            "#include \"log.h\"",
            "#include \"ssh2.h\"",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include <stdarg.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: cannot handle key\"",
            "__func__"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_to_blob",
          "args": [
            "id->key",
            "&blob",
            "&bloblen"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_to_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "880-884",
          "snippet": "int\nsshkey_to_blob(const struct sshkey *key, u_char **blobp, size_t *lenp)\n{\n\treturn to_blob(key, blobp, lenp, 0, SSHKEY_SERIALIZE_DEFAULT);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_to_blob(const struct sshkey *key, u_char **blobp, size_t *lenp)\n{\n\treturn to_blob(key, blobp, lenp, 0, SSHKEY_SERIALIZE_DEFAULT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_sig_algorithm",
          "args": [
            "ssh",
            "id->key"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "key_sig_algorithm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "1080-1117",
          "snippet": "static char *\nkey_sig_algorithm(struct ssh *ssh, const struct sshkey *key)\n{\n\tchar *allowed, *oallowed, *cp, *tmp, *alg = NULL;\n\n\t/*\n\t * The signature algorithm will only differ from the key algorithm\n\t * for RSA keys/certs and when the server advertises support for\n\t * newer (SHA2) algorithms.\n\t */\n\tif (ssh == NULL || ssh->kex->server_sig_algs == NULL ||\n\t    (key->type != KEY_RSA && key->type != KEY_RSA_CERT) ||\n\t    (key->type == KEY_RSA_CERT && (datafellows & SSH_BUG_SIGTYPE))) {\n\t\t/* Filter base key signature alg against our configuration */\n\t\treturn match_list(sshkey_ssh_name(key),\n\t\t    options.pubkey_key_types, NULL);\n\t}\n\n\t/*\n\t * For RSA keys/certs, since these might have a different sig type:\n\t * find the first entry in PubkeyAcceptedKeyTypes of the right type\n\t * that also appears in the supported signature algorithms list from\n\t * the server.\n\t */\n\toallowed = allowed = xstrdup(options.pubkey_key_types);\n\twhile ((cp = strsep(&allowed, \",\")) != NULL) {\n\t\tif (sshkey_type_from_name(cp) != key->type)\n\t\t\tcontinue;\n\t\ttmp = match_list(sshkey_sigalg_by_name(cp), ssh->kex->server_sig_algs, NULL);\n\t\tif (tmp != NULL)\n\t\t\talg = xstrdup(cp);\n\t\tfree(tmp);\n\t\tif (alg != NULL)\n\t\t\tbreak;\n\t}\n\tfree(oallowed);\n\treturn alg;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\n\nstatic char *\nkey_sig_algorithm(struct ssh *ssh, const struct sshkey *key)\n{\n\tchar *allowed, *oallowed, *cp, *tmp, *alg = NULL;\n\n\t/*\n\t * The signature algorithm will only differ from the key algorithm\n\t * for RSA keys/certs and when the server advertises support for\n\t * newer (SHA2) algorithms.\n\t */\n\tif (ssh == NULL || ssh->kex->server_sig_algs == NULL ||\n\t    (key->type != KEY_RSA && key->type != KEY_RSA_CERT) ||\n\t    (key->type == KEY_RSA_CERT && (datafellows & SSH_BUG_SIGTYPE))) {\n\t\t/* Filter base key signature alg against our configuration */\n\t\treturn match_list(sshkey_ssh_name(key),\n\t\t    options.pubkey_key_types, NULL);\n\t}\n\n\t/*\n\t * For RSA keys/certs, since these might have a different sig type:\n\t * find the first entry in PubkeyAcceptedKeyTypes of the right type\n\t * that also appears in the supported signature algorithms list from\n\t * the server.\n\t */\n\toallowed = allowed = xstrdup(options.pubkey_key_types);\n\twhile ((cp = strsep(&allowed, \",\")) != NULL) {\n\t\tif (sshkey_type_from_name(cp) != key->type)\n\t\t\tcontinue;\n\t\ttmp = match_list(sshkey_sigalg_by_name(cp), ssh->kex->server_sig_algs, NULL);\n\t\tif (tmp != NULL)\n\t\t\talg = xstrdup(cp);\n\t\tfree(tmp);\n\t\tif (alg != NULL)\n\t\t\tbreak;\n\t}\n\tfree(oallowed);\n\treturn alg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic struct sshkey *load_identity_file(Identity *);\nstatic Authmethod *authmethod_lookup(const char *name);\n\nstatic int\nsend_pubkey_test(struct ssh *ssh, Authctxt *authctxt, Identity *id)\n{\n\tu_char *blob = NULL;\n\tchar *alg = NULL;\n\tsize_t bloblen;\n\tu_int have_sig = 0;\n\tint sent = 0, r;\n\n\tif ((alg = key_sig_algorithm(ssh, id->key)) == NULL) {\n\t\tdebug(\"%s: no mutual signature algorithm\", __func__);\n\t\tgoto out;\n\t}\n\n\tif ((r = sshkey_to_blob(id->key, &blob, &bloblen)) != 0) {\n\t\t/* we cannot handle this key */\n\t\tdebug3(\"%s: cannot handle key\", __func__);\n\t\tgoto out;\n\t}\n\t/* register callback for USERAUTH_PK_OK message */\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_PK_OK, &input_userauth_pk_ok);\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, have_sig)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, alg)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, blob, bloblen)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tsent = 1;\n\n out:\n\tfree(alg);\n\tfree(blob);\n\treturn sent;\n}"
  },
  {
    "function_name": "sign_and_send_pubkey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "1182-1339",
    "snippet": "static int\nsign_and_send_pubkey(struct ssh *ssh, Authctxt *authctxt, Identity *id)\n{\n\tstruct sshbuf *b = NULL;\n\tIdentity *private_id, *sign_id = NULL;\n\tu_char *signature = NULL;\n\tsize_t slen = 0, skip = 0;\n\tint r, fallback_sigtype, sent = 0;\n\tchar *alg = NULL, *fp = NULL;\n\tconst char *loc = \"\";\n\n\tif ((fp = sshkey_fingerprint(id->key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\treturn 0;\n\n\tdebug3(\"%s: %s %s\", __func__, sshkey_type(id->key), fp);\n\n\t/*\n\t * If the key is an certificate, try to find a matching private key\n\t * and use it to complete the signature.\n\t * If no such private key exists, fall back to trying the certificate\n\t * key itself in case it has a private half already loaded.\n\t * This will try to set sign_id to the private key that will perform\n\t * the signature.\n\t */\n\tif (sshkey_is_cert(id->key)) {\n\t\tTAILQ_FOREACH(private_id, &authctxt->keys, next) {\n\t\t\tif (sshkey_equal_public(id->key, private_id->key) &&\n\t\t\t    id->key->type != private_id->key->type) {\n\t\t\t\tsign_id = private_id;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Exact key matches are preferred, but also allow\n\t\t * filename matches for non-PKCS#11/agent keys that\n\t\t * didn't load public keys. This supports the case\n\t\t * of keeping just a private key file and public\n\t\t * certificate on disk.\n\t\t */\n\t\tif (sign_id == NULL &&\n\t\t    !id->isprivate && id->agent_fd == -1 &&\n\t\t    (id->key->flags & SSHKEY_FLAG_EXT) == 0) {\n\t\t\tTAILQ_FOREACH(private_id, &authctxt->keys, next) {\n\t\t\t\tif (private_id->key == NULL &&\n\t\t\t\t    id_filename_matches(id, private_id)) {\n\t\t\t\t\tsign_id = private_id;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (sign_id != NULL) {\n\t\t\tdebug2(\"%s: using private key \\\"%s\\\"%s for \"\n\t\t\t    \"certificate\", __func__, id->filename,\n\t\t\t    id->agent_fd != -1 ? \" from agent\" : \"\");\n\t\t} else {\n\t\t\tdebug(\"%s: no separate private key for certificate \"\n\t\t\t    \"\\\"%s\\\"\", __func__, id->filename);\n\t\t}\n\t}\n\n\t/*\n\t * If the above didn't select another identity to do the signing\n\t * then default to the one we started with.\n\t */\n\tif (sign_id == NULL)\n\t\tsign_id = id;\n\n\t/* assemble and sign data */\n\tfor (fallback_sigtype = 0; fallback_sigtype <= 1; fallback_sigtype++) {\n\t\tfree(alg);\n\t\tslen = 0;\n\t\tsignature = NULL;\n\t\tif ((alg = key_sig_algorithm(fallback_sigtype ? NULL : ssh,\n\t\t    id->key)) == NULL) {\n\t\t\terror(\"%s: no mutual signature supported\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t\tdebug3(\"%s: signing using %s\", __func__, alg);\n\n\t\tsshbuf_free(b);\n\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\tif (datafellows & SSH_OLD_SESSIONID) {\n\t\t\tif ((r = sshbuf_put(b, session_id2,\n\t\t\t    session_id2_len)) != 0) {\n\t\t\t\tfatal(\"%s: sshbuf_put: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t} else {\n\t\t\tif ((r = sshbuf_put_string(b, session_id2,\n\t\t\t    session_id2_len)) != 0) {\n\t\t\t\tfatal(\"%s: sshbuf_put_string: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t}\n\t\tskip = sshbuf_len(b);\n\t\tif ((r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->server_user)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->method->name)) != 0 ||\n\t\t    (r = sshbuf_put_u8(b, 1)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, alg)) != 0 ||\n\t\t    (r = sshkey_puts(id->key, b)) != 0) {\n\t\t\tfatal(\"%s: assemble signed data: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t}\n\n\t\t/* generate signature */\n\t\tr = identity_sign(sign_id, &signature, &slen,\n\t\t    sshbuf_ptr(b), sshbuf_len(b), datafellows, alg);\n\t\tif (r == 0)\n\t\t\tbreak;\n\t\telse if (r == SSH_ERR_KEY_NOT_FOUND)\n\t\t\tgoto out; /* soft failure */\n\t\telse if (r == SSH_ERR_SIGN_ALG_UNSUPPORTED &&\n\t\t    !fallback_sigtype) {\n\t\t\tif (sign_id->agent_fd != -1)\n\t\t\t\tloc = \"agent \";\n\t\t\telse if ((sign_id->key->flags & SSHKEY_FLAG_EXT) != 0)\n\t\t\t\tloc = \"token \";\n\t\t\tlogit(\"%skey %s %s returned incorrect signature type\",\n\t\t\t    loc, sshkey_type(id->key), fp);\n\t\t\tcontinue;\n\t\t}\n\t\terror(\"%s: signing failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif (slen == 0 || signature == NULL) /* shouldn't happen */\n\t\tfatal(\"%s: no signature\", __func__);\n\n\t/* append signature */\n\tif ((r = sshbuf_put_string(b, signature, slen)) != 0)\n\t\tfatal(\"%s: append signature: %s\", __func__, ssh_err(r));\n\n#ifdef DEBUG_PK\n\tsshbuf_dump(b, stderr);\n#endif\n\t/* skip session id and packet type */\n\tif ((r = sshbuf_consume(b, skip + 1)) != 0)\n\t\tfatal(\"%s: consume: %s\", __func__, ssh_err(r));\n\n\t/* put remaining data from buffer into packet */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_putb(ssh, b)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: enqueue request: %s\", __func__, ssh_err(r));\n\n\t/* success */\n\tsent = 1;\n\n out:\n\tfree(fp);\n\tfree(alg);\n\tsshbuf_free(b);\n\tfreezero(signature, slen);\n\treturn sent;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "u_char *session_id2 = NULL;",
      "u_int session_id2_len = 0;",
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
      "int\tuserauth_none(Authctxt *);",
      "int\tuserauth_pubkey(Authctxt *);",
      "int\tuserauth_passwd(Authctxt *);",
      "int\tuserauth_kbdint(Authctxt *);",
      "int\tuserauth_hostbased(Authctxt *);",
      "void\tuserauth(Authctxt *, char *);",
      "static int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);",
      "static void pubkey_prepare(Authctxt *);",
      "static void pubkey_cleanup(Authctxt *);",
      "static void pubkey_reset(Authctxt *);",
      "static struct sshkey *load_identity_file(Identity *);",
      "static Authmethod *authmethod_lookup(const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "freezero",
          "args": [
            "signature",
            "slen"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "freezero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/freezero.c",
          "lines": "24-31",
          "snippet": "void\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "alg"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: enqueue request: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_putb",
          "args": [
            "ssh",
            "b"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_putb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2429-2433",
          "snippet": "int\nsshpkt_putb(struct ssh *ssh, const struct sshbuf *b)\n{\n\treturn sshbuf_putb(ssh->state->outgoing_packet, b);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_putb(struct ssh *ssh, const struct sshbuf *b)\n{\n\treturn sshbuf_putb(ssh->state->outgoing_packet, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_REQUEST"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_consume",
          "args": [
            "b",
            "skip + 1"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_consume_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "383-398",
          "snippet": "int\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_dump",
          "args": [
            "b",
            "stderr"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-misc.c",
          "lines": "65-70",
          "snippet": "void\nsshbuf_dump(struct sshbuf *buf, FILE *f)\n{\n\tfprintf(f, \"buffer %p len = %zu\\n\", buf, sshbuf_len(buf));\n\tsshbuf_dump_data(sshbuf_ptr(buf), sshbuf_len(buf), f);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <ctype.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <ctype.h>\n#include <resolv.h>\n#include <string.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_dump(struct sshbuf *buf, FILE *f)\n{\n\tfprintf(f, \"buffer %p len = %zu\\n\", buf, sshbuf_len(buf));\n\tsshbuf_dump_data(sshbuf_ptr(buf), sshbuf_len(buf), f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "b",
            "signature",
            "slen"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: no signature\"",
            "__func__"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: signing failed: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "input_gssapi_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "919-937",
          "snippet": "int\ninput_gssapi_error(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tchar *msg = NULL;\n\tchar *lang = NULL;\n\tint r;\n\n\tif ((r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* maj */\n\t    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* min */\n\t    (r = sshpkt_get_cstring(ssh, &msg, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &lang, NULL)) != 0)\n\t\tgoto out;\n\tr = sshpkt_get_end(ssh);\n\tdebug(\"Server GSSAPI Error:\\n%s\", msg);\n out:\n\tfree(msg);\n\tfree(lang);\n\treturn r;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\n\nint\ninput_gssapi_error(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tchar *msg = NULL;\n\tchar *lang = NULL;\n\tint r;\n\n\tif ((r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* maj */\n\t    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* min */\n\t    (r = sshpkt_get_cstring(ssh, &msg, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &lang, NULL)) != 0)\n\t\tgoto out;\n\tr = sshpkt_get_end(ssh);\n\tdebug(\"Server GSSAPI Error:\\n%s\", msg);\n out:\n\tfree(msg);\n\tfree(lang);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"%skey %s %s returned incorrect signature type\"",
            "loc",
            "sshkey_type(id->key)",
            "fp"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "id->key"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "identity_sign",
          "args": [
            "sign_id",
            "&signature",
            "&slen",
            "sshbuf_ptr(b)",
            "sshbuf_len(b)",
            "datafellows",
            "alg"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "identity_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "1119-1161",
          "snippet": "static int\nidentity_sign(struct identity *id, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, u_int compat, const char *alg)\n{\n\tstruct sshkey *prv;\n\tint r;\n\n\t/* The agent supports this key. */\n\tif (id->key != NULL && id->agent_fd != -1) {\n\t\treturn ssh_agent_sign(id->agent_fd, id->key, sigp, lenp,\n\t\t    data, datalen, alg, compat);\n\t}\n\n\t/*\n\t * We have already loaded the private key or the private key is\n\t * stored in external hardware.\n\t */\n\tif (id->key != NULL &&\n\t    (id->isprivate || (id->key->flags & SSHKEY_FLAG_EXT))) {\n\t\tif ((r = sshkey_sign(id->key, sigp, lenp, data, datalen,\n\t\t    alg, compat)) != 0)\n\t\t\treturn r;\n\t\t/*\n\t\t * PKCS#11 tokens may not support all signature algorithms,\n\t\t * so check what we get back.\n\t\t */\n\t\tif ((r = sshkey_check_sigtype(*sigp, *lenp, alg)) != 0)\n\t\t\treturn r;\n\t\treturn 0;\n\t}\n\n\t/* Load the private key from the file. */\n\tif ((prv = load_identity_file(id)) == NULL)\n\t\treturn SSH_ERR_KEY_NOT_FOUND;\n\tif (id->key != NULL && !sshkey_equal_public(prv, id->key)) {\n\t\terror(\"%s: private key %s contents do not match public\",\n\t\t   __func__, id->filename);\n\t\treturn SSH_ERR_KEY_NOT_FOUND;\n\t}\n\tr = sshkey_sign(prv, sigp, lenp, data, datalen, alg, compat);\n\tsshkey_free(prv);\n\treturn r;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nidentity_sign(struct identity *id, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, u_int compat, const char *alg)\n{\n\tstruct sshkey *prv;\n\tint r;\n\n\t/* The agent supports this key. */\n\tif (id->key != NULL && id->agent_fd != -1) {\n\t\treturn ssh_agent_sign(id->agent_fd, id->key, sigp, lenp,\n\t\t    data, datalen, alg, compat);\n\t}\n\n\t/*\n\t * We have already loaded the private key or the private key is\n\t * stored in external hardware.\n\t */\n\tif (id->key != NULL &&\n\t    (id->isprivate || (id->key->flags & SSHKEY_FLAG_EXT))) {\n\t\tif ((r = sshkey_sign(id->key, sigp, lenp, data, datalen,\n\t\t    alg, compat)) != 0)\n\t\t\treturn r;\n\t\t/*\n\t\t * PKCS#11 tokens may not support all signature algorithms,\n\t\t * so check what we get back.\n\t\t */\n\t\tif ((r = sshkey_check_sigtype(*sigp, *lenp, alg)) != 0)\n\t\t\treturn r;\n\t\treturn 0;\n\t}\n\n\t/* Load the private key from the file. */\n\tif ((prv = load_identity_file(id)) == NULL)\n\t\treturn SSH_ERR_KEY_NOT_FOUND;\n\tif (id->key != NULL && !sshkey_equal_public(prv, id->key)) {\n\t\terror(\"%s: private key %s contents do not match public\",\n\t\t   __func__, id->filename);\n\t\treturn SSH_ERR_KEY_NOT_FOUND;\n\t}\n\tr = sshkey_sign(prv, sigp, lenp, data, datalen, alg, compat);\n\tsshkey_free(prv);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "b"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "b"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_puts",
          "args": [
            "id->key",
            "b"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "836-840",
          "snippet": "int\nsshkey_puts(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn sshkey_puts_opts(key, b, SSHKEY_SERIALIZE_DEFAULT);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_puts(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn sshkey_puts_opts(key, b, SSHKEY_SERIALIZE_DEFAULT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "b",
            "alg"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u8",
          "args": [
            "b",
            "1"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "335-345",
          "snippet": "int\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u8(struct sshbuf *buf, u_char val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 1, &p)) < 0)\n\t\treturn r;\n\tp[0] = val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put",
          "args": [
            "b",
            "session_id2",
            "session_id2_len"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: signing using %s\"",
            "__func__",
            "alg"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: no mutual signature supported\"",
            "__func__"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_sig_algorithm",
          "args": [
            "fallback_sigtype ? NULL : ssh",
            "id->key"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "key_sig_algorithm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "1080-1117",
          "snippet": "static char *\nkey_sig_algorithm(struct ssh *ssh, const struct sshkey *key)\n{\n\tchar *allowed, *oallowed, *cp, *tmp, *alg = NULL;\n\n\t/*\n\t * The signature algorithm will only differ from the key algorithm\n\t * for RSA keys/certs and when the server advertises support for\n\t * newer (SHA2) algorithms.\n\t */\n\tif (ssh == NULL || ssh->kex->server_sig_algs == NULL ||\n\t    (key->type != KEY_RSA && key->type != KEY_RSA_CERT) ||\n\t    (key->type == KEY_RSA_CERT && (datafellows & SSH_BUG_SIGTYPE))) {\n\t\t/* Filter base key signature alg against our configuration */\n\t\treturn match_list(sshkey_ssh_name(key),\n\t\t    options.pubkey_key_types, NULL);\n\t}\n\n\t/*\n\t * For RSA keys/certs, since these might have a different sig type:\n\t * find the first entry in PubkeyAcceptedKeyTypes of the right type\n\t * that also appears in the supported signature algorithms list from\n\t * the server.\n\t */\n\toallowed = allowed = xstrdup(options.pubkey_key_types);\n\twhile ((cp = strsep(&allowed, \",\")) != NULL) {\n\t\tif (sshkey_type_from_name(cp) != key->type)\n\t\t\tcontinue;\n\t\ttmp = match_list(sshkey_sigalg_by_name(cp), ssh->kex->server_sig_algs, NULL);\n\t\tif (tmp != NULL)\n\t\t\talg = xstrdup(cp);\n\t\tfree(tmp);\n\t\tif (alg != NULL)\n\t\t\tbreak;\n\t}\n\tfree(oallowed);\n\treturn alg;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\n\nstatic char *\nkey_sig_algorithm(struct ssh *ssh, const struct sshkey *key)\n{\n\tchar *allowed, *oallowed, *cp, *tmp, *alg = NULL;\n\n\t/*\n\t * The signature algorithm will only differ from the key algorithm\n\t * for RSA keys/certs and when the server advertises support for\n\t * newer (SHA2) algorithms.\n\t */\n\tif (ssh == NULL || ssh->kex->server_sig_algs == NULL ||\n\t    (key->type != KEY_RSA && key->type != KEY_RSA_CERT) ||\n\t    (key->type == KEY_RSA_CERT && (datafellows & SSH_BUG_SIGTYPE))) {\n\t\t/* Filter base key signature alg against our configuration */\n\t\treturn match_list(sshkey_ssh_name(key),\n\t\t    options.pubkey_key_types, NULL);\n\t}\n\n\t/*\n\t * For RSA keys/certs, since these might have a different sig type:\n\t * find the first entry in PubkeyAcceptedKeyTypes of the right type\n\t * that also appears in the supported signature algorithms list from\n\t * the server.\n\t */\n\toallowed = allowed = xstrdup(options.pubkey_key_types);\n\twhile ((cp = strsep(&allowed, \",\")) != NULL) {\n\t\tif (sshkey_type_from_name(cp) != key->type)\n\t\t\tcontinue;\n\t\ttmp = match_list(sshkey_sigalg_by_name(cp), ssh->kex->server_sig_algs, NULL);\n\t\tif (tmp != NULL)\n\t\t\talg = xstrdup(cp);\n\t\tfree(tmp);\n\t\tif (alg != NULL)\n\t\t\tbreak;\n\t}\n\tfree(oallowed);\n\treturn alg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: using private key \\\"%s\\\"%s for \"\n\t\t\t    \"certificate\"",
            "__func__",
            "id->filename",
            "id->agent_fd != -1 ? \" from agent\" : \"\""
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "id_filename_matches",
          "args": [
            "id",
            "private_id"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "id_filename_matches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "1163-1180",
          "snippet": "static int\nid_filename_matches(Identity *id, Identity *private_id)\n{\n\tconst char *suffixes[] = { \".pub\", \"-cert.pub\", NULL };\n\tsize_t len = strlen(id->filename), plen = strlen(private_id->filename);\n\tsize_t i, slen;\n\n\tif (strcmp(id->filename, private_id->filename) == 0)\n\t\treturn 1;\n\tfor (i = 0; suffixes[i]; i++) {\n\t\tslen = strlen(suffixes[i]);\n\t\tif (len > slen && plen == len - slen &&\n\t\t    strcmp(id->filename + (len - slen), suffixes[i]) == 0 &&\n\t\t    memcmp(id->filename, private_id->filename, plen) == 0)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);",
            "static struct sshkey *load_identity_file(Identity *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);\nstatic struct sshkey *load_identity_file(Identity *);\n\nstatic int\nid_filename_matches(Identity *id, Identity *private_id)\n{\n\tconst char *suffixes[] = { \".pub\", \"-cert.pub\", NULL };\n\tsize_t len = strlen(id->filename), plen = strlen(private_id->filename);\n\tsize_t i, slen;\n\n\tif (strcmp(id->filename, private_id->filename) == 0)\n\t\treturn 1;\n\tfor (i = 0; suffixes[i]; i++) {\n\t\tslen = strlen(suffixes[i]);\n\t\tif (len > slen && plen == len - slen &&\n\t\t    strcmp(id->filename + (len - slen), suffixes[i]) == 0 &&\n\t\t    memcmp(id->filename, private_id->filename, plen) == 0)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_FOREACH",
          "args": [
            "private_id",
            "&authctxt->keys",
            "next"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_equal_public",
          "args": [
            "id->key",
            "private_id->key"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_equal_public",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "627-702",
          "snippet": "int\nsshkey_equal_public(const struct sshkey *a, const struct sshkey *b)\n{\n#if defined(WITH_OPENSSL)\n\tconst BIGNUM *rsa_e_a, *rsa_n_a;\n\tconst BIGNUM *rsa_e_b, *rsa_n_b;\n\tconst BIGNUM *dsa_p_a, *dsa_q_a, *dsa_g_a, *dsa_pub_key_a;\n\tconst BIGNUM *dsa_p_b, *dsa_q_b, *dsa_g_b, *dsa_pub_key_b;\n# if defined(OPENSSL_HAS_ECC)\n\tBN_CTX *bnctx;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n\tif (a == NULL || b == NULL ||\n\t    sshkey_type_plain(a->type) != sshkey_type_plain(b->type))\n\t\treturn 0;\n\n\tswitch (a->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\tif (a->rsa == NULL || b->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(a->rsa, &rsa_n_a, &rsa_e_a, NULL);\n\t\tRSA_get0_key(b->rsa, &rsa_n_b, &rsa_e_b, NULL);\n\t\treturn BN_cmp(rsa_e_a, rsa_e_b) == 0 &&\n\t\t    BN_cmp(rsa_n_a, rsa_n_b) == 0;\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\tif (a->dsa == NULL || b->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(a->dsa, &dsa_p_a, &dsa_q_a, &dsa_g_a);\n\t\tDSA_get0_pqg(b->dsa, &dsa_p_b, &dsa_q_b, &dsa_g_b);\n\t\tDSA_get0_key(a->dsa, &dsa_pub_key_a, NULL);\n\t\tDSA_get0_key(b->dsa, &dsa_pub_key_b, NULL);\n\t\treturn BN_cmp(dsa_p_a, dsa_p_b) == 0 &&\n\t\t    BN_cmp(dsa_q_a, dsa_q_b) == 0 &&\n\t\t    BN_cmp(dsa_g_a, dsa_g_b) == 0 &&\n\t\t    BN_cmp(dsa_pub_key_a, dsa_pub_key_b) == 0;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\tif (a->ecdsa == NULL || b->ecdsa == NULL ||\n\t\t    EC_KEY_get0_public_key(a->ecdsa) == NULL ||\n\t\t    EC_KEY_get0_public_key(b->ecdsa) == NULL)\n\t\t\treturn 0;\n\t\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\t\treturn 0;\n\t\tif (EC_GROUP_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_group(b->ecdsa), bnctx) != 0 ||\n\t\t    EC_POINT_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(b->ecdsa), bnctx) != 0) {\n\t\t\tBN_CTX_free(bnctx);\n\t\t\treturn 0;\n\t\t}\n\t\tBN_CTX_free(bnctx);\n\t\treturn 1;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn a->ed25519_pk != NULL && b->ed25519_pk != NULL &&\n\t\t    memcmp(a->ed25519_pk, b->ed25519_pk, ED25519_PK_SZ) == 0;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn a->xmss_pk != NULL && b->xmss_pk != NULL &&\n\t\t    sshkey_xmss_pklen(a) == sshkey_xmss_pklen(b) &&\n\t\t    memcmp(a->xmss_pk, b->xmss_pk, sshkey_xmss_pklen(a)) == 0;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_equal_public(const struct sshkey *a, const struct sshkey *b)\n{\n#if defined(WITH_OPENSSL)\n\tconst BIGNUM *rsa_e_a, *rsa_n_a;\n\tconst BIGNUM *rsa_e_b, *rsa_n_b;\n\tconst BIGNUM *dsa_p_a, *dsa_q_a, *dsa_g_a, *dsa_pub_key_a;\n\tconst BIGNUM *dsa_p_b, *dsa_q_b, *dsa_g_b, *dsa_pub_key_b;\n# if defined(OPENSSL_HAS_ECC)\n\tBN_CTX *bnctx;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n\tif (a == NULL || b == NULL ||\n\t    sshkey_type_plain(a->type) != sshkey_type_plain(b->type))\n\t\treturn 0;\n\n\tswitch (a->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\tif (a->rsa == NULL || b->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(a->rsa, &rsa_n_a, &rsa_e_a, NULL);\n\t\tRSA_get0_key(b->rsa, &rsa_n_b, &rsa_e_b, NULL);\n\t\treturn BN_cmp(rsa_e_a, rsa_e_b) == 0 &&\n\t\t    BN_cmp(rsa_n_a, rsa_n_b) == 0;\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\tif (a->dsa == NULL || b->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(a->dsa, &dsa_p_a, &dsa_q_a, &dsa_g_a);\n\t\tDSA_get0_pqg(b->dsa, &dsa_p_b, &dsa_q_b, &dsa_g_b);\n\t\tDSA_get0_key(a->dsa, &dsa_pub_key_a, NULL);\n\t\tDSA_get0_key(b->dsa, &dsa_pub_key_b, NULL);\n\t\treturn BN_cmp(dsa_p_a, dsa_p_b) == 0 &&\n\t\t    BN_cmp(dsa_q_a, dsa_q_b) == 0 &&\n\t\t    BN_cmp(dsa_g_a, dsa_g_b) == 0 &&\n\t\t    BN_cmp(dsa_pub_key_a, dsa_pub_key_b) == 0;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\tif (a->ecdsa == NULL || b->ecdsa == NULL ||\n\t\t    EC_KEY_get0_public_key(a->ecdsa) == NULL ||\n\t\t    EC_KEY_get0_public_key(b->ecdsa) == NULL)\n\t\t\treturn 0;\n\t\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\t\treturn 0;\n\t\tif (EC_GROUP_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_group(b->ecdsa), bnctx) != 0 ||\n\t\t    EC_POINT_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(b->ecdsa), bnctx) != 0) {\n\t\t\tBN_CTX_free(bnctx);\n\t\t\treturn 0;\n\t\t}\n\t\tBN_CTX_free(bnctx);\n\t\treturn 1;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn a->ed25519_pk != NULL && b->ed25519_pk != NULL &&\n\t\t    memcmp(a->ed25519_pk, b->ed25519_pk, ED25519_PK_SZ) == 0;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn a->xmss_pk != NULL && b->xmss_pk != NULL &&\n\t\t    sshkey_xmss_pklen(a) == sshkey_xmss_pklen(b) &&\n\t\t    memcmp(a->xmss_pk, b->xmss_pk, sshkey_xmss_pklen(a)) == 0;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_FOREACH",
          "args": [
            "private_id",
            "&authctxt->keys",
            "next"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_is_cert",
          "args": [
            "id->key"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_is_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "332-338",
          "snippet": "int\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "id->key",
            "options.fingerprint_hash",
            "SSH_FP_DEFAULT"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nu_char *session_id2 = NULL;\nu_int session_id2_len = 0;\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic struct sshkey *load_identity_file(Identity *);\nstatic Authmethod *authmethod_lookup(const char *name);\n\nstatic int\nsign_and_send_pubkey(struct ssh *ssh, Authctxt *authctxt, Identity *id)\n{\n\tstruct sshbuf *b = NULL;\n\tIdentity *private_id, *sign_id = NULL;\n\tu_char *signature = NULL;\n\tsize_t slen = 0, skip = 0;\n\tint r, fallback_sigtype, sent = 0;\n\tchar *alg = NULL, *fp = NULL;\n\tconst char *loc = \"\";\n\n\tif ((fp = sshkey_fingerprint(id->key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\treturn 0;\n\n\tdebug3(\"%s: %s %s\", __func__, sshkey_type(id->key), fp);\n\n\t/*\n\t * If the key is an certificate, try to find a matching private key\n\t * and use it to complete the signature.\n\t * If no such private key exists, fall back to trying the certificate\n\t * key itself in case it has a private half already loaded.\n\t * This will try to set sign_id to the private key that will perform\n\t * the signature.\n\t */\n\tif (sshkey_is_cert(id->key)) {\n\t\tTAILQ_FOREACH(private_id, &authctxt->keys, next) {\n\t\t\tif (sshkey_equal_public(id->key, private_id->key) &&\n\t\t\t    id->key->type != private_id->key->type) {\n\t\t\t\tsign_id = private_id;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Exact key matches are preferred, but also allow\n\t\t * filename matches for non-PKCS#11/agent keys that\n\t\t * didn't load public keys. This supports the case\n\t\t * of keeping just a private key file and public\n\t\t * certificate on disk.\n\t\t */\n\t\tif (sign_id == NULL &&\n\t\t    !id->isprivate && id->agent_fd == -1 &&\n\t\t    (id->key->flags & SSHKEY_FLAG_EXT) == 0) {\n\t\t\tTAILQ_FOREACH(private_id, &authctxt->keys, next) {\n\t\t\t\tif (private_id->key == NULL &&\n\t\t\t\t    id_filename_matches(id, private_id)) {\n\t\t\t\t\tsign_id = private_id;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (sign_id != NULL) {\n\t\t\tdebug2(\"%s: using private key \\\"%s\\\"%s for \"\n\t\t\t    \"certificate\", __func__, id->filename,\n\t\t\t    id->agent_fd != -1 ? \" from agent\" : \"\");\n\t\t} else {\n\t\t\tdebug(\"%s: no separate private key for certificate \"\n\t\t\t    \"\\\"%s\\\"\", __func__, id->filename);\n\t\t}\n\t}\n\n\t/*\n\t * If the above didn't select another identity to do the signing\n\t * then default to the one we started with.\n\t */\n\tif (sign_id == NULL)\n\t\tsign_id = id;\n\n\t/* assemble and sign data */\n\tfor (fallback_sigtype = 0; fallback_sigtype <= 1; fallback_sigtype++) {\n\t\tfree(alg);\n\t\tslen = 0;\n\t\tsignature = NULL;\n\t\tif ((alg = key_sig_algorithm(fallback_sigtype ? NULL : ssh,\n\t\t    id->key)) == NULL) {\n\t\t\terror(\"%s: no mutual signature supported\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t\tdebug3(\"%s: signing using %s\", __func__, alg);\n\n\t\tsshbuf_free(b);\n\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\tif (datafellows & SSH_OLD_SESSIONID) {\n\t\t\tif ((r = sshbuf_put(b, session_id2,\n\t\t\t    session_id2_len)) != 0) {\n\t\t\t\tfatal(\"%s: sshbuf_put: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t} else {\n\t\t\tif ((r = sshbuf_put_string(b, session_id2,\n\t\t\t    session_id2_len)) != 0) {\n\t\t\t\tfatal(\"%s: sshbuf_put_string: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t}\n\t\tskip = sshbuf_len(b);\n\t\tif ((r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->server_user)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->method->name)) != 0 ||\n\t\t    (r = sshbuf_put_u8(b, 1)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, alg)) != 0 ||\n\t\t    (r = sshkey_puts(id->key, b)) != 0) {\n\t\t\tfatal(\"%s: assemble signed data: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t}\n\n\t\t/* generate signature */\n\t\tr = identity_sign(sign_id, &signature, &slen,\n\t\t    sshbuf_ptr(b), sshbuf_len(b), datafellows, alg);\n\t\tif (r == 0)\n\t\t\tbreak;\n\t\telse if (r == SSH_ERR_KEY_NOT_FOUND)\n\t\t\tgoto out; /* soft failure */\n\t\telse if (r == SSH_ERR_SIGN_ALG_UNSUPPORTED &&\n\t\t    !fallback_sigtype) {\n\t\t\tif (sign_id->agent_fd != -1)\n\t\t\t\tloc = \"agent \";\n\t\t\telse if ((sign_id->key->flags & SSHKEY_FLAG_EXT) != 0)\n\t\t\t\tloc = \"token \";\n\t\t\tlogit(\"%skey %s %s returned incorrect signature type\",\n\t\t\t    loc, sshkey_type(id->key), fp);\n\t\t\tcontinue;\n\t\t}\n\t\terror(\"%s: signing failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif (slen == 0 || signature == NULL) /* shouldn't happen */\n\t\tfatal(\"%s: no signature\", __func__);\n\n\t/* append signature */\n\tif ((r = sshbuf_put_string(b, signature, slen)) != 0)\n\t\tfatal(\"%s: append signature: %s\", __func__, ssh_err(r));\n\n#ifdef DEBUG_PK\n\tsshbuf_dump(b, stderr);\n#endif\n\t/* skip session id and packet type */\n\tif ((r = sshbuf_consume(b, skip + 1)) != 0)\n\t\tfatal(\"%s: consume: %s\", __func__, ssh_err(r));\n\n\t/* put remaining data from buffer into packet */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_putb(ssh, b)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: enqueue request: %s\", __func__, ssh_err(r));\n\n\t/* success */\n\tsent = 1;\n\n out:\n\tfree(fp);\n\tfree(alg);\n\tsshbuf_free(b);\n\tfreezero(signature, slen);\n\treturn sent;\n}"
  },
  {
    "function_name": "id_filename_matches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "1163-1180",
    "snippet": "static int\nid_filename_matches(Identity *id, Identity *private_id)\n{\n\tconst char *suffixes[] = { \".pub\", \"-cert.pub\", NULL };\n\tsize_t len = strlen(id->filename), plen = strlen(private_id->filename);\n\tsize_t i, slen;\n\n\tif (strcmp(id->filename, private_id->filename) == 0)\n\t\treturn 1;\n\tfor (i = 0; suffixes[i]; i++) {\n\t\tslen = strlen(suffixes[i]);\n\t\tif (len > slen && plen == len - slen &&\n\t\t    strcmp(id->filename + (len - slen), suffixes[i]) == 0 &&\n\t\t    memcmp(id->filename, private_id->filename, plen) == 0)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);",
      "static struct sshkey *load_identity_file(Identity *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "id->filename",
            "private_id->filename",
            "plen"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "id->filename + (len - slen)",
            "suffixes[i]"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "suffixes[i]"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "private_id->filename"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "id->filename"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);\nstatic struct sshkey *load_identity_file(Identity *);\n\nstatic int\nid_filename_matches(Identity *id, Identity *private_id)\n{\n\tconst char *suffixes[] = { \".pub\", \"-cert.pub\", NULL };\n\tsize_t len = strlen(id->filename), plen = strlen(private_id->filename);\n\tsize_t i, slen;\n\n\tif (strcmp(id->filename, private_id->filename) == 0)\n\t\treturn 1;\n\tfor (i = 0; suffixes[i]; i++) {\n\t\tslen = strlen(suffixes[i]);\n\t\tif (len > slen && plen == len - slen &&\n\t\t    strcmp(id->filename + (len - slen), suffixes[i]) == 0 &&\n\t\t    memcmp(id->filename, private_id->filename, plen) == 0)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "identity_sign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "1119-1161",
    "snippet": "static int\nidentity_sign(struct identity *id, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, u_int compat, const char *alg)\n{\n\tstruct sshkey *prv;\n\tint r;\n\n\t/* The agent supports this key. */\n\tif (id->key != NULL && id->agent_fd != -1) {\n\t\treturn ssh_agent_sign(id->agent_fd, id->key, sigp, lenp,\n\t\t    data, datalen, alg, compat);\n\t}\n\n\t/*\n\t * We have already loaded the private key or the private key is\n\t * stored in external hardware.\n\t */\n\tif (id->key != NULL &&\n\t    (id->isprivate || (id->key->flags & SSHKEY_FLAG_EXT))) {\n\t\tif ((r = sshkey_sign(id->key, sigp, lenp, data, datalen,\n\t\t    alg, compat)) != 0)\n\t\t\treturn r;\n\t\t/*\n\t\t * PKCS#11 tokens may not support all signature algorithms,\n\t\t * so check what we get back.\n\t\t */\n\t\tif ((r = sshkey_check_sigtype(*sigp, *lenp, alg)) != 0)\n\t\t\treturn r;\n\t\treturn 0;\n\t}\n\n\t/* Load the private key from the file. */\n\tif ((prv = load_identity_file(id)) == NULL)\n\t\treturn SSH_ERR_KEY_NOT_FOUND;\n\tif (id->key != NULL && !sshkey_equal_public(prv, id->key)) {\n\t\terror(\"%s: private key %s contents do not match public\",\n\t\t   __func__, id->filename);\n\t\treturn SSH_ERR_KEY_NOT_FOUND;\n\t}\n\tr = sshkey_sign(prv, sigp, lenp, data, datalen, alg, compat);\n\tsshkey_free(prv);\n\treturn r;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "prv"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_sign",
          "args": [
            "prv",
            "sigp",
            "lenp",
            "data",
            "datalen",
            "alg",
            "compat"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2385-2421",
          "snippet": "int\nsshkey_sign(const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_sign(key, sigp, lenp, data, datalen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_sign(key, sigp, lenp, data, datalen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_sign(key, sigp, lenp, data, datalen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_sign(key, sigp, lenp, data, datalen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_sign(key, sigp, lenp, data, datalen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_sign(const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_sign(key, sigp, lenp, data, datalen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_sign(key, sigp, lenp, data, datalen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_sign(key, sigp, lenp, data, datalen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_sign(key, sigp, lenp, data, datalen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_sign(key, sigp, lenp, data, datalen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: private key %s contents do not match public\"",
            "__func__",
            "id->filename"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "input_gssapi_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "919-937",
          "snippet": "int\ninput_gssapi_error(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tchar *msg = NULL;\n\tchar *lang = NULL;\n\tint r;\n\n\tif ((r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* maj */\n\t    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* min */\n\t    (r = sshpkt_get_cstring(ssh, &msg, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &lang, NULL)) != 0)\n\t\tgoto out;\n\tr = sshpkt_get_end(ssh);\n\tdebug(\"Server GSSAPI Error:\\n%s\", msg);\n out:\n\tfree(msg);\n\tfree(lang);\n\treturn r;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\n\nint\ninput_gssapi_error(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tchar *msg = NULL;\n\tchar *lang = NULL;\n\tint r;\n\n\tif ((r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* maj */\n\t    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* min */\n\t    (r = sshpkt_get_cstring(ssh, &msg, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &lang, NULL)) != 0)\n\t\tgoto out;\n\tr = sshpkt_get_end(ssh);\n\tdebug(\"Server GSSAPI Error:\\n%s\", msg);\n out:\n\tfree(msg);\n\tfree(lang);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_equal_public",
          "args": [
            "prv",
            "id->key"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_equal_public",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "627-702",
          "snippet": "int\nsshkey_equal_public(const struct sshkey *a, const struct sshkey *b)\n{\n#if defined(WITH_OPENSSL)\n\tconst BIGNUM *rsa_e_a, *rsa_n_a;\n\tconst BIGNUM *rsa_e_b, *rsa_n_b;\n\tconst BIGNUM *dsa_p_a, *dsa_q_a, *dsa_g_a, *dsa_pub_key_a;\n\tconst BIGNUM *dsa_p_b, *dsa_q_b, *dsa_g_b, *dsa_pub_key_b;\n# if defined(OPENSSL_HAS_ECC)\n\tBN_CTX *bnctx;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n\tif (a == NULL || b == NULL ||\n\t    sshkey_type_plain(a->type) != sshkey_type_plain(b->type))\n\t\treturn 0;\n\n\tswitch (a->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\tif (a->rsa == NULL || b->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(a->rsa, &rsa_n_a, &rsa_e_a, NULL);\n\t\tRSA_get0_key(b->rsa, &rsa_n_b, &rsa_e_b, NULL);\n\t\treturn BN_cmp(rsa_e_a, rsa_e_b) == 0 &&\n\t\t    BN_cmp(rsa_n_a, rsa_n_b) == 0;\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\tif (a->dsa == NULL || b->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(a->dsa, &dsa_p_a, &dsa_q_a, &dsa_g_a);\n\t\tDSA_get0_pqg(b->dsa, &dsa_p_b, &dsa_q_b, &dsa_g_b);\n\t\tDSA_get0_key(a->dsa, &dsa_pub_key_a, NULL);\n\t\tDSA_get0_key(b->dsa, &dsa_pub_key_b, NULL);\n\t\treturn BN_cmp(dsa_p_a, dsa_p_b) == 0 &&\n\t\t    BN_cmp(dsa_q_a, dsa_q_b) == 0 &&\n\t\t    BN_cmp(dsa_g_a, dsa_g_b) == 0 &&\n\t\t    BN_cmp(dsa_pub_key_a, dsa_pub_key_b) == 0;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\tif (a->ecdsa == NULL || b->ecdsa == NULL ||\n\t\t    EC_KEY_get0_public_key(a->ecdsa) == NULL ||\n\t\t    EC_KEY_get0_public_key(b->ecdsa) == NULL)\n\t\t\treturn 0;\n\t\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\t\treturn 0;\n\t\tif (EC_GROUP_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_group(b->ecdsa), bnctx) != 0 ||\n\t\t    EC_POINT_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(b->ecdsa), bnctx) != 0) {\n\t\t\tBN_CTX_free(bnctx);\n\t\t\treturn 0;\n\t\t}\n\t\tBN_CTX_free(bnctx);\n\t\treturn 1;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn a->ed25519_pk != NULL && b->ed25519_pk != NULL &&\n\t\t    memcmp(a->ed25519_pk, b->ed25519_pk, ED25519_PK_SZ) == 0;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn a->xmss_pk != NULL && b->xmss_pk != NULL &&\n\t\t    sshkey_xmss_pklen(a) == sshkey_xmss_pklen(b) &&\n\t\t    memcmp(a->xmss_pk, b->xmss_pk, sshkey_xmss_pklen(a)) == 0;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_equal_public(const struct sshkey *a, const struct sshkey *b)\n{\n#if defined(WITH_OPENSSL)\n\tconst BIGNUM *rsa_e_a, *rsa_n_a;\n\tconst BIGNUM *rsa_e_b, *rsa_n_b;\n\tconst BIGNUM *dsa_p_a, *dsa_q_a, *dsa_g_a, *dsa_pub_key_a;\n\tconst BIGNUM *dsa_p_b, *dsa_q_b, *dsa_g_b, *dsa_pub_key_b;\n# if defined(OPENSSL_HAS_ECC)\n\tBN_CTX *bnctx;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\n\tif (a == NULL || b == NULL ||\n\t    sshkey_type_plain(a->type) != sshkey_type_plain(b->type))\n\t\treturn 0;\n\n\tswitch (a->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\tif (a->rsa == NULL || b->rsa == NULL)\n\t\t\treturn 0;\n\t\tRSA_get0_key(a->rsa, &rsa_n_a, &rsa_e_a, NULL);\n\t\tRSA_get0_key(b->rsa, &rsa_n_b, &rsa_e_b, NULL);\n\t\treturn BN_cmp(rsa_e_a, rsa_e_b) == 0 &&\n\t\t    BN_cmp(rsa_n_a, rsa_n_b) == 0;\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\tif (a->dsa == NULL || b->dsa == NULL)\n\t\t\treturn 0;\n\t\tDSA_get0_pqg(a->dsa, &dsa_p_a, &dsa_q_a, &dsa_g_a);\n\t\tDSA_get0_pqg(b->dsa, &dsa_p_b, &dsa_q_b, &dsa_g_b);\n\t\tDSA_get0_key(a->dsa, &dsa_pub_key_a, NULL);\n\t\tDSA_get0_key(b->dsa, &dsa_pub_key_b, NULL);\n\t\treturn BN_cmp(dsa_p_a, dsa_p_b) == 0 &&\n\t\t    BN_cmp(dsa_q_a, dsa_q_b) == 0 &&\n\t\t    BN_cmp(dsa_g_a, dsa_g_b) == 0 &&\n\t\t    BN_cmp(dsa_pub_key_a, dsa_pub_key_b) == 0;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\tif (a->ecdsa == NULL || b->ecdsa == NULL ||\n\t\t    EC_KEY_get0_public_key(a->ecdsa) == NULL ||\n\t\t    EC_KEY_get0_public_key(b->ecdsa) == NULL)\n\t\t\treturn 0;\n\t\tif ((bnctx = BN_CTX_new()) == NULL)\n\t\t\treturn 0;\n\t\tif (EC_GROUP_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_group(b->ecdsa), bnctx) != 0 ||\n\t\t    EC_POINT_cmp(EC_KEY_get0_group(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(a->ecdsa),\n\t\t    EC_KEY_get0_public_key(b->ecdsa), bnctx) != 0) {\n\t\t\tBN_CTX_free(bnctx);\n\t\t\treturn 0;\n\t\t}\n\t\tBN_CTX_free(bnctx);\n\t\treturn 1;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn a->ed25519_pk != NULL && b->ed25519_pk != NULL &&\n\t\t    memcmp(a->ed25519_pk, b->ed25519_pk, ED25519_PK_SZ) == 0;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn a->xmss_pk != NULL && b->xmss_pk != NULL &&\n\t\t    sshkey_xmss_pklen(a) == sshkey_xmss_pklen(b) &&\n\t\t    memcmp(a->xmss_pk, b->xmss_pk, sshkey_xmss_pklen(a)) == 0;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_identity_file",
          "args": [
            "id"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "load_identity_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "1380-1442",
          "snippet": "static struct sshkey *\nload_identity_file(Identity *id)\n{\n\tstruct sshkey *private = NULL;\n\tchar prompt[300], *passphrase, *comment;\n\tint r, perm_ok = 0, quit = 0, i;\n\tstruct stat st;\n\n\tif (stat(id->filename, &st) < 0) {\n\t\t(id->userprovided ? logit : debug3)(\"no such identity: %s: %s\",\n\t\t    id->filename, strerror(errno));\n\t\treturn NULL;\n\t}\n\tsnprintf(prompt, sizeof prompt,\n\t    \"Enter passphrase for key '%.100s': \", id->filename);\n\tfor (i = 0; i <= options.number_of_password_prompts; i++) {\n\t\tif (i == 0)\n\t\t\tpassphrase = \"\";\n\t\telse {\n\t\t\tpassphrase = read_passphrase(prompt, 0);\n\t\t\tif (*passphrase == '\\0') {\n\t\t\t\tdebug2(\"no passphrase given, try next key\");\n\t\t\t\tfree(passphrase);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tswitch ((r = sshkey_load_private_type(KEY_UNSPEC, id->filename,\n\t\t    passphrase, &private, &comment, &perm_ok))) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\t\tif (options.batch_mode) {\n\t\t\t\tquit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i != 0)\n\t\t\t\tdebug2(\"bad passphrase given, try again...\");\n\t\t\tbreak;\n\t\tcase SSH_ERR_SYSTEM_ERROR:\n\t\t\tif (errno == ENOENT) {\n\t\t\t\tdebug2(\"Load key \\\"%s\\\": %s\",\n\t\t\t\t    id->filename, ssh_err(r));\n\t\t\t\tquit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tdefault:\n\t\t\terror(\"Load key \\\"%s\\\": %s\", id->filename, ssh_err(r));\n\t\t\tquit = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!quit && private != NULL && id->agent_fd == -1 &&\n\t\t    !(id->key && id->isprivate))\n\t\t\tmaybe_add_key_to_agent(id->filename, private, comment,\n\t\t\t    passphrase);\n\t\tif (i > 0)\n\t\t\tfreezero(passphrase, strlen(passphrase));\n\t\tfree(comment);\n\t\tif (private != NULL || quit)\n\t\t\tbreak;\n\t}\n\treturn private;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "static int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);",
            "static struct sshkey *load_identity_file(Identity *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nstatic int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);\nstatic struct sshkey *load_identity_file(Identity *);\n\nstatic struct sshkey *\nload_identity_file(Identity *id)\n{\n\tstruct sshkey *private = NULL;\n\tchar prompt[300], *passphrase, *comment;\n\tint r, perm_ok = 0, quit = 0, i;\n\tstruct stat st;\n\n\tif (stat(id->filename, &st) < 0) {\n\t\t(id->userprovided ? logit : debug3)(\"no such identity: %s: %s\",\n\t\t    id->filename, strerror(errno));\n\t\treturn NULL;\n\t}\n\tsnprintf(prompt, sizeof prompt,\n\t    \"Enter passphrase for key '%.100s': \", id->filename);\n\tfor (i = 0; i <= options.number_of_password_prompts; i++) {\n\t\tif (i == 0)\n\t\t\tpassphrase = \"\";\n\t\telse {\n\t\t\tpassphrase = read_passphrase(prompt, 0);\n\t\t\tif (*passphrase == '\\0') {\n\t\t\t\tdebug2(\"no passphrase given, try next key\");\n\t\t\t\tfree(passphrase);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tswitch ((r = sshkey_load_private_type(KEY_UNSPEC, id->filename,\n\t\t    passphrase, &private, &comment, &perm_ok))) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\t\tif (options.batch_mode) {\n\t\t\t\tquit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i != 0)\n\t\t\t\tdebug2(\"bad passphrase given, try again...\");\n\t\t\tbreak;\n\t\tcase SSH_ERR_SYSTEM_ERROR:\n\t\t\tif (errno == ENOENT) {\n\t\t\t\tdebug2(\"Load key \\\"%s\\\": %s\",\n\t\t\t\t    id->filename, ssh_err(r));\n\t\t\t\tquit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tdefault:\n\t\t\terror(\"Load key \\\"%s\\\": %s\", id->filename, ssh_err(r));\n\t\t\tquit = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!quit && private != NULL && id->agent_fd == -1 &&\n\t\t    !(id->key && id->isprivate))\n\t\t\tmaybe_add_key_to_agent(id->filename, private, comment,\n\t\t\t    passphrase);\n\t\tif (i > 0)\n\t\t\tfreezero(passphrase, strlen(passphrase));\n\t\tfree(comment);\n\t\tif (private != NULL || quit)\n\t\t\tbreak;\n\t}\n\treturn private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_check_sigtype",
          "args": [
            "*sigp",
            "*lenp",
            "alg"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_check_sigtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2366-2383",
          "snippet": "int\nsshkey_check_sigtype(const u_char *sig, size_t siglen,\n    const char *requested_alg)\n{\n\tconst char *expected_alg;\n\tchar *sigtype = NULL;\n\tint r;\n\n\tif (requested_alg == NULL)\n\t\treturn 0;\n\tif ((expected_alg = sshkey_sigalg_by_name(requested_alg)) == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = get_sigtype(sig, siglen, &sigtype)) != 0)\n\t\treturn r;\n\tr = strcmp(expected_alg, sigtype) == 0;\n\tfree(sigtype);\n\treturn r ? 0 : SSH_ERR_SIGN_ALG_UNSUPPORTED;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_check_sigtype(const u_char *sig, size_t siglen,\n    const char *requested_alg)\n{\n\tconst char *expected_alg;\n\tchar *sigtype = NULL;\n\tint r;\n\n\tif (requested_alg == NULL)\n\t\treturn 0;\n\tif ((expected_alg = sshkey_sigalg_by_name(requested_alg)) == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = get_sigtype(sig, siglen, &sigtype)) != 0)\n\t\treturn r;\n\tr = strcmp(expected_alg, sigtype) == 0;\n\tfree(sigtype);\n\treturn r ? 0 : SSH_ERR_SIGN_ALG_UNSUPPORTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_agent_sign",
          "args": [
            "id->agent_fd",
            "id->key",
            "sigp",
            "lenp",
            "data",
            "datalen",
            "alg",
            "compat"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_agent_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "340-390",
          "snippet": "int\nssh_agent_sign(int sock, const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tstruct sshbuf *msg;\n\tu_char *sig = NULL, type = 0;\n\tsize_t len = 0;\n\tu_int flags = 0;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t*sigp = NULL;\n\t*lenp = 0;\n\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tflags |= agent_encode_alg(key, alg);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENTC_SIGN_REQUEST)) != 0 ||\n\t    (r = sshkey_puts(key, msg)) != 0 ||\n\t    (r = sshbuf_put_string(msg, data, datalen)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, flags)) != 0)\n\t\tgoto out;\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tif (agent_failed(type)) {\n\t\tr = SSH_ERR_AGENT_FAILURE;\n\t\tgoto out;\n\t} else if (type != SSH2_AGENT_SIGN_RESPONSE) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_string(msg, &sig, &len)) != 0)\n\t\tgoto out;\n\t/* Check what we actually got back from the agent. */\n\tif ((r = sshkey_check_sigtype(sig, len, alg)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*sigp = sig;\n\t*lenp = len;\n\tsig = NULL;\n\tlen = 0;\n\tr = 0;\n out:\n\tfreezero(sig, len);\n\tsshbuf_free(msg);\n\treturn r;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_agent_sign(int sock, const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tstruct sshbuf *msg;\n\tu_char *sig = NULL, type = 0;\n\tsize_t len = 0;\n\tu_int flags = 0;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t*sigp = NULL;\n\t*lenp = 0;\n\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((msg = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tflags |= agent_encode_alg(key, alg);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENTC_SIGN_REQUEST)) != 0 ||\n\t    (r = sshkey_puts(key, msg)) != 0 ||\n\t    (r = sshbuf_put_string(msg, data, datalen)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, flags)) != 0)\n\t\tgoto out;\n\tif ((r = ssh_request_reply(sock, msg, msg)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tgoto out;\n\tif (agent_failed(type)) {\n\t\tr = SSH_ERR_AGENT_FAILURE;\n\t\tgoto out;\n\t} else if (type != SSH2_AGENT_SIGN_RESPONSE) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_string(msg, &sig, &len)) != 0)\n\t\tgoto out;\n\t/* Check what we actually got back from the agent. */\n\tif ((r = sshkey_check_sigtype(sig, len, alg)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*sigp = sig;\n\t*lenp = len;\n\tsig = NULL;\n\tlen = 0;\n\tr = 0;\n out:\n\tfreezero(sig, len);\n\tsshbuf_free(msg);\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nidentity_sign(struct identity *id, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, u_int compat, const char *alg)\n{\n\tstruct sshkey *prv;\n\tint r;\n\n\t/* The agent supports this key. */\n\tif (id->key != NULL && id->agent_fd != -1) {\n\t\treturn ssh_agent_sign(id->agent_fd, id->key, sigp, lenp,\n\t\t    data, datalen, alg, compat);\n\t}\n\n\t/*\n\t * We have already loaded the private key or the private key is\n\t * stored in external hardware.\n\t */\n\tif (id->key != NULL &&\n\t    (id->isprivate || (id->key->flags & SSHKEY_FLAG_EXT))) {\n\t\tif ((r = sshkey_sign(id->key, sigp, lenp, data, datalen,\n\t\t    alg, compat)) != 0)\n\t\t\treturn r;\n\t\t/*\n\t\t * PKCS#11 tokens may not support all signature algorithms,\n\t\t * so check what we get back.\n\t\t */\n\t\tif ((r = sshkey_check_sigtype(*sigp, *lenp, alg)) != 0)\n\t\t\treturn r;\n\t\treturn 0;\n\t}\n\n\t/* Load the private key from the file. */\n\tif ((prv = load_identity_file(id)) == NULL)\n\t\treturn SSH_ERR_KEY_NOT_FOUND;\n\tif (id->key != NULL && !sshkey_equal_public(prv, id->key)) {\n\t\terror(\"%s: private key %s contents do not match public\",\n\t\t   __func__, id->filename);\n\t\treturn SSH_ERR_KEY_NOT_FOUND;\n\t}\n\tr = sshkey_sign(prv, sigp, lenp, data, datalen, alg, compat);\n\tsshkey_free(prv);\n\treturn r;\n}"
  },
  {
    "function_name": "key_sig_algorithm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "1080-1117",
    "snippet": "static char *\nkey_sig_algorithm(struct ssh *ssh, const struct sshkey *key)\n{\n\tchar *allowed, *oallowed, *cp, *tmp, *alg = NULL;\n\n\t/*\n\t * The signature algorithm will only differ from the key algorithm\n\t * for RSA keys/certs and when the server advertises support for\n\t * newer (SHA2) algorithms.\n\t */\n\tif (ssh == NULL || ssh->kex->server_sig_algs == NULL ||\n\t    (key->type != KEY_RSA && key->type != KEY_RSA_CERT) ||\n\t    (key->type == KEY_RSA_CERT && (datafellows & SSH_BUG_SIGTYPE))) {\n\t\t/* Filter base key signature alg against our configuration */\n\t\treturn match_list(sshkey_ssh_name(key),\n\t\t    options.pubkey_key_types, NULL);\n\t}\n\n\t/*\n\t * For RSA keys/certs, since these might have a different sig type:\n\t * find the first entry in PubkeyAcceptedKeyTypes of the right type\n\t * that also appears in the supported signature algorithms list from\n\t * the server.\n\t */\n\toallowed = allowed = xstrdup(options.pubkey_key_types);\n\twhile ((cp = strsep(&allowed, \",\")) != NULL) {\n\t\tif (sshkey_type_from_name(cp) != key->type)\n\t\t\tcontinue;\n\t\ttmp = match_list(sshkey_sigalg_by_name(cp), ssh->kex->server_sig_algs, NULL);\n\t\tif (tmp != NULL)\n\t\t\talg = xstrdup(cp);\n\t\tfree(tmp);\n\t\tif (alg != NULL)\n\t\t\tbreak;\n\t}\n\tfree(oallowed);\n\treturn alg;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "oallowed"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "cp"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_list",
          "args": [
            "sshkey_sigalg_by_name(cp)",
            "ssh->kex->server_sig_algs",
            "NULL"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "match_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/match.c",
          "lines": "256-294",
          "snippet": "char *\nmatch_list(const char *client, const char *server, u_int *next)\n{\n\tchar *sproposals[MAX_PROP];\n\tchar *c, *s, *p, *ret, *cp, *sp;\n\tint i, j, nproposals;\n\n\tc = cp = xstrdup(client);\n\ts = sp = xstrdup(server);\n\n\tfor ((p = strsep(&sp, SEP)), i=0; p && *p != '\\0';\n\t    (p = strsep(&sp, SEP)), i++) {\n\t\tif (i < MAX_PROP)\n\t\t\tsproposals[i] = p;\n\t\telse\n\t\t\tbreak;\n\t}\n\tnproposals = i;\n\n\tfor ((p = strsep(&cp, SEP)), i=0; p && *p != '\\0';\n\t    (p = strsep(&cp, SEP)), i++) {\n\t\tfor (j = 0; j < nproposals; j++) {\n\t\t\tif (strcmp(p, sproposals[j]) == 0) {\n\t\t\t\tret = xstrdup(p);\n\t\t\t\tif (next != NULL)\n\t\t\t\t\t*next = (cp == NULL) ?\n\t\t\t\t\t    strlen(c) : (u_int)(cp - c);\n\t\t\t\tfree(c);\n\t\t\t\tfree(s);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\tif (next != NULL)\n\t\t*next = strlen(c);\n\tfree(c);\n\tfree(s);\n\treturn NULL;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define\tSEP\t\",\"",
            "#define\tMAX_PROP\t40"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define\tSEP\t\",\"\n#define\tMAX_PROP\t40\n\nchar *\nmatch_list(const char *client, const char *server, u_int *next)\n{\n\tchar *sproposals[MAX_PROP];\n\tchar *c, *s, *p, *ret, *cp, *sp;\n\tint i, j, nproposals;\n\n\tc = cp = xstrdup(client);\n\ts = sp = xstrdup(server);\n\n\tfor ((p = strsep(&sp, SEP)), i=0; p && *p != '\\0';\n\t    (p = strsep(&sp, SEP)), i++) {\n\t\tif (i < MAX_PROP)\n\t\t\tsproposals[i] = p;\n\t\telse\n\t\t\tbreak;\n\t}\n\tnproposals = i;\n\n\tfor ((p = strsep(&cp, SEP)), i=0; p && *p != '\\0';\n\t    (p = strsep(&cp, SEP)), i++) {\n\t\tfor (j = 0; j < nproposals; j++) {\n\t\t\tif (strcmp(p, sproposals[j]) == 0) {\n\t\t\t\tret = xstrdup(p);\n\t\t\t\tif (next != NULL)\n\t\t\t\t\t*next = (cp == NULL) ?\n\t\t\t\t\t    strlen(c) : (u_int)(cp - c);\n\t\t\t\tfree(c);\n\t\t\t\tfree(s);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\tif (next != NULL)\n\t\t*next = strlen(c);\n\tfree(c);\n\tfree(s);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_sigalg_by_name",
          "args": [
            "cp"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_sigalg_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2344-2360",
          "snippet": "const char *\nsshkey_sigalg_by_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (strcmp(kt->name, name) != 0)\n\t\t\tcontinue;\n\t\tif (kt->sigalg != NULL)\n\t\t\treturn kt->sigalg;\n\t\tif (!kt->cert)\n\t\t\treturn kt->name;\n\t\treturn sshkey_ssh_name_from_type_nid(\n\t\t    sshkey_type_plain(kt->type), kt->nid);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nconst char *\nsshkey_sigalg_by_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (strcmp(kt->name, name) != 0)\n\t\t\tcontinue;\n\t\tif (kt->sigalg != NULL)\n\t\t\treturn kt->sigalg;\n\t\tif (!kt->cert)\n\t\t\treturn kt->name;\n\t\treturn sshkey_ssh_name_from_type_nid(\n\t\t    sshkey_type_plain(kt->type), kt->nid);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_from_name",
          "args": [
            "cp"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "190-202",
          "snippet": "int\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&allowed",
            "\",\""
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "xstrsep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keyscan.c",
          "lines": "162-178",
          "snippet": "static char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}",
          "includes": [
            "#include \"dns.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"myproposal.h\"",
            "#include \"compat.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include <netdb.h>",
            "#include <openssl/bn.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/resource.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"myproposal.h\"\n#include \"compat.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <netdb.h>\n#include <openssl/bn.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/resource.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_ssh_name",
          "args": [
            "key"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_ssh_name_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "183-188",
          "snippet": "const char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\n\nstatic char *\nkey_sig_algorithm(struct ssh *ssh, const struct sshkey *key)\n{\n\tchar *allowed, *oallowed, *cp, *tmp, *alg = NULL;\n\n\t/*\n\t * The signature algorithm will only differ from the key algorithm\n\t * for RSA keys/certs and when the server advertises support for\n\t * newer (SHA2) algorithms.\n\t */\n\tif (ssh == NULL || ssh->kex->server_sig_algs == NULL ||\n\t    (key->type != KEY_RSA && key->type != KEY_RSA_CERT) ||\n\t    (key->type == KEY_RSA_CERT && (datafellows & SSH_BUG_SIGTYPE))) {\n\t\t/* Filter base key signature alg against our configuration */\n\t\treturn match_list(sshkey_ssh_name(key),\n\t\t    options.pubkey_key_types, NULL);\n\t}\n\n\t/*\n\t * For RSA keys/certs, since these might have a different sig type:\n\t * find the first entry in PubkeyAcceptedKeyTypes of the right type\n\t * that also appears in the supported signature algorithms list from\n\t * the server.\n\t */\n\toallowed = allowed = xstrdup(options.pubkey_key_types);\n\twhile ((cp = strsep(&allowed, \",\")) != NULL) {\n\t\tif (sshkey_type_from_name(cp) != key->type)\n\t\t\tcontinue;\n\t\ttmp = match_list(sshkey_sigalg_by_name(cp), ssh->kex->server_sig_algs, NULL);\n\t\tif (tmp != NULL)\n\t\t\talg = xstrdup(cp);\n\t\tfree(tmp);\n\t\tif (alg != NULL)\n\t\t\tbreak;\n\t}\n\tfree(oallowed);\n\treturn alg;\n}"
  },
  {
    "function_name": "input_userauth_passwd_changereq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "999-1071",
    "snippet": "int\ninput_userauth_passwd_changereq(int type, u_int32_t seqnr, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tchar *info = NULL, *lang = NULL, *password = NULL, *retype = NULL;\n\tchar prompt[256];\n\tconst char *host;\n\tint r;\n\n\tdebug2(\"input_userauth_passwd_changereq\");\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_userauth_passwd_changereq: \"\n\t\t    \"no authentication context\");\n\thost = options.host_key_alias ? options.host_key_alias : authctxt->host;\n\n\tif ((r = sshpkt_get_cstring(ssh, &info, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &lang, NULL)) != 0)\n\t\tgoto out;\n\tif (strlen(info) > 0)\n\t\tlogit(\"%s\", info);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 1)) != 0)\t/* additional info */\n\t\tgoto out;\n\n\tsnprintf(prompt, sizeof(prompt),\n\t    \"Enter %.30s@%.128s's old password: \",\n\t    authctxt->server_user, host);\n\tpassword = read_passphrase(prompt, 0);\n\tif ((r = sshpkt_put_cstring(ssh, password)) != 0)\n\t\tgoto out;\n\n\tfreezero(password, strlen(password));\n\tpassword = NULL;\n\twhile (password == NULL) {\n\t\tsnprintf(prompt, sizeof(prompt),\n\t\t    \"Enter %.30s@%.128s's new password: \",\n\t\t    authctxt->server_user, host);\n\t\tpassword = read_passphrase(prompt, RP_ALLOW_EOF);\n\t\tif (password == NULL) {\n\t\t\t/* bail out */\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tsnprintf(prompt, sizeof(prompt),\n\t\t    \"Retype %.30s@%.128s's new password: \",\n\t\t    authctxt->server_user, host);\n\t\tretype = read_passphrase(prompt, 0);\n\t\tif (strcmp(password, retype) != 0) {\n\t\t\tfreezero(password, strlen(password));\n\t\t\tlogit(\"Mismatch; try again, EOF to quit.\");\n\t\t\tpassword = NULL;\n\t\t}\n\t\tfreezero(retype, strlen(retype));\n\t}\n\tif ((r = sshpkt_put_cstring(ssh, password)) != 0 ||\n\t    (r = sshpkt_add_padding(ssh, 64)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tgoto out;\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ,\n\t    &input_userauth_passwd_changereq);\n\tr = 0;\n out:\n\tif (password)\n\t\tfreezero(password, strlen(password));\n\tfree(info);\n\tfree(lang);\n\treturn r;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
      "int\tuserauth_none(Authctxt *);",
      "int\tuserauth_pubkey(Authctxt *);",
      "int\tuserauth_passwd(Authctxt *);",
      "int\tuserauth_kbdint(Authctxt *);",
      "int\tuserauth_hostbased(Authctxt *);",
      "void\tuserauth(Authctxt *, char *);",
      "static void pubkey_prepare(Authctxt *);",
      "static void pubkey_cleanup(Authctxt *);",
      "static void pubkey_reset(Authctxt *);",
      "static Authmethod *authmethod_lookup(const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "lang"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezero",
          "args": [
            "password",
            "strlen(password)"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "freezero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/freezero.c",
          "lines": "24-31",
          "snippet": "void\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "password"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_dispatch_set",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ",
            "&input_userauth_passwd_changereq"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_dispatch_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dispatch.c",
          "lines": "81-85",
          "snippet": "void\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"dispatch.h\"",
            "#include \"log.h\"",
            "#include \"ssh2.h\"",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include <stdarg.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_add_padding",
          "args": [
            "ssh",
            "64"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_add_padding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2677-2682",
          "snippet": "int\nsshpkt_add_padding(struct ssh *ssh, u_char pad)\n{\n\tssh->state->extra_pad = pad;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_add_padding(struct ssh *ssh, u_char pad)\n{\n\tssh->state->extra_pad = pad;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_cstring",
          "args": [
            "ssh",
            "password"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2459-2463",
          "snippet": "int\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "retype"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Mismatch; try again, EOF to quit.\""
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "password"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "password",
            "retype"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_passphrase",
          "args": [
            "prompt",
            "0"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "read_passphrase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readpass.c",
          "lines": "117-166",
          "snippet": "char *\nread_passphrase(const char *prompt, int flags)\n{\n\tchar *askpass = NULL, *ret, buf[1024];\n\tint rppflags, use_askpass = 0, ttyfd;\n\n\trppflags = (flags & RP_ECHO) ? RPP_ECHO_ON : RPP_ECHO_OFF;\n\tif (flags & RP_USE_ASKPASS)\n\t\tuse_askpass = 1;\n\telse if (flags & RP_ALLOW_STDIN) {\n\t\tif (!isatty(STDIN_FILENO)) {\n\t\t\tdebug(\"read_passphrase: stdin is not a tty\");\n\t\t\tuse_askpass = 1;\n\t\t}\n\t} else {\n\t\trppflags |= RPP_REQUIRE_TTY;\n\t\tttyfd = open(_PATH_TTY, O_RDWR);\n\t\tif (ttyfd >= 0)\n\t\t\tclose(ttyfd);\n\t\telse {\n\t\t\tdebug(\"read_passphrase: can't open %s: %s\", _PATH_TTY,\n\t\t\t    strerror(errno));\n\t\t\tuse_askpass = 1;\n\t\t}\n\t}\n\n\tif ((flags & RP_USE_ASKPASS) && getenv(\"DISPLAY\") == NULL)\n\t\treturn (flags & RP_ALLOW_EOF) ? NULL : xstrdup(\"\");\n\n\tif (use_askpass && getenv(\"DISPLAY\")) {\n\t\tif (getenv(SSH_ASKPASS_ENV))\n\t\t\taskpass = getenv(SSH_ASKPASS_ENV);\n\t\telse\n\t\t\taskpass = _PATH_SSH_ASKPASS_DEFAULT;\n\t\tif ((ret = ssh_askpass(askpass, prompt)) == NULL)\n\t\t\tif (!(flags & RP_ALLOW_EOF))\n\t\t\t\treturn xstrdup(\"\");\n\t\treturn ret;\n\t}\n\n\tif (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {\n\t\tif (flags & RP_ALLOW_EOF)\n\t\t\treturn NULL;\n\t\treturn xstrdup(\"\");\n\t}\n\n\tret = xstrdup(buf);\n\texplicit_bzero(buf, sizeof(buf));\n\treturn ret;\n}",
          "includes": [
            "#include \"uidswap.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uidswap.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nread_passphrase(const char *prompt, int flags)\n{\n\tchar *askpass = NULL, *ret, buf[1024];\n\tint rppflags, use_askpass = 0, ttyfd;\n\n\trppflags = (flags & RP_ECHO) ? RPP_ECHO_ON : RPP_ECHO_OFF;\n\tif (flags & RP_USE_ASKPASS)\n\t\tuse_askpass = 1;\n\telse if (flags & RP_ALLOW_STDIN) {\n\t\tif (!isatty(STDIN_FILENO)) {\n\t\t\tdebug(\"read_passphrase: stdin is not a tty\");\n\t\t\tuse_askpass = 1;\n\t\t}\n\t} else {\n\t\trppflags |= RPP_REQUIRE_TTY;\n\t\tttyfd = open(_PATH_TTY, O_RDWR);\n\t\tif (ttyfd >= 0)\n\t\t\tclose(ttyfd);\n\t\telse {\n\t\t\tdebug(\"read_passphrase: can't open %s: %s\", _PATH_TTY,\n\t\t\t    strerror(errno));\n\t\t\tuse_askpass = 1;\n\t\t}\n\t}\n\n\tif ((flags & RP_USE_ASKPASS) && getenv(\"DISPLAY\") == NULL)\n\t\treturn (flags & RP_ALLOW_EOF) ? NULL : xstrdup(\"\");\n\n\tif (use_askpass && getenv(\"DISPLAY\")) {\n\t\tif (getenv(SSH_ASKPASS_ENV))\n\t\t\taskpass = getenv(SSH_ASKPASS_ENV);\n\t\telse\n\t\t\taskpass = _PATH_SSH_ASKPASS_DEFAULT;\n\t\tif ((ret = ssh_askpass(askpass, prompt)) == NULL)\n\t\t\tif (!(flags & RP_ALLOW_EOF))\n\t\t\t\treturn xstrdup(\"\");\n\t\treturn ret;\n\t}\n\n\tif (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {\n\t\tif (flags & RP_ALLOW_EOF)\n\t\t\treturn NULL;\n\t\treturn xstrdup(\"\");\n\t}\n\n\tret = xstrdup(buf);\n\texplicit_bzero(buf, sizeof(buf));\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "prompt",
            "sizeof(prompt)",
            "\"Retype %.30s@%.128s's new password: \"",
            "authctxt->server_user",
            "host"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "password"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u8",
          "args": [
            "ssh",
            "1"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2435-2439",
          "snippet": "int\nsshpkt_put_u8(struct ssh *ssh, u_char val)\n{\n\treturn sshbuf_put_u8(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u8(struct ssh *ssh, u_char val)\n{\n\treturn sshbuf_put_u8(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_REQUEST"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "info"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshpkt_get_cstring",
          "args": [
            "ssh",
            "&lang",
            "NULL"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2532-2536",
          "snippet": "int\nsshpkt_get_cstring(struct ssh *ssh, char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_cstring(ssh->state->incoming_packet, valp, lenp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_cstring(struct ssh *ssh, char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_cstring(ssh->state->incoming_packet, valp, lenp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"input_userauth_passwd_changereq: \"\n\t\t    \"no authentication context\""
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"input_userauth_passwd_changereq\""
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic Authmethod *authmethod_lookup(const char *name);\n\nint\ninput_userauth_passwd_changereq(int type, u_int32_t seqnr, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tchar *info = NULL, *lang = NULL, *password = NULL, *retype = NULL;\n\tchar prompt[256];\n\tconst char *host;\n\tint r;\n\n\tdebug2(\"input_userauth_passwd_changereq\");\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_userauth_passwd_changereq: \"\n\t\t    \"no authentication context\");\n\thost = options.host_key_alias ? options.host_key_alias : authctxt->host;\n\n\tif ((r = sshpkt_get_cstring(ssh, &info, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &lang, NULL)) != 0)\n\t\tgoto out;\n\tif (strlen(info) > 0)\n\t\tlogit(\"%s\", info);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 1)) != 0)\t/* additional info */\n\t\tgoto out;\n\n\tsnprintf(prompt, sizeof(prompt),\n\t    \"Enter %.30s@%.128s's old password: \",\n\t    authctxt->server_user, host);\n\tpassword = read_passphrase(prompt, 0);\n\tif ((r = sshpkt_put_cstring(ssh, password)) != 0)\n\t\tgoto out;\n\n\tfreezero(password, strlen(password));\n\tpassword = NULL;\n\twhile (password == NULL) {\n\t\tsnprintf(prompt, sizeof(prompt),\n\t\t    \"Enter %.30s@%.128s's new password: \",\n\t\t    authctxt->server_user, host);\n\t\tpassword = read_passphrase(prompt, RP_ALLOW_EOF);\n\t\tif (password == NULL) {\n\t\t\t/* bail out */\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tsnprintf(prompt, sizeof(prompt),\n\t\t    \"Retype %.30s@%.128s's new password: \",\n\t\t    authctxt->server_user, host);\n\t\tretype = read_passphrase(prompt, 0);\n\t\tif (strcmp(password, retype) != 0) {\n\t\t\tfreezero(password, strlen(password));\n\t\t\tlogit(\"Mismatch; try again, EOF to quit.\");\n\t\t\tpassword = NULL;\n\t\t}\n\t\tfreezero(retype, strlen(retype));\n\t}\n\tif ((r = sshpkt_put_cstring(ssh, password)) != 0 ||\n\t    (r = sshpkt_add_padding(ssh, 64)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tgoto out;\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ,\n\t    &input_userauth_passwd_changereq);\n\tr = 0;\n out:\n\tif (password)\n\t\tfreezero(password, strlen(password));\n\tfree(info);\n\tfree(lang);\n\treturn r;\n}"
  },
  {
    "function_name": "userauth_passwd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "956-993",
    "snippet": "int\nuserauth_passwd(Authctxt *authctxt)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tstatic int attempt = 0;\n\tchar prompt[256];\n\tchar *password;\n\tconst char *host = options.host_key_alias ?  options.host_key_alias :\n\t    authctxt->host;\n\tint r;\n\n\tif (attempt++ >= options.number_of_password_prompts)\n\t\treturn 0;\n\n\tif (attempt != 1)\n\t\terror(\"Permission denied, please try again.\");\n\n\tsnprintf(prompt, sizeof(prompt), \"%.30s@%.128s's password: \",\n\t    authctxt->server_user, host);\n\tpassword = read_passphrase(prompt, 0);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 0)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, password)) != 0 ||\n\t    (r = sshpkt_add_padding(ssh, 64)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tif (password)\n\t\tfreezero(password, strlen(password));\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ,\n\t    &input_userauth_passwd_changereq);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
      "int\tuserauth_none(Authctxt *);",
      "int\tuserauth_pubkey(Authctxt *);",
      "int\tuserauth_passwd(Authctxt *);",
      "int\tuserauth_kbdint(Authctxt *);",
      "int\tuserauth_hostbased(Authctxt *);",
      "void\tuserauth(Authctxt *, char *);",
      "static void pubkey_prepare(Authctxt *);",
      "static void pubkey_cleanup(Authctxt *);",
      "static void pubkey_reset(Authctxt *);",
      "static Authmethod *authmethod_lookup(const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_dispatch_set",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ",
            "&input_userauth_passwd_changereq"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_dispatch_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dispatch.c",
          "lines": "81-85",
          "snippet": "void\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"dispatch.h\"",
            "#include \"log.h\"",
            "#include \"ssh2.h\"",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include <stdarg.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezero",
          "args": [
            "password",
            "strlen(password)"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "freezero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/freezero.c",
          "lines": "24-31",
          "snippet": "void\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreezero(void *ptr, size_t sz)\n{\n\tif (ptr == NULL)\n\t\treturn;\n\texplicit_bzero(ptr, sz);\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "password"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_add_padding",
          "args": [
            "ssh",
            "64"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_add_padding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2677-2682",
          "snippet": "int\nsshpkt_add_padding(struct ssh *ssh, u_char pad)\n{\n\tssh->state->extra_pad = pad;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_add_padding(struct ssh *ssh, u_char pad)\n{\n\tssh->state->extra_pad = pad;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_cstring",
          "args": [
            "ssh",
            "password"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2459-2463",
          "snippet": "int\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u8",
          "args": [
            "ssh",
            "0"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2435-2439",
          "snippet": "int\nsshpkt_put_u8(struct ssh *ssh, u_char val)\n{\n\treturn sshbuf_put_u8(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u8(struct ssh *ssh, u_char val)\n{\n\treturn sshbuf_put_u8(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_REQUEST"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_passphrase",
          "args": [
            "prompt",
            "0"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "read_passphrase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/readpass.c",
          "lines": "117-166",
          "snippet": "char *\nread_passphrase(const char *prompt, int flags)\n{\n\tchar *askpass = NULL, *ret, buf[1024];\n\tint rppflags, use_askpass = 0, ttyfd;\n\n\trppflags = (flags & RP_ECHO) ? RPP_ECHO_ON : RPP_ECHO_OFF;\n\tif (flags & RP_USE_ASKPASS)\n\t\tuse_askpass = 1;\n\telse if (flags & RP_ALLOW_STDIN) {\n\t\tif (!isatty(STDIN_FILENO)) {\n\t\t\tdebug(\"read_passphrase: stdin is not a tty\");\n\t\t\tuse_askpass = 1;\n\t\t}\n\t} else {\n\t\trppflags |= RPP_REQUIRE_TTY;\n\t\tttyfd = open(_PATH_TTY, O_RDWR);\n\t\tif (ttyfd >= 0)\n\t\t\tclose(ttyfd);\n\t\telse {\n\t\t\tdebug(\"read_passphrase: can't open %s: %s\", _PATH_TTY,\n\t\t\t    strerror(errno));\n\t\t\tuse_askpass = 1;\n\t\t}\n\t}\n\n\tif ((flags & RP_USE_ASKPASS) && getenv(\"DISPLAY\") == NULL)\n\t\treturn (flags & RP_ALLOW_EOF) ? NULL : xstrdup(\"\");\n\n\tif (use_askpass && getenv(\"DISPLAY\")) {\n\t\tif (getenv(SSH_ASKPASS_ENV))\n\t\t\taskpass = getenv(SSH_ASKPASS_ENV);\n\t\telse\n\t\t\taskpass = _PATH_SSH_ASKPASS_DEFAULT;\n\t\tif ((ret = ssh_askpass(askpass, prompt)) == NULL)\n\t\t\tif (!(flags & RP_ALLOW_EOF))\n\t\t\t\treturn xstrdup(\"\");\n\t\treturn ret;\n\t}\n\n\tif (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {\n\t\tif (flags & RP_ALLOW_EOF)\n\t\t\treturn NULL;\n\t\treturn xstrdup(\"\");\n\t}\n\n\tret = xstrdup(buf);\n\texplicit_bzero(buf, sizeof(buf));\n\treturn ret;\n}",
          "includes": [
            "#include \"uidswap.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uidswap.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nread_passphrase(const char *prompt, int flags)\n{\n\tchar *askpass = NULL, *ret, buf[1024];\n\tint rppflags, use_askpass = 0, ttyfd;\n\n\trppflags = (flags & RP_ECHO) ? RPP_ECHO_ON : RPP_ECHO_OFF;\n\tif (flags & RP_USE_ASKPASS)\n\t\tuse_askpass = 1;\n\telse if (flags & RP_ALLOW_STDIN) {\n\t\tif (!isatty(STDIN_FILENO)) {\n\t\t\tdebug(\"read_passphrase: stdin is not a tty\");\n\t\t\tuse_askpass = 1;\n\t\t}\n\t} else {\n\t\trppflags |= RPP_REQUIRE_TTY;\n\t\tttyfd = open(_PATH_TTY, O_RDWR);\n\t\tif (ttyfd >= 0)\n\t\t\tclose(ttyfd);\n\t\telse {\n\t\t\tdebug(\"read_passphrase: can't open %s: %s\", _PATH_TTY,\n\t\t\t    strerror(errno));\n\t\t\tuse_askpass = 1;\n\t\t}\n\t}\n\n\tif ((flags & RP_USE_ASKPASS) && getenv(\"DISPLAY\") == NULL)\n\t\treturn (flags & RP_ALLOW_EOF) ? NULL : xstrdup(\"\");\n\n\tif (use_askpass && getenv(\"DISPLAY\")) {\n\t\tif (getenv(SSH_ASKPASS_ENV))\n\t\t\taskpass = getenv(SSH_ASKPASS_ENV);\n\t\telse\n\t\t\taskpass = _PATH_SSH_ASKPASS_DEFAULT;\n\t\tif ((ret = ssh_askpass(askpass, prompt)) == NULL)\n\t\t\tif (!(flags & RP_ALLOW_EOF))\n\t\t\t\treturn xstrdup(\"\");\n\t\treturn ret;\n\t}\n\n\tif (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {\n\t\tif (flags & RP_ALLOW_EOF)\n\t\t\treturn NULL;\n\t\treturn xstrdup(\"\");\n\t}\n\n\tret = xstrdup(buf);\n\texplicit_bzero(buf, sizeof(buf));\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "prompt",
            "sizeof(prompt)",
            "\"%.30s@%.128s's password: \"",
            "authctxt->server_user",
            "host"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Permission denied, please try again.\""
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic Authmethod *authmethod_lookup(const char *name);\n\nint\nuserauth_passwd(Authctxt *authctxt)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tstatic int attempt = 0;\n\tchar prompt[256];\n\tchar *password;\n\tconst char *host = options.host_key_alias ?  options.host_key_alias :\n\t    authctxt->host;\n\tint r;\n\n\tif (attempt++ >= options.number_of_password_prompts)\n\t\treturn 0;\n\n\tif (attempt != 1)\n\t\terror(\"Permission denied, please try again.\");\n\n\tsnprintf(prompt, sizeof(prompt), \"%.30s@%.128s's password: \",\n\t    authctxt->server_user, host);\n\tpassword = read_passphrase(prompt, 0);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 0)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, password)) != 0 ||\n\t    (r = sshpkt_add_padding(ssh, 64)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tif (password)\n\t\tfreezero(password, strlen(password));\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ,\n\t    &input_userauth_passwd_changereq);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "userauth_none",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "940-954",
    "snippet": "int\nuserauth_none(Authctxt *authctxt)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tint r;\n\n\t/* initial userauth request */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\treturn 1;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
      "int\tuserauth_none(Authctxt *);",
      "int\tuserauth_pubkey(Authctxt *);",
      "int\tuserauth_passwd(Authctxt *);",
      "int\tuserauth_kbdint(Authctxt *);",
      "int\tuserauth_hostbased(Authctxt *);",
      "void\tuserauth(Authctxt *, char *);",
      "static void pubkey_prepare(Authctxt *);",
      "static void pubkey_cleanup(Authctxt *);",
      "static void pubkey_reset(Authctxt *);",
      "static Authmethod *authmethod_lookup(const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_cstring",
          "args": [
            "ssh",
            "authctxt->method->name"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2459-2463",
          "snippet": "int\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_REQUEST"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic Authmethod *authmethod_lookup(const char *name);\n\nint\nuserauth_none(Authctxt *authctxt)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tint r;\n\n\t/* initial userauth request */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\treturn 1;\n}"
  },
  {
    "function_name": "input_gssapi_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "919-937",
    "snippet": "int\ninput_gssapi_error(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tchar *msg = NULL;\n\tchar *lang = NULL;\n\tint r;\n\n\tif ((r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* maj */\n\t    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* min */\n\t    (r = sshpkt_get_cstring(ssh, &msg, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &lang, NULL)) != 0)\n\t\tgoto out;\n\tr = sshpkt_get_end(ssh);\n\tdebug(\"Server GSSAPI Error:\\n%s\", msg);\n out:\n\tfree(msg);\n\tfree(lang);\n\treturn r;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "lang"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Server GSSAPI Error:\\n%s\"",
            "msg"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_end",
          "args": [
            "ssh"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2555-2561",
          "snippet": "int\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_cstring",
          "args": [
            "ssh",
            "&lang",
            "NULL"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2532-2536",
          "snippet": "int\nsshpkt_get_cstring(struct ssh *ssh, char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_cstring(ssh->state->incoming_packet, valp, lenp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_cstring(struct ssh *ssh, char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_cstring(ssh->state->incoming_packet, valp, lenp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_u32",
          "args": [
            "ssh",
            "NULL"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2502-2506",
          "snippet": "int\nsshpkt_get_u32(struct ssh *ssh, u_int32_t *valp)\n{\n\treturn sshbuf_get_u32(ssh->state->incoming_packet, valp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_u32(struct ssh *ssh, u_int32_t *valp)\n{\n\treturn sshbuf_get_u32(ssh->state->incoming_packet, valp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\n\nint\ninput_gssapi_error(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tchar *msg = NULL;\n\tchar *lang = NULL;\n\tint r;\n\n\tif ((r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* maj */\n\t    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* min */\n\t    (r = sshpkt_get_cstring(ssh, &msg, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &lang, NULL)) != 0)\n\t\tgoto out;\n\tr = sshpkt_get_end(ssh);\n\tdebug(\"Server GSSAPI Error:\\n%s\", msg);\n out:\n\tfree(msg);\n\tfree(lang);\n\treturn r;\n}"
  },
  {
    "function_name": "input_gssapi_errtok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "884-916",
    "snippet": "int\ninput_gssapi_errtok(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt;\n\tgss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc recv_tok;\n\tOM_uint32 ms;\n\tu_char *p = NULL;\n\tsize_t len;\n\tint r;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_gssapi_response: no authentication context\");\n\tgssctxt = authctxt->methoddata;\n\n\tif ((r = sshpkt_get_string(ssh, &p, &len)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\tfree(p);\n\t\treturn r;\n\t}\n\n\t/* Stick it into GSSAPI and see what it says */\n\trecv_tok.value = p;\n\trecv_tok.length = len;\n\t(void)ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,\n\t    &recv_tok, &send_tok, NULL);\n\tfree(p);\n\tgss_release_buffer(&ms, &send_tok);\n\n\t/* Server will be returning a failed packet after this one */\n\treturn 0;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
      "int\tuserauth_none(Authctxt *);",
      "int\tuserauth_pubkey(Authctxt *);",
      "int\tuserauth_passwd(Authctxt *);",
      "int\tuserauth_kbdint(Authctxt *);",
      "int\tuserauth_hostbased(Authctxt *);",
      "void\tuserauth(Authctxt *, char *);",
      "static void pubkey_prepare(Authctxt *);",
      "static void pubkey_cleanup(Authctxt *);",
      "static void pubkey_reset(Authctxt *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gss_release_buffer",
          "args": [
            "&ms",
            "&send_tok"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "p"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_init_ctx",
          "args": [
            "gssctxt",
            "options.gss_deleg_creds",
            "&recv_tok",
            "&send_tok",
            "NULL"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_init_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-genr.c",
          "lines": "209-229",
          "snippet": "OM_uint32\nssh_gssapi_init_ctx(Gssctxt *ctx, int deleg_creds, gss_buffer_desc *recv_tok,\n    gss_buffer_desc* send_tok, OM_uint32 *flags)\n{\n\tint deleg_flag = 0;\n\n\tif (deleg_creds) {\n\t\tdeleg_flag = GSS_C_DELEG_FLAG;\n\t\tdebug(\"Delegating credentials\");\n\t}\n\n\tctx->major = gss_init_sec_context(&ctx->minor,\n\t    GSS_C_NO_CREDENTIAL, &ctx->context, ctx->name, ctx->oid,\n\t    GSS_C_MUTUAL_FLAG | GSS_C_INTEG_FLAG | deleg_flag,\n\t    0, NULL, recv_tok, NULL, send_tok, flags, NULL);\n\n\tif (GSS_ERROR(ctx->major))\n\t\tssh_gssapi_error(ctx);\n\n\treturn (ctx->major);\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"ssh2.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"ssh2.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOM_uint32\nssh_gssapi_init_ctx(Gssctxt *ctx, int deleg_creds, gss_buffer_desc *recv_tok,\n    gss_buffer_desc* send_tok, OM_uint32 *flags)\n{\n\tint deleg_flag = 0;\n\n\tif (deleg_creds) {\n\t\tdeleg_flag = GSS_C_DELEG_FLAG;\n\t\tdebug(\"Delegating credentials\");\n\t}\n\n\tctx->major = gss_init_sec_context(&ctx->minor,\n\t    GSS_C_NO_CREDENTIAL, &ctx->context, ctx->name, ctx->oid,\n\t    GSS_C_MUTUAL_FLAG | GSS_C_INTEG_FLAG | deleg_flag,\n\t    0, NULL, recv_tok, NULL, send_tok, flags, NULL);\n\n\tif (GSS_ERROR(ctx->major))\n\t\tssh_gssapi_error(ctx);\n\n\treturn (ctx->major);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_end",
          "args": [
            "ssh"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2555-2561",
          "snippet": "int\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_string",
          "args": [
            "ssh",
            "&p",
            "&len"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2520-2524",
          "snippet": "int\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"input_gssapi_response: no authentication context\""
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\n\nint\ninput_gssapi_errtok(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt;\n\tgss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc recv_tok;\n\tOM_uint32 ms;\n\tu_char *p = NULL;\n\tsize_t len;\n\tint r;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_gssapi_response: no authentication context\");\n\tgssctxt = authctxt->methoddata;\n\n\tif ((r = sshpkt_get_string(ssh, &p, &len)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\tfree(p);\n\t\treturn r;\n\t}\n\n\t/* Stick it into GSSAPI and see what it says */\n\trecv_tok.value = p;\n\trecv_tok.length = len;\n\t(void)ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,\n\t    &recv_tok, &send_tok, NULL);\n\tfree(p);\n\tgss_release_buffer(&ms, &send_tok);\n\n\t/* Server will be returning a failed packet after this one */\n\treturn 0;\n}"
  },
  {
    "function_name": "input_gssapi_token",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "851-881",
    "snippet": "int\ninput_gssapi_token(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tgss_buffer_desc recv_tok;\n\tu_char *p = NULL;\n\tsize_t len;\n\tOM_uint32 status;\n\tint r;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_gssapi_response: no authentication context\");\n\n\tif ((r = sshpkt_get_string(ssh, &p, &len)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto out;\n\n\trecv_tok.value = p;\n\trecv_tok.length = len;\n\tstatus = process_gssapi_token(ssh, &recv_tok);\n\n\t/* Start again with the next method in the list */\n\tif (GSS_ERROR(status)) {\n\t\tuserauth(authctxt, NULL);\n\t\t/* ok */\n\t}\n\tr = 0;\n out:\n\tfree(p);\n\treturn r;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
      "int\tuserauth_none(Authctxt *);",
      "int\tuserauth_pubkey(Authctxt *);",
      "int\tuserauth_passwd(Authctxt *);",
      "int\tuserauth_kbdint(Authctxt *);",
      "int\tuserauth_hostbased(Authctxt *);",
      "void\tuserauth(Authctxt *, char *);",
      "static void pubkey_prepare(Authctxt *);",
      "static void pubkey_cleanup(Authctxt *);",
      "static void pubkey_reset(Authctxt *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "p"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "userauth",
          "args": [
            "authctxt",
            "NULL"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "userauth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "458-494",
          "snippet": "void\nuserauth(Authctxt *authctxt, char *authlist)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\n\tif (authctxt->method != NULL && authctxt->method->cleanup != NULL)\n\t\tauthctxt->method->cleanup(authctxt);\n\n\tfree(authctxt->methoddata);\n\tauthctxt->methoddata = NULL;\n\tif (authlist == NULL) {\n\t\tauthlist = authctxt->authlist;\n\t} else {\n\t\tfree(authctxt->authlist);\n\t\tauthctxt->authlist = authlist;\n\t}\n\tfor (;;) {\n\t\tAuthmethod *method = authmethod_get(authlist);\n\t\tif (method == NULL)\n\t\t\tfatal(\"%s@%s: Permission denied (%s).\",\n\t\t\t    authctxt->server_user, authctxt->host, authlist);\n\t\tauthctxt->method = method;\n\n\t\t/* reset the per method handler */\n\t\tssh_dispatch_range(ssh, SSH2_MSG_USERAUTH_PER_METHOD_MIN,\n\t\t    SSH2_MSG_USERAUTH_PER_METHOD_MAX, NULL);\n\n\t\t/* and try new method */\n\t\tif (method->userauth(authctxt) != 0) {\n\t\t\tdebug2(\"we sent a %s packet, wait for reply\", method->name);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tdebug2(\"we did not send a packet, disable method\");\n\t\t\tmethod->enabled = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
            "int\tuserauth_none(Authctxt *);",
            "int\tuserauth_pubkey(Authctxt *);",
            "int\tuserauth_passwd(Authctxt *);",
            "int\tuserauth_kbdint(Authctxt *);",
            "int\tuserauth_hostbased(Authctxt *);",
            "void\tuserauth(Authctxt *, char *);",
            "static void pubkey_prepare(Authctxt *);",
            "static void pubkey_cleanup(Authctxt *);",
            "static void pubkey_reset(Authctxt *);",
            "static Authmethod *authmethod_get(char *authlist);",
            "static Authmethod *authmethod_lookup(const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic Authmethod *authmethod_get(char *authlist);\nstatic Authmethod *authmethod_lookup(const char *name);\n\nvoid\nuserauth(Authctxt *authctxt, char *authlist)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\n\tif (authctxt->method != NULL && authctxt->method->cleanup != NULL)\n\t\tauthctxt->method->cleanup(authctxt);\n\n\tfree(authctxt->methoddata);\n\tauthctxt->methoddata = NULL;\n\tif (authlist == NULL) {\n\t\tauthlist = authctxt->authlist;\n\t} else {\n\t\tfree(authctxt->authlist);\n\t\tauthctxt->authlist = authlist;\n\t}\n\tfor (;;) {\n\t\tAuthmethod *method = authmethod_get(authlist);\n\t\tif (method == NULL)\n\t\t\tfatal(\"%s@%s: Permission denied (%s).\",\n\t\t\t    authctxt->server_user, authctxt->host, authlist);\n\t\tauthctxt->method = method;\n\n\t\t/* reset the per method handler */\n\t\tssh_dispatch_range(ssh, SSH2_MSG_USERAUTH_PER_METHOD_MIN,\n\t\t    SSH2_MSG_USERAUTH_PER_METHOD_MAX, NULL);\n\n\t\t/* and try new method */\n\t\tif (method->userauth(authctxt) != 0) {\n\t\t\tdebug2(\"we sent a %s packet, wait for reply\", method->name);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tdebug2(\"we did not send a packet, disable method\");\n\t\t\tmethod->enabled = NULL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GSS_ERROR",
          "args": [
            "status"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_gssapi_token",
          "args": [
            "ssh",
            "&recv_tok"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "process_gssapi_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "739-803",
          "snippet": "static OM_uint32\nprocess_gssapi_token(struct ssh *ssh, gss_buffer_t recv_tok)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt = authctxt->methoddata;\n\tgss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc mic = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc gssbuf;\n\tOM_uint32 status, ms, flags;\n\tint r;\n\n\tstatus = ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,\n\t    recv_tok, &send_tok, &flags);\n\n\tif (send_tok.length > 0) {\n\t\tu_char type = GSS_ERROR(status) ?\n\t\t    SSH2_MSG_USERAUTH_GSSAPI_ERRTOK :\n\t\t    SSH2_MSG_USERAUTH_GSSAPI_TOKEN;\n\n\t\tif ((r = sshpkt_start(ssh, type)) != 0 ||\n\t\t    (r = sshpkt_put_string(ssh, send_tok.value,\n\t\t    send_tok.length)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\t\tgss_release_buffer(&ms, &send_tok);\n\t}\n\n\tif (status == GSS_S_COMPLETE) {\n\t\t/* send either complete or MIC, depending on mechanism */\n\t\tif (!(flags & GSS_C_INTEG_FLAG)) {\n\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\t} else {\n\t\t\tstruct sshbuf *b;\n\n\t\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tssh_gssapi_buildmic(b, authctxt->server_user,\n\t\t\t    authctxt->service, \"gssapi-with-mic\");\n\n\t\t\tif ((gssbuf.value = sshbuf_mutable_ptr(b)) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_mutable_ptr failed\", __func__);\n\t\t\tgssbuf.length = sshbuf_len(b);\n\n\t\t\tstatus = ssh_gssapi_sign(gssctxt, &gssbuf, &mic);\n\n\t\t\tif (!GSS_ERROR(status)) {\n\t\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_MIC)) != 0 ||\n\t\t\t\t    (r = sshpkt_put_string(ssh, mic.value,\n\t\t\t\t    mic.length)) != 0 ||\n\t\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\t\t}\n\n\t\t\tsshbuf_free(b);\n\t\t\tgss_release_buffer(&ms, &mic);\n\t\t}\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
            "int\tuserauth_none(Authctxt *);",
            "int\tuserauth_pubkey(Authctxt *);",
            "int\tuserauth_passwd(Authctxt *);",
            "int\tuserauth_kbdint(Authctxt *);",
            "int\tuserauth_hostbased(Authctxt *);",
            "void\tuserauth(Authctxt *, char *);",
            "static void pubkey_prepare(Authctxt *);",
            "static void pubkey_cleanup(Authctxt *);",
            "static void pubkey_reset(Authctxt *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\n\nstatic OM_uint32\nprocess_gssapi_token(struct ssh *ssh, gss_buffer_t recv_tok)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt = authctxt->methoddata;\n\tgss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc mic = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc gssbuf;\n\tOM_uint32 status, ms, flags;\n\tint r;\n\n\tstatus = ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,\n\t    recv_tok, &send_tok, &flags);\n\n\tif (send_tok.length > 0) {\n\t\tu_char type = GSS_ERROR(status) ?\n\t\t    SSH2_MSG_USERAUTH_GSSAPI_ERRTOK :\n\t\t    SSH2_MSG_USERAUTH_GSSAPI_TOKEN;\n\n\t\tif ((r = sshpkt_start(ssh, type)) != 0 ||\n\t\t    (r = sshpkt_put_string(ssh, send_tok.value,\n\t\t    send_tok.length)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\t\tgss_release_buffer(&ms, &send_tok);\n\t}\n\n\tif (status == GSS_S_COMPLETE) {\n\t\t/* send either complete or MIC, depending on mechanism */\n\t\tif (!(flags & GSS_C_INTEG_FLAG)) {\n\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\t} else {\n\t\t\tstruct sshbuf *b;\n\n\t\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tssh_gssapi_buildmic(b, authctxt->server_user,\n\t\t\t    authctxt->service, \"gssapi-with-mic\");\n\n\t\t\tif ((gssbuf.value = sshbuf_mutable_ptr(b)) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_mutable_ptr failed\", __func__);\n\t\t\tgssbuf.length = sshbuf_len(b);\n\n\t\t\tstatus = ssh_gssapi_sign(gssctxt, &gssbuf, &mic);\n\n\t\t\tif (!GSS_ERROR(status)) {\n\t\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_MIC)) != 0 ||\n\t\t\t\t    (r = sshpkt_put_string(ssh, mic.value,\n\t\t\t\t    mic.length)) != 0 ||\n\t\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\t\t}\n\n\t\t\tsshbuf_free(b);\n\t\t\tgss_release_buffer(&ms, &mic);\n\t\t}\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_end",
          "args": [
            "ssh"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2555-2561",
          "snippet": "int\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_string",
          "args": [
            "ssh",
            "&p",
            "&len"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2520-2524",
          "snippet": "int\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"input_gssapi_response: no authentication context\""
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\n\nint\ninput_gssapi_token(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tgss_buffer_desc recv_tok;\n\tu_char *p = NULL;\n\tsize_t len;\n\tOM_uint32 status;\n\tint r;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_gssapi_response: no authentication context\");\n\n\tif ((r = sshpkt_get_string(ssh, &p, &len)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto out;\n\n\trecv_tok.value = p;\n\trecv_tok.length = len;\n\tstatus = process_gssapi_token(ssh, &recv_tok);\n\n\t/* Start again with the next method in the list */\n\tif (GSS_ERROR(status)) {\n\t\tuserauth(authctxt, NULL);\n\t\t/* ok */\n\t}\n\tr = 0;\n out:\n\tfree(p);\n\treturn r;\n}"
  },
  {
    "function_name": "input_gssapi_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "806-848",
    "snippet": "int\ninput_gssapi_response(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt;\n\tsize_t oidlen;\n\tu_char *oidv = NULL;\n\tint r;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_gssapi_response: no authentication context\");\n\tgssctxt = authctxt->methoddata;\n\n\t/* Setup our OID */\n\tif ((r = sshpkt_get_string(ssh, &oidv, &oidlen)) != 0)\n\t\tgoto done;\n\n\tif (oidlen <= 2 ||\n\t    oidv[0] != SSH_GSS_OIDTYPE ||\n\t    oidv[1] != oidlen - 2) {\n\t\tdebug(\"Badly encoded mechanism OID received\");\n\t\tuserauth(authctxt, NULL);\n\t\tgoto ok;\n\t}\n\n\tif (!ssh_gssapi_check_oid(gssctxt, oidv + 2, oidlen - 2))\n\t\tfatal(\"Server returned different OID than expected\");\n\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto done;\n\n\tif (GSS_ERROR(process_gssapi_token(ssh, GSS_C_NO_BUFFER))) {\n\t\t/* Start again with next method on list */\n\t\tdebug(\"Trying to start again\");\n\t\tuserauth(authctxt, NULL);\n\t\tgoto ok;\n\t}\n ok:\n\tr = 0;\n done:\n\tfree(oidv);\n\treturn r;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
      "int\tuserauth_none(Authctxt *);",
      "int\tuserauth_pubkey(Authctxt *);",
      "int\tuserauth_passwd(Authctxt *);",
      "int\tuserauth_kbdint(Authctxt *);",
      "int\tuserauth_hostbased(Authctxt *);",
      "void\tuserauth(Authctxt *, char *);",
      "static void pubkey_prepare(Authctxt *);",
      "static void pubkey_cleanup(Authctxt *);",
      "static void pubkey_reset(Authctxt *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "oidv"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "userauth",
          "args": [
            "authctxt",
            "NULL"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "userauth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "458-494",
          "snippet": "void\nuserauth(Authctxt *authctxt, char *authlist)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\n\tif (authctxt->method != NULL && authctxt->method->cleanup != NULL)\n\t\tauthctxt->method->cleanup(authctxt);\n\n\tfree(authctxt->methoddata);\n\tauthctxt->methoddata = NULL;\n\tif (authlist == NULL) {\n\t\tauthlist = authctxt->authlist;\n\t} else {\n\t\tfree(authctxt->authlist);\n\t\tauthctxt->authlist = authlist;\n\t}\n\tfor (;;) {\n\t\tAuthmethod *method = authmethod_get(authlist);\n\t\tif (method == NULL)\n\t\t\tfatal(\"%s@%s: Permission denied (%s).\",\n\t\t\t    authctxt->server_user, authctxt->host, authlist);\n\t\tauthctxt->method = method;\n\n\t\t/* reset the per method handler */\n\t\tssh_dispatch_range(ssh, SSH2_MSG_USERAUTH_PER_METHOD_MIN,\n\t\t    SSH2_MSG_USERAUTH_PER_METHOD_MAX, NULL);\n\n\t\t/* and try new method */\n\t\tif (method->userauth(authctxt) != 0) {\n\t\t\tdebug2(\"we sent a %s packet, wait for reply\", method->name);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tdebug2(\"we did not send a packet, disable method\");\n\t\t\tmethod->enabled = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
            "int\tuserauth_none(Authctxt *);",
            "int\tuserauth_pubkey(Authctxt *);",
            "int\tuserauth_passwd(Authctxt *);",
            "int\tuserauth_kbdint(Authctxt *);",
            "int\tuserauth_hostbased(Authctxt *);",
            "void\tuserauth(Authctxt *, char *);",
            "static void pubkey_prepare(Authctxt *);",
            "static void pubkey_cleanup(Authctxt *);",
            "static void pubkey_reset(Authctxt *);",
            "static Authmethod *authmethod_get(char *authlist);",
            "static Authmethod *authmethod_lookup(const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic Authmethod *authmethod_get(char *authlist);\nstatic Authmethod *authmethod_lookup(const char *name);\n\nvoid\nuserauth(Authctxt *authctxt, char *authlist)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\n\tif (authctxt->method != NULL && authctxt->method->cleanup != NULL)\n\t\tauthctxt->method->cleanup(authctxt);\n\n\tfree(authctxt->methoddata);\n\tauthctxt->methoddata = NULL;\n\tif (authlist == NULL) {\n\t\tauthlist = authctxt->authlist;\n\t} else {\n\t\tfree(authctxt->authlist);\n\t\tauthctxt->authlist = authlist;\n\t}\n\tfor (;;) {\n\t\tAuthmethod *method = authmethod_get(authlist);\n\t\tif (method == NULL)\n\t\t\tfatal(\"%s@%s: Permission denied (%s).\",\n\t\t\t    authctxt->server_user, authctxt->host, authlist);\n\t\tauthctxt->method = method;\n\n\t\t/* reset the per method handler */\n\t\tssh_dispatch_range(ssh, SSH2_MSG_USERAUTH_PER_METHOD_MIN,\n\t\t    SSH2_MSG_USERAUTH_PER_METHOD_MAX, NULL);\n\n\t\t/* and try new method */\n\t\tif (method->userauth(authctxt) != 0) {\n\t\t\tdebug2(\"we sent a %s packet, wait for reply\", method->name);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tdebug2(\"we did not send a packet, disable method\");\n\t\t\tmethod->enabled = NULL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Trying to start again\""
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GSS_ERROR",
          "args": [
            "process_gssapi_token(ssh, GSS_C_NO_BUFFER)"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_gssapi_token",
          "args": [
            "ssh",
            "GSS_C_NO_BUFFER"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "process_gssapi_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "739-803",
          "snippet": "static OM_uint32\nprocess_gssapi_token(struct ssh *ssh, gss_buffer_t recv_tok)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt = authctxt->methoddata;\n\tgss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc mic = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc gssbuf;\n\tOM_uint32 status, ms, flags;\n\tint r;\n\n\tstatus = ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,\n\t    recv_tok, &send_tok, &flags);\n\n\tif (send_tok.length > 0) {\n\t\tu_char type = GSS_ERROR(status) ?\n\t\t    SSH2_MSG_USERAUTH_GSSAPI_ERRTOK :\n\t\t    SSH2_MSG_USERAUTH_GSSAPI_TOKEN;\n\n\t\tif ((r = sshpkt_start(ssh, type)) != 0 ||\n\t\t    (r = sshpkt_put_string(ssh, send_tok.value,\n\t\t    send_tok.length)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\t\tgss_release_buffer(&ms, &send_tok);\n\t}\n\n\tif (status == GSS_S_COMPLETE) {\n\t\t/* send either complete or MIC, depending on mechanism */\n\t\tif (!(flags & GSS_C_INTEG_FLAG)) {\n\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\t} else {\n\t\t\tstruct sshbuf *b;\n\n\t\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tssh_gssapi_buildmic(b, authctxt->server_user,\n\t\t\t    authctxt->service, \"gssapi-with-mic\");\n\n\t\t\tif ((gssbuf.value = sshbuf_mutable_ptr(b)) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_mutable_ptr failed\", __func__);\n\t\t\tgssbuf.length = sshbuf_len(b);\n\n\t\t\tstatus = ssh_gssapi_sign(gssctxt, &gssbuf, &mic);\n\n\t\t\tif (!GSS_ERROR(status)) {\n\t\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_MIC)) != 0 ||\n\t\t\t\t    (r = sshpkt_put_string(ssh, mic.value,\n\t\t\t\t    mic.length)) != 0 ||\n\t\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\t\t}\n\n\t\t\tsshbuf_free(b);\n\t\t\tgss_release_buffer(&ms, &mic);\n\t\t}\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
            "int\tuserauth_none(Authctxt *);",
            "int\tuserauth_pubkey(Authctxt *);",
            "int\tuserauth_passwd(Authctxt *);",
            "int\tuserauth_kbdint(Authctxt *);",
            "int\tuserauth_hostbased(Authctxt *);",
            "void\tuserauth(Authctxt *, char *);",
            "static void pubkey_prepare(Authctxt *);",
            "static void pubkey_cleanup(Authctxt *);",
            "static void pubkey_reset(Authctxt *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\n\nstatic OM_uint32\nprocess_gssapi_token(struct ssh *ssh, gss_buffer_t recv_tok)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt = authctxt->methoddata;\n\tgss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc mic = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc gssbuf;\n\tOM_uint32 status, ms, flags;\n\tint r;\n\n\tstatus = ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,\n\t    recv_tok, &send_tok, &flags);\n\n\tif (send_tok.length > 0) {\n\t\tu_char type = GSS_ERROR(status) ?\n\t\t    SSH2_MSG_USERAUTH_GSSAPI_ERRTOK :\n\t\t    SSH2_MSG_USERAUTH_GSSAPI_TOKEN;\n\n\t\tif ((r = sshpkt_start(ssh, type)) != 0 ||\n\t\t    (r = sshpkt_put_string(ssh, send_tok.value,\n\t\t    send_tok.length)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\t\tgss_release_buffer(&ms, &send_tok);\n\t}\n\n\tif (status == GSS_S_COMPLETE) {\n\t\t/* send either complete or MIC, depending on mechanism */\n\t\tif (!(flags & GSS_C_INTEG_FLAG)) {\n\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\t} else {\n\t\t\tstruct sshbuf *b;\n\n\t\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tssh_gssapi_buildmic(b, authctxt->server_user,\n\t\t\t    authctxt->service, \"gssapi-with-mic\");\n\n\t\t\tif ((gssbuf.value = sshbuf_mutable_ptr(b)) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_mutable_ptr failed\", __func__);\n\t\t\tgssbuf.length = sshbuf_len(b);\n\n\t\t\tstatus = ssh_gssapi_sign(gssctxt, &gssbuf, &mic);\n\n\t\t\tif (!GSS_ERROR(status)) {\n\t\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_MIC)) != 0 ||\n\t\t\t\t    (r = sshpkt_put_string(ssh, mic.value,\n\t\t\t\t    mic.length)) != 0 ||\n\t\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\t\t}\n\n\t\t\tsshbuf_free(b);\n\t\t\tgss_release_buffer(&ms, &mic);\n\t\t}\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_end",
          "args": [
            "ssh"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2555-2561",
          "snippet": "int\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Server returned different OID than expected\""
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_check_oid",
          "args": [
            "gssctxt",
            "oidv + 2",
            "oidlen - 2"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_check_oid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-genr.c",
          "lines": "66-72",
          "snippet": "int\nssh_gssapi_check_oid(Gssctxt *ctx, void *data, size_t len)\n{\n\treturn (ctx != NULL && ctx->oid != GSS_C_NO_OID &&\n\t    ctx->oid->length == len &&\n\t    memcmp(ctx->oid->elements, data, len) == 0);\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"ssh2.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"ssh2.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_gssapi_check_oid(Gssctxt *ctx, void *data, size_t len)\n{\n\treturn (ctx != NULL && ctx->oid != GSS_C_NO_OID &&\n\t    ctx->oid->length == len &&\n\t    memcmp(ctx->oid->elements, data, len) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_string",
          "args": [
            "ssh",
            "&oidv",
            "&oidlen"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2520-2524",
          "snippet": "int\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\n\nint\ninput_gssapi_response(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt;\n\tsize_t oidlen;\n\tu_char *oidv = NULL;\n\tint r;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_gssapi_response: no authentication context\");\n\tgssctxt = authctxt->methoddata;\n\n\t/* Setup our OID */\n\tif ((r = sshpkt_get_string(ssh, &oidv, &oidlen)) != 0)\n\t\tgoto done;\n\n\tif (oidlen <= 2 ||\n\t    oidv[0] != SSH_GSS_OIDTYPE ||\n\t    oidv[1] != oidlen - 2) {\n\t\tdebug(\"Badly encoded mechanism OID received\");\n\t\tuserauth(authctxt, NULL);\n\t\tgoto ok;\n\t}\n\n\tif (!ssh_gssapi_check_oid(gssctxt, oidv + 2, oidlen - 2))\n\t\tfatal(\"Server returned different OID than expected\");\n\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto done;\n\n\tif (GSS_ERROR(process_gssapi_token(ssh, GSS_C_NO_BUFFER))) {\n\t\t/* Start again with next method on list */\n\t\tdebug(\"Trying to start again\");\n\t\tuserauth(authctxt, NULL);\n\t\tgoto ok;\n\t}\n ok:\n\tr = 0;\n done:\n\tfree(oidv);\n\treturn r;\n}"
  },
  {
    "function_name": "process_gssapi_token",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "739-803",
    "snippet": "static OM_uint32\nprocess_gssapi_token(struct ssh *ssh, gss_buffer_t recv_tok)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt = authctxt->methoddata;\n\tgss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc mic = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc gssbuf;\n\tOM_uint32 status, ms, flags;\n\tint r;\n\n\tstatus = ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,\n\t    recv_tok, &send_tok, &flags);\n\n\tif (send_tok.length > 0) {\n\t\tu_char type = GSS_ERROR(status) ?\n\t\t    SSH2_MSG_USERAUTH_GSSAPI_ERRTOK :\n\t\t    SSH2_MSG_USERAUTH_GSSAPI_TOKEN;\n\n\t\tif ((r = sshpkt_start(ssh, type)) != 0 ||\n\t\t    (r = sshpkt_put_string(ssh, send_tok.value,\n\t\t    send_tok.length)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\t\tgss_release_buffer(&ms, &send_tok);\n\t}\n\n\tif (status == GSS_S_COMPLETE) {\n\t\t/* send either complete or MIC, depending on mechanism */\n\t\tif (!(flags & GSS_C_INTEG_FLAG)) {\n\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\t} else {\n\t\t\tstruct sshbuf *b;\n\n\t\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tssh_gssapi_buildmic(b, authctxt->server_user,\n\t\t\t    authctxt->service, \"gssapi-with-mic\");\n\n\t\t\tif ((gssbuf.value = sshbuf_mutable_ptr(b)) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_mutable_ptr failed\", __func__);\n\t\t\tgssbuf.length = sshbuf_len(b);\n\n\t\t\tstatus = ssh_gssapi_sign(gssctxt, &gssbuf, &mic);\n\n\t\t\tif (!GSS_ERROR(status)) {\n\t\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_MIC)) != 0 ||\n\t\t\t\t    (r = sshpkt_put_string(ssh, mic.value,\n\t\t\t\t    mic.length)) != 0 ||\n\t\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\t\t}\n\n\t\t\tsshbuf_free(b);\n\t\t\tgss_release_buffer(&ms, &mic);\n\t\t}\n\t}\n\n\treturn status;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
      "int\tuserauth_none(Authctxt *);",
      "int\tuserauth_pubkey(Authctxt *);",
      "int\tuserauth_passwd(Authctxt *);",
      "int\tuserauth_kbdint(Authctxt *);",
      "int\tuserauth_hostbased(Authctxt *);",
      "void\tuserauth(Authctxt *, char *);",
      "static void pubkey_prepare(Authctxt *);",
      "static void pubkey_cleanup(Authctxt *);",
      "static void pubkey_reset(Authctxt *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gss_release_buffer",
          "args": [
            "&ms",
            "&mic"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_string",
          "args": [
            "ssh",
            "mic.value",
            "mic.length"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2453-2457",
          "snippet": "int\nsshpkt_put_string(struct ssh *ssh, const void *v, size_t len)\n{\n\treturn sshbuf_put_string(ssh->state->outgoing_packet, v, len);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_string(struct ssh *ssh, const void *v, size_t len)\n{\n\treturn sshbuf_put_string(ssh->state->outgoing_packet, v, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_GSSAPI_MIC"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GSS_ERROR",
          "args": [
            "status"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_sign",
          "args": [
            "gssctxt",
            "&gssbuf",
            "&mic"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-genr.c",
          "lines": "250-258",
          "snippet": "OM_uint32\nssh_gssapi_sign(Gssctxt *ctx, gss_buffer_t buffer, gss_buffer_t hash)\n{\n\tif ((ctx->major = gss_get_mic(&ctx->minor, ctx->context,\n\t    GSS_C_QOP_DEFAULT, buffer, hash)))\n\t\tssh_gssapi_error(ctx);\n\n\treturn (ctx->major);\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"ssh2.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"ssh2.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOM_uint32\nssh_gssapi_sign(Gssctxt *ctx, gss_buffer_t buffer, gss_buffer_t hash)\n{\n\tif ((ctx->major = gss_get_mic(&ctx->minor, ctx->context,\n\t    GSS_C_QOP_DEFAULT, buffer, hash)))\n\t\tssh_gssapi_error(ctx);\n\n\treturn (ctx->major);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "b"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_mutable_ptr failed\"",
            "__func__"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_mutable_ptr",
          "args": [
            "b"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_mutable_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "276-282",
          "snippet": "u_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_buildmic",
          "args": [
            "b",
            "authctxt->server_user",
            "authctxt->service",
            "\"gssapi-with-mic\""
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_buildmic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-genr.c",
          "lines": "260-273",
          "snippet": "void\nssh_gssapi_buildmic(struct sshbuf *b, const char *user, const char *service,\n    const char *context)\n{\n\tint r;\n\n\tsshbuf_reset(b);\n\tif ((r = sshbuf_put_string(b, session_id2, session_id2_len)) != 0 ||\n\t    (r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, user)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, service)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, context)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"ssh2.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"ssh2.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_gssapi_buildmic(struct sshbuf *b, const char *user, const char *service,\n    const char *context)\n{\n\tint r;\n\n\tsshbuf_reset(b);\n\tif ((r = sshbuf_put_string(b, session_id2, session_id2_len)) != 0 ||\n\t    (r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, user)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, service)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, context)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gss_release_buffer",
          "args": [
            "&ms",
            "&send_tok"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GSS_ERROR",
          "args": [
            "status"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_init_ctx",
          "args": [
            "gssctxt",
            "options.gss_deleg_creds",
            "recv_tok",
            "&send_tok",
            "&flags"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_init_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-genr.c",
          "lines": "209-229",
          "snippet": "OM_uint32\nssh_gssapi_init_ctx(Gssctxt *ctx, int deleg_creds, gss_buffer_desc *recv_tok,\n    gss_buffer_desc* send_tok, OM_uint32 *flags)\n{\n\tint deleg_flag = 0;\n\n\tif (deleg_creds) {\n\t\tdeleg_flag = GSS_C_DELEG_FLAG;\n\t\tdebug(\"Delegating credentials\");\n\t}\n\n\tctx->major = gss_init_sec_context(&ctx->minor,\n\t    GSS_C_NO_CREDENTIAL, &ctx->context, ctx->name, ctx->oid,\n\t    GSS_C_MUTUAL_FLAG | GSS_C_INTEG_FLAG | deleg_flag,\n\t    0, NULL, recv_tok, NULL, send_tok, flags, NULL);\n\n\tif (GSS_ERROR(ctx->major))\n\t\tssh_gssapi_error(ctx);\n\n\treturn (ctx->major);\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"ssh2.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"ssh2.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nOM_uint32\nssh_gssapi_init_ctx(Gssctxt *ctx, int deleg_creds, gss_buffer_desc *recv_tok,\n    gss_buffer_desc* send_tok, OM_uint32 *flags)\n{\n\tint deleg_flag = 0;\n\n\tif (deleg_creds) {\n\t\tdeleg_flag = GSS_C_DELEG_FLAG;\n\t\tdebug(\"Delegating credentials\");\n\t}\n\n\tctx->major = gss_init_sec_context(&ctx->minor,\n\t    GSS_C_NO_CREDENTIAL, &ctx->context, ctx->name, ctx->oid,\n\t    GSS_C_MUTUAL_FLAG | GSS_C_INTEG_FLAG | deleg_flag,\n\t    0, NULL, recv_tok, NULL, send_tok, flags, NULL);\n\n\tif (GSS_ERROR(ctx->major))\n\t\tssh_gssapi_error(ctx);\n\n\treturn (ctx->major);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\n\nstatic OM_uint32\nprocess_gssapi_token(struct ssh *ssh, gss_buffer_t recv_tok)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt = authctxt->methoddata;\n\tgss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc mic = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc gssbuf;\n\tOM_uint32 status, ms, flags;\n\tint r;\n\n\tstatus = ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,\n\t    recv_tok, &send_tok, &flags);\n\n\tif (send_tok.length > 0) {\n\t\tu_char type = GSS_ERROR(status) ?\n\t\t    SSH2_MSG_USERAUTH_GSSAPI_ERRTOK :\n\t\t    SSH2_MSG_USERAUTH_GSSAPI_TOKEN;\n\n\t\tif ((r = sshpkt_start(ssh, type)) != 0 ||\n\t\t    (r = sshpkt_put_string(ssh, send_tok.value,\n\t\t    send_tok.length)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\t\tgss_release_buffer(&ms, &send_tok);\n\t}\n\n\tif (status == GSS_S_COMPLETE) {\n\t\t/* send either complete or MIC, depending on mechanism */\n\t\tif (!(flags & GSS_C_INTEG_FLAG)) {\n\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\t} else {\n\t\t\tstruct sshbuf *b;\n\n\t\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tssh_gssapi_buildmic(b, authctxt->server_user,\n\t\t\t    authctxt->service, \"gssapi-with-mic\");\n\n\t\t\tif ((gssbuf.value = sshbuf_mutable_ptr(b)) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_mutable_ptr failed\", __func__);\n\t\t\tgssbuf.length = sshbuf_len(b);\n\n\t\t\tstatus = ssh_gssapi_sign(gssctxt, &gssbuf, &mic);\n\n\t\t\tif (!GSS_ERROR(status)) {\n\t\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_MIC)) != 0 ||\n\t\t\t\t    (r = sshpkt_put_string(ssh, mic.value,\n\t\t\t\t    mic.length)) != 0 ||\n\t\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\t\t}\n\n\t\t\tsshbuf_free(b);\n\t\t\tgss_release_buffer(&ms, &mic);\n\t\t}\n\t}\n\n\treturn status;\n}"
  },
  {
    "function_name": "userauth_gssapi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "680-737",
    "snippet": "int\nuserauth_gssapi(Authctxt *authctxt)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tGssctxt *gssctxt = NULL;\n\tstatic gss_OID_set gss_supported = NULL;\n\tstatic u_int mech = 0;\n\tOM_uint32 min;\n\tint r, ok = 0;\n\n\t/* Try one GSSAPI method at a time, rather than sending them all at\n\t * once. */\n\n\tif (gss_supported == NULL)\n\t\tgss_indicate_mechs(&min, &gss_supported);\n\n\t/* Check to see if the mechanism is usable before we offer it */\n\twhile (mech < gss_supported->count && !ok) {\n\t\t/* My DER encoding requires length<128 */\n\t\tif (gss_supported->elements[mech].length < 128 &&\n\t\t    ssh_gssapi_check_mechanism(&gssctxt,\n\t\t    &gss_supported->elements[mech], authctxt->host)) {\n\t\t\tok = 1; /* Mechanism works */\n\t\t} else {\n\t\t\tmech++;\n\t\t}\n\t}\n\n\tif (!ok)\n\t\treturn 0;\n\n\tauthctxt->methoddata=(void *)gssctxt;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, 1)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh,\n\t    (gss_supported->elements[mech].length) + 2)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, SSH_GSS_OIDTYPE)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh,\n\t    gss_supported->elements[mech].length)) != 0 ||\n\t    (r = sshpkt_put(ssh,\n\t    gss_supported->elements[mech].elements,\n\t    gss_supported->elements[mech].length)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_RESPONSE, &input_gssapi_response);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERROR, &input_gssapi_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);\n\n\tmech++; /* Move along to next candidate */\n\n\treturn 1;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
      "int\tuserauth_none(Authctxt *);",
      "int\tuserauth_pubkey(Authctxt *);",
      "int\tuserauth_passwd(Authctxt *);",
      "int\tuserauth_kbdint(Authctxt *);",
      "int\tuserauth_hostbased(Authctxt *);",
      "void\tuserauth(Authctxt *, char *);",
      "static void pubkey_prepare(Authctxt *);",
      "static void pubkey_cleanup(Authctxt *);",
      "static void pubkey_reset(Authctxt *);",
      "static Authmethod *authmethod_lookup(const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_dispatch_set",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_GSSAPI_ERRTOK",
            "&input_gssapi_errtok"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_dispatch_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dispatch.c",
          "lines": "81-85",
          "snippet": "void\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"dispatch.h\"",
            "#include \"log.h\"",
            "#include \"ssh2.h\"",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include <stdarg.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put",
          "args": [
            "ssh",
            "gss_supported->elements[mech].elements",
            "gss_supported->elements[mech].length"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_ec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2473-2477",
          "snippet": "int\nsshpkt_put_ec(struct ssh *ssh, const EC_POINT *v, const EC_GROUP *g)\n{\n\treturn sshbuf_put_ec(ssh->state->outgoing_packet, v, g);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_ec(struct ssh *ssh, const EC_POINT *v, const EC_GROUP *g)\n{\n\treturn sshbuf_put_ec(ssh->state->outgoing_packet, v, g);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u8",
          "args": [
            "ssh",
            "gss_supported->elements[mech].length"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2435-2439",
          "snippet": "int\nsshpkt_put_u8(struct ssh *ssh, u_char val)\n{\n\treturn sshbuf_put_u8(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u8(struct ssh *ssh, u_char val)\n{\n\treturn sshbuf_put_u8(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u32",
          "args": [
            "ssh",
            "(gss_supported->elements[mech].length) + 2"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2441-2445",
          "snippet": "int\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_cstring",
          "args": [
            "ssh",
            "authctxt->method->name"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2459-2463",
          "snippet": "int\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_REQUEST"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_gssapi_check_mechanism",
          "args": [
            "&gssctxt",
            "&gss_supported->elements[mech]",
            "authctxt->host"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gssapi_check_mechanism",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/gss-genr.c",
          "lines": "275-303",
          "snippet": "int\nssh_gssapi_check_mechanism(Gssctxt **ctx, gss_OID oid, const char *host)\n{\n\tgss_buffer_desc token = GSS_C_EMPTY_BUFFER;\n\tOM_uint32 major, minor;\n\tgss_OID_desc spnego_oid = {6, (void *)\"\\x2B\\x06\\x01\\x05\\x05\\x02\"};\n\n\t/* RFC 4462 says we MUST NOT do SPNEGO */\n\tif (oid->length == spnego_oid.length && \n\t    (memcmp(oid->elements, spnego_oid.elements, oid->length) == 0))\n\t\treturn 0; /* false */\n\n\tssh_gssapi_build_ctx(ctx);\n\tssh_gssapi_set_oid(*ctx, oid);\n\tmajor = ssh_gssapi_import_name(*ctx, host);\n\tif (!GSS_ERROR(major)) {\n\t\tmajor = ssh_gssapi_init_ctx(*ctx, 0, GSS_C_NO_BUFFER, &token, \n\t\t    NULL);\n\t\tgss_release_buffer(&minor, &token);\n\t\tif ((*ctx)->context != GSS_C_NO_CONTEXT)\n\t\t\tgss_delete_sec_context(&minor, &(*ctx)->context,\n\t\t\t    GSS_C_NO_BUFFER);\n\t}\n\n\tif (GSS_ERROR(major)) \n\t\tssh_gssapi_delete_ctx(ctx);\n\n\treturn (!GSS_ERROR(major));\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"ssh2.h\"",
            "#include \"log.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"ssh2.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_gssapi_check_mechanism(Gssctxt **ctx, gss_OID oid, const char *host)\n{\n\tgss_buffer_desc token = GSS_C_EMPTY_BUFFER;\n\tOM_uint32 major, minor;\n\tgss_OID_desc spnego_oid = {6, (void *)\"\\x2B\\x06\\x01\\x05\\x05\\x02\"};\n\n\t/* RFC 4462 says we MUST NOT do SPNEGO */\n\tif (oid->length == spnego_oid.length && \n\t    (memcmp(oid->elements, spnego_oid.elements, oid->length) == 0))\n\t\treturn 0; /* false */\n\n\tssh_gssapi_build_ctx(ctx);\n\tssh_gssapi_set_oid(*ctx, oid);\n\tmajor = ssh_gssapi_import_name(*ctx, host);\n\tif (!GSS_ERROR(major)) {\n\t\tmajor = ssh_gssapi_init_ctx(*ctx, 0, GSS_C_NO_BUFFER, &token, \n\t\t    NULL);\n\t\tgss_release_buffer(&minor, &token);\n\t\tif ((*ctx)->context != GSS_C_NO_CONTEXT)\n\t\t\tgss_delete_sec_context(&minor, &(*ctx)->context,\n\t\t\t    GSS_C_NO_BUFFER);\n\t}\n\n\tif (GSS_ERROR(major)) \n\t\tssh_gssapi_delete_ctx(ctx);\n\n\treturn (!GSS_ERROR(major));\n}"
        }
      },
      {
        "call_info": {
          "callee": "gss_indicate_mechs",
          "args": [
            "&min",
            "&gss_supported"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic Authmethod *authmethod_lookup(const char *name);\n\nint\nuserauth_gssapi(Authctxt *authctxt)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tGssctxt *gssctxt = NULL;\n\tstatic gss_OID_set gss_supported = NULL;\n\tstatic u_int mech = 0;\n\tOM_uint32 min;\n\tint r, ok = 0;\n\n\t/* Try one GSSAPI method at a time, rather than sending them all at\n\t * once. */\n\n\tif (gss_supported == NULL)\n\t\tgss_indicate_mechs(&min, &gss_supported);\n\n\t/* Check to see if the mechanism is usable before we offer it */\n\twhile (mech < gss_supported->count && !ok) {\n\t\t/* My DER encoding requires length<128 */\n\t\tif (gss_supported->elements[mech].length < 128 &&\n\t\t    ssh_gssapi_check_mechanism(&gssctxt,\n\t\t    &gss_supported->elements[mech], authctxt->host)) {\n\t\t\tok = 1; /* Mechanism works */\n\t\t} else {\n\t\t\tmech++;\n\t\t}\n\t}\n\n\tif (!ok)\n\t\treturn 0;\n\n\tauthctxt->methoddata=(void *)gssctxt;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, 1)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh,\n\t    (gss_supported->elements[mech].length) + 2)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, SSH_GSS_OIDTYPE)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh,\n\t    gss_supported->elements[mech].length)) != 0 ||\n\t    (r = sshpkt_put(ssh,\n\t    gss_supported->elements[mech].elements,\n\t    gss_supported->elements[mech].length)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_RESPONSE, &input_gssapi_response);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERROR, &input_gssapi_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);\n\n\tmech++; /* Move along to next candidate */\n\n\treturn 1;\n}"
  },
  {
    "function_name": "input_userauth_pk_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "609-677",
    "snippet": "int\ninput_userauth_pk_ok(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct sshkey *key = NULL;\n\tIdentity *id = NULL;\n\tint pktype, found = 0, sent = 0;\n\tsize_t blen;\n\tchar *pkalg = NULL, *fp = NULL, *ident = NULL;\n\tu_char *pkblob = NULL;\n\tint r;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_userauth_pk_ok: no authentication context\");\n\n\tif ((r = sshpkt_get_cstring(ssh, &pkalg, NULL)) != 0 ||\n\t    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto done;\n\n\tif ((pktype = sshkey_type_from_name(pkalg)) == KEY_UNSPEC) {\n\t\tdebug(\"%s: server sent unknown pkalg %s\", __func__, pkalg);\n\t\tgoto done;\n\t}\n\tif ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {\n\t\tdebug(\"no key from blob. pkalg %s: %s\", pkalg, ssh_err(r));\n\t\tgoto done;\n\t}\n\tif (key->type != pktype) {\n\t\terror(\"input_userauth_pk_ok: type mismatch \"\n\t\t    \"for decoded key (received %d, expected %d)\",\n\t\t    key->type, pktype);\n\t\tgoto done;\n\t}\n\n\t/*\n\t * search keys in the reverse order, because last candidate has been\n\t * moved to the end of the queue.  this also avoids confusion by\n\t * duplicate keys\n\t */\n\tTAILQ_FOREACH_REVERSE(id, &authctxt->keys, idlist, next) {\n\t\tif (sshkey_equal(key, id->key)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found || id == NULL) {\n\t\tfp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t\terror(\"%s: server replied with unknown key: %s %s\", __func__,\n\t\t    sshkey_type(key), fp == NULL ? \"<ERROR>\" : fp);\n\t\tgoto done;\n\t}\n\tident = format_identity(id);\n\tdebug(\"Server accepts key: %s\", ident);\n\tsent = sign_and_send_pubkey(ssh, authctxt, id);\n\tr = 0;\n done:\n\tsshkey_free(key);\n\tfree(ident);\n\tfree(fp);\n\tfree(pkalg);\n\tfree(pkblob);\n\n\t/* try another method if we did not send a packet */\n\tif (r == 0 && sent == 0)\n\t\tuserauth(authctxt, NULL);\n\treturn r;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
      "int\tuserauth_none(Authctxt *);",
      "int\tuserauth_pubkey(Authctxt *);",
      "int\tuserauth_passwd(Authctxt *);",
      "int\tuserauth_kbdint(Authctxt *);",
      "int\tuserauth_hostbased(Authctxt *);",
      "void\tuserauth(Authctxt *, char *);",
      "static int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);",
      "static void pubkey_prepare(Authctxt *);",
      "static void pubkey_cleanup(Authctxt *);",
      "static void pubkey_reset(Authctxt *);",
      "static struct sshkey *load_identity_file(Identity *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "userauth",
          "args": [
            "authctxt",
            "NULL"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "userauth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "458-494",
          "snippet": "void\nuserauth(Authctxt *authctxt, char *authlist)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\n\tif (authctxt->method != NULL && authctxt->method->cleanup != NULL)\n\t\tauthctxt->method->cleanup(authctxt);\n\n\tfree(authctxt->methoddata);\n\tauthctxt->methoddata = NULL;\n\tif (authlist == NULL) {\n\t\tauthlist = authctxt->authlist;\n\t} else {\n\t\tfree(authctxt->authlist);\n\t\tauthctxt->authlist = authlist;\n\t}\n\tfor (;;) {\n\t\tAuthmethod *method = authmethod_get(authlist);\n\t\tif (method == NULL)\n\t\t\tfatal(\"%s@%s: Permission denied (%s).\",\n\t\t\t    authctxt->server_user, authctxt->host, authlist);\n\t\tauthctxt->method = method;\n\n\t\t/* reset the per method handler */\n\t\tssh_dispatch_range(ssh, SSH2_MSG_USERAUTH_PER_METHOD_MIN,\n\t\t    SSH2_MSG_USERAUTH_PER_METHOD_MAX, NULL);\n\n\t\t/* and try new method */\n\t\tif (method->userauth(authctxt) != 0) {\n\t\t\tdebug2(\"we sent a %s packet, wait for reply\", method->name);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tdebug2(\"we did not send a packet, disable method\");\n\t\t\tmethod->enabled = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
            "int\tuserauth_none(Authctxt *);",
            "int\tuserauth_pubkey(Authctxt *);",
            "int\tuserauth_passwd(Authctxt *);",
            "int\tuserauth_kbdint(Authctxt *);",
            "int\tuserauth_hostbased(Authctxt *);",
            "void\tuserauth(Authctxt *, char *);",
            "static void pubkey_prepare(Authctxt *);",
            "static void pubkey_cleanup(Authctxt *);",
            "static void pubkey_reset(Authctxt *);",
            "static Authmethod *authmethod_get(char *authlist);",
            "static Authmethod *authmethod_lookup(const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic Authmethod *authmethod_get(char *authlist);\nstatic Authmethod *authmethod_lookup(const char *name);\n\nvoid\nuserauth(Authctxt *authctxt, char *authlist)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\n\tif (authctxt->method != NULL && authctxt->method->cleanup != NULL)\n\t\tauthctxt->method->cleanup(authctxt);\n\n\tfree(authctxt->methoddata);\n\tauthctxt->methoddata = NULL;\n\tif (authlist == NULL) {\n\t\tauthlist = authctxt->authlist;\n\t} else {\n\t\tfree(authctxt->authlist);\n\t\tauthctxt->authlist = authlist;\n\t}\n\tfor (;;) {\n\t\tAuthmethod *method = authmethod_get(authlist);\n\t\tif (method == NULL)\n\t\t\tfatal(\"%s@%s: Permission denied (%s).\",\n\t\t\t    authctxt->server_user, authctxt->host, authlist);\n\t\tauthctxt->method = method;\n\n\t\t/* reset the per method handler */\n\t\tssh_dispatch_range(ssh, SSH2_MSG_USERAUTH_PER_METHOD_MIN,\n\t\t    SSH2_MSG_USERAUTH_PER_METHOD_MAX, NULL);\n\n\t\t/* and try new method */\n\t\tif (method->userauth(authctxt) != 0) {\n\t\t\tdebug2(\"we sent a %s packet, wait for reply\", method->name);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tdebug2(\"we did not send a packet, disable method\");\n\t\t\tmethod->enabled = NULL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pkblob"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "key"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sign_and_send_pubkey",
          "args": [
            "ssh",
            "authctxt",
            "id"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "sign_and_send_pubkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "1182-1339",
          "snippet": "static int\nsign_and_send_pubkey(struct ssh *ssh, Authctxt *authctxt, Identity *id)\n{\n\tstruct sshbuf *b = NULL;\n\tIdentity *private_id, *sign_id = NULL;\n\tu_char *signature = NULL;\n\tsize_t slen = 0, skip = 0;\n\tint r, fallback_sigtype, sent = 0;\n\tchar *alg = NULL, *fp = NULL;\n\tconst char *loc = \"\";\n\n\tif ((fp = sshkey_fingerprint(id->key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\treturn 0;\n\n\tdebug3(\"%s: %s %s\", __func__, sshkey_type(id->key), fp);\n\n\t/*\n\t * If the key is an certificate, try to find a matching private key\n\t * and use it to complete the signature.\n\t * If no such private key exists, fall back to trying the certificate\n\t * key itself in case it has a private half already loaded.\n\t * This will try to set sign_id to the private key that will perform\n\t * the signature.\n\t */\n\tif (sshkey_is_cert(id->key)) {\n\t\tTAILQ_FOREACH(private_id, &authctxt->keys, next) {\n\t\t\tif (sshkey_equal_public(id->key, private_id->key) &&\n\t\t\t    id->key->type != private_id->key->type) {\n\t\t\t\tsign_id = private_id;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Exact key matches are preferred, but also allow\n\t\t * filename matches for non-PKCS#11/agent keys that\n\t\t * didn't load public keys. This supports the case\n\t\t * of keeping just a private key file and public\n\t\t * certificate on disk.\n\t\t */\n\t\tif (sign_id == NULL &&\n\t\t    !id->isprivate && id->agent_fd == -1 &&\n\t\t    (id->key->flags & SSHKEY_FLAG_EXT) == 0) {\n\t\t\tTAILQ_FOREACH(private_id, &authctxt->keys, next) {\n\t\t\t\tif (private_id->key == NULL &&\n\t\t\t\t    id_filename_matches(id, private_id)) {\n\t\t\t\t\tsign_id = private_id;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (sign_id != NULL) {\n\t\t\tdebug2(\"%s: using private key \\\"%s\\\"%s for \"\n\t\t\t    \"certificate\", __func__, id->filename,\n\t\t\t    id->agent_fd != -1 ? \" from agent\" : \"\");\n\t\t} else {\n\t\t\tdebug(\"%s: no separate private key for certificate \"\n\t\t\t    \"\\\"%s\\\"\", __func__, id->filename);\n\t\t}\n\t}\n\n\t/*\n\t * If the above didn't select another identity to do the signing\n\t * then default to the one we started with.\n\t */\n\tif (sign_id == NULL)\n\t\tsign_id = id;\n\n\t/* assemble and sign data */\n\tfor (fallback_sigtype = 0; fallback_sigtype <= 1; fallback_sigtype++) {\n\t\tfree(alg);\n\t\tslen = 0;\n\t\tsignature = NULL;\n\t\tif ((alg = key_sig_algorithm(fallback_sigtype ? NULL : ssh,\n\t\t    id->key)) == NULL) {\n\t\t\terror(\"%s: no mutual signature supported\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t\tdebug3(\"%s: signing using %s\", __func__, alg);\n\n\t\tsshbuf_free(b);\n\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\tif (datafellows & SSH_OLD_SESSIONID) {\n\t\t\tif ((r = sshbuf_put(b, session_id2,\n\t\t\t    session_id2_len)) != 0) {\n\t\t\t\tfatal(\"%s: sshbuf_put: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t} else {\n\t\t\tif ((r = sshbuf_put_string(b, session_id2,\n\t\t\t    session_id2_len)) != 0) {\n\t\t\t\tfatal(\"%s: sshbuf_put_string: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t}\n\t\tskip = sshbuf_len(b);\n\t\tif ((r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->server_user)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->method->name)) != 0 ||\n\t\t    (r = sshbuf_put_u8(b, 1)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, alg)) != 0 ||\n\t\t    (r = sshkey_puts(id->key, b)) != 0) {\n\t\t\tfatal(\"%s: assemble signed data: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t}\n\n\t\t/* generate signature */\n\t\tr = identity_sign(sign_id, &signature, &slen,\n\t\t    sshbuf_ptr(b), sshbuf_len(b), datafellows, alg);\n\t\tif (r == 0)\n\t\t\tbreak;\n\t\telse if (r == SSH_ERR_KEY_NOT_FOUND)\n\t\t\tgoto out; /* soft failure */\n\t\telse if (r == SSH_ERR_SIGN_ALG_UNSUPPORTED &&\n\t\t    !fallback_sigtype) {\n\t\t\tif (sign_id->agent_fd != -1)\n\t\t\t\tloc = \"agent \";\n\t\t\telse if ((sign_id->key->flags & SSHKEY_FLAG_EXT) != 0)\n\t\t\t\tloc = \"token \";\n\t\t\tlogit(\"%skey %s %s returned incorrect signature type\",\n\t\t\t    loc, sshkey_type(id->key), fp);\n\t\t\tcontinue;\n\t\t}\n\t\terror(\"%s: signing failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif (slen == 0 || signature == NULL) /* shouldn't happen */\n\t\tfatal(\"%s: no signature\", __func__);\n\n\t/* append signature */\n\tif ((r = sshbuf_put_string(b, signature, slen)) != 0)\n\t\tfatal(\"%s: append signature: %s\", __func__, ssh_err(r));\n\n#ifdef DEBUG_PK\n\tsshbuf_dump(b, stderr);\n#endif\n\t/* skip session id and packet type */\n\tif ((r = sshbuf_consume(b, skip + 1)) != 0)\n\t\tfatal(\"%s: consume: %s\", __func__, ssh_err(r));\n\n\t/* put remaining data from buffer into packet */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_putb(ssh, b)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: enqueue request: %s\", __func__, ssh_err(r));\n\n\t/* success */\n\tsent = 1;\n\n out:\n\tfree(fp);\n\tfree(alg);\n\tsshbuf_free(b);\n\tfreezero(signature, slen);\n\treturn sent;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "u_char *session_id2 = NULL;",
            "u_int session_id2_len = 0;",
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
            "int\tuserauth_none(Authctxt *);",
            "int\tuserauth_pubkey(Authctxt *);",
            "int\tuserauth_passwd(Authctxt *);",
            "int\tuserauth_kbdint(Authctxt *);",
            "int\tuserauth_hostbased(Authctxt *);",
            "void\tuserauth(Authctxt *, char *);",
            "static int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);",
            "static void pubkey_prepare(Authctxt *);",
            "static void pubkey_cleanup(Authctxt *);",
            "static void pubkey_reset(Authctxt *);",
            "static struct sshkey *load_identity_file(Identity *);",
            "static Authmethod *authmethod_lookup(const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nu_char *session_id2 = NULL;\nu_int session_id2_len = 0;\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic struct sshkey *load_identity_file(Identity *);\nstatic Authmethod *authmethod_lookup(const char *name);\n\nstatic int\nsign_and_send_pubkey(struct ssh *ssh, Authctxt *authctxt, Identity *id)\n{\n\tstruct sshbuf *b = NULL;\n\tIdentity *private_id, *sign_id = NULL;\n\tu_char *signature = NULL;\n\tsize_t slen = 0, skip = 0;\n\tint r, fallback_sigtype, sent = 0;\n\tchar *alg = NULL, *fp = NULL;\n\tconst char *loc = \"\";\n\n\tif ((fp = sshkey_fingerprint(id->key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\treturn 0;\n\n\tdebug3(\"%s: %s %s\", __func__, sshkey_type(id->key), fp);\n\n\t/*\n\t * If the key is an certificate, try to find a matching private key\n\t * and use it to complete the signature.\n\t * If no such private key exists, fall back to trying the certificate\n\t * key itself in case it has a private half already loaded.\n\t * This will try to set sign_id to the private key that will perform\n\t * the signature.\n\t */\n\tif (sshkey_is_cert(id->key)) {\n\t\tTAILQ_FOREACH(private_id, &authctxt->keys, next) {\n\t\t\tif (sshkey_equal_public(id->key, private_id->key) &&\n\t\t\t    id->key->type != private_id->key->type) {\n\t\t\t\tsign_id = private_id;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Exact key matches are preferred, but also allow\n\t\t * filename matches for non-PKCS#11/agent keys that\n\t\t * didn't load public keys. This supports the case\n\t\t * of keeping just a private key file and public\n\t\t * certificate on disk.\n\t\t */\n\t\tif (sign_id == NULL &&\n\t\t    !id->isprivate && id->agent_fd == -1 &&\n\t\t    (id->key->flags & SSHKEY_FLAG_EXT) == 0) {\n\t\t\tTAILQ_FOREACH(private_id, &authctxt->keys, next) {\n\t\t\t\tif (private_id->key == NULL &&\n\t\t\t\t    id_filename_matches(id, private_id)) {\n\t\t\t\t\tsign_id = private_id;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (sign_id != NULL) {\n\t\t\tdebug2(\"%s: using private key \\\"%s\\\"%s for \"\n\t\t\t    \"certificate\", __func__, id->filename,\n\t\t\t    id->agent_fd != -1 ? \" from agent\" : \"\");\n\t\t} else {\n\t\t\tdebug(\"%s: no separate private key for certificate \"\n\t\t\t    \"\\\"%s\\\"\", __func__, id->filename);\n\t\t}\n\t}\n\n\t/*\n\t * If the above didn't select another identity to do the signing\n\t * then default to the one we started with.\n\t */\n\tif (sign_id == NULL)\n\t\tsign_id = id;\n\n\t/* assemble and sign data */\n\tfor (fallback_sigtype = 0; fallback_sigtype <= 1; fallback_sigtype++) {\n\t\tfree(alg);\n\t\tslen = 0;\n\t\tsignature = NULL;\n\t\tif ((alg = key_sig_algorithm(fallback_sigtype ? NULL : ssh,\n\t\t    id->key)) == NULL) {\n\t\t\terror(\"%s: no mutual signature supported\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t\tdebug3(\"%s: signing using %s\", __func__, alg);\n\n\t\tsshbuf_free(b);\n\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\tif (datafellows & SSH_OLD_SESSIONID) {\n\t\t\tif ((r = sshbuf_put(b, session_id2,\n\t\t\t    session_id2_len)) != 0) {\n\t\t\t\tfatal(\"%s: sshbuf_put: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t} else {\n\t\t\tif ((r = sshbuf_put_string(b, session_id2,\n\t\t\t    session_id2_len)) != 0) {\n\t\t\t\tfatal(\"%s: sshbuf_put_string: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t}\n\t\tskip = sshbuf_len(b);\n\t\tif ((r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->server_user)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->method->name)) != 0 ||\n\t\t    (r = sshbuf_put_u8(b, 1)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, alg)) != 0 ||\n\t\t    (r = sshkey_puts(id->key, b)) != 0) {\n\t\t\tfatal(\"%s: assemble signed data: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t}\n\n\t\t/* generate signature */\n\t\tr = identity_sign(sign_id, &signature, &slen,\n\t\t    sshbuf_ptr(b), sshbuf_len(b), datafellows, alg);\n\t\tif (r == 0)\n\t\t\tbreak;\n\t\telse if (r == SSH_ERR_KEY_NOT_FOUND)\n\t\t\tgoto out; /* soft failure */\n\t\telse if (r == SSH_ERR_SIGN_ALG_UNSUPPORTED &&\n\t\t    !fallback_sigtype) {\n\t\t\tif (sign_id->agent_fd != -1)\n\t\t\t\tloc = \"agent \";\n\t\t\telse if ((sign_id->key->flags & SSHKEY_FLAG_EXT) != 0)\n\t\t\t\tloc = \"token \";\n\t\t\tlogit(\"%skey %s %s returned incorrect signature type\",\n\t\t\t    loc, sshkey_type(id->key), fp);\n\t\t\tcontinue;\n\t\t}\n\t\terror(\"%s: signing failed: %s\", __func__, ssh_err(r));\n\t\tgoto out;\n\t}\n\tif (slen == 0 || signature == NULL) /* shouldn't happen */\n\t\tfatal(\"%s: no signature\", __func__);\n\n\t/* append signature */\n\tif ((r = sshbuf_put_string(b, signature, slen)) != 0)\n\t\tfatal(\"%s: append signature: %s\", __func__, ssh_err(r));\n\n#ifdef DEBUG_PK\n\tsshbuf_dump(b, stderr);\n#endif\n\t/* skip session id and packet type */\n\tif ((r = sshbuf_consume(b, skip + 1)) != 0)\n\t\tfatal(\"%s: consume: %s\", __func__, ssh_err(r));\n\n\t/* put remaining data from buffer into packet */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_putb(ssh, b)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: enqueue request: %s\", __func__, ssh_err(r));\n\n\t/* success */\n\tsent = 1;\n\n out:\n\tfree(fp);\n\tfree(alg);\n\tsshbuf_free(b);\n\tfreezero(signature, slen);\n\treturn sent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Server accepts key: %s\"",
            "ident"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_identity",
          "args": [
            "id"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "format_identity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "588-606",
          "snippet": "static char *\nformat_identity(Identity *id)\n{\n\tchar *fp = NULL, *ret = NULL;\n\n\tif (id->key != NULL) {\n\t     fp = sshkey_fingerprint(id->key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t}\n\txasprintf(&ret, \"%s %s%s%s%s%s%s\",\n\t    id->filename,\n\t    id->key ? sshkey_type(id->key) : \"\", id->key ? \" \" : \"\",\n\t    fp ? fp : \"\",\n\t    id->userprovided ? \" explicit\" : \"\",\n\t    (id->key && (id->key->flags & SSHKEY_FLAG_EXT)) ? \" token\" : \"\",\n\t    id->agent_fd != -1 ? \" agent\" : \"\");\n\tfree(fp);\n\treturn ret;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "static int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);",
            "static struct sshkey *load_identity_file(Identity *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nstatic int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);\nstatic struct sshkey *load_identity_file(Identity *);\n\nstatic char *\nformat_identity(Identity *id)\n{\n\tchar *fp = NULL, *ret = NULL;\n\n\tif (id->key != NULL) {\n\t     fp = sshkey_fingerprint(id->key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t}\n\txasprintf(&ret, \"%s %s%s%s%s%s%s\",\n\t    id->filename,\n\t    id->key ? sshkey_type(id->key) : \"\", id->key ? \" \" : \"\",\n\t    fp ? fp : \"\",\n\t    id->userprovided ? \" explicit\" : \"\",\n\t    (id->key && (id->key->flags & SSHKEY_FLAG_EXT)) ? \" token\" : \"\",\n\t    id->agent_fd != -1 ? \" agent\" : \"\");\n\tfree(fp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: server replied with unknown key: %s %s\"",
            "__func__",
            "sshkey_type(key)",
            "fp == NULL ? \"<ERROR>\" : fp"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "key"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "key",
            "options.fingerprint_hash",
            "SSH_FP_DEFAULT"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_equal",
          "args": [
            "key",
            "id->key"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "704-714",
          "snippet": "int\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_FOREACH_REVERSE",
          "args": [
            "id",
            "&authctxt->keys",
            "idlist",
            "next"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"input_userauth_pk_ok: type mismatch \"\n\t\t    \"for decoded key (received %d, expected %d)\"",
            "key->type",
            "pktype"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "input_gssapi_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "919-937",
          "snippet": "int\ninput_gssapi_error(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tchar *msg = NULL;\n\tchar *lang = NULL;\n\tint r;\n\n\tif ((r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* maj */\n\t    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* min */\n\t    (r = sshpkt_get_cstring(ssh, &msg, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &lang, NULL)) != 0)\n\t\tgoto out;\n\tr = sshpkt_get_end(ssh);\n\tdebug(\"Server GSSAPI Error:\\n%s\", msg);\n out:\n\tfree(msg);\n\tfree(lang);\n\treturn r;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\n\nint\ninput_gssapi_error(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tchar *msg = NULL;\n\tchar *lang = NULL;\n\tint r;\n\n\tif ((r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* maj */\n\t    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* min */\n\t    (r = sshpkt_get_cstring(ssh, &msg, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &lang, NULL)) != 0)\n\t\tgoto out;\n\tr = sshpkt_get_end(ssh);\n\tdebug(\"Server GSSAPI Error:\\n%s\", msg);\n out:\n\tfree(msg);\n\tfree(lang);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_from_blob",
          "args": [
            "pkblob",
            "blen",
            "&key"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2263-2274",
          "snippet": "int\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_from_name",
          "args": [
            "pkalg"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "190-202",
          "snippet": "int\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_end",
          "args": [
            "ssh"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2555-2561",
          "snippet": "int\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_string",
          "args": [
            "ssh",
            "&pkblob",
            "&blen"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2520-2524",
          "snippet": "int\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_cstring",
          "args": [
            "ssh",
            "&pkalg",
            "NULL"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2532-2536",
          "snippet": "int\nsshpkt_get_cstring(struct ssh *ssh, char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_cstring(ssh->state->incoming_packet, valp, lenp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_cstring(struct ssh *ssh, char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_cstring(ssh->state->incoming_packet, valp, lenp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"input_userauth_pk_ok: no authentication context\""
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic struct sshkey *load_identity_file(Identity *);\n\nint\ninput_userauth_pk_ok(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct sshkey *key = NULL;\n\tIdentity *id = NULL;\n\tint pktype, found = 0, sent = 0;\n\tsize_t blen;\n\tchar *pkalg = NULL, *fp = NULL, *ident = NULL;\n\tu_char *pkblob = NULL;\n\tint r;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_userauth_pk_ok: no authentication context\");\n\n\tif ((r = sshpkt_get_cstring(ssh, &pkalg, NULL)) != 0 ||\n\t    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto done;\n\n\tif ((pktype = sshkey_type_from_name(pkalg)) == KEY_UNSPEC) {\n\t\tdebug(\"%s: server sent unknown pkalg %s\", __func__, pkalg);\n\t\tgoto done;\n\t}\n\tif ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {\n\t\tdebug(\"no key from blob. pkalg %s: %s\", pkalg, ssh_err(r));\n\t\tgoto done;\n\t}\n\tif (key->type != pktype) {\n\t\terror(\"input_userauth_pk_ok: type mismatch \"\n\t\t    \"for decoded key (received %d, expected %d)\",\n\t\t    key->type, pktype);\n\t\tgoto done;\n\t}\n\n\t/*\n\t * search keys in the reverse order, because last candidate has been\n\t * moved to the end of the queue.  this also avoids confusion by\n\t * duplicate keys\n\t */\n\tTAILQ_FOREACH_REVERSE(id, &authctxt->keys, idlist, next) {\n\t\tif (sshkey_equal(key, id->key)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found || id == NULL) {\n\t\tfp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t\terror(\"%s: server replied with unknown key: %s %s\", __func__,\n\t\t    sshkey_type(key), fp == NULL ? \"<ERROR>\" : fp);\n\t\tgoto done;\n\t}\n\tident = format_identity(id);\n\tdebug(\"Server accepts key: %s\", ident);\n\tsent = sign_and_send_pubkey(ssh, authctxt, id);\n\tr = 0;\n done:\n\tsshkey_free(key);\n\tfree(ident);\n\tfree(fp);\n\tfree(pkalg);\n\tfree(pkblob);\n\n\t/* try another method if we did not send a packet */\n\tif (r == 0 && sent == 0)\n\t\tuserauth(authctxt, NULL);\n\treturn r;\n}"
  },
  {
    "function_name": "format_identity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "588-606",
    "snippet": "static char *\nformat_identity(Identity *id)\n{\n\tchar *fp = NULL, *ret = NULL;\n\n\tif (id->key != NULL) {\n\t     fp = sshkey_fingerprint(id->key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t}\n\txasprintf(&ret, \"%s %s%s%s%s%s%s\",\n\t    id->filename,\n\t    id->key ? sshkey_type(id->key) : \"\", id->key ? \" \" : \"\",\n\t    fp ? fp : \"\",\n\t    id->userprovided ? \" explicit\" : \"\",\n\t    (id->key && (id->key->flags & SSHKEY_FLAG_EXT)) ? \" token\" : \"\",\n\t    id->agent_fd != -1 ? \" agent\" : \"\");\n\tfree(fp);\n\treturn ret;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "static int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);",
      "static struct sshkey *load_identity_file(Identity *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fp"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&ret",
            "\"%s %s%s%s%s%s%s\"",
            "id->filename",
            "id->key ? sshkey_type(id->key) : \"\"",
            "id->key ? \" \" : \"\"",
            "fp ? fp : \"\"",
            "id->userprovided ? \" explicit\" : \"\"",
            "(id->key && (id->key->flags & SSHKEY_FLAG_EXT)) ? \" token\" : \"\"",
            "id->agent_fd != -1 ? \" agent\" : \"\""
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "id->key"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_fingerprint",
          "args": [
            "id->key",
            "options.fingerprint_hash",
            "SSH_FP_DEFAULT"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_fingerprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1155-1198",
          "snippet": "char *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\texplicit_bzero(dgst_raw, dgst_raw_len);\n\t\tfree(dgst_raw);\n\t\treturn NULL;\n\t}\n\texplicit_bzero(dgst_raw, dgst_raw_len);\n\tfree(dgst_raw);\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nstatic int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);\nstatic struct sshkey *load_identity_file(Identity *);\n\nstatic char *\nformat_identity(Identity *id)\n{\n\tchar *fp = NULL, *ret = NULL;\n\n\tif (id->key != NULL) {\n\t     fp = sshkey_fingerprint(id->key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t}\n\txasprintf(&ret, \"%s %s%s%s%s%s%s\",\n\t    id->filename,\n\t    id->key ? sshkey_type(id->key) : \"\", id->key ? \" \" : \"\",\n\t    fp ? fp : \"\",\n\t    id->userprovided ? \" explicit\" : \"\",\n\t    (id->key && (id->key->flags & SSHKEY_FLAG_EXT)) ? \" token\" : \"\",\n\t    id->agent_fd != -1 ? \" agent\" : \"\");\n\tfree(fp);\n\treturn ret;\n}"
  },
  {
    "function_name": "input_userauth_failure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "554-582",
    "snippet": "int\ninput_userauth_failure(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tchar *authlist = NULL;\n\tu_char partial;\n\tint r;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_userauth_failure: no authentication context\");\n\n\tif ((r = sshpkt_get_cstring(ssh, &authlist, NULL)) != 0 ||\n\t    (r = sshpkt_get_u8(ssh, &partial)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto out;\n\n\tif (partial != 0) {\n\t\tverbose(\"Authenticated with partial success.\");\n\t\t/* reset state */\n\t\tpubkey_reset(authctxt);\n\t}\n\tdebug(\"Authentications that can continue: %s\", authlist);\n\n\tuserauth(authctxt, authlist);\n\tauthlist = NULL;\n out:\n\tfree(authlist);\n\treturn 0;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
      "int\tuserauth_none(Authctxt *);",
      "int\tuserauth_pubkey(Authctxt *);",
      "int\tuserauth_passwd(Authctxt *);",
      "int\tuserauth_kbdint(Authctxt *);",
      "int\tuserauth_hostbased(Authctxt *);",
      "void\tuserauth(Authctxt *, char *);",
      "static void pubkey_prepare(Authctxt *);",
      "static void pubkey_cleanup(Authctxt *);",
      "static void pubkey_reset(Authctxt *);",
      "static Authmethod *authmethod_get(char *authlist);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "authlist"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "userauth",
          "args": [
            "authctxt",
            "authlist"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "userauth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "458-494",
          "snippet": "void\nuserauth(Authctxt *authctxt, char *authlist)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\n\tif (authctxt->method != NULL && authctxt->method->cleanup != NULL)\n\t\tauthctxt->method->cleanup(authctxt);\n\n\tfree(authctxt->methoddata);\n\tauthctxt->methoddata = NULL;\n\tif (authlist == NULL) {\n\t\tauthlist = authctxt->authlist;\n\t} else {\n\t\tfree(authctxt->authlist);\n\t\tauthctxt->authlist = authlist;\n\t}\n\tfor (;;) {\n\t\tAuthmethod *method = authmethod_get(authlist);\n\t\tif (method == NULL)\n\t\t\tfatal(\"%s@%s: Permission denied (%s).\",\n\t\t\t    authctxt->server_user, authctxt->host, authlist);\n\t\tauthctxt->method = method;\n\n\t\t/* reset the per method handler */\n\t\tssh_dispatch_range(ssh, SSH2_MSG_USERAUTH_PER_METHOD_MIN,\n\t\t    SSH2_MSG_USERAUTH_PER_METHOD_MAX, NULL);\n\n\t\t/* and try new method */\n\t\tif (method->userauth(authctxt) != 0) {\n\t\t\tdebug2(\"we sent a %s packet, wait for reply\", method->name);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tdebug2(\"we did not send a packet, disable method\");\n\t\t\tmethod->enabled = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
            "int\tuserauth_none(Authctxt *);",
            "int\tuserauth_pubkey(Authctxt *);",
            "int\tuserauth_passwd(Authctxt *);",
            "int\tuserauth_kbdint(Authctxt *);",
            "int\tuserauth_hostbased(Authctxt *);",
            "void\tuserauth(Authctxt *, char *);",
            "static void pubkey_prepare(Authctxt *);",
            "static void pubkey_cleanup(Authctxt *);",
            "static void pubkey_reset(Authctxt *);",
            "static Authmethod *authmethod_get(char *authlist);",
            "static Authmethod *authmethod_lookup(const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic Authmethod *authmethod_get(char *authlist);\nstatic Authmethod *authmethod_lookup(const char *name);\n\nvoid\nuserauth(Authctxt *authctxt, char *authlist)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\n\tif (authctxt->method != NULL && authctxt->method->cleanup != NULL)\n\t\tauthctxt->method->cleanup(authctxt);\n\n\tfree(authctxt->methoddata);\n\tauthctxt->methoddata = NULL;\n\tif (authlist == NULL) {\n\t\tauthlist = authctxt->authlist;\n\t} else {\n\t\tfree(authctxt->authlist);\n\t\tauthctxt->authlist = authlist;\n\t}\n\tfor (;;) {\n\t\tAuthmethod *method = authmethod_get(authlist);\n\t\tif (method == NULL)\n\t\t\tfatal(\"%s@%s: Permission denied (%s).\",\n\t\t\t    authctxt->server_user, authctxt->host, authlist);\n\t\tauthctxt->method = method;\n\n\t\t/* reset the per method handler */\n\t\tssh_dispatch_range(ssh, SSH2_MSG_USERAUTH_PER_METHOD_MIN,\n\t\t    SSH2_MSG_USERAUTH_PER_METHOD_MAX, NULL);\n\n\t\t/* and try new method */\n\t\tif (method->userauth(authctxt) != 0) {\n\t\t\tdebug2(\"we sent a %s packet, wait for reply\", method->name);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tdebug2(\"we did not send a packet, disable method\");\n\t\t\tmethod->enabled = NULL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Authentications that can continue: %s\"",
            "authlist"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pubkey_reset",
          "args": [
            "authctxt"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "pubkey_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "1636-1643",
          "snippet": "static void\npubkey_reset(Authctxt *authctxt)\n{\n\tIdentity *id;\n\n\tTAILQ_FOREACH(id, &authctxt->keys, next)\n\t\tid->tried = 0;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tuserauth_none(Authctxt *);",
            "int\tuserauth_pubkey(Authctxt *);",
            "int\tuserauth_passwd(Authctxt *);",
            "int\tuserauth_kbdint(Authctxt *);",
            "int\tuserauth_hostbased(Authctxt *);",
            "void\tuserauth(Authctxt *, char *);",
            "static int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);",
            "static void pubkey_prepare(Authctxt *);",
            "static void pubkey_cleanup(Authctxt *);",
            "static void pubkey_reset(Authctxt *);",
            "static struct sshkey *load_identity_file(Identity *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic struct sshkey *load_identity_file(Identity *);\n\nstatic void\npubkey_reset(Authctxt *authctxt)\n{\n\tIdentity *id;\n\n\tTAILQ_FOREACH(id, &authctxt->keys, next)\n\t\tid->tried = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Authenticated with partial success.\""
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "210-218",
          "snippet": "void\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nverbose(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_VERBOSE, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_end",
          "args": [
            "ssh"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2555-2561",
          "snippet": "int\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_u8",
          "args": [
            "ssh",
            "&partial"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2496-2500",
          "snippet": "int\nsshpkt_get_u8(struct ssh *ssh, u_char *valp)\n{\n\treturn sshbuf_get_u8(ssh->state->incoming_packet, valp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_u8(struct ssh *ssh, u_char *valp)\n{\n\treturn sshbuf_get_u8(ssh->state->incoming_packet, valp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_cstring",
          "args": [
            "ssh",
            "&authlist",
            "NULL"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2532-2536",
          "snippet": "int\nsshpkt_get_cstring(struct ssh *ssh, char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_cstring(ssh->state->incoming_packet, valp, lenp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_cstring(struct ssh *ssh, char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_cstring(ssh->state->incoming_packet, valp, lenp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"input_userauth_failure: no authentication context\""
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic Authmethod *authmethod_get(char *authlist);\n\nint\ninput_userauth_failure(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tchar *authlist = NULL;\n\tu_char partial;\n\tint r;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_userauth_failure: no authentication context\");\n\n\tif ((r = sshpkt_get_cstring(ssh, &authlist, NULL)) != 0 ||\n\t    (r = sshpkt_get_u8(ssh, &partial)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto out;\n\n\tif (partial != 0) {\n\t\tverbose(\"Authenticated with partial success.\");\n\t\t/* reset state */\n\t\tpubkey_reset(authctxt);\n\t}\n\tdebug(\"Authentications that can continue: %s\", authlist);\n\n\tuserauth(authctxt, authlist);\n\tauthlist = NULL;\n out:\n\tfree(authlist);\n\treturn 0;\n}"
  },
  {
    "function_name": "input_userauth_success_unexpected",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "540-551",
    "snippet": "int\ninput_userauth_success_unexpected(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"%s: no authentication context\", __func__);\n\n\tfatal(\"Unexpected authentication success during %s.\",\n\t    authctxt->method->name);\n\treturn 0;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
      "int\tuserauth_none(Authctxt *);",
      "int\tuserauth_pubkey(Authctxt *);",
      "int\tuserauth_passwd(Authctxt *);",
      "int\tuserauth_kbdint(Authctxt *);",
      "int\tuserauth_hostbased(Authctxt *);",
      "void\tuserauth(Authctxt *, char *);",
      "static void pubkey_prepare(Authctxt *);",
      "static void pubkey_cleanup(Authctxt *);",
      "static void pubkey_reset(Authctxt *);",
      "static Authmethod *authmethod_lookup(const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Unexpected authentication success during %s.\"",
            "authctxt->method->name"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic Authmethod *authmethod_lookup(const char *name);\n\nint\ninput_userauth_success_unexpected(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"%s: no authentication context\", __func__);\n\n\tfatal(\"Unexpected authentication success during %s.\",\n\t    authctxt->method->name);\n\treturn 0;\n}"
  },
  {
    "function_name": "input_userauth_success",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "523-538",
    "snippet": "int\ninput_userauth_success(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_userauth_success: no authentication context\");\n\tfree(authctxt->authlist);\n\tauthctxt->authlist = NULL;\n\tif (authctxt->method != NULL && authctxt->method->cleanup != NULL)\n\t\tauthctxt->method->cleanup(authctxt);\n\tfree(authctxt->methoddata);\n\tauthctxt->methoddata = NULL;\n\tauthctxt->success = 1;\t\t\t/* break out */\n\treturn 0;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
      "int\tuserauth_none(Authctxt *);",
      "int\tuserauth_pubkey(Authctxt *);",
      "int\tuserauth_passwd(Authctxt *);",
      "int\tuserauth_kbdint(Authctxt *);",
      "int\tuserauth_hostbased(Authctxt *);",
      "void\tuserauth(Authctxt *, char *);",
      "static void pubkey_prepare(Authctxt *);",
      "static void pubkey_cleanup(Authctxt *);",
      "static void pubkey_reset(Authctxt *);",
      "static Authmethod *authmethod_get(char *authlist);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "authctxt->methoddata"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "authctxt->method->cleanup",
          "args": [
            "authctxt"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"input_userauth_success: no authentication context\""
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic Authmethod *authmethod_get(char *authlist);\n\nint\ninput_userauth_success(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_userauth_success: no authentication context\");\n\tfree(authctxt->authlist);\n\tauthctxt->authlist = NULL;\n\tif (authctxt->method != NULL && authctxt->method->cleanup != NULL)\n\t\tauthctxt->method->cleanup(authctxt);\n\tfree(authctxt->methoddata);\n\tauthctxt->methoddata = NULL;\n\tauthctxt->success = 1;\t\t\t/* break out */\n\treturn 0;\n}"
  },
  {
    "function_name": "input_userauth_banner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "506-520",
    "snippet": "int\ninput_userauth_banner(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tchar *msg, *lang;\n\tu_int len;\n\n\tdebug3(\"%s\", __func__);\n\tmsg = packet_get_string(&len);\n\tlang = packet_get_string(NULL);\n\tif (len > 0 && options.log_level >= SYSLOG_LEVEL_INFO)\n\t\tfmprintf(stderr, \"%s\", msg);\n\tfree(msg);\n\tfree(lang);\n\treturn 0;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "lang"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmprintf",
          "args": [
            "stderr",
            "\"%s\"",
            "msg"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "fmprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/utf8.c",
          "lines": "277-287",
          "snippet": "int\nfmprintf(FILE *stream, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stream, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"utf8.h\"",
            "# include <wchar.h>",
            "# include <vis.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "# include <langinfo.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t vasnmprintf(char **, size_t, int *, const char *, va_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n# include <wchar.h>\n# include <vis.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <limits.h>\n# include <langinfo.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\t vasnmprintf(char **, size_t, int *, const char *, va_list);\n\nint\nfmprintf(FILE *stream, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stream, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_get_string",
          "args": [
            "NULL"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "packet_get_string",
          "args": [
            "&len"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s\"",
            "__func__"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\n\nint\ninput_userauth_banner(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tchar *msg, *lang;\n\tu_int len;\n\n\tdebug3(\"%s\", __func__);\n\tmsg = packet_get_string(&len);\n\tlang = packet_get_string(NULL);\n\tif (len > 0 && options.log_level >= SYSLOG_LEVEL_INFO)\n\t\tfmprintf(stderr, \"%s\", msg);\n\tfree(msg);\n\tfree(lang);\n\treturn 0;\n}"
  },
  {
    "function_name": "input_userauth_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "497-503",
    "snippet": "int\ninput_userauth_error(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tfatal(\"input_userauth_error: bad message during authentication: \"\n\t    \"type %d\", type);\n\treturn 0;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"input_userauth_error: bad message during authentication: \"\n\t    \"type %d\"",
            "type"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\n\nint\ninput_userauth_error(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tfatal(\"input_userauth_error: bad message during authentication: \"\n\t    \"type %d\", type);\n\treturn 0;\n}"
  },
  {
    "function_name": "userauth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "458-494",
    "snippet": "void\nuserauth(Authctxt *authctxt, char *authlist)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\n\tif (authctxt->method != NULL && authctxt->method->cleanup != NULL)\n\t\tauthctxt->method->cleanup(authctxt);\n\n\tfree(authctxt->methoddata);\n\tauthctxt->methoddata = NULL;\n\tif (authlist == NULL) {\n\t\tauthlist = authctxt->authlist;\n\t} else {\n\t\tfree(authctxt->authlist);\n\t\tauthctxt->authlist = authlist;\n\t}\n\tfor (;;) {\n\t\tAuthmethod *method = authmethod_get(authlist);\n\t\tif (method == NULL)\n\t\t\tfatal(\"%s@%s: Permission denied (%s).\",\n\t\t\t    authctxt->server_user, authctxt->host, authlist);\n\t\tauthctxt->method = method;\n\n\t\t/* reset the per method handler */\n\t\tssh_dispatch_range(ssh, SSH2_MSG_USERAUTH_PER_METHOD_MIN,\n\t\t    SSH2_MSG_USERAUTH_PER_METHOD_MAX, NULL);\n\n\t\t/* and try new method */\n\t\tif (method->userauth(authctxt) != 0) {\n\t\t\tdebug2(\"we sent a %s packet, wait for reply\", method->name);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tdebug2(\"we did not send a packet, disable method\");\n\t\t\tmethod->enabled = NULL;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
      "int\tuserauth_none(Authctxt *);",
      "int\tuserauth_pubkey(Authctxt *);",
      "int\tuserauth_passwd(Authctxt *);",
      "int\tuserauth_kbdint(Authctxt *);",
      "int\tuserauth_hostbased(Authctxt *);",
      "void\tuserauth(Authctxt *, char *);",
      "static void pubkey_prepare(Authctxt *);",
      "static void pubkey_cleanup(Authctxt *);",
      "static void pubkey_reset(Authctxt *);",
      "static Authmethod *authmethod_get(char *authlist);",
      "static Authmethod *authmethod_lookup(const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"we did not send a packet, disable method\""
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "method->userauth",
          "args": [
            "authctxt"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_dispatch_range",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_PER_METHOD_MIN",
            "SSH2_MSG_USERAUTH_PER_METHOD_MAX",
            "NULL"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_dispatch_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dispatch.c",
          "lines": "69-79",
          "snippet": "void\nssh_dispatch_range(struct ssh *ssh, u_int from, u_int to, dispatch_fn *fn)\n{\n\tu_int i;\n\n\tfor (i = from; i <= to; i++) {\n\t\tif (i >= DISPATCH_MAX)\n\t\t\tbreak;\n\t\tssh->dispatch[i] = fn;\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"dispatch.h\"",
            "#include \"log.h\"",
            "#include \"ssh2.h\"",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include <stdarg.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_dispatch_range(struct ssh *ssh, u_int from, u_int to, dispatch_fn *fn)\n{\n\tu_int i;\n\n\tfor (i = from; i <= to; i++) {\n\t\tif (i >= DISPATCH_MAX)\n\t\t\tbreak;\n\t\tssh->dispatch[i] = fn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s@%s: Permission denied (%s).\"",
            "authctxt->server_user",
            "authctxt->host",
            "authlist"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "authmethod_get",
          "args": [
            "authlist"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "authmethod_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "2099-2137",
          "snippet": "static Authmethod *\nauthmethod_get(char *authlist)\n{\n\tchar *name = NULL;\n\tu_int next;\n\n\t/* Use a suitable default if we're passed a nil list.  */\n\tif (authlist == NULL || strlen(authlist) == 0)\n\t\tauthlist = options.preferred_authentications;\n\n\tif (supported == NULL || strcmp(authlist, supported) != 0) {\n\t\tdebug3(\"start over, passed a different list %s\", authlist);\n\t\tfree(supported);\n\t\tsupported = xstrdup(authlist);\n\t\tpreferred = options.preferred_authentications;\n\t\tdebug3(\"preferred %s\", preferred);\n\t\tcurrent = NULL;\n\t} else if (current != NULL && authmethod_is_enabled(current))\n\t\treturn current;\n\n\tfor (;;) {\n\t\tif ((name = match_list(preferred, supported, &next)) == NULL) {\n\t\t\tdebug(\"No more authentication methods to try.\");\n\t\t\tcurrent = NULL;\n\t\t\treturn NULL;\n\t\t}\n\t\tpreferred += next;\n\t\tdebug3(\"authmethod_lookup %s\", name);\n\t\tdebug3(\"remaining preferred: %s\", preferred);\n\t\tif ((current = authmethod_lookup(name)) != NULL &&\n\t\t    authmethod_is_enabled(current)) {\n\t\t\tdebug3(\"authmethod_is_enabled %s\", name);\n\t\t\tdebug(\"Next authentication method: %s\", name);\n\t\t\tfree(name);\n\t\t\treturn current;\n\t\t}\n\t\tfree(name);\n\t}\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "static Authmethod *authmethod_get(char *authlist);",
            "static Authmethod *authmethod_lookup(const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nstatic Authmethod *authmethod_get(char *authlist);\nstatic Authmethod *authmethod_lookup(const char *name);\n\nstatic Authmethod *\nauthmethod_get(char *authlist)\n{\n\tchar *name = NULL;\n\tu_int next;\n\n\t/* Use a suitable default if we're passed a nil list.  */\n\tif (authlist == NULL || strlen(authlist) == 0)\n\t\tauthlist = options.preferred_authentications;\n\n\tif (supported == NULL || strcmp(authlist, supported) != 0) {\n\t\tdebug3(\"start over, passed a different list %s\", authlist);\n\t\tfree(supported);\n\t\tsupported = xstrdup(authlist);\n\t\tpreferred = options.preferred_authentications;\n\t\tdebug3(\"preferred %s\", preferred);\n\t\tcurrent = NULL;\n\t} else if (current != NULL && authmethod_is_enabled(current))\n\t\treturn current;\n\n\tfor (;;) {\n\t\tif ((name = match_list(preferred, supported, &next)) == NULL) {\n\t\t\tdebug(\"No more authentication methods to try.\");\n\t\t\tcurrent = NULL;\n\t\t\treturn NULL;\n\t\t}\n\t\tpreferred += next;\n\t\tdebug3(\"authmethod_lookup %s\", name);\n\t\tdebug3(\"remaining preferred: %s\", preferred);\n\t\tif ((current = authmethod_lookup(name)) != NULL &&\n\t\t    authmethod_is_enabled(current)) {\n\t\t\tdebug3(\"authmethod_is_enabled %s\", name);\n\t\t\tdebug(\"Next authentication method: %s\", name);\n\t\t\tfree(name);\n\t\t\treturn current;\n\t\t}\n\t\tfree(name);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "authctxt->authlist"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "authctxt->method->cleanup",
          "args": [
            "authctxt"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic Authmethod *authmethod_get(char *authlist);\nstatic Authmethod *authmethod_lookup(const char *name);\n\nvoid\nuserauth(Authctxt *authctxt, char *authlist)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\n\tif (authctxt->method != NULL && authctxt->method->cleanup != NULL)\n\t\tauthctxt->method->cleanup(authctxt);\n\n\tfree(authctxt->methoddata);\n\tauthctxt->methoddata = NULL;\n\tif (authlist == NULL) {\n\t\tauthlist = authctxt->authlist;\n\t} else {\n\t\tfree(authctxt->authlist);\n\t\tauthctxt->authlist = authlist;\n\t}\n\tfor (;;) {\n\t\tAuthmethod *method = authmethod_get(authlist);\n\t\tif (method == NULL)\n\t\t\tfatal(\"%s@%s: Permission denied (%s).\",\n\t\t\t    authctxt->server_user, authctxt->host, authlist);\n\t\tauthctxt->method = method;\n\n\t\t/* reset the per method handler */\n\t\tssh_dispatch_range(ssh, SSH2_MSG_USERAUTH_PER_METHOD_MIN,\n\t\t    SSH2_MSG_USERAUTH_PER_METHOD_MAX, NULL);\n\n\t\t/* and try new method */\n\t\tif (method->userauth(authctxt) != 0) {\n\t\t\tdebug2(\"we sent a %s packet, wait for reply\", method->name);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tdebug2(\"we did not send a packet, disable method\");\n\t\t\tmethod->enabled = NULL;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "input_userauth_ext_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "452-456",
    "snippet": "int\ninput_userauth_ext_info(int type, u_int32_t seqnr, struct ssh *ssh)\n{\n\treturn kex_input_ext_info(type, seqnr, ssh);\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kex_input_ext_info",
          "args": [
            "type",
            "seqnr",
            "ssh"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "kex_input_ext_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/kex.c",
          "lines": "438-474",
          "snippet": "int\nkex_input_ext_info(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct kex *kex = ssh->kex;\n\tu_int32_t i, ninfo;\n\tchar *name;\n\tu_char *val;\n\tsize_t vlen;\n\tint r;\n\n\tdebug(\"SSH2_MSG_EXT_INFO received\");\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &kex_protocol_error);\n\tif ((r = sshpkt_get_u32(ssh, &ninfo)) != 0)\n\t\treturn r;\n\tfor (i = 0; i < ninfo; i++) {\n\t\tif ((r = sshpkt_get_cstring(ssh, &name, NULL)) != 0)\n\t\t\treturn r;\n\t\tif ((r = sshpkt_get_string(ssh, &val, &vlen)) != 0) {\n\t\t\tfree(name);\n\t\t\treturn r;\n\t\t}\n\t\tif (strcmp(name, \"server-sig-algs\") == 0) {\n\t\t\t/* Ensure no \\0 lurking in value */\n\t\t\tif (memchr(val, '\\0', vlen) != NULL) {\n\t\t\t\terror(\"%s: nul byte in %s\", __func__, name);\n\t\t\t\treturn SSH_ERR_INVALID_FORMAT;\n\t\t\t}\n\t\t\tdebug(\"%s: %s=<%s>\", __func__, name, val);\n\t\t\tkex->server_sig_algs = val;\n\t\t\tval = NULL;\n\t\t} else\n\t\t\tdebug(\"%s: %s (unrecognised)\", __func__, name);\n\t\tfree(name);\n\t\tfree(val);\n\t}\n\treturn sshpkt_get_end(ssh);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor.h\"",
            "#include \"dispatch.h\"",
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"log.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include <openssl/dh.h>",
            "#include <openssl/crypto.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int kex_choose_conf(struct ssh *);",
            "static int kex_input_newkeys(int, u_int32_t, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"monitor.h\"\n#include \"dispatch.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include <openssl/dh.h>\n#include <openssl/crypto.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include \"includes.h\"\n\nstatic int kex_choose_conf(struct ssh *);\nstatic int kex_input_newkeys(int, u_int32_t, struct ssh *);\n\nint\nkex_input_ext_info(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct kex *kex = ssh->kex;\n\tu_int32_t i, ninfo;\n\tchar *name;\n\tu_char *val;\n\tsize_t vlen;\n\tint r;\n\n\tdebug(\"SSH2_MSG_EXT_INFO received\");\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &kex_protocol_error);\n\tif ((r = sshpkt_get_u32(ssh, &ninfo)) != 0)\n\t\treturn r;\n\tfor (i = 0; i < ninfo; i++) {\n\t\tif ((r = sshpkt_get_cstring(ssh, &name, NULL)) != 0)\n\t\t\treturn r;\n\t\tif ((r = sshpkt_get_string(ssh, &val, &vlen)) != 0) {\n\t\t\tfree(name);\n\t\t\treturn r;\n\t\t}\n\t\tif (strcmp(name, \"server-sig-algs\") == 0) {\n\t\t\t/* Ensure no \\0 lurking in value */\n\t\t\tif (memchr(val, '\\0', vlen) != NULL) {\n\t\t\t\terror(\"%s: nul byte in %s\", __func__, name);\n\t\t\t\treturn SSH_ERR_INVALID_FORMAT;\n\t\t\t}\n\t\t\tdebug(\"%s: %s=<%s>\", __func__, name, val);\n\t\t\tkex->server_sig_algs = val;\n\t\t\tval = NULL;\n\t\t} else\n\t\t\tdebug(\"%s: %s (unrecognised)\", __func__, name);\n\t\tfree(name);\n\t\tfree(val);\n\t}\n\treturn sshpkt_get_end(ssh);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\n\nint\ninput_userauth_ext_info(int type, u_int32_t seqnr, struct ssh *ssh)\n{\n\treturn kex_input_ext_info(type, seqnr, ssh);\n}"
  },
  {
    "function_name": "input_userauth_service_accept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "419-449",
    "snippet": "int\ninput_userauth_service_accept(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tint r;\n\n\tif (ssh_packet_remaining(ssh) > 0) {\n\t\tchar *reply;\n\n\t\tif ((r = sshpkt_get_cstring(ssh, &reply, NULL)) != 0)\n\t\t\tgoto out;\n\t\tdebug2(\"service_accept: %s\", reply);\n\t\tfree(reply);\n\t} else {\n\t\tdebug2(\"buggy server: service_accept w/o service\");\n\t}\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto out;\n\tdebug(\"SSH2_MSG_SERVICE_ACCEPT received\");\n\n\t/* initial userauth request */\n\tuserauth_none(authctxt);\n\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &input_userauth_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_SUCCESS, &input_userauth_success);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_FAILURE, &input_userauth_failure);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_BANNER, &input_userauth_banner);\n\tr = 0;\n out:\n\treturn r;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
      "int\tuserauth_none(Authctxt *);",
      "int\tuserauth_pubkey(Authctxt *);",
      "int\tuserauth_passwd(Authctxt *);",
      "int\tuserauth_kbdint(Authctxt *);",
      "int\tuserauth_hostbased(Authctxt *);",
      "void\tuserauth(Authctxt *, char *);",
      "static void pubkey_prepare(Authctxt *);",
      "static void pubkey_cleanup(Authctxt *);",
      "static void pubkey_reset(Authctxt *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_dispatch_set",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_BANNER",
            "&input_userauth_banner"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_dispatch_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dispatch.c",
          "lines": "81-85",
          "snippet": "void\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"dispatch.h\"",
            "#include \"log.h\"",
            "#include \"ssh2.h\"",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include <stdarg.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "userauth_none",
          "args": [
            "authctxt"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "userauth_none",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "940-954",
          "snippet": "int\nuserauth_none(Authctxt *authctxt)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tint r;\n\n\t/* initial userauth request */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\treturn 1;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
            "int\tuserauth_none(Authctxt *);",
            "int\tuserauth_pubkey(Authctxt *);",
            "int\tuserauth_passwd(Authctxt *);",
            "int\tuserauth_kbdint(Authctxt *);",
            "int\tuserauth_hostbased(Authctxt *);",
            "void\tuserauth(Authctxt *, char *);",
            "static void pubkey_prepare(Authctxt *);",
            "static void pubkey_cleanup(Authctxt *);",
            "static void pubkey_reset(Authctxt *);",
            "static Authmethod *authmethod_lookup(const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic Authmethod *authmethod_lookup(const char *name);\n\nint\nuserauth_none(Authctxt *authctxt)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tint r;\n\n\t/* initial userauth request */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"SSH2_MSG_SERVICE_ACCEPT received\""
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_end",
          "args": [
            "ssh"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2555-2561",
          "snippet": "int\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"buggy server: service_accept w/o service\""
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "reply"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_cstring",
          "args": [
            "ssh",
            "&reply",
            "NULL"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2532-2536",
          "snippet": "int\nsshpkt_get_cstring(struct ssh *ssh, char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_cstring(ssh->state->incoming_packet, valp, lenp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_cstring(struct ssh *ssh, char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_cstring(ssh->state->incoming_packet, valp, lenp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_remaining",
          "args": [
            "ssh"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_remaining",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "1757-1761",
          "snippet": "int\nssh_packet_remaining(struct ssh *ssh)\n{\n\treturn sshbuf_len(ssh->state->incoming_packet);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_packet_remaining(struct ssh *ssh)\n{\n\treturn sshbuf_len(ssh->state->incoming_packet);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\n\nint\ninput_userauth_service_accept(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tint r;\n\n\tif (ssh_packet_remaining(ssh) > 0) {\n\t\tchar *reply;\n\n\t\tif ((r = sshpkt_get_cstring(ssh, &reply, NULL)) != 0)\n\t\t\tgoto out;\n\t\tdebug2(\"service_accept: %s\", reply);\n\t\tfree(reply);\n\t} else {\n\t\tdebug2(\"buggy server: service_accept w/o service\");\n\t}\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto out;\n\tdebug(\"SSH2_MSG_SERVICE_ACCEPT received\");\n\n\t/* initial userauth request */\n\tuserauth_none(authctxt);\n\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &input_userauth_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_SUCCESS, &input_userauth_success);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_FAILURE, &input_userauth_failure);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_BANNER, &input_userauth_banner);\n\tr = 0;\n out:\n\treturn r;\n}"
  },
  {
    "function_name": "ssh_userauth2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "367-416",
    "snippet": "void\nssh_userauth2(const char *local_user, const char *server_user, char *host,\n    Sensitive *sensitive)\n{\n\tstruct ssh *ssh = active_state;\n\tAuthctxt authctxt;\n\tint r;\n\n\tif (options.challenge_response_authentication)\n\t\toptions.kbd_interactive_authentication = 1;\n\tif (options.preferred_authentications == NULL)\n\t\toptions.preferred_authentications = authmethods_get();\n\n\t/* setup authentication context */\n\tmemset(&authctxt, 0, sizeof(authctxt));\n\tauthctxt.server_user = server_user;\n\tauthctxt.local_user = local_user;\n\tauthctxt.host = host;\n\tauthctxt.service = \"ssh-connection\";\t\t/* service name */\n\tauthctxt.success = 0;\n\tauthctxt.method = authmethod_lookup(\"none\");\n\tauthctxt.authlist = NULL;\n\tauthctxt.methoddata = NULL;\n\tauthctxt.sensitive = sensitive;\n\tauthctxt.active_ktype = authctxt.oktypes = authctxt.ktypes = NULL;\n\tauthctxt.info_req_seen = 0;\n\tauthctxt.agent_fd = -1;\n\tpubkey_prepare(&authctxt);\n\tif (authctxt.method == NULL)\n\t\tfatal(\"ssh_userauth2: internal error: cannot send userauth none request\");\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_SERVICE_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"ssh-userauth\")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tssh->authctxt = &authctxt;\n\tssh_dispatch_init(ssh, &input_userauth_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &input_userauth_ext_info);\n\tssh_dispatch_set(ssh, SSH2_MSG_SERVICE_ACCEPT, &input_userauth_service_accept);\n\tssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &authctxt.success);\t/* loop until success */\n\tssh->authctxt = NULL;\n\n\tpubkey_cleanup(&authctxt);\n\tssh_dispatch_range(ssh, SSH2_MSG_USERAUTH_MIN, SSH2_MSG_USERAUTH_MAX, NULL);\n\n\tif (!authctxt.success)\n\t\tfatal(\"Authentication failed.\");\n\tdebug(\"Authentication succeeded (%s).\", authctxt.method->name);\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;",
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
      "int\tuserauth_none(Authctxt *);",
      "int\tuserauth_pubkey(Authctxt *);",
      "int\tuserauth_passwd(Authctxt *);",
      "int\tuserauth_kbdint(Authctxt *);",
      "int\tuserauth_hostbased(Authctxt *);",
      "void\tuserauth(Authctxt *, char *);",
      "static void pubkey_prepare(Authctxt *);",
      "static void pubkey_cleanup(Authctxt *);",
      "static void pubkey_reset(Authctxt *);",
      "static Authmethod *authmethod_get(char *authlist);",
      "static Authmethod *authmethod_lookup(const char *name);",
      "static char *authmethods_get(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Authentication succeeded (%s).\"",
            "authctxt.method->name"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Authentication failed.\""
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_dispatch_range",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_MIN",
            "SSH2_MSG_USERAUTH_MAX",
            "NULL"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_dispatch_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dispatch.c",
          "lines": "69-79",
          "snippet": "void\nssh_dispatch_range(struct ssh *ssh, u_int from, u_int to, dispatch_fn *fn)\n{\n\tu_int i;\n\n\tfor (i = from; i <= to; i++) {\n\t\tif (i >= DISPATCH_MAX)\n\t\t\tbreak;\n\t\tssh->dispatch[i] = fn;\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"dispatch.h\"",
            "#include \"log.h\"",
            "#include \"ssh2.h\"",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include <stdarg.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_dispatch_range(struct ssh *ssh, u_int from, u_int to, dispatch_fn *fn)\n{\n\tu_int i;\n\n\tfor (i = from; i <= to; i++) {\n\t\tif (i >= DISPATCH_MAX)\n\t\t\tbreak;\n\t\tssh->dispatch[i] = fn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pubkey_cleanup",
          "args": [
            "&authctxt"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "pubkey_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "1618-1634",
          "snippet": "static void\npubkey_cleanup(Authctxt *authctxt)\n{\n\tIdentity *id;\n\n\tif (authctxt->agent_fd != -1) {\n\t\tssh_close_authentication_socket(authctxt->agent_fd);\n\t\tauthctxt->agent_fd = -1;\n\t}\n\tfor (id = TAILQ_FIRST(&authctxt->keys); id;\n\t    id = TAILQ_FIRST(&authctxt->keys)) {\n\t\tTAILQ_REMOVE(&authctxt->keys, id, next);\n\t\tsshkey_free(id->key);\n\t\tfree(id->filename);\n\t\tfree(id);\n\t}\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tuserauth_none(Authctxt *);",
            "int\tuserauth_pubkey(Authctxt *);",
            "int\tuserauth_passwd(Authctxt *);",
            "int\tuserauth_kbdint(Authctxt *);",
            "int\tuserauth_hostbased(Authctxt *);",
            "void\tuserauth(Authctxt *, char *);",
            "static int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);",
            "static void pubkey_prepare(Authctxt *);",
            "static void pubkey_cleanup(Authctxt *);",
            "static void pubkey_reset(Authctxt *);",
            "static struct sshkey *load_identity_file(Identity *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic int sign_and_send_pubkey(struct ssh *ssh, Authctxt *, Identity *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic struct sshkey *load_identity_file(Identity *);\n\nstatic void\npubkey_cleanup(Authctxt *authctxt)\n{\n\tIdentity *id;\n\n\tif (authctxt->agent_fd != -1) {\n\t\tssh_close_authentication_socket(authctxt->agent_fd);\n\t\tauthctxt->agent_fd = -1;\n\t}\n\tfor (id = TAILQ_FIRST(&authctxt->keys); id;\n\t    id = TAILQ_FIRST(&authctxt->keys)) {\n\t\tTAILQ_REMOVE(&authctxt->keys, id, next);\n\t\tsshkey_free(id->key);\n\t\tfree(id->filename);\n\t\tfree(id);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_dispatch_run_fatal",
          "args": [
            "ssh",
            "DISPATCH_BLOCK",
            "&authctxt.success"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_dispatch_run_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dispatch.c",
          "lines": "128-135",
          "snippet": "void\nssh_dispatch_run_fatal(struct ssh *ssh, int mode, volatile sig_atomic_t *done)\n{\n\tint r;\n\n\tif ((r = ssh_dispatch_run(ssh, mode, done)) != 0)\n\t\tsshpkt_fatal(ssh, __func__, r);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"dispatch.h\"",
            "#include \"log.h\"",
            "#include \"ssh2.h\"",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include <stdarg.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_dispatch_run_fatal(struct ssh *ssh, int mode, volatile sig_atomic_t *done)\n{\n\tint r;\n\n\tif ((r = ssh_dispatch_run(ssh, mode, done)) != 0)\n\t\tsshpkt_fatal(ssh, __func__, r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_dispatch_set",
          "args": [
            "ssh",
            "SSH2_MSG_SERVICE_ACCEPT",
            "&input_userauth_service_accept"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_dispatch_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dispatch.c",
          "lines": "81-85",
          "snippet": "void\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"dispatch.h\"",
            "#include \"log.h\"",
            "#include \"ssh2.h\"",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include <stdarg.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_dispatch_init",
          "args": [
            "ssh",
            "&input_userauth_error"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_dispatch_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dispatch.c",
          "lines": "61-67",
          "snippet": "void\nssh_dispatch_init(struct ssh *ssh, dispatch_fn *dflt)\n{\n\tu_int i;\n\tfor (i = 0; i < DISPATCH_MAX; i++)\n\t\tssh->dispatch[i] = dflt;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"dispatch.h\"",
            "#include \"log.h\"",
            "#include \"ssh2.h\"",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include <stdarg.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_dispatch_init(struct ssh *ssh, dispatch_fn *dflt)\n{\n\tu_int i;\n\tfor (i = 0; i < DISPATCH_MAX; i++)\n\t\tssh->dispatch[i] = dflt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_cstring",
          "args": [
            "ssh",
            "\"ssh-userauth\""
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2459-2463",
          "snippet": "int\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_SERVICE_REQUEST"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pubkey_prepare",
          "args": [
            "&authctxt"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "pubkey_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "1482-1616",
          "snippet": "static void\npubkey_prepare(Authctxt *authctxt)\n{\n\tstruct identity *id, *id2, *tmp;\n\tstruct idlist agent, files, *preferred;\n\tstruct sshkey *key;\n\tint agent_fd = -1, i, r, found;\n\tsize_t j;\n\tstruct ssh_identitylist *idlist;\n\tchar *ident;\n\n\tTAILQ_INIT(&agent);\t/* keys from the agent */\n\tTAILQ_INIT(&files);\t/* keys from the config file */\n\tpreferred = &authctxt->keys;\n\tTAILQ_INIT(preferred);\t/* preferred order of keys */\n\n\t/* list of keys stored in the filesystem and PKCS#11 */\n\tfor (i = 0; i < options.num_identity_files; i++) {\n\t\tkey = options.identity_keys[i];\n\t\tif (key && key->cert && key->cert->type != SSH2_CERT_TYPE_USER)\n\t\t\tcontinue;\n\t\toptions.identity_keys[i] = NULL;\n\t\tid = xcalloc(1, sizeof(*id));\n\t\tid->agent_fd = -1;\n\t\tid->key = key;\n\t\tid->filename = xstrdup(options.identity_files[i]);\n\t\tid->userprovided = options.identity_file_userprovided[i];\n\t\tTAILQ_INSERT_TAIL(&files, id, next);\n\t}\n\t/* list of certificates specified by user */\n\tfor (i = 0; i < options.num_certificate_files; i++) {\n\t\tkey = options.certificates[i];\n\t\tif (!sshkey_is_cert(key) || key->cert == NULL ||\n\t\t    key->cert->type != SSH2_CERT_TYPE_USER)\n\t\t\tcontinue;\n\t\tid = xcalloc(1, sizeof(*id));\n\t\tid->agent_fd = -1;\n\t\tid->key = key;\n\t\tid->filename = xstrdup(options.certificate_files[i]);\n\t\tid->userprovided = options.certificate_file_userprovided[i];\n\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t}\n\t/* list of keys supported by the agent */\n\tif ((r = ssh_get_authentication_socket(&agent_fd)) != 0) {\n\t\tif (r != SSH_ERR_AGENT_NOT_PRESENT)\n\t\t\tdebug(\"%s: ssh_get_authentication_socket: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t} else if ((r = ssh_fetch_identitylist(agent_fd, &idlist)) != 0) {\n\t\tif (r != SSH_ERR_AGENT_NO_IDENTITIES)\n\t\t\tdebug(\"%s: ssh_fetch_identitylist: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\tclose(agent_fd);\n\t} else {\n\t\tfor (j = 0; j < idlist->nkeys; j++) {\n\t\t\tfound = 0;\n\t\t\tTAILQ_FOREACH(id, &files, next) {\n\t\t\t\t/*\n\t\t\t\t * agent keys from the config file are\n\t\t\t\t * preferred\n\t\t\t\t */\n\t\t\t\tif (sshkey_equal(idlist->keys[j], id->key)) {\n\t\t\t\t\tTAILQ_REMOVE(&files, id, next);\n\t\t\t\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t\t\t\t\tid->agent_fd = agent_fd;\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found && !options.identities_only) {\n\t\t\t\tid = xcalloc(1, sizeof(*id));\n\t\t\t\t/* XXX \"steals\" key/comment from idlist */\n\t\t\t\tid->key = idlist->keys[j];\n\t\t\t\tid->filename = idlist->comments[j];\n\t\t\t\tidlist->keys[j] = NULL;\n\t\t\t\tidlist->comments[j] = NULL;\n\t\t\t\tid->agent_fd = agent_fd;\n\t\t\t\tTAILQ_INSERT_TAIL(&agent, id, next);\n\t\t\t}\n\t\t}\n\t\tssh_free_identitylist(idlist);\n\t\t/* append remaining agent keys */\n\t\tfor (id = TAILQ_FIRST(&agent); id; id = TAILQ_FIRST(&agent)) {\n\t\t\tTAILQ_REMOVE(&agent, id, next);\n\t\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t\t}\n\t\tauthctxt->agent_fd = agent_fd;\n\t}\n\t/* Prefer PKCS11 keys that are explicitly listed */\n\tTAILQ_FOREACH_SAFE(id, &files, next, tmp) {\n\t\tif (id->key == NULL || (id->key->flags & SSHKEY_FLAG_EXT) == 0)\n\t\t\tcontinue;\n\t\tfound = 0;\n\t\tTAILQ_FOREACH(id2, &files, next) {\n\t\t\tif (id2->key == NULL ||\n\t\t\t    (id2->key->flags & SSHKEY_FLAG_EXT) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (sshkey_equal(id->key, id2->key)) {\n\t\t\t\tTAILQ_REMOVE(&files, id, next);\n\t\t\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* If IdentitiesOnly set and key not found then don't use it */\n\t\tif (!found && options.identities_only) {\n\t\t\tTAILQ_REMOVE(&files, id, next);\n\t\t\tfreezero(id, sizeof(*id));\n\t\t}\n\t}\n\t/* append remaining keys from the config file */\n\tfor (id = TAILQ_FIRST(&files); id; id = TAILQ_FIRST(&files)) {\n\t\tTAILQ_REMOVE(&files, id, next);\n\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t}\n\t/* finally, filter by PubkeyAcceptedKeyTypes */\n\tTAILQ_FOREACH_SAFE(id, preferred, next, id2) {\n\t\tif (id->key != NULL && !key_type_allowed_by_config(id->key)) {\n\t\t\tdebug(\"Skipping %s key %s - \"\n\t\t\t    \"not in PubkeyAcceptedKeyTypes\",\n\t\t\t    sshkey_ssh_name(id->key), id->filename);\n\t\t\tTAILQ_REMOVE(preferred, id, next);\n\t\t\tsshkey_free(id->key);\n\t\t\tfree(id->filename);\n\t\t\tmemset(id, 0, sizeof(*id));\n\t\t\tcontinue;\n\t\t}\n\t}\n\t/* List the keys we plan on using */\n\tTAILQ_FOREACH_SAFE(id, preferred, next, id2) {\n\t\tident = format_identity(id);\n\t\tdebug(\"Will attempt key: %s\", ident);\n\t\tfree(ident);\n\t}\n\tdebug2(\"%s: done\", __func__);\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "int\tuserauth_none(Authctxt *);",
            "int\tuserauth_pubkey(Authctxt *);",
            "int\tuserauth_passwd(Authctxt *);",
            "int\tuserauth_kbdint(Authctxt *);",
            "int\tuserauth_hostbased(Authctxt *);",
            "void\tuserauth(Authctxt *, char *);",
            "static void pubkey_prepare(Authctxt *);",
            "static void pubkey_cleanup(Authctxt *);",
            "static void pubkey_reset(Authctxt *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\n\nstatic void\npubkey_prepare(Authctxt *authctxt)\n{\n\tstruct identity *id, *id2, *tmp;\n\tstruct idlist agent, files, *preferred;\n\tstruct sshkey *key;\n\tint agent_fd = -1, i, r, found;\n\tsize_t j;\n\tstruct ssh_identitylist *idlist;\n\tchar *ident;\n\n\tTAILQ_INIT(&agent);\t/* keys from the agent */\n\tTAILQ_INIT(&files);\t/* keys from the config file */\n\tpreferred = &authctxt->keys;\n\tTAILQ_INIT(preferred);\t/* preferred order of keys */\n\n\t/* list of keys stored in the filesystem and PKCS#11 */\n\tfor (i = 0; i < options.num_identity_files; i++) {\n\t\tkey = options.identity_keys[i];\n\t\tif (key && key->cert && key->cert->type != SSH2_CERT_TYPE_USER)\n\t\t\tcontinue;\n\t\toptions.identity_keys[i] = NULL;\n\t\tid = xcalloc(1, sizeof(*id));\n\t\tid->agent_fd = -1;\n\t\tid->key = key;\n\t\tid->filename = xstrdup(options.identity_files[i]);\n\t\tid->userprovided = options.identity_file_userprovided[i];\n\t\tTAILQ_INSERT_TAIL(&files, id, next);\n\t}\n\t/* list of certificates specified by user */\n\tfor (i = 0; i < options.num_certificate_files; i++) {\n\t\tkey = options.certificates[i];\n\t\tif (!sshkey_is_cert(key) || key->cert == NULL ||\n\t\t    key->cert->type != SSH2_CERT_TYPE_USER)\n\t\t\tcontinue;\n\t\tid = xcalloc(1, sizeof(*id));\n\t\tid->agent_fd = -1;\n\t\tid->key = key;\n\t\tid->filename = xstrdup(options.certificate_files[i]);\n\t\tid->userprovided = options.certificate_file_userprovided[i];\n\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t}\n\t/* list of keys supported by the agent */\n\tif ((r = ssh_get_authentication_socket(&agent_fd)) != 0) {\n\t\tif (r != SSH_ERR_AGENT_NOT_PRESENT)\n\t\t\tdebug(\"%s: ssh_get_authentication_socket: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t} else if ((r = ssh_fetch_identitylist(agent_fd, &idlist)) != 0) {\n\t\tif (r != SSH_ERR_AGENT_NO_IDENTITIES)\n\t\t\tdebug(\"%s: ssh_fetch_identitylist: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\tclose(agent_fd);\n\t} else {\n\t\tfor (j = 0; j < idlist->nkeys; j++) {\n\t\t\tfound = 0;\n\t\t\tTAILQ_FOREACH(id, &files, next) {\n\t\t\t\t/*\n\t\t\t\t * agent keys from the config file are\n\t\t\t\t * preferred\n\t\t\t\t */\n\t\t\t\tif (sshkey_equal(idlist->keys[j], id->key)) {\n\t\t\t\t\tTAILQ_REMOVE(&files, id, next);\n\t\t\t\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t\t\t\t\tid->agent_fd = agent_fd;\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found && !options.identities_only) {\n\t\t\t\tid = xcalloc(1, sizeof(*id));\n\t\t\t\t/* XXX \"steals\" key/comment from idlist */\n\t\t\t\tid->key = idlist->keys[j];\n\t\t\t\tid->filename = idlist->comments[j];\n\t\t\t\tidlist->keys[j] = NULL;\n\t\t\t\tidlist->comments[j] = NULL;\n\t\t\t\tid->agent_fd = agent_fd;\n\t\t\t\tTAILQ_INSERT_TAIL(&agent, id, next);\n\t\t\t}\n\t\t}\n\t\tssh_free_identitylist(idlist);\n\t\t/* append remaining agent keys */\n\t\tfor (id = TAILQ_FIRST(&agent); id; id = TAILQ_FIRST(&agent)) {\n\t\t\tTAILQ_REMOVE(&agent, id, next);\n\t\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t\t}\n\t\tauthctxt->agent_fd = agent_fd;\n\t}\n\t/* Prefer PKCS11 keys that are explicitly listed */\n\tTAILQ_FOREACH_SAFE(id, &files, next, tmp) {\n\t\tif (id->key == NULL || (id->key->flags & SSHKEY_FLAG_EXT) == 0)\n\t\t\tcontinue;\n\t\tfound = 0;\n\t\tTAILQ_FOREACH(id2, &files, next) {\n\t\t\tif (id2->key == NULL ||\n\t\t\t    (id2->key->flags & SSHKEY_FLAG_EXT) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (sshkey_equal(id->key, id2->key)) {\n\t\t\t\tTAILQ_REMOVE(&files, id, next);\n\t\t\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* If IdentitiesOnly set and key not found then don't use it */\n\t\tif (!found && options.identities_only) {\n\t\t\tTAILQ_REMOVE(&files, id, next);\n\t\t\tfreezero(id, sizeof(*id));\n\t\t}\n\t}\n\t/* append remaining keys from the config file */\n\tfor (id = TAILQ_FIRST(&files); id; id = TAILQ_FIRST(&files)) {\n\t\tTAILQ_REMOVE(&files, id, next);\n\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t}\n\t/* finally, filter by PubkeyAcceptedKeyTypes */\n\tTAILQ_FOREACH_SAFE(id, preferred, next, id2) {\n\t\tif (id->key != NULL && !key_type_allowed_by_config(id->key)) {\n\t\t\tdebug(\"Skipping %s key %s - \"\n\t\t\t    \"not in PubkeyAcceptedKeyTypes\",\n\t\t\t    sshkey_ssh_name(id->key), id->filename);\n\t\t\tTAILQ_REMOVE(preferred, id, next);\n\t\t\tsshkey_free(id->key);\n\t\t\tfree(id->filename);\n\t\t\tmemset(id, 0, sizeof(*id));\n\t\t\tcontinue;\n\t\t}\n\t}\n\t/* List the keys we plan on using */\n\tTAILQ_FOREACH_SAFE(id, preferred, next, id2) {\n\t\tident = format_identity(id);\n\t\tdebug(\"Will attempt key: %s\", ident);\n\t\tfree(ident);\n\t}\n\tdebug2(\"%s: done\", __func__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "authmethod_lookup",
          "args": [
            "\"none\""
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "authmethod_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "2077-2087",
          "snippet": "static Authmethod *\nauthmethod_lookup(const char *name)\n{\n\tAuthmethod *method = NULL;\n\tif (name != NULL)\n\t\tfor (method = authmethods; method->name != NULL; method++)\n\t\t\tif (strcmp(name, method->name) == 0)\n\t\t\t\treturn method;\n\tdebug2(\"Unrecognized authentication method name: %s\", name ? name : \"NULL\");\n\treturn NULL;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Authmethod *authmethod_lookup(const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Authmethod *authmethod_lookup(const char *name);\n\nstatic Authmethod *\nauthmethod_lookup(const char *name)\n{\n\tAuthmethod *method = NULL;\n\tif (name != NULL)\n\t\tfor (method = authmethods; method->name != NULL; method++)\n\t\t\tif (strcmp(name, method->name) == 0)\n\t\t\t\treturn method;\n\tdebug2(\"Unrecognized authentication method name: %s\", name ? name : \"NULL\");\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&authctxt",
            "0",
            "sizeof(authctxt)"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "authmethods_get",
          "args": [],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "authmethods_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "2139-2161",
          "snippet": "static char *\nauthmethods_get(void)\n{\n\tAuthmethod *method = NULL;\n\tstruct sshbuf *b;\n\tchar *list;\n\tint r;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tfor (method = authmethods; method->name != NULL; method++) {\n\t\tif (authmethod_is_enabled(method)) {\n\t\t\tif ((r = sshbuf_putf(b, \"%s%s\",\n\t\t\t    sshbuf_len(b) ? \",\" : \"\", method->name)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t}\n\tif ((list = sshbuf_dup_string(b)) == NULL)\n\t\tfatal(\"%s: sshbuf_dup_string failed\", __func__);\n\tsshbuf_free(b);\n\treturn list;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Authmethod *authmethod_lookup(const char *name);",
            "static char *authmethods_get(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic Authmethod *authmethod_lookup(const char *name);\nstatic char *authmethods_get(void);\n\nstatic char *\nauthmethods_get(void)\n{\n\tAuthmethod *method = NULL;\n\tstruct sshbuf *b;\n\tchar *list;\n\tint r;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tfor (method = authmethods; method->name != NULL; method++) {\n\t\tif (authmethod_is_enabled(method)) {\n\t\t\tif ((r = sshbuf_putf(b, \"%s%s\",\n\t\t\t    sshbuf_len(b) ? \",\" : \"\", method->name)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t}\n\tif ((list = sshbuf_dup_string(b)) == NULL)\n\t\tfatal(\"%s: sshbuf_dup_string failed\", __func__);\n\tsshbuf_free(b);\n\treturn list;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic Authmethod *authmethod_get(char *authlist);\nstatic Authmethod *authmethod_lookup(const char *name);\nstatic char *authmethods_get(void);\n\nvoid\nssh_userauth2(const char *local_user, const char *server_user, char *host,\n    Sensitive *sensitive)\n{\n\tstruct ssh *ssh = active_state;\n\tAuthctxt authctxt;\n\tint r;\n\n\tif (options.challenge_response_authentication)\n\t\toptions.kbd_interactive_authentication = 1;\n\tif (options.preferred_authentications == NULL)\n\t\toptions.preferred_authentications = authmethods_get();\n\n\t/* setup authentication context */\n\tmemset(&authctxt, 0, sizeof(authctxt));\n\tauthctxt.server_user = server_user;\n\tauthctxt.local_user = local_user;\n\tauthctxt.host = host;\n\tauthctxt.service = \"ssh-connection\";\t\t/* service name */\n\tauthctxt.success = 0;\n\tauthctxt.method = authmethod_lookup(\"none\");\n\tauthctxt.authlist = NULL;\n\tauthctxt.methoddata = NULL;\n\tauthctxt.sensitive = sensitive;\n\tauthctxt.active_ktype = authctxt.oktypes = authctxt.ktypes = NULL;\n\tauthctxt.info_req_seen = 0;\n\tauthctxt.agent_fd = -1;\n\tpubkey_prepare(&authctxt);\n\tif (authctxt.method == NULL)\n\t\tfatal(\"ssh_userauth2: internal error: cannot send userauth none request\");\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_SERVICE_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"ssh-userauth\")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tssh->authctxt = &authctxt;\n\tssh_dispatch_init(ssh, &input_userauth_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &input_userauth_ext_info);\n\tssh_dispatch_set(ssh, SSH2_MSG_SERVICE_ACCEPT, &input_userauth_service_accept);\n\tssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &authctxt.success);\t/* loop until success */\n\tssh->authctxt = NULL;\n\n\tpubkey_cleanup(&authctxt);\n\tssh_dispatch_range(ssh, SSH2_MSG_USERAUTH_MIN, SSH2_MSG_USERAUTH_MAX, NULL);\n\n\tif (!authctxt.success)\n\t\tfatal(\"Authentication failed.\");\n\tdebug(\"Authentication succeeded (%s).\", authctxt.method->name);\n}"
  },
  {
    "function_name": "ssh_kex2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "157-241",
    "snippet": "void\nssh_kex2(char *host, struct sockaddr *hostaddr, u_short port)\n{\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tchar *s, *all_key;\n\tstruct kex *kex;\n\tint r;\n\n\txxx_host = host;\n\txxx_hostaddr = hostaddr;\n\n\tif ((s = kex_names_cat(options.kex_algorithms, \"ext-info-c\")) == NULL)\n\t\tfatal(\"%s: kex_names_cat\", __func__);\n\tmyproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(s);\n\tmyproposal[PROPOSAL_ENC_ALGS_CTOS] =\n\t    compat_cipher_proposal(options.ciphers);\n\tmyproposal[PROPOSAL_ENC_ALGS_STOC] =\n\t    compat_cipher_proposal(options.ciphers);\n\tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_COMP_ALGS_STOC] = options.compression ?\n\t    \"zlib@openssh.com,zlib,none\" : \"none,zlib@openssh.com,zlib\";\n\tmyproposal[PROPOSAL_MAC_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;\n\tif (options.hostkeyalgorithms != NULL) {\n\t\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\t\tif (kex_assemble_names(&options.hostkeyalgorithms,\n\t\t    KEX_DEFAULT_PK_ALG, all_key) != 0)\n\t\t\tfatal(\"%s: kex_assemble_namelist\", __func__);\n\t\tfree(all_key);\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =\n\t\t    compat_pkalg_proposal(options.hostkeyalgorithms);\n\t} else {\n\t\t/* Enforce default */\n\t\toptions.hostkeyalgorithms = xstrdup(KEX_DEFAULT_PK_ALG);\n\t\t/* Prefer algorithms that we already have keys for */\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =\n\t\t    compat_pkalg_proposal(\n\t\t    order_hostkeyalgs(host, hostaddr, port));\n\t}\n\n\tif (options.rekey_limit || options.rekey_interval)\n\t\tpacket_set_rekey_limits(options.rekey_limit,\n\t\t    options.rekey_interval);\n\n\t/* start key exchange */\n\tif ((r = kex_setup(active_state, myproposal)) != 0)\n\t\tfatal(\"kex_setup: %s\", ssh_err(r));\n\tkex = active_state->kex;\n#ifdef WITH_OPENSSL\n\tkex->kex[KEX_DH_GRP1_SHA1] = kexdh_client;\n\tkex->kex[KEX_DH_GRP14_SHA1] = kexdh_client;\n\tkex->kex[KEX_DH_GRP14_SHA256] = kexdh_client;\n\tkex->kex[KEX_DH_GRP16_SHA512] = kexdh_client;\n\tkex->kex[KEX_DH_GRP18_SHA512] = kexdh_client;\n\tkex->kex[KEX_DH_GEX_SHA1] = kexgex_client;\n\tkex->kex[KEX_DH_GEX_SHA256] = kexgex_client;\n# ifdef OPENSSL_HAS_ECC\n\tkex->kex[KEX_ECDH_SHA2] = kexecdh_client;\n# endif\n#endif\n\tkex->kex[KEX_C25519_SHA256] = kexc25519_client;\n\tkex->client_version_string=client_version_string;\n\tkex->server_version_string=server_version_string;\n\tkex->verify_host_key=&verify_host_key_callback;\n\n\tssh_dispatch_run_fatal(active_state, DISPATCH_BLOCK, &kex->done);\n\n\t/* remove ext-info from the KEX proposals for rekeying */\n\tmyproposal[PROPOSAL_KEX_ALGS] =\n\t    compat_kex_proposal(options.kex_algorithms);\n\tif ((r = kex_prop2buf(kex->my, myproposal)) != 0)\n\t\tfatal(\"kex_prop2buf: %s\", ssh_err(r));\n\n\tsession_id2 = kex->session_id;\n\tsession_id2_len = kex->session_id_len;\n\n#ifdef DEBUG_KEXDH\n\t/* send 1st encrypted/maced/compressed message */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_IGNORE)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"markus\")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n#endif\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char *client_version_string;",
      "extern char *server_version_string;",
      "extern Options options;",
      "u_char *session_id2 = NULL;",
      "u_int session_id2_len = 0;",
      "char *xxx_host;",
      "struct sockaddr *xxx_hostaddr;",
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_write_wait",
          "args": [
            "ssh"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_write_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "1930-1985",
          "snippet": "int\nssh_packet_write_wait(struct ssh *ssh)\n{\n\tfd_set *setp;\n\tint ret, r, ms_remain = 0;\n\tstruct timeval start, timeout, *timeoutp = NULL;\n\tstruct session_state *state = ssh->state;\n\n\tsetp = calloc(howmany(state->connection_out + 1,\n\t    NFDBITS), sizeof(fd_mask));\n\tif (setp == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = ssh_packet_write_poll(ssh)) != 0) {\n\t\tfree(setp);\n\t\treturn r;\n\t}\n\twhile (ssh_packet_have_data_to_write(ssh)) {\n\t\tmemset(setp, 0, howmany(state->connection_out + 1,\n\t\t    NFDBITS) * sizeof(fd_mask));\n\t\tFD_SET(state->connection_out, setp);\n\n\t\tif (state->packet_timeout_ms > 0) {\n\t\t\tms_remain = state->packet_timeout_ms;\n\t\t\ttimeoutp = &timeout;\n\t\t}\n\t\tfor (;;) {\n\t\t\tif (state->packet_timeout_ms != -1) {\n\t\t\t\tms_to_timeval(&timeout, ms_remain);\n\t\t\t\tmonotime_tv(&start);\n\t\t\t}\n\t\t\tif ((ret = select(state->connection_out + 1,\n\t\t\t    NULL, setp, NULL, timeoutp)) >= 0)\n\t\t\t\tbreak;\n\t\t\tif (errno != EAGAIN && errno != EINTR &&\n\t\t\t    errno != EWOULDBLOCK)\n\t\t\t\tbreak;\n\t\t\tif (state->packet_timeout_ms == -1)\n\t\t\t\tcontinue;\n\t\t\tms_subtract_diff(&start, &ms_remain);\n\t\t\tif (ms_remain <= 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ret == 0) {\n\t\t\tfree(setp);\n\t\t\treturn SSH_ERR_CONN_TIMEOUT;\n\t\t}\n\t\tif ((r = ssh_packet_write_poll(ssh)) != 0) {\n\t\t\tfree(setp);\n\t\t\treturn r;\n\t\t}\n\t}\n\tfree(setp);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_packet_write_wait(struct ssh *ssh)\n{\n\tfd_set *setp;\n\tint ret, r, ms_remain = 0;\n\tstruct timeval start, timeout, *timeoutp = NULL;\n\tstruct session_state *state = ssh->state;\n\n\tsetp = calloc(howmany(state->connection_out + 1,\n\t    NFDBITS), sizeof(fd_mask));\n\tif (setp == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = ssh_packet_write_poll(ssh)) != 0) {\n\t\tfree(setp);\n\t\treturn r;\n\t}\n\twhile (ssh_packet_have_data_to_write(ssh)) {\n\t\tmemset(setp, 0, howmany(state->connection_out + 1,\n\t\t    NFDBITS) * sizeof(fd_mask));\n\t\tFD_SET(state->connection_out, setp);\n\n\t\tif (state->packet_timeout_ms > 0) {\n\t\t\tms_remain = state->packet_timeout_ms;\n\t\t\ttimeoutp = &timeout;\n\t\t}\n\t\tfor (;;) {\n\t\t\tif (state->packet_timeout_ms != -1) {\n\t\t\t\tms_to_timeval(&timeout, ms_remain);\n\t\t\t\tmonotime_tv(&start);\n\t\t\t}\n\t\t\tif ((ret = select(state->connection_out + 1,\n\t\t\t    NULL, setp, NULL, timeoutp)) >= 0)\n\t\t\t\tbreak;\n\t\t\tif (errno != EAGAIN && errno != EINTR &&\n\t\t\t    errno != EWOULDBLOCK)\n\t\t\t\tbreak;\n\t\t\tif (state->packet_timeout_ms == -1)\n\t\t\t\tcontinue;\n\t\t\tms_subtract_diff(&start, &ms_remain);\n\t\t\tif (ms_remain <= 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ret == 0) {\n\t\t\tfree(setp);\n\t\t\treturn SSH_ERR_CONN_TIMEOUT;\n\t\t}\n\t\tif ((r = ssh_packet_write_poll(ssh)) != 0) {\n\t\t\tfree(setp);\n\t\t\treturn r;\n\t\t}\n\t}\n\tfree(setp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_cstring",
          "args": [
            "ssh",
            "\"markus\""
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2459-2463",
          "snippet": "int\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_IGNORE"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"kex_prop2buf: %s\"",
            "ssh_err(r)"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kex_prop2buf",
          "args": [
            "kex->my",
            "myproposal"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "kex_prop2buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/kex.c",
          "lines": "297-321",
          "snippet": "int\nkex_prop2buf(struct sshbuf *b, char *proposal[PROPOSAL_MAX])\n{\n\tu_int i;\n\tint r;\n\n\tsshbuf_reset(b);\n\n\t/*\n\t * add a dummy cookie, the cookie will be overwritten by\n\t * kex_send_kexinit(), each time a kexinit is set\n\t */\n\tfor (i = 0; i < KEX_COOKIE_LEN; i++) {\n\t\tif ((r = sshbuf_put_u8(b, 0)) != 0)\n\t\t\treturn r;\n\t}\n\tfor (i = 0; i < PROPOSAL_MAX; i++) {\n\t\tif ((r = sshbuf_put_cstring(b, proposal[i])) != 0)\n\t\t\treturn r;\n\t}\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* first_kex_packet_follows */\n\t    (r = sshbuf_put_u32(b, 0)) != 0)\t/* uint32 reserved */\n\t\treturn r;\n\treturn 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor.h\"",
            "#include \"dispatch.h\"",
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"log.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include <openssl/dh.h>",
            "#include <openssl/crypto.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"monitor.h\"\n#include \"dispatch.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include <openssl/dh.h>\n#include <openssl/crypto.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include \"includes.h\"\n\nint\nkex_prop2buf(struct sshbuf *b, char *proposal[PROPOSAL_MAX])\n{\n\tu_int i;\n\tint r;\n\n\tsshbuf_reset(b);\n\n\t/*\n\t * add a dummy cookie, the cookie will be overwritten by\n\t * kex_send_kexinit(), each time a kexinit is set\n\t */\n\tfor (i = 0; i < KEX_COOKIE_LEN; i++) {\n\t\tif ((r = sshbuf_put_u8(b, 0)) != 0)\n\t\t\treturn r;\n\t}\n\tfor (i = 0; i < PROPOSAL_MAX; i++) {\n\t\tif ((r = sshbuf_put_cstring(b, proposal[i])) != 0)\n\t\t\treturn r;\n\t}\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t/* first_kex_packet_follows */\n\t    (r = sshbuf_put_u32(b, 0)) != 0)\t/* uint32 reserved */\n\t\treturn r;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_kex_proposal",
          "args": [
            "options.kex_algorithms"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "compat_kex_proposal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/compat.c",
          "lines": "214-234",
          "snippet": "char *\ncompat_kex_proposal(char *p)\n{\n\tif ((datafellows & (SSH_BUG_CURVE25519PAD|SSH_OLD_DHGEX)) == 0)\n\t\treturn p;\n\tdebug2(\"%s: original KEX proposal: %s\", __func__, p);\n\tif ((datafellows & SSH_BUG_CURVE25519PAD) != 0)\n\t\tif ((p = match_filter_blacklist(p,\n\t\t    \"curve25519-sha256@libssh.org\")) == NULL)\n\t\t\tfatal(\"match_filter_blacklist failed\");\n\tif ((datafellows & SSH_OLD_DHGEX) != 0) {\n\t\tif ((p = match_filter_blacklist(p,\n\t\t    \"diffie-hellman-group-exchange-sha256,\"\n\t\t    \"diffie-hellman-group-exchange-sha1\")) == NULL)\n\t\t\tfatal(\"match_filter_blacklist failed\");\n\t}\n\tdebug2(\"%s: compat KEX proposal: %s\", __func__, p);\n\tif (*p == '\\0')\n\t\tfatal(\"No supported key exchange algorithms found\");\n\treturn p;\n}",
          "includes": [
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int datafellows = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kex.h\"\n#include \"match.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint datafellows = 0;\n\nchar *\ncompat_kex_proposal(char *p)\n{\n\tif ((datafellows & (SSH_BUG_CURVE25519PAD|SSH_OLD_DHGEX)) == 0)\n\t\treturn p;\n\tdebug2(\"%s: original KEX proposal: %s\", __func__, p);\n\tif ((datafellows & SSH_BUG_CURVE25519PAD) != 0)\n\t\tif ((p = match_filter_blacklist(p,\n\t\t    \"curve25519-sha256@libssh.org\")) == NULL)\n\t\t\tfatal(\"match_filter_blacklist failed\");\n\tif ((datafellows & SSH_OLD_DHGEX) != 0) {\n\t\tif ((p = match_filter_blacklist(p,\n\t\t    \"diffie-hellman-group-exchange-sha256,\"\n\t\t    \"diffie-hellman-group-exchange-sha1\")) == NULL)\n\t\t\tfatal(\"match_filter_blacklist failed\");\n\t}\n\tdebug2(\"%s: compat KEX proposal: %s\", __func__, p);\n\tif (*p == '\\0')\n\t\tfatal(\"No supported key exchange algorithms found\");\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_dispatch_run_fatal",
          "args": [
            "active_state",
            "DISPATCH_BLOCK",
            "&kex->done"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_dispatch_run_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dispatch.c",
          "lines": "128-135",
          "snippet": "void\nssh_dispatch_run_fatal(struct ssh *ssh, int mode, volatile sig_atomic_t *done)\n{\n\tint r;\n\n\tif ((r = ssh_dispatch_run(ssh, mode, done)) != 0)\n\t\tsshpkt_fatal(ssh, __func__, r);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"dispatch.h\"",
            "#include \"log.h\"",
            "#include \"ssh2.h\"",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include <stdarg.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_dispatch_run_fatal(struct ssh *ssh, int mode, volatile sig_atomic_t *done)\n{\n\tint r;\n\n\tif ((r = ssh_dispatch_run(ssh, mode, done)) != 0)\n\t\tsshpkt_fatal(ssh, __func__, r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kex_setup",
          "args": [
            "active_state",
            "myproposal"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "kex_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/kex.c",
          "lines": "664-677",
          "snippet": "int\nkex_setup(struct ssh *ssh, char *proposal[PROPOSAL_MAX])\n{\n\tint r;\n\n\tif ((r = kex_new(ssh, proposal, &ssh->kex)) != 0)\n\t\treturn r;\n\tif ((r = kex_send_kexinit(ssh)) != 0) {\t\t/* we start */\n\t\tkex_free(ssh->kex);\n\t\tssh->kex = NULL;\n\t\treturn r;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor.h\"",
            "#include \"dispatch.h\"",
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"log.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include <openssl/dh.h>",
            "#include <openssl/crypto.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int kex_choose_conf(struct ssh *);",
            "static int kex_input_newkeys(int, u_int32_t, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"monitor.h\"\n#include \"dispatch.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include <openssl/dh.h>\n#include <openssl/crypto.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include \"includes.h\"\n\nstatic int kex_choose_conf(struct ssh *);\nstatic int kex_input_newkeys(int, u_int32_t, struct ssh *);\n\nint\nkex_setup(struct ssh *ssh, char *proposal[PROPOSAL_MAX])\n{\n\tint r;\n\n\tif ((r = kex_new(ssh, proposal, &ssh->kex)) != 0)\n\t\treturn r;\n\tif ((r = kex_send_kexinit(ssh)) != 0) {\t\t/* we start */\n\t\tkex_free(ssh->kex);\n\t\tssh->kex = NULL;\n\t\treturn r;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packet_set_rekey_limits",
          "args": [
            "options.rekey_limit",
            "options.rekey_interval"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_pkalg_proposal",
          "args": [
            "order_hostkeyalgs(host, hostaddr, port)"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "compat_pkalg_proposal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/compat.c",
          "lines": "200-212",
          "snippet": "char *\ncompat_pkalg_proposal(char *pkalg_prop)\n{\n\tif (!(datafellows & SSH_BUG_RSASIGMD5))\n\t\treturn pkalg_prop;\n\tdebug2(\"%s: original public key proposal: %s\", __func__, pkalg_prop);\n\tif ((pkalg_prop = match_filter_blacklist(pkalg_prop, \"ssh-rsa\")) == NULL)\n\t\tfatal(\"match_filter_blacklist failed\");\n\tdebug2(\"%s: compat public key proposal: %s\", __func__, pkalg_prop);\n\tif (*pkalg_prop == '\\0')\n\t\tfatal(\"No supported PK algorithms found\");\n\treturn pkalg_prop;\n}",
          "includes": [
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int datafellows = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kex.h\"\n#include \"match.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint datafellows = 0;\n\nchar *\ncompat_pkalg_proposal(char *pkalg_prop)\n{\n\tif (!(datafellows & SSH_BUG_RSASIGMD5))\n\t\treturn pkalg_prop;\n\tdebug2(\"%s: original public key proposal: %s\", __func__, pkalg_prop);\n\tif ((pkalg_prop = match_filter_blacklist(pkalg_prop, \"ssh-rsa\")) == NULL)\n\t\tfatal(\"match_filter_blacklist failed\");\n\tdebug2(\"%s: compat public key proposal: %s\", __func__, pkalg_prop);\n\tif (*pkalg_prop == '\\0')\n\t\tfatal(\"No supported PK algorithms found\");\n\treturn pkalg_prop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "order_hostkeyalgs",
          "args": [
            "host",
            "hostaddr",
            "port"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "order_hostkeyalgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "103-155",
          "snippet": "static char *\norder_hostkeyalgs(char *host, struct sockaddr *hostaddr, u_short port)\n{\n\tchar *oavail, *avail, *first, *last, *alg, *hostname, *ret;\n\tsize_t maxlen;\n\tstruct hostkeys *hostkeys;\n\tint ktype;\n\tu_int i;\n\n\t/* Find all hostkeys for this hostname */\n\tget_hostfile_hostname_ipaddr(host, hostaddr, port, &hostname, NULL);\n\thostkeys = init_hostkeys();\n\tfor (i = 0; i < options.num_user_hostfiles; i++)\n\t\tload_hostkeys(hostkeys, hostname, options.user_hostfiles[i]);\n\tfor (i = 0; i < options.num_system_hostfiles; i++)\n\t\tload_hostkeys(hostkeys, hostname, options.system_hostfiles[i]);\n\n\toavail = avail = xstrdup(KEX_DEFAULT_PK_ALG);\n\tmaxlen = strlen(avail) + 1;\n\tfirst = xmalloc(maxlen);\n\tlast = xmalloc(maxlen);\n\t*first = *last = '\\0';\n\n#define ALG_APPEND(to, from) \\\n\tdo { \\\n\t\tif (*to != '\\0') \\\n\t\t\tstrlcat(to, \",\", maxlen); \\\n\t\tstrlcat(to, from, maxlen); \\\n\t} while (0)\n\n\twhile ((alg = strsep(&avail, \",\")) && *alg != '\\0') {\n\t\tif ((ktype = sshkey_type_from_name(alg)) == KEY_UNSPEC)\n\t\t\tfatal(\"%s: unknown alg %s\", __func__, alg);\n\t\tif (lookup_key_in_hostkeys_by_type(hostkeys,\n\t\t    sshkey_type_plain(ktype), NULL))\n\t\t\tALG_APPEND(first, alg);\n\t\telse\n\t\t\tALG_APPEND(last, alg);\n\t}\n#undef ALG_APPEND\n\txasprintf(&ret, \"%s%s%s\", first,\n\t    (*first == '\\0' || *last == '\\0') ? \"\" : \",\", last);\n\tif (*first != '\\0')\n\t\tdebug3(\"%s: prefer hostkeyalgs: %s\", __func__, first);\n\n\tfree(first);\n\tfree(last);\n\tfree(hostname);\n\tfree(oavail);\n\tfree_hostkeys(hostkeys);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nstatic char *\norder_hostkeyalgs(char *host, struct sockaddr *hostaddr, u_short port)\n{\n\tchar *oavail, *avail, *first, *last, *alg, *hostname, *ret;\n\tsize_t maxlen;\n\tstruct hostkeys *hostkeys;\n\tint ktype;\n\tu_int i;\n\n\t/* Find all hostkeys for this hostname */\n\tget_hostfile_hostname_ipaddr(host, hostaddr, port, &hostname, NULL);\n\thostkeys = init_hostkeys();\n\tfor (i = 0; i < options.num_user_hostfiles; i++)\n\t\tload_hostkeys(hostkeys, hostname, options.user_hostfiles[i]);\n\tfor (i = 0; i < options.num_system_hostfiles; i++)\n\t\tload_hostkeys(hostkeys, hostname, options.system_hostfiles[i]);\n\n\toavail = avail = xstrdup(KEX_DEFAULT_PK_ALG);\n\tmaxlen = strlen(avail) + 1;\n\tfirst = xmalloc(maxlen);\n\tlast = xmalloc(maxlen);\n\t*first = *last = '\\0';\n\n#define ALG_APPEND(to, from) \\\n\tdo { \\\n\t\tif (*to != '\\0') \\\n\t\t\tstrlcat(to, \",\", maxlen); \\\n\t\tstrlcat(to, from, maxlen); \\\n\t} while (0)\n\n\twhile ((alg = strsep(&avail, \",\")) && *alg != '\\0') {\n\t\tif ((ktype = sshkey_type_from_name(alg)) == KEY_UNSPEC)\n\t\t\tfatal(\"%s: unknown alg %s\", __func__, alg);\n\t\tif (lookup_key_in_hostkeys_by_type(hostkeys,\n\t\t    sshkey_type_plain(ktype), NULL))\n\t\t\tALG_APPEND(first, alg);\n\t\telse\n\t\t\tALG_APPEND(last, alg);\n\t}\n#undef ALG_APPEND\n\txasprintf(&ret, \"%s%s%s\", first,\n\t    (*first == '\\0' || *last == '\\0') ? \"\" : \",\", last);\n\tif (*first != '\\0')\n\t\tdebug3(\"%s: prefer hostkeyalgs: %s\", __func__, first);\n\n\tfree(first);\n\tfree(last);\n\tfree(hostname);\n\tfree(oavail);\n\tfree_hostkeys(hostkeys);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "KEX_DEFAULT_PK_ALG"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "all_key"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kex_assemble_names",
          "args": [
            "&options.hostkeyalgorithms",
            "KEX_DEFAULT_PK_ALG",
            "all_key"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "kex_assemble_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/kex.c",
          "lines": "211-294",
          "snippet": "int\nkex_assemble_names(char **listp, const char *def, const char *all)\n{\n\tchar *cp, *tmp, *patterns;\n\tchar *list = NULL, *ret = NULL, *matching = NULL, *opatterns = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (listp == NULL || *listp == NULL || **listp == '\\0') {\n\t\tif ((*listp = strdup(def)) == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\treturn 0;\n\t}\n\n\tlist = *listp;\n\t*listp = NULL;\n\tif (*list == '+') {\n\t\t/* Append names to default list */\n\t\tif ((tmp = kex_names_cat(def, list + 1)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(list);\n\t\tlist = tmp;\n\t} else if (*list == '-') {\n\t\t/* Remove names from default list */\n\t\tif ((*listp = match_filter_blacklist(def, list + 1)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(list);\n\t\t/* filtering has already been done */\n\t\treturn 0;\n\t} else {\n\t\t/* Explicit list, overrides default - just use \"list\" as is */\n\t}\n\n\t/*\n\t * The supplied names may be a pattern-list. For the -list case,\n\t * the patterns are applied above. For the +list and explicit list\n\t * cases we need to do it now.\n\t */\n\tret = NULL;\n\tif ((patterns = opatterns = strdup(list)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto fail;\n\t}\n\t/* Apply positive (i.e. non-negated) patterns from the list */\n\twhile ((cp = strsep(&patterns, \",\")) != NULL) {\n\t\tif (*cp == '!') {\n\t\t\t/* negated matches are not supported here */\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(matching);\n\t\tif ((matching = match_filter_whitelist(all, cp)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t\tif ((tmp = kex_names_cat(ret, matching)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(ret);\n\t\tret = tmp;\n\t}\n\tif (ret == NULL || *ret == '\\0') {\n\t\t/* An empty name-list is an error */\n\t\t/* XXX better error code? */\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto fail;\n\t}\n\n\t/* success */\n\t*listp = ret;\n\tret = NULL;\n\tr = 0;\n\n fail:\n\tfree(matching);\n\tfree(opatterns);\n\tfree(list);\n\tfree(ret);\n\treturn r;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor.h\"",
            "#include \"dispatch.h\"",
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"log.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include <openssl/dh.h>",
            "#include <openssl/crypto.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"monitor.h\"\n#include \"dispatch.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include <openssl/dh.h>\n#include <openssl/crypto.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include \"includes.h\"\n\nint\nkex_assemble_names(char **listp, const char *def, const char *all)\n{\n\tchar *cp, *tmp, *patterns;\n\tchar *list = NULL, *ret = NULL, *matching = NULL, *opatterns = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (listp == NULL || *listp == NULL || **listp == '\\0') {\n\t\tif ((*listp = strdup(def)) == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\treturn 0;\n\t}\n\n\tlist = *listp;\n\t*listp = NULL;\n\tif (*list == '+') {\n\t\t/* Append names to default list */\n\t\tif ((tmp = kex_names_cat(def, list + 1)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(list);\n\t\tlist = tmp;\n\t} else if (*list == '-') {\n\t\t/* Remove names from default list */\n\t\tif ((*listp = match_filter_blacklist(def, list + 1)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(list);\n\t\t/* filtering has already been done */\n\t\treturn 0;\n\t} else {\n\t\t/* Explicit list, overrides default - just use \"list\" as is */\n\t}\n\n\t/*\n\t * The supplied names may be a pattern-list. For the -list case,\n\t * the patterns are applied above. For the +list and explicit list\n\t * cases we need to do it now.\n\t */\n\tret = NULL;\n\tif ((patterns = opatterns = strdup(list)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto fail;\n\t}\n\t/* Apply positive (i.e. non-negated) patterns from the list */\n\twhile ((cp = strsep(&patterns, \",\")) != NULL) {\n\t\tif (*cp == '!') {\n\t\t\t/* negated matches are not supported here */\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(matching);\n\t\tif ((matching = match_filter_whitelist(all, cp)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t\tif ((tmp = kex_names_cat(ret, matching)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(ret);\n\t\tret = tmp;\n\t}\n\tif (ret == NULL || *ret == '\\0') {\n\t\t/* An empty name-list is an error */\n\t\t/* XXX better error code? */\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto fail;\n\t}\n\n\t/* success */\n\t*listp = ret;\n\tret = NULL;\n\tr = 0;\n\n fail:\n\tfree(matching);\n\tfree(opatterns);\n\tfree(list);\n\tfree(ret);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_alg_list",
          "args": [
            "0",
            "0",
            "1",
            "','"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_alg_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "218-244",
          "snippet": "char *\nsshkey_alg_list(int certs_only, int plain_only, int include_sigonly, char sep)\n{\n\tchar *tmp, *ret = NULL;\n\tsize_t nlen, rlen = 0;\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->name == NULL)\n\t\t\tcontinue;\n\t\tif (!include_sigonly && kt->sigonly)\n\t\t\tcontinue;\n\t\tif ((certs_only && !kt->cert) || (plain_only && kt->cert))\n\t\t\tcontinue;\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(kt->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, kt->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nchar *\nsshkey_alg_list(int certs_only, int plain_only, int include_sigonly, char sep)\n{\n\tchar *tmp, *ret = NULL;\n\tsize_t nlen, rlen = 0;\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\tif (kt->name == NULL)\n\t\t\tcontinue;\n\t\tif (!include_sigonly && kt->sigonly)\n\t\t\tcontinue;\n\t\tif ((certs_only && !kt->cert) || (plain_only && kt->cert))\n\t\t\tcontinue;\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(kt->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, kt->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_cipher_proposal",
          "args": [
            "options.ciphers"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "compat_cipher_proposal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/compat.c",
          "lines": "186-198",
          "snippet": "char *\ncompat_cipher_proposal(char *cipher_prop)\n{\n\tif (!(datafellows & SSH_BUG_BIGENDIANAES))\n\t\treturn cipher_prop;\n\tdebug2(\"%s: original cipher proposal: %s\", __func__, cipher_prop);\n\tif ((cipher_prop = match_filter_blacklist(cipher_prop, \"aes*\")) == NULL)\n\t\tfatal(\"match_filter_blacklist failed\");\n\tdebug2(\"%s: compat cipher proposal: %s\", __func__, cipher_prop);\n\tif (*cipher_prop == '\\0')\n\t\tfatal(\"No supported ciphers found\");\n\treturn cipher_prop;\n}",
          "includes": [
            "#include \"kex.h\"",
            "#include \"match.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int datafellows = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kex.h\"\n#include \"match.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint datafellows = 0;\n\nchar *\ncompat_cipher_proposal(char *cipher_prop)\n{\n\tif (!(datafellows & SSH_BUG_BIGENDIANAES))\n\t\treturn cipher_prop;\n\tdebug2(\"%s: original cipher proposal: %s\", __func__, cipher_prop);\n\tif ((cipher_prop = match_filter_blacklist(cipher_prop, \"aes*\")) == NULL)\n\t\tfatal(\"match_filter_blacklist failed\");\n\tdebug2(\"%s: compat cipher proposal: %s\", __func__, cipher_prop);\n\tif (*cipher_prop == '\\0')\n\t\tfatal(\"No supported ciphers found\");\n\treturn cipher_prop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kex_names_cat",
          "args": [
            "options.kex_algorithms",
            "\"ext-info-c\""
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "kex_names_cat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/kex.c",
          "lines": "170-203",
          "snippet": "char *\nkex_names_cat(const char *a, const char *b)\n{\n\tchar *ret = NULL, *tmp = NULL, *cp, *p, *m;\n\tsize_t len;\n\n\tif (a == NULL || *a == '\\0')\n\t\treturn strdup(b);\n\tif (b == NULL || *b == '\\0')\n\t\treturn strdup(a);\n\tif (strlen(b) > 1024*1024)\n\t\treturn NULL;\n\tlen = strlen(a) + strlen(b) + 2;\n\tif ((tmp = cp = strdup(b)) == NULL ||\n\t    (ret = calloc(1, len)) == NULL) {\n\t\tfree(tmp);\n\t\treturn NULL;\n\t}\n\tstrlcpy(ret, a, len);\n\tfor ((p = strsep(&cp, \",\")); p && *p != '\\0'; (p = strsep(&cp, \",\"))) {\n\t\tif ((m = match_list(ret, p, NULL)) != NULL) {\n\t\t\tfree(m);\n\t\t\tcontinue; /* Algorithm already present */\n\t\t}\n\t\tif (strlcat(ret, \",\", len) >= len ||\n\t\t    strlcat(ret, p, len) >= len) {\n\t\t\tfree(tmp);\n\t\t\tfree(ret);\n\t\t\treturn NULL; /* Shouldn't happen */\n\t\t}\n\t}\n\tfree(tmp);\n\treturn ret;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor.h\"",
            "#include \"dispatch.h\"",
            "#include \"misc.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"log.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include <openssl/dh.h>",
            "#include <openssl/crypto.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"monitor.h\"\n#include \"dispatch.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include <openssl/dh.h>\n#include <openssl/crypto.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include \"includes.h\"\n\nchar *\nkex_names_cat(const char *a, const char *b)\n{\n\tchar *ret = NULL, *tmp = NULL, *cp, *p, *m;\n\tsize_t len;\n\n\tif (a == NULL || *a == '\\0')\n\t\treturn strdup(b);\n\tif (b == NULL || *b == '\\0')\n\t\treturn strdup(a);\n\tif (strlen(b) > 1024*1024)\n\t\treturn NULL;\n\tlen = strlen(a) + strlen(b) + 2;\n\tif ((tmp = cp = strdup(b)) == NULL ||\n\t    (ret = calloc(1, len)) == NULL) {\n\t\tfree(tmp);\n\t\treturn NULL;\n\t}\n\tstrlcpy(ret, a, len);\n\tfor ((p = strsep(&cp, \",\")); p && *p != '\\0'; (p = strsep(&cp, \",\"))) {\n\t\tif ((m = match_list(ret, p, NULL)) != NULL) {\n\t\t\tfree(m);\n\t\t\tcontinue; /* Algorithm already present */\n\t\t}\n\t\tif (strlcat(ret, \",\", len) >= len ||\n\t\t    strlcat(ret, p, len) >= len) {\n\t\t\tfree(tmp);\n\t\t\tfree(ret);\n\t\t\treturn NULL; /* Shouldn't happen */\n\t\t}\n\t}\n\tfree(tmp);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern char *client_version_string;\nextern char *server_version_string;\nextern Options options;\nu_char *session_id2 = NULL;\nu_int session_id2_len = 0;\nchar *xxx_host;\nstruct sockaddr *xxx_hostaddr;\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\n\nvoid\nssh_kex2(char *host, struct sockaddr *hostaddr, u_short port)\n{\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tchar *s, *all_key;\n\tstruct kex *kex;\n\tint r;\n\n\txxx_host = host;\n\txxx_hostaddr = hostaddr;\n\n\tif ((s = kex_names_cat(options.kex_algorithms, \"ext-info-c\")) == NULL)\n\t\tfatal(\"%s: kex_names_cat\", __func__);\n\tmyproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(s);\n\tmyproposal[PROPOSAL_ENC_ALGS_CTOS] =\n\t    compat_cipher_proposal(options.ciphers);\n\tmyproposal[PROPOSAL_ENC_ALGS_STOC] =\n\t    compat_cipher_proposal(options.ciphers);\n\tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_COMP_ALGS_STOC] = options.compression ?\n\t    \"zlib@openssh.com,zlib,none\" : \"none,zlib@openssh.com,zlib\";\n\tmyproposal[PROPOSAL_MAC_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;\n\tif (options.hostkeyalgorithms != NULL) {\n\t\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\t\tif (kex_assemble_names(&options.hostkeyalgorithms,\n\t\t    KEX_DEFAULT_PK_ALG, all_key) != 0)\n\t\t\tfatal(\"%s: kex_assemble_namelist\", __func__);\n\t\tfree(all_key);\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =\n\t\t    compat_pkalg_proposal(options.hostkeyalgorithms);\n\t} else {\n\t\t/* Enforce default */\n\t\toptions.hostkeyalgorithms = xstrdup(KEX_DEFAULT_PK_ALG);\n\t\t/* Prefer algorithms that we already have keys for */\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =\n\t\t    compat_pkalg_proposal(\n\t\t    order_hostkeyalgs(host, hostaddr, port));\n\t}\n\n\tif (options.rekey_limit || options.rekey_interval)\n\t\tpacket_set_rekey_limits(options.rekey_limit,\n\t\t    options.rekey_interval);\n\n\t/* start key exchange */\n\tif ((r = kex_setup(active_state, myproposal)) != 0)\n\t\tfatal(\"kex_setup: %s\", ssh_err(r));\n\tkex = active_state->kex;\n#ifdef WITH_OPENSSL\n\tkex->kex[KEX_DH_GRP1_SHA1] = kexdh_client;\n\tkex->kex[KEX_DH_GRP14_SHA1] = kexdh_client;\n\tkex->kex[KEX_DH_GRP14_SHA256] = kexdh_client;\n\tkex->kex[KEX_DH_GRP16_SHA512] = kexdh_client;\n\tkex->kex[KEX_DH_GRP18_SHA512] = kexdh_client;\n\tkex->kex[KEX_DH_GEX_SHA1] = kexgex_client;\n\tkex->kex[KEX_DH_GEX_SHA256] = kexgex_client;\n# ifdef OPENSSL_HAS_ECC\n\tkex->kex[KEX_ECDH_SHA2] = kexecdh_client;\n# endif\n#endif\n\tkex->kex[KEX_C25519_SHA256] = kexc25519_client;\n\tkex->client_version_string=client_version_string;\n\tkex->server_version_string=server_version_string;\n\tkex->verify_host_key=&verify_host_key_callback;\n\n\tssh_dispatch_run_fatal(active_state, DISPATCH_BLOCK, &kex->done);\n\n\t/* remove ext-info from the KEX proposals for rekeying */\n\tmyproposal[PROPOSAL_KEX_ALGS] =\n\t    compat_kex_proposal(options.kex_algorithms);\n\tif ((r = kex_prop2buf(kex->my, myproposal)) != 0)\n\t\tfatal(\"kex_prop2buf: %s\", ssh_err(r));\n\n\tsession_id2 = kex->session_id;\n\tsession_id2_len = kex->session_id_len;\n\n#ifdef DEBUG_KEXDH\n\t/* send 1st encrypted/maced/compressed message */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_IGNORE)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"markus\")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n#endif\n}"
  },
  {
    "function_name": "order_hostkeyalgs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "103-155",
    "snippet": "static char *\norder_hostkeyalgs(char *host, struct sockaddr *hostaddr, u_short port)\n{\n\tchar *oavail, *avail, *first, *last, *alg, *hostname, *ret;\n\tsize_t maxlen;\n\tstruct hostkeys *hostkeys;\n\tint ktype;\n\tu_int i;\n\n\t/* Find all hostkeys for this hostname */\n\tget_hostfile_hostname_ipaddr(host, hostaddr, port, &hostname, NULL);\n\thostkeys = init_hostkeys();\n\tfor (i = 0; i < options.num_user_hostfiles; i++)\n\t\tload_hostkeys(hostkeys, hostname, options.user_hostfiles[i]);\n\tfor (i = 0; i < options.num_system_hostfiles; i++)\n\t\tload_hostkeys(hostkeys, hostname, options.system_hostfiles[i]);\n\n\toavail = avail = xstrdup(KEX_DEFAULT_PK_ALG);\n\tmaxlen = strlen(avail) + 1;\n\tfirst = xmalloc(maxlen);\n\tlast = xmalloc(maxlen);\n\t*first = *last = '\\0';\n\n#define ALG_APPEND(to, from) \\\n\tdo { \\\n\t\tif (*to != '\\0') \\\n\t\t\tstrlcat(to, \",\", maxlen); \\\n\t\tstrlcat(to, from, maxlen); \\\n\t} while (0)\n\n\twhile ((alg = strsep(&avail, \",\")) && *alg != '\\0') {\n\t\tif ((ktype = sshkey_type_from_name(alg)) == KEY_UNSPEC)\n\t\t\tfatal(\"%s: unknown alg %s\", __func__, alg);\n\t\tif (lookup_key_in_hostkeys_by_type(hostkeys,\n\t\t    sshkey_type_plain(ktype), NULL))\n\t\t\tALG_APPEND(first, alg);\n\t\telse\n\t\t\tALG_APPEND(last, alg);\n\t}\n#undef ALG_APPEND\n\txasprintf(&ret, \"%s%s%s\", first,\n\t    (*first == '\\0' || *last == '\\0') ? \"\" : \",\", last);\n\tif (*first != '\\0')\n\t\tdebug3(\"%s: prefer hostkeyalgs: %s\", __func__, first);\n\n\tfree(first);\n\tfree(last);\n\tfree(hostname);\n\tfree(oavail);\n\tfree_hostkeys(hostkeys);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern Options options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_hostkeys",
          "args": [
            "hostkeys"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "free_hostkeys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/hostfile.c",
          "lines": "291-305",
          "snippet": "void\nfree_hostkeys(struct hostkeys *hostkeys)\n{\n\tu_int i;\n\n\tfor (i = 0; i < hostkeys->num_entries; i++) {\n\t\tfree(hostkeys->entries[i].host);\n\t\tfree(hostkeys->entries[i].file);\n\t\tsshkey_free(hostkeys->entries[i].key);\n\t\texplicit_bzero(hostkeys->entries + i, sizeof(*hostkeys->entries));\n\t}\n\tfree(hostkeys->entries);\n\texplicit_bzero(hostkeys, sizeof(*hostkeys));\n\tfree(hostkeys);\n}",
          "includes": [
            "#include \"hmac.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <resolv.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <resolv.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfree_hostkeys(struct hostkeys *hostkeys)\n{\n\tu_int i;\n\n\tfor (i = 0; i < hostkeys->num_entries; i++) {\n\t\tfree(hostkeys->entries[i].host);\n\t\tfree(hostkeys->entries[i].file);\n\t\tsshkey_free(hostkeys->entries[i].key);\n\t\texplicit_bzero(hostkeys->entries + i, sizeof(*hostkeys->entries));\n\t}\n\tfree(hostkeys->entries);\n\texplicit_bzero(hostkeys, sizeof(*hostkeys));\n\tfree(hostkeys);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "oavail"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: prefer hostkeyalgs: %s\"",
            "__func__",
            "first"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xasprintf",
          "args": [
            "&ret",
            "\"%s%s%s\"",
            "first",
            "(*first == '\\0' || *last == '\\0') ? \"\" : \",\"",
            "last"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "xasprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "104-118",
          "snippet": "int\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nint\nxasprintf(char **ret, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(ret, fmt, ap);\n\tva_end(ap);\n\n\tif (i < 0 || *ret == NULL)\n\t\tfatal(\"xasprintf: could not allocate memory\");\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALG_APPEND",
          "args": [
            "last",
            "alg"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALG_APPEND",
          "args": [
            "first",
            "alg"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_key_in_hostkeys_by_type",
          "args": [
            "hostkeys",
            "sshkey_type_plain(ktype)",
            "NULL"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_key_in_hostkeys_by_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/hostfile.c",
          "lines": "404-410",
          "snippet": "int\nlookup_key_in_hostkeys_by_type(struct hostkeys *hostkeys, int keytype,\n    const struct hostkey_entry **found)\n{\n\treturn (check_hostkeys_by_key_or_type(hostkeys, NULL, keytype,\n\t    found) == HOST_FOUND);\n}",
          "includes": [
            "#include \"hmac.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <resolv.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <resolv.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nlookup_key_in_hostkeys_by_type(struct hostkeys *hostkeys, int keytype,\n    const struct hostkey_entry **found)\n{\n\treturn (check_hostkeys_by_key_or_type(hostkeys, NULL, keytype,\n\t    found) == HOST_FOUND);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_plain",
          "args": [
            "ktype"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: unknown alg %s\"",
            "__func__",
            "alg"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_from_name",
          "args": [
            "alg"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "190-202",
          "snippet": "int\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const struct keytype keytypes[] = {\n\t{ \"ssh-ed25519\", \"ED25519\", NULL, KEY_ED25519, 0, 0, 0 },\n\t{ \"ssh-ed25519-cert-v01@openssh.com\", \"ED25519-CERT\", NULL,\n\t    KEY_ED25519_CERT, 0, 1, 0 },\n#ifdef WITH_XMSS\n\t{ \"ssh-xmss@openssh.com\", \"XMSS\", NULL, KEY_XMSS, 0, 0, 0 },\n\t{ \"ssh-xmss-cert-v01@openssh.com\", \"XMSS-CERT\", NULL,\n\t    KEY_XMSS_CERT, 0, 1, 0 },\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\t{ \"ssh-rsa\", \"RSA\", NULL, KEY_RSA, 0, 0, 0 },\n\t{ \"rsa-sha2-256\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"rsa-sha2-512\", \"RSA\", NULL, KEY_RSA, 0, 0, 1 },\n\t{ \"ssh-dss\", \"DSA\", NULL, KEY_DSA, 0, 0, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_X9_62_prime256v1, 0, 0 },\n\t{ \"ecdsa-sha2-nistp384\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp384r1, 0, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521\", \"ECDSA\", NULL,\n\t    KEY_ECDSA, NID_secp521r1, 0, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n\t{ \"ssh-rsa-cert-v01@openssh.com\", \"RSA-CERT\", NULL,\n\t    KEY_RSA_CERT, 0, 1, 0 },\n\t{ \"rsa-sha2-256-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-256\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"rsa-sha2-512-cert-v01@openssh.com\", \"RSA-CERT\",\n\t    \"rsa-sha2-512\", KEY_RSA_CERT, 0, 1, 1 },\n\t{ \"ssh-dss-cert-v01@openssh.com\", \"DSA-CERT\", NULL,\n\t    KEY_DSA_CERT, 0, 1, 0 },\n# ifdef OPENSSL_HAS_ECC\n\t{ \"ecdsa-sha2-nistp256-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_X9_62_prime256v1, 1, 0 },\n\t{ \"ecdsa-sha2-nistp384-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t    KEY_ECDSA_CERT, NID_secp384r1, 1, 0 },\n#  ifdef OPENSSL_HAS_NISTP521\n\t{ \"ecdsa-sha2-nistp521-cert-v01@openssh.com\", \"ECDSA-CERT\", NULL,\n\t   KEY_ECDSA_CERT, NID_secp521r1, 1, 0 },\n#  endif /* OPENSSL_HAS_NISTP521 */\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\t{ NULL, NULL, NULL, -1, -1, 0, 0 }\n};\n\nint\nsshkey_type_from_name(const char *name)\n{\n\tconst struct keytype *kt;\n\n\tfor (kt = keytypes; kt->type != -1; kt++) {\n\t\t/* Only allow shortname matches for plain key types */\n\t\tif ((kt->name != NULL && strcmp(name, kt->name) == 0) ||\n\t\t    (!kt->cert && strcasecmp(kt->shortname, name) == 0))\n\t\t\treturn kt->type;\n\t}\n\treturn KEY_UNSPEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&avail",
            "\",\""
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "xstrsep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keyscan.c",
          "lines": "162-178",
          "snippet": "static char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}",
          "includes": [
            "#include \"dns.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"myproposal.h\"",
            "#include \"compat.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include <netdb.h>",
            "#include <openssl/bn.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/resource.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"myproposal.h\"\n#include \"compat.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <netdb.h>\n#include <openssl/bn.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/resource.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "maxlen"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "avail"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "KEX_DEFAULT_PK_ALG"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_hostkeys",
          "args": [
            "hostkeys",
            "hostname",
            "options.system_hostfiles[i]"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "load_hostkeys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/hostfile.c",
          "lines": "270-289",
          "snippet": "void\nload_hostkeys(struct hostkeys *hostkeys, const char *host, const char *path)\n{\n\tint r;\n\tstruct load_callback_ctx ctx;\n\n\tctx.host = host;\n\tctx.num_loaded = 0;\n\tctx.hostkeys = hostkeys;\n\n\tif ((r = hostkeys_foreach(path, record_hostkey, &ctx, host, NULL,\n\t    HKF_WANT_MATCH|HKF_WANT_PARSE_KEY)) != 0) {\n\t\tif (r != SSH_ERR_SYSTEM_ERROR && errno != ENOENT)\n\t\t\tdebug(\"%s: hostkeys_foreach failed for %s: %s\",\n\t\t\t    __func__, path, ssh_err(r));\n\t}\n\tif (ctx.num_loaded != 0)\n\t\tdebug3(\"%s: loaded %lu keys from %s\", __func__,\n\t\t    ctx.num_loaded, host);\n}",
          "includes": [
            "#include \"hmac.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <resolv.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <resolv.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nload_hostkeys(struct hostkeys *hostkeys, const char *host, const char *path)\n{\n\tint r;\n\tstruct load_callback_ctx ctx;\n\n\tctx.host = host;\n\tctx.num_loaded = 0;\n\tctx.hostkeys = hostkeys;\n\n\tif ((r = hostkeys_foreach(path, record_hostkey, &ctx, host, NULL,\n\t    HKF_WANT_MATCH|HKF_WANT_PARSE_KEY)) != 0) {\n\t\tif (r != SSH_ERR_SYSTEM_ERROR && errno != ENOENT)\n\t\t\tdebug(\"%s: hostkeys_foreach failed for %s: %s\",\n\t\t\t    __func__, path, ssh_err(r));\n\t}\n\tif (ctx.num_loaded != 0)\n\t\tdebug3(\"%s: loaded %lu keys from %s\", __func__,\n\t\t    ctx.num_loaded, host);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_hostkeys",
          "args": [],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "init_hostkeys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/hostfile.c",
          "lines": "221-228",
          "snippet": "struct hostkeys *\ninit_hostkeys(void)\n{\n\tstruct hostkeys *ret = xcalloc(1, sizeof(*ret));\n\n\tret->entries = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"hmac.h\"",
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <resolv.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hmac.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <resolv.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct hostkeys *\ninit_hostkeys(void)\n{\n\tstruct hostkeys *ret = xcalloc(1, sizeof(*ret));\n\n\tret->entries = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hostfile_hostname_ipaddr",
          "args": [
            "host",
            "hostaddr",
            "port",
            "&hostname",
            "NULL"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "get_hostfile_hostname_ipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "777-829",
          "snippet": "void\nget_hostfile_hostname_ipaddr(char *hostname, struct sockaddr *hostaddr,\n    u_short port, char **hostfile_hostname, char **hostfile_ipaddr)\n{\n\tchar ntop[NI_MAXHOST];\n\tsocklen_t addrlen;\n\n\tswitch (hostaddr == NULL ? -1 : hostaddr->sa_family) {\n\tcase -1:\n\t\taddrlen = 0;\n\t\tbreak;\n\tcase AF_INET:\n\t\taddrlen = sizeof(struct sockaddr_in);\n\t\tbreak;\n\tcase AF_INET6:\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tbreak;\n\tdefault:\n\t\taddrlen = sizeof(struct sockaddr);\n\t\tbreak;\n\t}\n\n\t/*\n\t * We don't have the remote ip-address for connections\n\t * using a proxy command\n\t */\n\tif (hostfile_ipaddr != NULL) {\n\t\tif (options.proxy_command == NULL) {\n\t\t\tif (getnameinfo(hostaddr, addrlen,\n\t\t\t    ntop, sizeof(ntop), NULL, 0, NI_NUMERICHOST) != 0)\n\t\t\tfatal(\"%s: getnameinfo failed\", __func__);\n\t\t\t*hostfile_ipaddr = put_host_port(ntop, port);\n\t\t} else {\n\t\t\t*hostfile_ipaddr = xstrdup(\"<no hostip for proxy \"\n\t\t\t    \"command>\");\n\t\t}\n\t}\n\n\t/*\n\t * Allow the user to record the key under a different name or\n\t * differentiate a non-standard port.  This is useful for ssh\n\t * tunneling over forwarded connections or if you run multiple\n\t * sshd's on different ports on the same machine.\n\t */\n\tif (hostfile_hostname != NULL) {\n\t\tif (options.host_key_alias != NULL) {\n\t\t\t*hostfile_hostname = xstrdup(options.host_key_alias);\n\t\t\tdebug(\"using hostkeyalias: %s\", *hostfile_hostname);\n\t\t} else {\n\t\t\t*hostfile_hostname = put_host_port(hostname, port);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nvoid\nget_hostfile_hostname_ipaddr(char *hostname, struct sockaddr *hostaddr,\n    u_short port, char **hostfile_hostname, char **hostfile_ipaddr)\n{\n\tchar ntop[NI_MAXHOST];\n\tsocklen_t addrlen;\n\n\tswitch (hostaddr == NULL ? -1 : hostaddr->sa_family) {\n\tcase -1:\n\t\taddrlen = 0;\n\t\tbreak;\n\tcase AF_INET:\n\t\taddrlen = sizeof(struct sockaddr_in);\n\t\tbreak;\n\tcase AF_INET6:\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tbreak;\n\tdefault:\n\t\taddrlen = sizeof(struct sockaddr);\n\t\tbreak;\n\t}\n\n\t/*\n\t * We don't have the remote ip-address for connections\n\t * using a proxy command\n\t */\n\tif (hostfile_ipaddr != NULL) {\n\t\tif (options.proxy_command == NULL) {\n\t\t\tif (getnameinfo(hostaddr, addrlen,\n\t\t\t    ntop, sizeof(ntop), NULL, 0, NI_NUMERICHOST) != 0)\n\t\t\tfatal(\"%s: getnameinfo failed\", __func__);\n\t\t\t*hostfile_ipaddr = put_host_port(ntop, port);\n\t\t} else {\n\t\t\t*hostfile_ipaddr = xstrdup(\"<no hostip for proxy \"\n\t\t\t    \"command>\");\n\t\t}\n\t}\n\n\t/*\n\t * Allow the user to record the key under a different name or\n\t * differentiate a non-standard port.  This is useful for ssh\n\t * tunneling over forwarded connections or if you run multiple\n\t * sshd's on different ports on the same machine.\n\t */\n\tif (hostfile_hostname != NULL) {\n\t\tif (options.host_key_alias != NULL) {\n\t\t\t*hostfile_hostname = xstrdup(options.host_key_alias);\n\t\t\tdebug(\"using hostkeyalias: %s\", *hostfile_hostname);\n\t\t} else {\n\t\t\t*hostfile_hostname = put_host_port(hostname, port);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\n\nstatic char *\norder_hostkeyalgs(char *host, struct sockaddr *hostaddr, u_short port)\n{\n\tchar *oavail, *avail, *first, *last, *alg, *hostname, *ret;\n\tsize_t maxlen;\n\tstruct hostkeys *hostkeys;\n\tint ktype;\n\tu_int i;\n\n\t/* Find all hostkeys for this hostname */\n\tget_hostfile_hostname_ipaddr(host, hostaddr, port, &hostname, NULL);\n\thostkeys = init_hostkeys();\n\tfor (i = 0; i < options.num_user_hostfiles; i++)\n\t\tload_hostkeys(hostkeys, hostname, options.user_hostfiles[i]);\n\tfor (i = 0; i < options.num_system_hostfiles; i++)\n\t\tload_hostkeys(hostkeys, hostname, options.system_hostfiles[i]);\n\n\toavail = avail = xstrdup(KEX_DEFAULT_PK_ALG);\n\tmaxlen = strlen(avail) + 1;\n\tfirst = xmalloc(maxlen);\n\tlast = xmalloc(maxlen);\n\t*first = *last = '\\0';\n\n#define ALG_APPEND(to, from) \\\n\tdo { \\\n\t\tif (*to != '\\0') \\\n\t\t\tstrlcat(to, \",\", maxlen); \\\n\t\tstrlcat(to, from, maxlen); \\\n\t} while (0)\n\n\twhile ((alg = strsep(&avail, \",\")) && *alg != '\\0') {\n\t\tif ((ktype = sshkey_type_from_name(alg)) == KEY_UNSPEC)\n\t\t\tfatal(\"%s: unknown alg %s\", __func__, alg);\n\t\tif (lookup_key_in_hostkeys_by_type(hostkeys,\n\t\t    sshkey_type_plain(ktype), NULL))\n\t\t\tALG_APPEND(first, alg);\n\t\telse\n\t\t\tALG_APPEND(last, alg);\n\t}\n#undef ALG_APPEND\n\txasprintf(&ret, \"%s%s%s\", first,\n\t    (*first == '\\0' || *last == '\\0') ? \"\" : \",\", last);\n\tif (*first != '\\0')\n\t\tdebug3(\"%s: prefer hostkeyalgs: %s\", __func__, first);\n\n\tfree(first);\n\tfree(last);\n\tfree(hostname);\n\tfree(oavail);\n\tfree_hostkeys(hostkeys);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "verify_host_key_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
    "lines": "95-101",
    "snippet": "static int\nverify_host_key_callback(struct sshkey *hostkey, struct ssh *ssh)\n{\n\tif (verify_host_key(xxx_host, xxx_hostaddr, hostkey) == -1)\n\t\tfatal(\"Host key verification failed.\");\n\treturn 0;\n}",
    "includes": [
      "#include \"ssh-gss.h\"",
      "#include \"utf8.h\"",
      "#include \"ssherr.h\"",
      "#include \"hostfile.h\"",
      "#include \"uidswap.h\"",
      "#include \"pathnames.h\"",
      "#include \"msg.h\"",
      "#include \"canohost.h\"",
      "#include \"dispatch.h\"",
      "#include \"match.h\"",
      "#include \"readconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"authfd.h\"",
      "#include \"dh.h\"",
      "#include \"authfile.h\"",
      "#include \"sshconnect.h\"",
      "#include \"myproposal.h\"",
      "#include \"kex.h\"",
      "#include \"sshkey.h\"",
      "#include \"cipher.h\"",
      "#include \"compat.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssh2.h\"",
      "#include \"ssh.h\"",
      "#include \"xmalloc.h\"",
      "#include \"openbsd-compat/sys-queue.h\"",
      "#include <vis.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "#include <pwd.h>",
      "#include <netdb.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *xxx_host;",
      "struct sockaddr *xxx_hostaddr;",
      "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
      "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Host key verification failed.\""
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_host_key",
          "args": [
            "xxx_host",
            "xxx_hostaddr",
            "hostkey"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "verify_host_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "1280-1390",
          "snippet": "int\nverify_host_key(char *host, struct sockaddr *hostaddr, struct sshkey *host_key)\n{\n\tu_int i;\n\tint r = -1, flags = 0;\n\tchar valid[64], *fp = NULL, *cafp = NULL;\n\tstruct sshkey *plain = NULL;\n\n\tif ((fp = sshkey_fingerprint(host_key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {\n\t\terror(\"%s: fingerprint host key: %s\", __func__, ssh_err(r));\n\t\tr = -1;\n\t\tgoto out;\n\t}\n\n\tif (sshkey_is_cert(host_key)) {\n\t\tif ((cafp = sshkey_fingerprint(host_key->cert->signature_key,\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {\n\t\t\terror(\"%s: fingerprint CA key: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\tr = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tsshkey_format_cert_validity(host_key->cert,\n\t\t    valid, sizeof(valid));\n\t\tdebug(\"Server host certificate: %s %s, serial %llu \"\n\t\t    \"ID \\\"%s\\\" CA %s %s valid %s\",\n\t\t    sshkey_ssh_name(host_key), fp,\n\t\t    (unsigned long long)host_key->cert->serial,\n\t\t    host_key->cert->key_id,\n\t\t    sshkey_ssh_name(host_key->cert->signature_key), cafp,\n\t\t    valid);\n\t\tfor (i = 0; i < host_key->cert->nprincipals; i++) {\n\t\t\tdebug2(\"Server host certificate hostname: %s\",\n\t\t\t    host_key->cert->principals[i]);\n\t\t}\n\t} else {\n\t\tdebug(\"Server host key: %s %s\", sshkey_ssh_name(host_key), fp);\n\t}\n\n\tif (sshkey_equal(previous_host_key, host_key)) {\n\t\tdebug2(\"%s: server host key %s %s matches cached key\",\n\t\t    __func__, sshkey_type(host_key), fp);\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\n\t/* Check in RevokedHostKeys file if specified */\n\tif (options.revoked_host_keys != NULL) {\n\t\tr = sshkey_check_revoked(host_key, options.revoked_host_keys);\n\t\tswitch (r) {\n\t\tcase 0:\n\t\t\tbreak; /* not revoked */\n\t\tcase SSH_ERR_KEY_REVOKED:\n\t\t\terror(\"Host key %s %s revoked by file %s\",\n\t\t\t    sshkey_type(host_key), fp,\n\t\t\t    options.revoked_host_keys);\n\t\t\tr = -1;\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\terror(\"Error checking host key %s %s in \"\n\t\t\t    \"revoked keys file %s: %s\", sshkey_type(host_key),\n\t\t\t    fp, options.revoked_host_keys, ssh_err(r));\n\t\t\tr = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (options.verify_host_key_dns) {\n\t\t/*\n\t\t * XXX certs are not yet supported for DNS, so downgrade\n\t\t * them and try the plain key.\n\t\t */\n\t\tif ((r = sshkey_from_private(host_key, &plain)) != 0)\n\t\t\tgoto out;\n\t\tif (sshkey_is_cert(plain))\n\t\t\tsshkey_drop_cert(plain);\n\t\tif (verify_host_key_dns(host, hostaddr, plain, &flags) == 0) {\n\t\t\tif (flags & DNS_VERIFY_FOUND) {\n\t\t\t\tif (options.verify_host_key_dns == 1 &&\n\t\t\t\t    flags & DNS_VERIFY_MATCH &&\n\t\t\t\t    flags & DNS_VERIFY_SECURE) {\n\t\t\t\t\tr = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (flags & DNS_VERIFY_MATCH) {\n\t\t\t\t\tmatching_host_key_dns = 1;\n\t\t\t\t} else {\n\t\t\t\t\twarn_changed_key(plain);\n\t\t\t\t\terror(\"Update the SSHFP RR in DNS \"\n\t\t\t\t\t    \"with the new host key to get rid \"\n\t\t\t\t\t    \"of this message.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tr = check_host_key(host, hostaddr, options.port, host_key, RDRW,\n\t    options.user_hostfiles, options.num_user_hostfiles,\n\t    options.system_hostfiles, options.num_system_hostfiles);\n\nout:\n\tsshkey_free(plain);\n\tfree(fp);\n\tfree(cafp);\n\tif (r == 0 && host_key != NULL) {\n\t\tsshkey_free(previous_host_key);\n\t\tr = sshkey_from_private(host_key, &previous_host_key);\n\t}\n\n\treturn r;\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define RDRW\t0"
          ],
          "globals_used": [
            "struct sshkey *previous_host_key = NULL;",
            "static int matching_host_key_dns = 0;",
            "extern Options options;",
            "static int show_other_keys(struct hostkeys *, struct sshkey *);",
            "static void warn_changed_key(struct sshkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define RDRW\t0\n\nstruct sshkey *previous_host_key = NULL;\nstatic int matching_host_key_dns = 0;\nextern Options options;\nstatic int show_other_keys(struct hostkeys *, struct sshkey *);\nstatic void warn_changed_key(struct sshkey *);\n\nint\nverify_host_key(char *host, struct sockaddr *hostaddr, struct sshkey *host_key)\n{\n\tu_int i;\n\tint r = -1, flags = 0;\n\tchar valid[64], *fp = NULL, *cafp = NULL;\n\tstruct sshkey *plain = NULL;\n\n\tif ((fp = sshkey_fingerprint(host_key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {\n\t\terror(\"%s: fingerprint host key: %s\", __func__, ssh_err(r));\n\t\tr = -1;\n\t\tgoto out;\n\t}\n\n\tif (sshkey_is_cert(host_key)) {\n\t\tif ((cafp = sshkey_fingerprint(host_key->cert->signature_key,\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {\n\t\t\terror(\"%s: fingerprint CA key: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\tr = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tsshkey_format_cert_validity(host_key->cert,\n\t\t    valid, sizeof(valid));\n\t\tdebug(\"Server host certificate: %s %s, serial %llu \"\n\t\t    \"ID \\\"%s\\\" CA %s %s valid %s\",\n\t\t    sshkey_ssh_name(host_key), fp,\n\t\t    (unsigned long long)host_key->cert->serial,\n\t\t    host_key->cert->key_id,\n\t\t    sshkey_ssh_name(host_key->cert->signature_key), cafp,\n\t\t    valid);\n\t\tfor (i = 0; i < host_key->cert->nprincipals; i++) {\n\t\t\tdebug2(\"Server host certificate hostname: %s\",\n\t\t\t    host_key->cert->principals[i]);\n\t\t}\n\t} else {\n\t\tdebug(\"Server host key: %s %s\", sshkey_ssh_name(host_key), fp);\n\t}\n\n\tif (sshkey_equal(previous_host_key, host_key)) {\n\t\tdebug2(\"%s: server host key %s %s matches cached key\",\n\t\t    __func__, sshkey_type(host_key), fp);\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\n\t/* Check in RevokedHostKeys file if specified */\n\tif (options.revoked_host_keys != NULL) {\n\t\tr = sshkey_check_revoked(host_key, options.revoked_host_keys);\n\t\tswitch (r) {\n\t\tcase 0:\n\t\t\tbreak; /* not revoked */\n\t\tcase SSH_ERR_KEY_REVOKED:\n\t\t\terror(\"Host key %s %s revoked by file %s\",\n\t\t\t    sshkey_type(host_key), fp,\n\t\t\t    options.revoked_host_keys);\n\t\t\tr = -1;\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\terror(\"Error checking host key %s %s in \"\n\t\t\t    \"revoked keys file %s: %s\", sshkey_type(host_key),\n\t\t\t    fp, options.revoked_host_keys, ssh_err(r));\n\t\t\tr = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (options.verify_host_key_dns) {\n\t\t/*\n\t\t * XXX certs are not yet supported for DNS, so downgrade\n\t\t * them and try the plain key.\n\t\t */\n\t\tif ((r = sshkey_from_private(host_key, &plain)) != 0)\n\t\t\tgoto out;\n\t\tif (sshkey_is_cert(plain))\n\t\t\tsshkey_drop_cert(plain);\n\t\tif (verify_host_key_dns(host, hostaddr, plain, &flags) == 0) {\n\t\t\tif (flags & DNS_VERIFY_FOUND) {\n\t\t\t\tif (options.verify_host_key_dns == 1 &&\n\t\t\t\t    flags & DNS_VERIFY_MATCH &&\n\t\t\t\t    flags & DNS_VERIFY_SECURE) {\n\t\t\t\t\tr = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (flags & DNS_VERIFY_MATCH) {\n\t\t\t\t\tmatching_host_key_dns = 1;\n\t\t\t\t} else {\n\t\t\t\t\twarn_changed_key(plain);\n\t\t\t\t\terror(\"Update the SSHFP RR in DNS \"\n\t\t\t\t\t    \"with the new host key to get rid \"\n\t\t\t\t\t    \"of this message.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tr = check_host_key(host, hostaddr, options.port, host_key, RDRW,\n\t    options.user_hostfiles, options.num_user_hostfiles,\n\t    options.system_hostfiles, options.num_system_hostfiles);\n\nout:\n\tsshkey_free(plain);\n\tfree(fp);\n\tfree(cafp);\n\tif (r == 0 && host_key != NULL) {\n\t\tsshkey_free(previous_host_key);\n\t\tr = sshkey_from_private(host_key, &previous_host_key);\n\t}\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *xxx_host;\nstruct sockaddr *xxx_hostaddr;\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\n\nstatic int\nverify_host_key_callback(struct sshkey *hostkey, struct ssh *ssh)\n{\n\tif (verify_host_key(xxx_host, xxx_hostaddr, hostkey) == -1)\n\t\tfatal(\"Host key verification failed.\");\n\treturn 0;\n}"
  }
]