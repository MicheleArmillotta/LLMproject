[
  {
    "function_name": "privsep_challenge_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
    "lines": "363-383",
    "snippet": "void\nprivsep_challenge_enable(void)\n{\n#if defined(BSD_AUTH) || defined(USE_PAM)\n\tint n = 0;\n#endif\n#ifdef BSD_AUTH\n\textern KbdintDevice mm_bsdauth_device;\n#endif\n#ifdef USE_PAM\n\textern KbdintDevice mm_sshpam_device;\n#endif\n\n#ifdef BSD_AUTH\n\tdevices[n++] = &mm_bsdauth_device;\n#else\n#ifdef USE_PAM\n\tdevices[n++] = &mm_sshpam_device;\n#endif\n#endif\n}",
    "includes": [
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"dispatch.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"xmalloc.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "KbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nKbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};\n\nvoid\nprivsep_challenge_enable(void)\n{\n#if defined(BSD_AUTH) || defined(USE_PAM)\n\tint n = 0;\n#endif\n#ifdef BSD_AUTH\n\textern KbdintDevice mm_bsdauth_device;\n#endif\n#ifdef USE_PAM\n\textern KbdintDevice mm_sshpam_device;\n#endif\n\n#ifdef BSD_AUTH\n\tdevices[n++] = &mm_bsdauth_device;\n#else\n#ifdef USE_PAM\n\tdevices[n++] = &mm_sshpam_device;\n#endif\n#endif\n}"
  },
  {
    "function_name": "input_userauth_info_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
    "lines": "290-361",
    "snippet": "static int\ninput_userauth_info_response(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tKbdintAuthctxt *kbdintctxt;\n\tint authenticated = 0, res;\n\tint r;\n\tu_int i, nresp;\n\tconst char *devicename = NULL;\n\tchar **response = NULL;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_userauth_info_response: no authctxt\");\n\tkbdintctxt = authctxt->kbdintctxt;\n\tif (kbdintctxt == NULL || kbdintctxt->ctxt == NULL)\n\t\tfatal(\"input_userauth_info_response: no kbdintctxt\");\n\tif (kbdintctxt->device == NULL)\n\t\tfatal(\"input_userauth_info_response: no device\");\n\n\tauthctxt->postponed = 0;\t/* reset */\n\tif ((r = sshpkt_get_u32(ssh, &nresp)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tif (nresp != kbdintctxt->nreq)\n\t\tfatal(\"input_userauth_info_response: wrong number of replies\");\n\tif (nresp > 100)\n\t\tfatal(\"input_userauth_info_response: too many replies\");\n\tif (nresp > 0) {\n\t\tresponse = xcalloc(nresp, sizeof(char *));\n\t\tfor (i = 0; i < nresp; i++)\n\t\t\tif ((r = sshpkt_get_cstring(ssh, &response[i],\n\t\t\t    NULL)) != 0)\n\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t}\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tres = kbdintctxt->device->respond(kbdintctxt->ctxt, nresp, response);\n\n\tfor (i = 0; i < nresp; i++) {\n\t\texplicit_bzero(response[i], strlen(response[i]));\n\t\tfree(response[i]);\n\t}\n\tfree(response);\n\n\tswitch (res) {\n\tcase 0:\n\t\t/* Success! */\n\t\tauthenticated = authctxt->valid ? 1 : 0;\n\t\tbreak;\n\tcase 1:\n\t\t/* Authentication needs further interaction */\n\t\tif (send_userauth_info_request(ssh) == 1)\n\t\t\tauthctxt->postponed = 1;\n\t\tbreak;\n\tdefault:\n\t\t/* Failure! */\n\t\tbreak;\n\t}\n\tdevicename = kbdintctxt->device->name;\n\tif (!authctxt->postponed) {\n\t\tif (authenticated) {\n\t\t\tauth2_challenge_stop(ssh);\n\t\t} else {\n\t\t\t/* start next device */\n\t\t\t/* may set authctxt->postponed */\n\t\t\tauth2_challenge_start(ssh);\n\t\t}\n\t}\n\tuserauth_finish(ssh, authenticated, \"keyboard-interactive\",\n\t    devicename);\n\treturn 0;\n}",
    "includes": [
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"dispatch.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"xmalloc.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int auth2_challenge_start(struct ssh *);",
      "static int send_userauth_info_request(struct ssh *);",
      "static int input_userauth_info_response(int, u_int32_t, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "userauth_finish",
          "args": [
            "ssh",
            "authenticated",
            "\"keyboard-interactive\"",
            "devicename"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "userauth_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2.c",
          "lines": "340-429",
          "snippet": "void\nuserauth_finish(struct ssh *ssh, int authenticated, const char *method,\n    const char *submethod)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tchar *methods;\n\tint partial = 0;\n\n\tif (!authctxt->valid && authenticated)\n\t\tfatal(\"INTERNAL ERROR: authenticated invalid user %s\",\n\t\t    authctxt->user);\n\tif (authenticated && authctxt->postponed)\n\t\tfatal(\"INTERNAL ERROR: authenticated and postponed\");\n\n\t/* Special handling for root */\n\tif (authenticated && authctxt->pw->pw_uid == 0 &&\n\t    !auth_root_allowed(ssh, method)) {\n\t\tauthenticated = 0;\n#ifdef SSH_AUDIT_EVENTS\n\t\tPRIVSEP(audit_event(SSH_LOGIN_ROOT_DENIED));\n#endif\n\t}\n\n\tif (authenticated && options.num_auth_methods != 0) {\n\t\tif (!auth2_update_methods_lists(authctxt, method, submethod)) {\n\t\t\tauthenticated = 0;\n\t\t\tpartial = 1;\n\t\t}\n\t}\n\n\t/* Log before sending the reply */\n\tauth_log(authctxt, authenticated, partial, method, submethod);\n\n\t/* Update information exposed to session */\n\tif (authenticated || partial)\n\t\tauth2_update_session_info(authctxt, method, submethod);\n\n\tif (authctxt->postponed)\n\t\treturn;\n\n#ifdef USE_PAM\n\tif (options.use_pam && authenticated) {\n\t\tint r;\n\n\t\tif (!PRIVSEP(do_pam_account())) {\n\t\t\t/* if PAM returned a message, send it to the user */\n\t\t\tif (sshbuf_len(loginmsg) > 0) {\n\t\t\t\tif ((r = sshbuf_put(loginmsg, \"\\0\", 1)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tuserauth_send_banner(sshbuf_ptr(loginmsg));\n\t\t\t\tpacket_write_wait();\n\t\t\t}\n\t\t\tfatal(\"Access denied for user %s by PAM account \"\n\t\t\t    \"configuration\", authctxt->user);\n\t\t}\n\t}\n#endif\n\n\tif (authenticated == 1) {\n\t\t/* turn off userauth */\n\t\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_REQUEST, &dispatch_protocol_ignore);\n\t\tpacket_start(SSH2_MSG_USERAUTH_SUCCESS);\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\t\t/* now we can break out */\n\t\tauthctxt->success = 1;\n\t\tssh_packet_set_log_preamble(ssh, \"user %s\", authctxt->user);\n\t} else {\n\t\t/* Allow initial try of \"none\" auth without failure penalty */\n\t\tif (!partial && !authctxt->server_caused_failure &&\n\t\t    (authctxt->attempt > 1 || strcmp(method, \"none\") != 0))\n\t\t\tauthctxt->failures++;\n\t\tif (authctxt->failures >= options.max_authtries) {\n#ifdef SSH_AUDIT_EVENTS\n\t\t\tPRIVSEP(audit_event(SSH_LOGIN_EXCEED_MAXTRIES));\n#endif\n\t\t\tauth_maxtries_exceeded(authctxt);\n\t\t}\n\t\tmethods = authmethods_get(authctxt);\n\t\tdebug3(\"%s: failure partial=%d next methods=\\\"%s\\\"\", __func__,\n\t\t    partial, methods);\n\t\tpacket_start(SSH2_MSG_USERAUTH_FAILURE);\n\t\tpacket_put_cstring(methods);\n\t\tpacket_put_char(partial);\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\t\tfree(methods);\n\t}\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"pathnames.h\"",
            "#include \"dispatch.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "extern struct sshbuf *loginmsg;",
            "static int input_service_request(int, u_int32_t, struct ssh *);",
            "static int input_userauth_request(int, u_int32_t, struct ssh *);",
            "static Authmethod *authmethod_lookup(Authctxt *, const char *);",
            "static char *authmethods_get(Authctxt *authctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"pathnames.h\"\n#include \"dispatch.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nextern struct sshbuf *loginmsg;\nstatic int input_service_request(int, u_int32_t, struct ssh *);\nstatic int input_userauth_request(int, u_int32_t, struct ssh *);\nstatic Authmethod *authmethod_lookup(Authctxt *, const char *);\nstatic char *authmethods_get(Authctxt *authctxt);\n\nvoid\nuserauth_finish(struct ssh *ssh, int authenticated, const char *method,\n    const char *submethod)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tchar *methods;\n\tint partial = 0;\n\n\tif (!authctxt->valid && authenticated)\n\t\tfatal(\"INTERNAL ERROR: authenticated invalid user %s\",\n\t\t    authctxt->user);\n\tif (authenticated && authctxt->postponed)\n\t\tfatal(\"INTERNAL ERROR: authenticated and postponed\");\n\n\t/* Special handling for root */\n\tif (authenticated && authctxt->pw->pw_uid == 0 &&\n\t    !auth_root_allowed(ssh, method)) {\n\t\tauthenticated = 0;\n#ifdef SSH_AUDIT_EVENTS\n\t\tPRIVSEP(audit_event(SSH_LOGIN_ROOT_DENIED));\n#endif\n\t}\n\n\tif (authenticated && options.num_auth_methods != 0) {\n\t\tif (!auth2_update_methods_lists(authctxt, method, submethod)) {\n\t\t\tauthenticated = 0;\n\t\t\tpartial = 1;\n\t\t}\n\t}\n\n\t/* Log before sending the reply */\n\tauth_log(authctxt, authenticated, partial, method, submethod);\n\n\t/* Update information exposed to session */\n\tif (authenticated || partial)\n\t\tauth2_update_session_info(authctxt, method, submethod);\n\n\tif (authctxt->postponed)\n\t\treturn;\n\n#ifdef USE_PAM\n\tif (options.use_pam && authenticated) {\n\t\tint r;\n\n\t\tif (!PRIVSEP(do_pam_account())) {\n\t\t\t/* if PAM returned a message, send it to the user */\n\t\t\tif (sshbuf_len(loginmsg) > 0) {\n\t\t\t\tif ((r = sshbuf_put(loginmsg, \"\\0\", 1)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tuserauth_send_banner(sshbuf_ptr(loginmsg));\n\t\t\t\tpacket_write_wait();\n\t\t\t}\n\t\t\tfatal(\"Access denied for user %s by PAM account \"\n\t\t\t    \"configuration\", authctxt->user);\n\t\t}\n\t}\n#endif\n\n\tif (authenticated == 1) {\n\t\t/* turn off userauth */\n\t\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_REQUEST, &dispatch_protocol_ignore);\n\t\tpacket_start(SSH2_MSG_USERAUTH_SUCCESS);\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\t\t/* now we can break out */\n\t\tauthctxt->success = 1;\n\t\tssh_packet_set_log_preamble(ssh, \"user %s\", authctxt->user);\n\t} else {\n\t\t/* Allow initial try of \"none\" auth without failure penalty */\n\t\tif (!partial && !authctxt->server_caused_failure &&\n\t\t    (authctxt->attempt > 1 || strcmp(method, \"none\") != 0))\n\t\t\tauthctxt->failures++;\n\t\tif (authctxt->failures >= options.max_authtries) {\n#ifdef SSH_AUDIT_EVENTS\n\t\t\tPRIVSEP(audit_event(SSH_LOGIN_EXCEED_MAXTRIES));\n#endif\n\t\t\tauth_maxtries_exceeded(authctxt);\n\t\t}\n\t\tmethods = authmethods_get(authctxt);\n\t\tdebug3(\"%s: failure partial=%d next methods=\\\"%s\\\"\", __func__,\n\t\t    partial, methods);\n\t\tpacket_start(SSH2_MSG_USERAUTH_FAILURE);\n\t\tpacket_put_cstring(methods);\n\t\tpacket_put_char(partial);\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\t\tfree(methods);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth2_challenge_start",
          "args": [
            "ssh"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "auth2_challenge_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
          "lines": "222-251",
          "snippet": "static int\nauth2_challenge_start(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tKbdintAuthctxt *kbdintctxt = authctxt->kbdintctxt;\n\n\tdebug2(\"auth2_challenge_start: devices %s\",\n\t    kbdintctxt->devices ?  kbdintctxt->devices : \"<empty>\");\n\n\tif (kbdint_next_device(authctxt, kbdintctxt) == 0) {\n\t\tauth2_challenge_stop(ssh);\n\t\treturn 0;\n\t}\n\tdebug(\"auth2_challenge_start: trying authentication method '%s'\",\n\t    kbdintctxt->device->name);\n\n\tif ((kbdintctxt->ctxt = kbdintctxt->device->init_ctx(authctxt)) == NULL) {\n\t\tauth2_challenge_stop(ssh);\n\t\treturn 0;\n\t}\n\tif (send_userauth_info_request(ssh) == 0) {\n\t\tauth2_challenge_stop(ssh);\n\t\treturn 0;\n\t}\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_INFO_RESPONSE,\n\t    &input_userauth_info_response);\n\n\tauthctxt->postponed = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int auth2_challenge_start(struct ssh *);",
            "static int send_userauth_info_request(struct ssh *);",
            "static int input_userauth_info_response(int, u_int32_t, struct ssh *);",
            "KbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int auth2_challenge_start(struct ssh *);\nstatic int send_userauth_info_request(struct ssh *);\nstatic int input_userauth_info_response(int, u_int32_t, struct ssh *);\nKbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};\n\nstatic int\nauth2_challenge_start(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tKbdintAuthctxt *kbdintctxt = authctxt->kbdintctxt;\n\n\tdebug2(\"auth2_challenge_start: devices %s\",\n\t    kbdintctxt->devices ?  kbdintctxt->devices : \"<empty>\");\n\n\tif (kbdint_next_device(authctxt, kbdintctxt) == 0) {\n\t\tauth2_challenge_stop(ssh);\n\t\treturn 0;\n\t}\n\tdebug(\"auth2_challenge_start: trying authentication method '%s'\",\n\t    kbdintctxt->device->name);\n\n\tif ((kbdintctxt->ctxt = kbdintctxt->device->init_ctx(authctxt)) == NULL) {\n\t\tauth2_challenge_stop(ssh);\n\t\treturn 0;\n\t}\n\tif (send_userauth_info_request(ssh) == 0) {\n\t\tauth2_challenge_stop(ssh);\n\t\treturn 0;\n\t}\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_INFO_RESPONSE,\n\t    &input_userauth_info_response);\n\n\tauthctxt->postponed = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth2_challenge_stop",
          "args": [
            "ssh"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "auth2_challenge_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
          "lines": "209-219",
          "snippet": "void\nauth2_challenge_stop(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\t/* unregister callback */\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_INFO_RESPONSE, NULL);\n\tif (authctxt->kbdintctxt != NULL) {\n\t\tkbdint_free(authctxt->kbdintctxt);\n\t\tauthctxt->kbdintctxt = NULL;\n\t}\n}",
          "includes": [
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int auth2_challenge_start(struct ssh *);",
            "static int send_userauth_info_request(struct ssh *);",
            "static int input_userauth_info_response(int, u_int32_t, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int auth2_challenge_start(struct ssh *);\nstatic int send_userauth_info_request(struct ssh *);\nstatic int input_userauth_info_response(int, u_int32_t, struct ssh *);\n\nvoid\nauth2_challenge_stop(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\t/* unregister callback */\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_INFO_RESPONSE, NULL);\n\tif (authctxt->kbdintctxt != NULL) {\n\t\tkbdint_free(authctxt->kbdintctxt);\n\t\tauthctxt->kbdintctxt = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_userauth_info_request",
          "args": [
            "ssh"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "send_userauth_info_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
          "lines": "253-288",
          "snippet": "static int\nsend_userauth_info_request(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tKbdintAuthctxt *kbdintctxt;\n\tchar *name, *instr, **prompts;\n\tu_int r, i, *echo_on;\n\n\tkbdintctxt = authctxt->kbdintctxt;\n\tif (kbdintctxt->device->query(kbdintctxt->ctxt,\n\t    &name, &instr, &kbdintctxt->nreq, &prompts, &echo_on))\n\t\treturn 0;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_INFO_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, name)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, instr)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"\")) != 0 ||\t/* language not used */\n\t    (r = sshpkt_put_u32(ssh, kbdintctxt->nreq)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tfor (i = 0; i < kbdintctxt->nreq; i++) {\n\t\tif ((r = sshpkt_put_cstring(ssh, prompts[i])) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, echo_on[i])) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t}\n\tif ((r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tfor (i = 0; i < kbdintctxt->nreq; i++)\n\t\tfree(prompts[i]);\n\tfree(prompts);\n\tfree(echo_on);\n\tfree(name);\n\tfree(instr);\n\treturn 1;\n}",
          "includes": [
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int auth2_challenge_start(struct ssh *);",
            "static int send_userauth_info_request(struct ssh *);",
            "static int input_userauth_info_response(int, u_int32_t, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int auth2_challenge_start(struct ssh *);\nstatic int send_userauth_info_request(struct ssh *);\nstatic int input_userauth_info_response(int, u_int32_t, struct ssh *);\n\nstatic int\nsend_userauth_info_request(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tKbdintAuthctxt *kbdintctxt;\n\tchar *name, *instr, **prompts;\n\tu_int r, i, *echo_on;\n\n\tkbdintctxt = authctxt->kbdintctxt;\n\tif (kbdintctxt->device->query(kbdintctxt->ctxt,\n\t    &name, &instr, &kbdintctxt->nreq, &prompts, &echo_on))\n\t\treturn 0;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_INFO_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, name)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, instr)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"\")) != 0 ||\t/* language not used */\n\t    (r = sshpkt_put_u32(ssh, kbdintctxt->nreq)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tfor (i = 0; i < kbdintctxt->nreq; i++) {\n\t\tif ((r = sshpkt_put_cstring(ssh, prompts[i])) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, echo_on[i])) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t}\n\tif ((r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tfor (i = 0; i < kbdintctxt->nreq; i++)\n\t\tfree(prompts[i]);\n\tfree(prompts);\n\tfree(echo_on);\n\tfree(name);\n\tfree(instr);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "response"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "kbdint_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
          "lines": "143-151",
          "snippet": "static void\nkbdint_free(KbdintAuthctxt *kbdintctxt)\n{\n\tif (kbdintctxt->device)\n\t\tkbdint_reset_device(kbdintctxt);\n\tfree(kbdintctxt->devices);\n\texplicit_bzero(kbdintctxt, sizeof(*kbdintctxt));\n\tfree(kbdintctxt);\n}",
          "includes": [
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "KbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nKbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};\n\nstatic void\nkbdint_free(KbdintAuthctxt *kbdintctxt)\n{\n\tif (kbdintctxt->device)\n\t\tkbdint_reset_device(kbdintctxt);\n\tfree(kbdintctxt->devices);\n\texplicit_bzero(kbdintctxt, sizeof(*kbdintctxt));\n\tfree(kbdintctxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "response[i]",
            "strlen(response[i])"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "response[i]"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kbdintctxt->device->respond",
          "args": [
            "kbdintctxt->ctxt",
            "nresp",
            "response"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_end",
          "args": [
            "ssh"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2555-2561",
          "snippet": "int\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_cstring",
          "args": [
            "ssh",
            "&response[i]",
            "NULL"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2532-2536",
          "snippet": "int\nsshpkt_get_cstring(struct ssh *ssh, char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_cstring(ssh->state->incoming_packet, valp, lenp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_cstring(struct ssh *ssh, char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_cstring(ssh->state->incoming_packet, valp, lenp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "nresp",
            "sizeof(char *)"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_get_u32",
          "args": [
            "ssh",
            "&nresp"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_get_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2502-2506",
          "snippet": "int\nsshpkt_get_u32(struct ssh *ssh, u_int32_t *valp)\n{\n\treturn sshbuf_get_u32(ssh->state->incoming_packet, valp);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_get_u32(struct ssh *ssh, u_int32_t *valp)\n{\n\treturn sshbuf_get_u32(ssh->state->incoming_packet, valp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int auth2_challenge_start(struct ssh *);\nstatic int send_userauth_info_request(struct ssh *);\nstatic int input_userauth_info_response(int, u_int32_t, struct ssh *);\n\nstatic int\ninput_userauth_info_response(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tKbdintAuthctxt *kbdintctxt;\n\tint authenticated = 0, res;\n\tint r;\n\tu_int i, nresp;\n\tconst char *devicename = NULL;\n\tchar **response = NULL;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_userauth_info_response: no authctxt\");\n\tkbdintctxt = authctxt->kbdintctxt;\n\tif (kbdintctxt == NULL || kbdintctxt->ctxt == NULL)\n\t\tfatal(\"input_userauth_info_response: no kbdintctxt\");\n\tif (kbdintctxt->device == NULL)\n\t\tfatal(\"input_userauth_info_response: no device\");\n\n\tauthctxt->postponed = 0;\t/* reset */\n\tif ((r = sshpkt_get_u32(ssh, &nresp)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tif (nresp != kbdintctxt->nreq)\n\t\tfatal(\"input_userauth_info_response: wrong number of replies\");\n\tif (nresp > 100)\n\t\tfatal(\"input_userauth_info_response: too many replies\");\n\tif (nresp > 0) {\n\t\tresponse = xcalloc(nresp, sizeof(char *));\n\t\tfor (i = 0; i < nresp; i++)\n\t\t\tif ((r = sshpkt_get_cstring(ssh, &response[i],\n\t\t\t    NULL)) != 0)\n\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t}\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tres = kbdintctxt->device->respond(kbdintctxt->ctxt, nresp, response);\n\n\tfor (i = 0; i < nresp; i++) {\n\t\texplicit_bzero(response[i], strlen(response[i]));\n\t\tfree(response[i]);\n\t}\n\tfree(response);\n\n\tswitch (res) {\n\tcase 0:\n\t\t/* Success! */\n\t\tauthenticated = authctxt->valid ? 1 : 0;\n\t\tbreak;\n\tcase 1:\n\t\t/* Authentication needs further interaction */\n\t\tif (send_userauth_info_request(ssh) == 1)\n\t\t\tauthctxt->postponed = 1;\n\t\tbreak;\n\tdefault:\n\t\t/* Failure! */\n\t\tbreak;\n\t}\n\tdevicename = kbdintctxt->device->name;\n\tif (!authctxt->postponed) {\n\t\tif (authenticated) {\n\t\t\tauth2_challenge_stop(ssh);\n\t\t} else {\n\t\t\t/* start next device */\n\t\t\t/* may set authctxt->postponed */\n\t\t\tauth2_challenge_start(ssh);\n\t\t}\n\t}\n\tuserauth_finish(ssh, authenticated, \"keyboard-interactive\",\n\t    devicename);\n\treturn 0;\n}"
  },
  {
    "function_name": "send_userauth_info_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
    "lines": "253-288",
    "snippet": "static int\nsend_userauth_info_request(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tKbdintAuthctxt *kbdintctxt;\n\tchar *name, *instr, **prompts;\n\tu_int r, i, *echo_on;\n\n\tkbdintctxt = authctxt->kbdintctxt;\n\tif (kbdintctxt->device->query(kbdintctxt->ctxt,\n\t    &name, &instr, &kbdintctxt->nreq, &prompts, &echo_on))\n\t\treturn 0;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_INFO_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, name)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, instr)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"\")) != 0 ||\t/* language not used */\n\t    (r = sshpkt_put_u32(ssh, kbdintctxt->nreq)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tfor (i = 0; i < kbdintctxt->nreq; i++) {\n\t\tif ((r = sshpkt_put_cstring(ssh, prompts[i])) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, echo_on[i])) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t}\n\tif ((r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tfor (i = 0; i < kbdintctxt->nreq; i++)\n\t\tfree(prompts[i]);\n\tfree(prompts);\n\tfree(echo_on);\n\tfree(name);\n\tfree(instr);\n\treturn 1;\n}",
    "includes": [
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"dispatch.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"xmalloc.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int auth2_challenge_start(struct ssh *);",
      "static int send_userauth_info_request(struct ssh *);",
      "static int input_userauth_info_response(int, u_int32_t, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "instr"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "kbdint_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
          "lines": "143-151",
          "snippet": "static void\nkbdint_free(KbdintAuthctxt *kbdintctxt)\n{\n\tif (kbdintctxt->device)\n\t\tkbdint_reset_device(kbdintctxt);\n\tfree(kbdintctxt->devices);\n\texplicit_bzero(kbdintctxt, sizeof(*kbdintctxt));\n\tfree(kbdintctxt);\n}",
          "includes": [
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "KbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nKbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};\n\nstatic void\nkbdint_free(KbdintAuthctxt *kbdintctxt)\n{\n\tif (kbdintctxt->device)\n\t\tkbdint_reset_device(kbdintctxt);\n\tfree(kbdintctxt->devices);\n\texplicit_bzero(kbdintctxt, sizeof(*kbdintctxt));\n\tfree(kbdintctxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_packet_write_wait",
          "args": [
            "ssh"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_packet_write_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "1930-1985",
          "snippet": "int\nssh_packet_write_wait(struct ssh *ssh)\n{\n\tfd_set *setp;\n\tint ret, r, ms_remain = 0;\n\tstruct timeval start, timeout, *timeoutp = NULL;\n\tstruct session_state *state = ssh->state;\n\n\tsetp = calloc(howmany(state->connection_out + 1,\n\t    NFDBITS), sizeof(fd_mask));\n\tif (setp == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = ssh_packet_write_poll(ssh)) != 0) {\n\t\tfree(setp);\n\t\treturn r;\n\t}\n\twhile (ssh_packet_have_data_to_write(ssh)) {\n\t\tmemset(setp, 0, howmany(state->connection_out + 1,\n\t\t    NFDBITS) * sizeof(fd_mask));\n\t\tFD_SET(state->connection_out, setp);\n\n\t\tif (state->packet_timeout_ms > 0) {\n\t\t\tms_remain = state->packet_timeout_ms;\n\t\t\ttimeoutp = &timeout;\n\t\t}\n\t\tfor (;;) {\n\t\t\tif (state->packet_timeout_ms != -1) {\n\t\t\t\tms_to_timeval(&timeout, ms_remain);\n\t\t\t\tmonotime_tv(&start);\n\t\t\t}\n\t\t\tif ((ret = select(state->connection_out + 1,\n\t\t\t    NULL, setp, NULL, timeoutp)) >= 0)\n\t\t\t\tbreak;\n\t\t\tif (errno != EAGAIN && errno != EINTR &&\n\t\t\t    errno != EWOULDBLOCK)\n\t\t\t\tbreak;\n\t\t\tif (state->packet_timeout_ms == -1)\n\t\t\t\tcontinue;\n\t\t\tms_subtract_diff(&start, &ms_remain);\n\t\t\tif (ms_remain <= 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ret == 0) {\n\t\t\tfree(setp);\n\t\t\treturn SSH_ERR_CONN_TIMEOUT;\n\t\t}\n\t\tif ((r = ssh_packet_write_poll(ssh)) != 0) {\n\t\t\tfree(setp);\n\t\t\treturn r;\n\t\t}\n\t}\n\tfree(setp);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_packet_write_wait(struct ssh *ssh)\n{\n\tfd_set *setp;\n\tint ret, r, ms_remain = 0;\n\tstruct timeval start, timeout, *timeoutp = NULL;\n\tstruct session_state *state = ssh->state;\n\n\tsetp = calloc(howmany(state->connection_out + 1,\n\t    NFDBITS), sizeof(fd_mask));\n\tif (setp == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = ssh_packet_write_poll(ssh)) != 0) {\n\t\tfree(setp);\n\t\treturn r;\n\t}\n\twhile (ssh_packet_have_data_to_write(ssh)) {\n\t\tmemset(setp, 0, howmany(state->connection_out + 1,\n\t\t    NFDBITS) * sizeof(fd_mask));\n\t\tFD_SET(state->connection_out, setp);\n\n\t\tif (state->packet_timeout_ms > 0) {\n\t\t\tms_remain = state->packet_timeout_ms;\n\t\t\ttimeoutp = &timeout;\n\t\t}\n\t\tfor (;;) {\n\t\t\tif (state->packet_timeout_ms != -1) {\n\t\t\t\tms_to_timeval(&timeout, ms_remain);\n\t\t\t\tmonotime_tv(&start);\n\t\t\t}\n\t\t\tif ((ret = select(state->connection_out + 1,\n\t\t\t    NULL, setp, NULL, timeoutp)) >= 0)\n\t\t\t\tbreak;\n\t\t\tif (errno != EAGAIN && errno != EINTR &&\n\t\t\t    errno != EWOULDBLOCK)\n\t\t\t\tbreak;\n\t\t\tif (state->packet_timeout_ms == -1)\n\t\t\t\tcontinue;\n\t\t\tms_subtract_diff(&start, &ms_remain);\n\t\t\tif (ms_remain <= 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ret == 0) {\n\t\t\tfree(setp);\n\t\t\treturn SSH_ERR_CONN_TIMEOUT;\n\t\t}\n\t\tif ((r = ssh_packet_write_poll(ssh)) != 0) {\n\t\t\tfree(setp);\n\t\t\treturn r;\n\t\t}\n\t}\n\tfree(setp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_send",
          "args": [
            "ssh"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2648-2654",
          "snippet": "int\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u8",
          "args": [
            "ssh",
            "echo_on[i]"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2435-2439",
          "snippet": "int\nsshpkt_put_u8(struct ssh *ssh, u_char val)\n{\n\treturn sshbuf_put_u8(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u8(struct ssh *ssh, u_char val)\n{\n\treturn sshbuf_put_u8(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_cstring",
          "args": [
            "ssh",
            "prompts[i]"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2459-2463",
          "snippet": "int\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_put_u32",
          "args": [
            "ssh",
            "kbdintctxt->nreq"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2441-2445",
          "snippet": "int\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshpkt_start",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_INFO_REQUEST"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "sshpkt_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/packet.c",
          "lines": "2573-2583",
          "snippet": "int\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"ssh.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"mac.h\"",
            "#include \"digest.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"ssh2.h\"",
            "#include \"compat.h\"",
            "#include \"crc32.h\"",
            "#include \"xmalloc.h\"",
            "#include <zlib.h>",
            "#  include <openssl/ec.h>",
            "# include <openssl/evp.h>",
            "# include <openssl/bn.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"ssh.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"ssh2.h\"\n#include \"compat.h\"\n#include \"crc32.h\"\n#include \"xmalloc.h\"\n#include <zlib.h>\n#  include <openssl/ec.h>\n# include <openssl/evp.h>\n# include <openssl/bn.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6]; /* u32 packet length, u8 pad len, u8 type */\n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbdintctxt->device->query",
          "args": [
            "kbdintctxt->ctxt",
            "&name",
            "&instr",
            "&kbdintctxt->nreq",
            "&prompts",
            "&echo_on"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int auth2_challenge_start(struct ssh *);\nstatic int send_userauth_info_request(struct ssh *);\nstatic int input_userauth_info_response(int, u_int32_t, struct ssh *);\n\nstatic int\nsend_userauth_info_request(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tKbdintAuthctxt *kbdintctxt;\n\tchar *name, *instr, **prompts;\n\tu_int r, i, *echo_on;\n\n\tkbdintctxt = authctxt->kbdintctxt;\n\tif (kbdintctxt->device->query(kbdintctxt->ctxt,\n\t    &name, &instr, &kbdintctxt->nreq, &prompts, &echo_on))\n\t\treturn 0;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_INFO_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, name)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, instr)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"\")) != 0 ||\t/* language not used */\n\t    (r = sshpkt_put_u32(ssh, kbdintctxt->nreq)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tfor (i = 0; i < kbdintctxt->nreq; i++) {\n\t\tif ((r = sshpkt_put_cstring(ssh, prompts[i])) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, echo_on[i])) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t}\n\tif ((r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tfor (i = 0; i < kbdintctxt->nreq; i++)\n\t\tfree(prompts[i]);\n\tfree(prompts);\n\tfree(echo_on);\n\tfree(name);\n\tfree(instr);\n\treturn 1;\n}"
  },
  {
    "function_name": "auth2_challenge_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
    "lines": "222-251",
    "snippet": "static int\nauth2_challenge_start(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tKbdintAuthctxt *kbdintctxt = authctxt->kbdintctxt;\n\n\tdebug2(\"auth2_challenge_start: devices %s\",\n\t    kbdintctxt->devices ?  kbdintctxt->devices : \"<empty>\");\n\n\tif (kbdint_next_device(authctxt, kbdintctxt) == 0) {\n\t\tauth2_challenge_stop(ssh);\n\t\treturn 0;\n\t}\n\tdebug(\"auth2_challenge_start: trying authentication method '%s'\",\n\t    kbdintctxt->device->name);\n\n\tif ((kbdintctxt->ctxt = kbdintctxt->device->init_ctx(authctxt)) == NULL) {\n\t\tauth2_challenge_stop(ssh);\n\t\treturn 0;\n\t}\n\tif (send_userauth_info_request(ssh) == 0) {\n\t\tauth2_challenge_stop(ssh);\n\t\treturn 0;\n\t}\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_INFO_RESPONSE,\n\t    &input_userauth_info_response);\n\n\tauthctxt->postponed = 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"dispatch.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"xmalloc.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int auth2_challenge_start(struct ssh *);",
      "static int send_userauth_info_request(struct ssh *);",
      "static int input_userauth_info_response(int, u_int32_t, struct ssh *);",
      "KbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_dispatch_set",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_INFO_RESPONSE",
            "&input_userauth_info_response"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_dispatch_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dispatch.c",
          "lines": "81-85",
          "snippet": "void\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"dispatch.h\"",
            "#include \"log.h\"",
            "#include \"ssh2.h\"",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include <stdarg.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth2_challenge_stop",
          "args": [
            "ssh"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "auth2_challenge_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
          "lines": "209-219",
          "snippet": "void\nauth2_challenge_stop(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\t/* unregister callback */\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_INFO_RESPONSE, NULL);\n\tif (authctxt->kbdintctxt != NULL) {\n\t\tkbdint_free(authctxt->kbdintctxt);\n\t\tauthctxt->kbdintctxt = NULL;\n\t}\n}",
          "includes": [
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int auth2_challenge_start(struct ssh *);",
            "static int send_userauth_info_request(struct ssh *);",
            "static int input_userauth_info_response(int, u_int32_t, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int auth2_challenge_start(struct ssh *);\nstatic int send_userauth_info_request(struct ssh *);\nstatic int input_userauth_info_response(int, u_int32_t, struct ssh *);\n\nvoid\nauth2_challenge_stop(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\t/* unregister callback */\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_INFO_RESPONSE, NULL);\n\tif (authctxt->kbdintctxt != NULL) {\n\t\tkbdint_free(authctxt->kbdintctxt);\n\t\tauthctxt->kbdintctxt = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_userauth_info_request",
          "args": [
            "ssh"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "send_userauth_info_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
          "lines": "253-288",
          "snippet": "static int\nsend_userauth_info_request(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tKbdintAuthctxt *kbdintctxt;\n\tchar *name, *instr, **prompts;\n\tu_int r, i, *echo_on;\n\n\tkbdintctxt = authctxt->kbdintctxt;\n\tif (kbdintctxt->device->query(kbdintctxt->ctxt,\n\t    &name, &instr, &kbdintctxt->nreq, &prompts, &echo_on))\n\t\treturn 0;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_INFO_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, name)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, instr)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"\")) != 0 ||\t/* language not used */\n\t    (r = sshpkt_put_u32(ssh, kbdintctxt->nreq)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tfor (i = 0; i < kbdintctxt->nreq; i++) {\n\t\tif ((r = sshpkt_put_cstring(ssh, prompts[i])) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, echo_on[i])) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t}\n\tif ((r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tfor (i = 0; i < kbdintctxt->nreq; i++)\n\t\tfree(prompts[i]);\n\tfree(prompts);\n\tfree(echo_on);\n\tfree(name);\n\tfree(instr);\n\treturn 1;\n}",
          "includes": [
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int auth2_challenge_start(struct ssh *);",
            "static int send_userauth_info_request(struct ssh *);",
            "static int input_userauth_info_response(int, u_int32_t, struct ssh *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int auth2_challenge_start(struct ssh *);\nstatic int send_userauth_info_request(struct ssh *);\nstatic int input_userauth_info_response(int, u_int32_t, struct ssh *);\n\nstatic int\nsend_userauth_info_request(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tKbdintAuthctxt *kbdintctxt;\n\tchar *name, *instr, **prompts;\n\tu_int r, i, *echo_on;\n\n\tkbdintctxt = authctxt->kbdintctxt;\n\tif (kbdintctxt->device->query(kbdintctxt->ctxt,\n\t    &name, &instr, &kbdintctxt->nreq, &prompts, &echo_on))\n\t\treturn 0;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_INFO_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, name)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, instr)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"\")) != 0 ||\t/* language not used */\n\t    (r = sshpkt_put_u32(ssh, kbdintctxt->nreq)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tfor (i = 0; i < kbdintctxt->nreq; i++) {\n\t\tif ((r = sshpkt_put_cstring(ssh, prompts[i])) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, echo_on[i])) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t}\n\tif ((r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tfor (i = 0; i < kbdintctxt->nreq; i++)\n\t\tfree(prompts[i]);\n\tfree(prompts);\n\tfree(echo_on);\n\tfree(name);\n\tfree(instr);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbdintctxt->device->init_ctx",
          "args": [
            "authctxt"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"auth2_challenge_start: trying authentication method '%s'\"",
            "kbdintctxt->device->name"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbdint_next_device",
          "args": [
            "authctxt",
            "kbdintctxt"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "kbdint_next_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
          "lines": "153-187",
          "snippet": "static int\nkbdint_next_device(Authctxt *authctxt, KbdintAuthctxt *kbdintctxt)\n{\n\tsize_t len;\n\tchar *t;\n\tint i;\n\n\tif (kbdintctxt->device)\n\t\tkbdint_reset_device(kbdintctxt);\n\tdo {\n\t\tlen = kbdintctxt->devices ?\n\t\t    strcspn(kbdintctxt->devices, \",\") : 0;\n\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; devices[i]; i++) {\n\t\t\tif ((kbdintctxt->devices_done & (1 << i)) != 0 ||\n\t\t\t    !auth2_method_allowed(authctxt,\n\t\t\t    \"keyboard-interactive\", devices[i]->name))\n\t\t\t\tcontinue;\n\t\t\tif (strncmp(kbdintctxt->devices, devices[i]->name,\n\t\t\t    len) == 0) {\n\t\t\t\tkbdintctxt->device = devices[i];\n\t\t\t\tkbdintctxt->devices_done |= 1 << i;\n\t\t\t}\n\t\t}\n\t\tt = kbdintctxt->devices;\n\t\tkbdintctxt->devices = t[len] ? xstrdup(t+len+1) : NULL;\n\t\tfree(t);\n\t\tdebug2(\"kbdint_next_device: devices %s\", kbdintctxt->devices ?\n\t\t    kbdintctxt->devices : \"<empty>\");\n\t} while (kbdintctxt->devices && !kbdintctxt->device);\n\n\treturn kbdintctxt->device ? 1 : 0;\n}",
          "includes": [
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "KbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nKbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};\n\nstatic int\nkbdint_next_device(Authctxt *authctxt, KbdintAuthctxt *kbdintctxt)\n{\n\tsize_t len;\n\tchar *t;\n\tint i;\n\n\tif (kbdintctxt->device)\n\t\tkbdint_reset_device(kbdintctxt);\n\tdo {\n\t\tlen = kbdintctxt->devices ?\n\t\t    strcspn(kbdintctxt->devices, \",\") : 0;\n\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; devices[i]; i++) {\n\t\t\tif ((kbdintctxt->devices_done & (1 << i)) != 0 ||\n\t\t\t    !auth2_method_allowed(authctxt,\n\t\t\t    \"keyboard-interactive\", devices[i]->name))\n\t\t\t\tcontinue;\n\t\t\tif (strncmp(kbdintctxt->devices, devices[i]->name,\n\t\t\t    len) == 0) {\n\t\t\t\tkbdintctxt->device = devices[i];\n\t\t\t\tkbdintctxt->devices_done |= 1 << i;\n\t\t\t}\n\t\t}\n\t\tt = kbdintctxt->devices;\n\t\tkbdintctxt->devices = t[len] ? xstrdup(t+len+1) : NULL;\n\t\tfree(t);\n\t\tdebug2(\"kbdint_next_device: devices %s\", kbdintctxt->devices ?\n\t\t    kbdintctxt->devices : \"<empty>\");\n\t} while (kbdintctxt->devices && !kbdintctxt->device);\n\n\treturn kbdintctxt->device ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"auth2_challenge_start: devices %s\"",
            "kbdintctxt->devices ?  kbdintctxt->devices : \"<empty>\""
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int auth2_challenge_start(struct ssh *);\nstatic int send_userauth_info_request(struct ssh *);\nstatic int input_userauth_info_response(int, u_int32_t, struct ssh *);\nKbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};\n\nstatic int\nauth2_challenge_start(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tKbdintAuthctxt *kbdintctxt = authctxt->kbdintctxt;\n\n\tdebug2(\"auth2_challenge_start: devices %s\",\n\t    kbdintctxt->devices ?  kbdintctxt->devices : \"<empty>\");\n\n\tif (kbdint_next_device(authctxt, kbdintctxt) == 0) {\n\t\tauth2_challenge_stop(ssh);\n\t\treturn 0;\n\t}\n\tdebug(\"auth2_challenge_start: trying authentication method '%s'\",\n\t    kbdintctxt->device->name);\n\n\tif ((kbdintctxt->ctxt = kbdintctxt->device->init_ctx(authctxt)) == NULL) {\n\t\tauth2_challenge_stop(ssh);\n\t\treturn 0;\n\t}\n\tif (send_userauth_info_request(ssh) == 0) {\n\t\tauth2_challenge_stop(ssh);\n\t\treturn 0;\n\t}\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_INFO_RESPONSE,\n\t    &input_userauth_info_response);\n\n\tauthctxt->postponed = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "auth2_challenge_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
    "lines": "209-219",
    "snippet": "void\nauth2_challenge_stop(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\t/* unregister callback */\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_INFO_RESPONSE, NULL);\n\tif (authctxt->kbdintctxt != NULL) {\n\t\tkbdint_free(authctxt->kbdintctxt);\n\t\tauthctxt->kbdintctxt = NULL;\n\t}\n}",
    "includes": [
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"dispatch.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"xmalloc.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int auth2_challenge_start(struct ssh *);",
      "static int send_userauth_info_request(struct ssh *);",
      "static int input_userauth_info_response(int, u_int32_t, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kbdint_free",
          "args": [
            "authctxt->kbdintctxt"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "kbdint_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
          "lines": "143-151",
          "snippet": "static void\nkbdint_free(KbdintAuthctxt *kbdintctxt)\n{\n\tif (kbdintctxt->device)\n\t\tkbdint_reset_device(kbdintctxt);\n\tfree(kbdintctxt->devices);\n\texplicit_bzero(kbdintctxt, sizeof(*kbdintctxt));\n\tfree(kbdintctxt);\n}",
          "includes": [
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "KbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nKbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};\n\nstatic void\nkbdint_free(KbdintAuthctxt *kbdintctxt)\n{\n\tif (kbdintctxt->device)\n\t\tkbdint_reset_device(kbdintctxt);\n\tfree(kbdintctxt->devices);\n\texplicit_bzero(kbdintctxt, sizeof(*kbdintctxt));\n\tfree(kbdintctxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_dispatch_set",
          "args": [
            "ssh",
            "SSH2_MSG_USERAUTH_INFO_RESPONSE",
            "NULL"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_dispatch_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/dispatch.c",
          "lines": "81-85",
          "snippet": "void\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"dispatch.h\"",
            "#include \"log.h\"",
            "#include \"ssh2.h\"",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n#include <stdarg.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_dispatch_set(struct ssh *ssh, int type, dispatch_fn *fn)\n{\n\tssh->dispatch[type] = fn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int auth2_challenge_start(struct ssh *);\nstatic int send_userauth_info_request(struct ssh *);\nstatic int input_userauth_info_response(int, u_int32_t, struct ssh *);\n\nvoid\nauth2_challenge_stop(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\t/* unregister callback */\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_INFO_RESPONSE, NULL);\n\tif (authctxt->kbdintctxt != NULL) {\n\t\tkbdint_free(authctxt->kbdintctxt);\n\t\tauthctxt->kbdintctxt = NULL;\n\t}\n}"
  },
  {
    "function_name": "auth2_challenge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
    "lines": "193-206",
    "snippet": "int\nauth2_challenge(struct ssh *ssh, char *devs)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tdebug(\"auth2_challenge: user=%s devs=%s\",\n\t    authctxt->user ? authctxt->user : \"<nouser>\",\n\t    devs ? devs : \"<no devs>\");\n\n\tif (authctxt->user == NULL || !devs)\n\t\treturn 0;\n\tif (authctxt->kbdintctxt == NULL)\n\t\tauthctxt->kbdintctxt = kbdint_alloc(devs);\n\treturn auth2_challenge_start(ssh);\n}",
    "includes": [
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"dispatch.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"xmalloc.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int auth2_challenge_start(struct ssh *);",
      "static int send_userauth_info_request(struct ssh *);",
      "static int input_userauth_info_response(int, u_int32_t, struct ssh *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "auth2_challenge_start",
          "args": [
            "ssh"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "auth2_challenge_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
          "lines": "222-251",
          "snippet": "static int\nauth2_challenge_start(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tKbdintAuthctxt *kbdintctxt = authctxt->kbdintctxt;\n\n\tdebug2(\"auth2_challenge_start: devices %s\",\n\t    kbdintctxt->devices ?  kbdintctxt->devices : \"<empty>\");\n\n\tif (kbdint_next_device(authctxt, kbdintctxt) == 0) {\n\t\tauth2_challenge_stop(ssh);\n\t\treturn 0;\n\t}\n\tdebug(\"auth2_challenge_start: trying authentication method '%s'\",\n\t    kbdintctxt->device->name);\n\n\tif ((kbdintctxt->ctxt = kbdintctxt->device->init_ctx(authctxt)) == NULL) {\n\t\tauth2_challenge_stop(ssh);\n\t\treturn 0;\n\t}\n\tif (send_userauth_info_request(ssh) == 0) {\n\t\tauth2_challenge_stop(ssh);\n\t\treturn 0;\n\t}\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_INFO_RESPONSE,\n\t    &input_userauth_info_response);\n\n\tauthctxt->postponed = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int auth2_challenge_start(struct ssh *);",
            "static int send_userauth_info_request(struct ssh *);",
            "static int input_userauth_info_response(int, u_int32_t, struct ssh *);",
            "KbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int auth2_challenge_start(struct ssh *);\nstatic int send_userauth_info_request(struct ssh *);\nstatic int input_userauth_info_response(int, u_int32_t, struct ssh *);\nKbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};\n\nstatic int\nauth2_challenge_start(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tKbdintAuthctxt *kbdintctxt = authctxt->kbdintctxt;\n\n\tdebug2(\"auth2_challenge_start: devices %s\",\n\t    kbdintctxt->devices ?  kbdintctxt->devices : \"<empty>\");\n\n\tif (kbdint_next_device(authctxt, kbdintctxt) == 0) {\n\t\tauth2_challenge_stop(ssh);\n\t\treturn 0;\n\t}\n\tdebug(\"auth2_challenge_start: trying authentication method '%s'\",\n\t    kbdintctxt->device->name);\n\n\tif ((kbdintctxt->ctxt = kbdintctxt->device->init_ctx(authctxt)) == NULL) {\n\t\tauth2_challenge_stop(ssh);\n\t\treturn 0;\n\t}\n\tif (send_userauth_info_request(ssh) == 0) {\n\t\tauth2_challenge_stop(ssh);\n\t\treturn 0;\n\t}\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_INFO_RESPONSE,\n\t    &input_userauth_info_response);\n\n\tauthctxt->postponed = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbdint_alloc",
          "args": [
            "devs"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "kbdint_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
          "lines": "99-133",
          "snippet": "static KbdintAuthctxt *\nkbdint_alloc(const char *devs)\n{\n\tKbdintAuthctxt *kbdintctxt;\n\tstruct sshbuf *b;\n\tint i, r;\n\n#ifdef USE_PAM\n\tif (!options.use_pam)\n\t\tremove_kbdint_device(\"pam\");\n#endif\n\n\tkbdintctxt = xcalloc(1, sizeof(KbdintAuthctxt));\n\tif (strcmp(devs, \"\") == 0) {\n\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\tfor (i = 0; devices[i]; i++) {\n\t\t\tif ((r = sshbuf_putf(b, \"%s%s\",\n\t\t\t    sshbuf_len(b) ? \",\" : \"\", devices[i]->name)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t\tif ((kbdintctxt->devices = sshbuf_dup_string(b)) == NULL)\n\t\t\tfatal(\"%s: sshbuf_dup_string failed\", __func__);\n\t\tsshbuf_free(b);\n\t} else {\n\t\tkbdintctxt->devices = xstrdup(devs);\n\t}\n\tdebug(\"kbdint_alloc: devices '%s'\", kbdintctxt->devices);\n\tkbdintctxt->ctxt = NULL;\n\tkbdintctxt->device = NULL;\n\tkbdintctxt->nreq = 0;\n\n\treturn kbdintctxt;\n}",
          "includes": [
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern ServerOptions options;",
            "KbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nKbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};\n\nstatic KbdintAuthctxt *\nkbdint_alloc(const char *devs)\n{\n\tKbdintAuthctxt *kbdintctxt;\n\tstruct sshbuf *b;\n\tint i, r;\n\n#ifdef USE_PAM\n\tif (!options.use_pam)\n\t\tremove_kbdint_device(\"pam\");\n#endif\n\n\tkbdintctxt = xcalloc(1, sizeof(KbdintAuthctxt));\n\tif (strcmp(devs, \"\") == 0) {\n\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\tfor (i = 0; devices[i]; i++) {\n\t\t\tif ((r = sshbuf_putf(b, \"%s%s\",\n\t\t\t    sshbuf_len(b) ? \",\" : \"\", devices[i]->name)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t\tif ((kbdintctxt->devices = sshbuf_dup_string(b)) == NULL)\n\t\t\tfatal(\"%s: sshbuf_dup_string failed\", __func__);\n\t\tsshbuf_free(b);\n\t} else {\n\t\tkbdintctxt->devices = xstrdup(devs);\n\t}\n\tdebug(\"kbdint_alloc: devices '%s'\", kbdintctxt->devices);\n\tkbdintctxt->ctxt = NULL;\n\tkbdintctxt->device = NULL;\n\tkbdintctxt->nreq = 0;\n\n\treturn kbdintctxt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"auth2_challenge: user=%s devs=%s\"",
            "authctxt->user ? authctxt->user : \"<nouser>\"",
            "devs ? devs : \"<no devs>\""
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int auth2_challenge_start(struct ssh *);\nstatic int send_userauth_info_request(struct ssh *);\nstatic int input_userauth_info_response(int, u_int32_t, struct ssh *);\n\nint\nauth2_challenge(struct ssh *ssh, char *devs)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tdebug(\"auth2_challenge: user=%s devs=%s\",\n\t    authctxt->user ? authctxt->user : \"<nouser>\",\n\t    devs ? devs : \"<no devs>\");\n\n\tif (authctxt->user == NULL || !devs)\n\t\treturn 0;\n\tif (authctxt->kbdintctxt == NULL)\n\t\tauthctxt->kbdintctxt = kbdint_alloc(devs);\n\treturn auth2_challenge_start(ssh);\n}"
  },
  {
    "function_name": "kbdint_next_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
    "lines": "153-187",
    "snippet": "static int\nkbdint_next_device(Authctxt *authctxt, KbdintAuthctxt *kbdintctxt)\n{\n\tsize_t len;\n\tchar *t;\n\tint i;\n\n\tif (kbdintctxt->device)\n\t\tkbdint_reset_device(kbdintctxt);\n\tdo {\n\t\tlen = kbdintctxt->devices ?\n\t\t    strcspn(kbdintctxt->devices, \",\") : 0;\n\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; devices[i]; i++) {\n\t\t\tif ((kbdintctxt->devices_done & (1 << i)) != 0 ||\n\t\t\t    !auth2_method_allowed(authctxt,\n\t\t\t    \"keyboard-interactive\", devices[i]->name))\n\t\t\t\tcontinue;\n\t\t\tif (strncmp(kbdintctxt->devices, devices[i]->name,\n\t\t\t    len) == 0) {\n\t\t\t\tkbdintctxt->device = devices[i];\n\t\t\t\tkbdintctxt->devices_done |= 1 << i;\n\t\t\t}\n\t\t}\n\t\tt = kbdintctxt->devices;\n\t\tkbdintctxt->devices = t[len] ? xstrdup(t+len+1) : NULL;\n\t\tfree(t);\n\t\tdebug2(\"kbdint_next_device: devices %s\", kbdintctxt->devices ?\n\t\t    kbdintctxt->devices : \"<empty>\");\n\t} while (kbdintctxt->devices && !kbdintctxt->device);\n\n\treturn kbdintctxt->device ? 1 : 0;\n}",
    "includes": [
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"dispatch.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"xmalloc.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "KbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"kbdint_next_device: devices %s\"",
            "kbdintctxt->devices ?\n\t\t    kbdintctxt->devices : \"<empty>\""
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "t"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "kbdint_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
          "lines": "143-151",
          "snippet": "static void\nkbdint_free(KbdintAuthctxt *kbdintctxt)\n{\n\tif (kbdintctxt->device)\n\t\tkbdint_reset_device(kbdintctxt);\n\tfree(kbdintctxt->devices);\n\texplicit_bzero(kbdintctxt, sizeof(*kbdintctxt));\n\tfree(kbdintctxt);\n}",
          "includes": [
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "KbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nKbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};\n\nstatic void\nkbdint_free(KbdintAuthctxt *kbdintctxt)\n{\n\tif (kbdintctxt->device)\n\t\tkbdint_reset_device(kbdintctxt);\n\tfree(kbdintctxt->devices);\n\texplicit_bzero(kbdintctxt, sizeof(*kbdintctxt));\n\tfree(kbdintctxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "t+len+1"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "kbdintctxt->devices",
            "devices[i]->name",
            "len"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "g_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "422-435",
          "snippet": "static int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth2_method_allowed",
          "args": [
            "authctxt",
            "\"keyboard-interactive\"",
            "devices[i]->name"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "auth2_method_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2.c",
          "lines": "436-454",
          "snippet": "int\nauth2_method_allowed(Authctxt *authctxt, const char *method,\n    const char *submethod)\n{\n\tu_int i;\n\n\t/*\n\t * NB. authctxt->num_auth_methods might be zero as a result of\n\t * auth2_setup_methods_lists(), so check the configuration.\n\t */\n\tif (options.num_auth_methods == 0)\n\t\treturn 1;\n\tfor (i = 0; i < authctxt->num_auth_methods; i++) {\n\t\tif (list_starts_with(authctxt->auth_methods[i], method,\n\t\t    submethod) != MATCH_NONE)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"ssherr.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"pathnames.h\"",
            "#include \"dispatch.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include \"atomicio.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define MATCH_NONE\t0\t/* method or submethod mismatch */"
          ],
          "globals_used": [
            "extern ServerOptions options;",
            "static Authmethod *authmethod_lookup(Authctxt *, const char *);",
            "static char *authmethods_get(Authctxt *authctxt);",
            "static int list_starts_with(const char *, const char *, const char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"monitor_wrap.h\"\n#include \"ssh-gss.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"pathnames.h\"\n#include \"dispatch.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include \"atomicio.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define MATCH_NONE\t0\t/* method or submethod mismatch */\n\nextern ServerOptions options;\nstatic Authmethod *authmethod_lookup(Authctxt *, const char *);\nstatic char *authmethods_get(Authctxt *authctxt);\nstatic int list_starts_with(const char *, const char *, const char *);\n\nint\nauth2_method_allowed(Authctxt *authctxt, const char *method,\n    const char *submethod)\n{\n\tu_int i;\n\n\t/*\n\t * NB. authctxt->num_auth_methods might be zero as a result of\n\t * auth2_setup_methods_lists(), so check the configuration.\n\t */\n\tif (options.num_auth_methods == 0)\n\t\treturn 1;\n\tfor (i = 0; i < authctxt->num_auth_methods; i++) {\n\t\tif (list_starts_with(authctxt->auth_methods[i], method,\n\t\t    submethod) != MATCH_NONE)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "kbdintctxt->devices",
            "\",\""
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kbdint_reset_device",
          "args": [
            "kbdintctxt"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "kbdint_reset_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
          "lines": "134-142",
          "snippet": "static void\nkbdint_reset_device(KbdintAuthctxt *kbdintctxt)\n{\n\tif (kbdintctxt->ctxt) {\n\t\tkbdintctxt->device->free_ctx(kbdintctxt->ctxt);\n\t\tkbdintctxt->ctxt = NULL;\n\t}\n\tkbdintctxt->device = NULL;\n}",
          "includes": [
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nkbdint_reset_device(KbdintAuthctxt *kbdintctxt)\n{\n\tif (kbdintctxt->ctxt) {\n\t\tkbdintctxt->device->free_ctx(kbdintctxt->ctxt);\n\t\tkbdintctxt->ctxt = NULL;\n\t}\n\tkbdintctxt->device = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nKbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};\n\nstatic int\nkbdint_next_device(Authctxt *authctxt, KbdintAuthctxt *kbdintctxt)\n{\n\tsize_t len;\n\tchar *t;\n\tint i;\n\n\tif (kbdintctxt->device)\n\t\tkbdint_reset_device(kbdintctxt);\n\tdo {\n\t\tlen = kbdintctxt->devices ?\n\t\t    strcspn(kbdintctxt->devices, \",\") : 0;\n\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; devices[i]; i++) {\n\t\t\tif ((kbdintctxt->devices_done & (1 << i)) != 0 ||\n\t\t\t    !auth2_method_allowed(authctxt,\n\t\t\t    \"keyboard-interactive\", devices[i]->name))\n\t\t\t\tcontinue;\n\t\t\tif (strncmp(kbdintctxt->devices, devices[i]->name,\n\t\t\t    len) == 0) {\n\t\t\t\tkbdintctxt->device = devices[i];\n\t\t\t\tkbdintctxt->devices_done |= 1 << i;\n\t\t\t}\n\t\t}\n\t\tt = kbdintctxt->devices;\n\t\tkbdintctxt->devices = t[len] ? xstrdup(t+len+1) : NULL;\n\t\tfree(t);\n\t\tdebug2(\"kbdint_next_device: devices %s\", kbdintctxt->devices ?\n\t\t    kbdintctxt->devices : \"<empty>\");\n\t} while (kbdintctxt->devices && !kbdintctxt->device);\n\n\treturn kbdintctxt->device ? 1 : 0;\n}"
  },
  {
    "function_name": "kbdint_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
    "lines": "143-151",
    "snippet": "static void\nkbdint_free(KbdintAuthctxt *kbdintctxt)\n{\n\tif (kbdintctxt->device)\n\t\tkbdint_reset_device(kbdintctxt);\n\tfree(kbdintctxt->devices);\n\texplicit_bzero(kbdintctxt, sizeof(*kbdintctxt));\n\tfree(kbdintctxt);\n}",
    "includes": [
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"dispatch.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"xmalloc.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "KbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "kbdintctxt"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "kbdint_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
          "lines": "143-151",
          "snippet": "static void\nkbdint_free(KbdintAuthctxt *kbdintctxt)\n{\n\tif (kbdintctxt->device)\n\t\tkbdint_reset_device(kbdintctxt);\n\tfree(kbdintctxt->devices);\n\texplicit_bzero(kbdintctxt, sizeof(*kbdintctxt));\n\tfree(kbdintctxt);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "kbdintctxt",
            "sizeof(*kbdintctxt)"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbdint_reset_device",
          "args": [
            "kbdintctxt"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "kbdint_reset_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
          "lines": "134-142",
          "snippet": "static void\nkbdint_reset_device(KbdintAuthctxt *kbdintctxt)\n{\n\tif (kbdintctxt->ctxt) {\n\t\tkbdintctxt->device->free_ctx(kbdintctxt->ctxt);\n\t\tkbdintctxt->ctxt = NULL;\n\t}\n\tkbdintctxt->device = NULL;\n}",
          "includes": [
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nkbdint_reset_device(KbdintAuthctxt *kbdintctxt)\n{\n\tif (kbdintctxt->ctxt) {\n\t\tkbdintctxt->device->free_ctx(kbdintctxt->ctxt);\n\t\tkbdintctxt->ctxt = NULL;\n\t}\n\tkbdintctxt->device = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nKbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};\n\nstatic void\nkbdint_free(KbdintAuthctxt *kbdintctxt)\n{\n\tif (kbdintctxt->device)\n\t\tkbdint_reset_device(kbdintctxt);\n\tfree(kbdintctxt->devices);\n\texplicit_bzero(kbdintctxt, sizeof(*kbdintctxt));\n\tfree(kbdintctxt);\n}"
  },
  {
    "function_name": "kbdint_reset_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
    "lines": "134-142",
    "snippet": "static void\nkbdint_reset_device(KbdintAuthctxt *kbdintctxt)\n{\n\tif (kbdintctxt->ctxt) {\n\t\tkbdintctxt->device->free_ctx(kbdintctxt->ctxt);\n\t\tkbdintctxt->ctxt = NULL;\n\t}\n\tkbdintctxt->device = NULL;\n}",
    "includes": [
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"dispatch.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"xmalloc.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kbdintctxt->device->free_ctx",
          "args": [
            "kbdintctxt->ctxt"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nkbdint_reset_device(KbdintAuthctxt *kbdintctxt)\n{\n\tif (kbdintctxt->ctxt) {\n\t\tkbdintctxt->device->free_ctx(kbdintctxt->ctxt);\n\t\tkbdintctxt->ctxt = NULL;\n\t}\n\tkbdintctxt->device = NULL;\n}"
  },
  {
    "function_name": "kbdint_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
    "lines": "99-133",
    "snippet": "static KbdintAuthctxt *\nkbdint_alloc(const char *devs)\n{\n\tKbdintAuthctxt *kbdintctxt;\n\tstruct sshbuf *b;\n\tint i, r;\n\n#ifdef USE_PAM\n\tif (!options.use_pam)\n\t\tremove_kbdint_device(\"pam\");\n#endif\n\n\tkbdintctxt = xcalloc(1, sizeof(KbdintAuthctxt));\n\tif (strcmp(devs, \"\") == 0) {\n\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\tfor (i = 0; devices[i]; i++) {\n\t\t\tif ((r = sshbuf_putf(b, \"%s%s\",\n\t\t\t    sshbuf_len(b) ? \",\" : \"\", devices[i]->name)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t\tif ((kbdintctxt->devices = sshbuf_dup_string(b)) == NULL)\n\t\t\tfatal(\"%s: sshbuf_dup_string failed\", __func__);\n\t\tsshbuf_free(b);\n\t} else {\n\t\tkbdintctxt->devices = xstrdup(devs);\n\t}\n\tdebug(\"kbdint_alloc: devices '%s'\", kbdintctxt->devices);\n\tkbdintctxt->ctxt = NULL;\n\tkbdintctxt->device = NULL;\n\tkbdintctxt->nreq = 0;\n\n\treturn kbdintctxt;\n}",
    "includes": [
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"dispatch.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"xmalloc.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;",
      "KbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"kbdint_alloc: devices '%s'\"",
            "kbdintctxt->devices"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "devs"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: sshbuf_dup_string failed\"",
            "__func__"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "match_test_missing_fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "988-993",
          "snippet": "static void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_dup_string",
          "args": [
            "b"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_dup_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-misc.c",
          "lines": "139-160",
          "snippet": "char *\nsshbuf_dup_string(struct sshbuf *buf)\n{\n\tconst u_char *p = NULL, *s = sshbuf_ptr(buf);\n\tsize_t l = sshbuf_len(buf);\n\tchar *r;\n\n\tif (s == NULL || l > SIZE_MAX)\n\t\treturn NULL;\n\t/* accept a nul only as the last character in the buffer */\n\tif (l > 0 && (p = memchr(s, '\\0', l)) != NULL) {\n\t\tif (p != s + l - 1)\n\t\t\treturn NULL;\n\t\tl--; /* the nul is put back below */\n\t}\n\tif ((r = malloc(l + 1)) == NULL)\n\t\treturn NULL;\n\tif (l > 0)\n\t\tmemcpy(r, s, l);\n\tr[l] = '\\0';\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <ctype.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <limits.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <ctype.h>\n#include <resolv.h>\n#include <string.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nsshbuf_dup_string(struct sshbuf *buf)\n{\n\tconst u_char *p = NULL, *s = sshbuf_ptr(buf);\n\tsize_t l = sshbuf_len(buf);\n\tchar *r;\n\n\tif (s == NULL || l > SIZE_MAX)\n\t\treturn NULL;\n\t/* accept a nul only as the last character in the buffer */\n\tif (l > 0 && (p = memchr(s, '\\0', l)) != NULL) {\n\t\tif (p != s + l - 1)\n\t\t\treturn NULL;\n\t\tl--; /* the nul is put back below */\n\t}\n\tif ((r = malloc(l + 1)) == NULL)\n\t\treturn NULL;\n\tif (l > 0)\n\t\tmemcpy(r, s, l);\n\tr[l] = '\\0';\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: buffer error: %s\"",
            "__func__",
            "ssh_err(r)"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "fatal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/fatal.c",
          "lines": "36-45",
          "snippet": "void\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfatal(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_FATAL, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_err",
          "args": [
            "r"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssherr.c",
          "lines": "22-147",
          "snippet": "const char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include <string.h>\n#include <errno.h>\n\nconst char *\nssh_err(int n)\n{\n\tswitch (n) {\n\tcase SSH_ERR_SUCCESS:\n\t\treturn \"success\";\n\tcase SSH_ERR_INTERNAL_ERROR:\n\t\treturn \"unexpected internal error\";\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\treturn \"memory allocation failed\";\n\tcase SSH_ERR_MESSAGE_INCOMPLETE:\n\t\treturn \"incomplete message\";\n\tcase SSH_ERR_INVALID_FORMAT:\n\t\treturn \"invalid format\";\n\tcase SSH_ERR_BIGNUM_IS_NEGATIVE:\n\t\treturn \"bignum is negative\";\n\tcase SSH_ERR_STRING_TOO_LARGE:\n\t\treturn \"string is too large\";\n\tcase SSH_ERR_BIGNUM_TOO_LARGE:\n\t\treturn \"bignum is too large\";\n\tcase SSH_ERR_ECPOINT_TOO_LARGE:\n\t\treturn \"elliptic curve point is too large\";\n\tcase SSH_ERR_NO_BUFFER_SPACE:\n\t\treturn \"insufficient buffer space\";\n\tcase SSH_ERR_INVALID_ARGUMENT:\n\t\treturn \"invalid argument\";\n\tcase SSH_ERR_KEY_BITS_MISMATCH:\n\t\treturn \"key bits do not match\";\n\tcase SSH_ERR_EC_CURVE_INVALID:\n\t\treturn \"invalid elliptic curve\";\n\tcase SSH_ERR_KEY_TYPE_MISMATCH:\n\t\treturn \"key type does not match\";\n\tcase SSH_ERR_KEY_TYPE_UNKNOWN:\n\t\treturn \"unknown or unsupported key type\";\n\tcase SSH_ERR_EC_CURVE_MISMATCH:\n\t\treturn \"elliptic curve does not match\";\n\tcase SSH_ERR_EXPECTED_CERT:\n\t\treturn \"plain key provided where certificate required\";\n\tcase SSH_ERR_KEY_LACKS_CERTBLOB:\n\t\treturn \"key lacks certificate data\";\n\tcase SSH_ERR_KEY_CERT_UNKNOWN_TYPE:\n\t\treturn \"unknown/unsupported certificate type\";\n\tcase SSH_ERR_KEY_CERT_INVALID_SIGN_KEY:\n\t\treturn \"invalid certificate signing key\";\n\tcase SSH_ERR_KEY_INVALID_EC_VALUE:\n\t\treturn \"invalid elliptic curve value\";\n\tcase SSH_ERR_SIGNATURE_INVALID:\n\t\treturn \"incorrect signature\";\n\tcase SSH_ERR_LIBCRYPTO_ERROR:\n\t\treturn \"error in libcrypto\";  /* XXX fetch and return */\n\tcase SSH_ERR_UNEXPECTED_TRAILING_DATA:\n\t\treturn \"unexpected bytes remain after decoding\";\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\treturn strerror(errno);\n\tcase SSH_ERR_KEY_CERT_INVALID:\n\t\treturn \"invalid certificate\";\n\tcase SSH_ERR_AGENT_COMMUNICATION:\n\t\treturn \"communication with agent failed\";\n\tcase SSH_ERR_AGENT_FAILURE:\n\t\treturn \"agent refused operation\";\n\tcase SSH_ERR_DH_GEX_OUT_OF_RANGE:\n\t\treturn \"DH GEX group out of range\";\n\tcase SSH_ERR_DISCONNECTED:\n\t\treturn \"disconnected\";\n\tcase SSH_ERR_MAC_INVALID:\n\t\treturn \"message authentication code incorrect\";\n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\t\treturn \"no matching cipher found\";\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\t\treturn \"no matching MAC found\";\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\t\treturn \"no matching compression method found\";\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\t\treturn \"no matching key exchange method found\";\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\treturn \"no matching host key type found\";\n\tcase SSH_ERR_PROTOCOL_MISMATCH:\n\t\treturn \"protocol version mismatch\";\n\tcase SSH_ERR_NO_PROTOCOL_VERSION:\n\t\treturn \"could not read protocol version\";\n\tcase SSH_ERR_NO_HOSTKEY_LOADED:\n\t\treturn \"could not load host key\";\n\tcase SSH_ERR_NEED_REKEY:\n\t\treturn \"rekeying not supported by peer\";\n\tcase SSH_ERR_PASSPHRASE_TOO_SHORT:\n\t\treturn \"passphrase is too short (minimum five characters)\";\n\tcase SSH_ERR_FILE_CHANGED:\n\t\treturn \"file changed while reading\";\n\tcase SSH_ERR_KEY_UNKNOWN_CIPHER:\n\t\treturn \"key encrypted using unsupported cipher\";\n\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\treturn \"incorrect passphrase supplied to decrypt private key\";\n\tcase SSH_ERR_KEY_BAD_PERMISSIONS:\n\t\treturn \"bad permissions\";\n\tcase SSH_ERR_KEY_CERT_MISMATCH:\n\t\treturn \"certificate does not match key\";\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\treturn \"key not found\";\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\treturn \"agent not present\";\n\tcase SSH_ERR_AGENT_NO_IDENTITIES:\n\t\treturn \"agent contains no identities\";\n\tcase SSH_ERR_BUFFER_READ_ONLY:\n\t\treturn \"internal error: buffer is read-only\";\n\tcase SSH_ERR_KRL_BAD_MAGIC:\n\t\treturn \"KRL file has invalid magic number\";\n\tcase SSH_ERR_KEY_REVOKED:\n\t\treturn \"Key is revoked\";\n\tcase SSH_ERR_CONN_CLOSED:\n\t\treturn \"Connection closed\";\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\treturn \"Connection timed out\";\n\tcase SSH_ERR_CONN_CORRUPT:\n\t\treturn \"Connection corrupted\";\n\tcase SSH_ERR_PROTOCOL_ERROR:\n\t\treturn \"Protocol error\";\n\tcase SSH_ERR_KEY_LENGTH:\n\t\treturn \"Invalid key length\";\n\tcase SSH_ERR_NUMBER_TOO_LARGE:\n\t\treturn \"number is too large\";\n\tcase SSH_ERR_SIGN_ALG_UNSUPPORTED:\n\t\treturn \"signature algorithm not supported\";\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_putf",
          "args": [
            "b",
            "\"%s%s\"",
            "sshbuf_len(b) ? \",\" : \"\"",
            "devices[i]->name"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "254-264",
          "snippet": "int\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putf(struct sshbuf *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = sshbuf_putfv(buf, fmt, ap);\n\tva_end(ap);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "b"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "devs",
            "\"\""
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xcalloc",
          "args": [
            "1",
            "sizeof(KbdintAuthctxt)"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_kbdint_device",
          "args": [
            "\"pam\""
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "remove_kbdint_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
          "lines": "85-96",
          "snippet": "void\nremove_kbdint_device(const char *devname)\n{\n\tint i, j;\n\n\tfor (i = 0; devices[i] != NULL; i++)\n\t\tif (strcmp(devices[i]->name, devname) == 0) {\n\t\t\tfor (j = i; devices[j] != NULL; j++)\n\t\t\t\tdevices[j] = devices[j+1];\n\t\t\ti--;\n\t\t}\n}",
          "includes": [
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssh2.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "KbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nKbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};\n\nvoid\nremove_kbdint_device(const char *devname)\n{\n\tint i, j;\n\n\tfor (i = 0; devices[i] != NULL; i++)\n\t\tif (strcmp(devices[i]->name, devname) == 0) {\n\t\t\tfor (j = i; devices[j] != NULL; j++)\n\t\t\t\tdevices[j] = devices[j+1];\n\t\t\ti--;\n\t\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\nKbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};\n\nstatic KbdintAuthctxt *\nkbdint_alloc(const char *devs)\n{\n\tKbdintAuthctxt *kbdintctxt;\n\tstruct sshbuf *b;\n\tint i, r;\n\n#ifdef USE_PAM\n\tif (!options.use_pam)\n\t\tremove_kbdint_device(\"pam\");\n#endif\n\n\tkbdintctxt = xcalloc(1, sizeof(KbdintAuthctxt));\n\tif (strcmp(devs, \"\") == 0) {\n\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\tfor (i = 0; devices[i]; i++) {\n\t\t\tif ((r = sshbuf_putf(b, \"%s%s\",\n\t\t\t    sshbuf_len(b) ? \",\" : \"\", devices[i]->name)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t\tif ((kbdintctxt->devices = sshbuf_dup_string(b)) == NULL)\n\t\t\tfatal(\"%s: sshbuf_dup_string failed\", __func__);\n\t\tsshbuf_free(b);\n\t} else {\n\t\tkbdintctxt->devices = xstrdup(devs);\n\t}\n\tdebug(\"kbdint_alloc: devices '%s'\", kbdintctxt->devices);\n\tkbdintctxt->ctxt = NULL;\n\tkbdintctxt->device = NULL;\n\tkbdintctxt->nreq = 0;\n\n\treturn kbdintctxt;\n}"
  },
  {
    "function_name": "remove_kbdint_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth2-chall.c",
    "lines": "85-96",
    "snippet": "void\nremove_kbdint_device(const char *devname)\n{\n\tint i, j;\n\n\tfor (i = 0; devices[i] != NULL; i++)\n\t\tif (strcmp(devices[i]->name, devname) == 0) {\n\t\t\tfor (j = i; devices[j] != NULL; j++)\n\t\t\t\tdevices[j] = devices[j+1];\n\t\t\ti--;\n\t\t}\n}",
    "includes": [
      "#include \"servconf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"ssherr.h\"",
      "#include \"dispatch.h\"",
      "#include \"packet.h\"",
      "#include \"sshbuf.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"ssh2.h\"",
      "#include \"xmalloc.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "KbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "devices[i]->name",
            "devname"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"servconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssh2.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nKbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};\n\nvoid\nremove_kbdint_device(const char *devname)\n{\n\tint i, j;\n\n\tfor (i = 0; devices[i] != NULL; i++)\n\t\tif (strcmp(devices[i]->name, devname) == 0) {\n\t\t\tfor (j = i; devices[j] != NULL; j++)\n\t\t\t\tdevices[j] = devices[j+1];\n\t\t\ti--;\n\t\t}\n}"
  }
]