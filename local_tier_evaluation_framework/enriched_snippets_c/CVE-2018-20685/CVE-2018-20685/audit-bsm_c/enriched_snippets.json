[
  {
    "function_name": "audit_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit-bsm.c",
    "lines": "393-453",
    "snippet": "void\naudit_event(ssh_audit_event_t event)\n{\n\tchar    textbuf[BSM_TEXTBUFSZ];\n\tstatic int logged_in = 0;\n\tconst char *user = the_authctxt ? the_authctxt->user : \"(unknown user)\";\n\n\tif (cannot_audit(0))\n\t\treturn;\n\n\tswitch(event) {\n\tcase SSH_AUTH_SUCCESS:\n\t\tlogged_in = 1;\n\t\tbsm_audit_session_setup();\n\t\tsnprintf(textbuf, sizeof(textbuf),\n\t\t    gettext(\"successful login %s\"), user);\n\t\tbsm_audit_record(0, textbuf, AUE_openssh);\n\t\tbreak;\n\n\tcase SSH_CONNECTION_CLOSE:\n\t\t/*\n\t\t * We can also get a close event if the user attempted auth\n\t\t * but never succeeded.\n\t\t */\n\t\tif (logged_in) {\n\t\t\tsnprintf(textbuf, sizeof(textbuf),\n\t\t\t    gettext(\"sshd logout %s\"), the_authctxt->user);\n\t\t\tbsm_audit_record(0, textbuf, AUE_logout);\n\t\t} else {\n\t\t\tdebug(\"%s: connection closed without authentication\",\n\t\t\t    __func__);\n\t\t}\n\t\tbreak;\n\n\tcase SSH_NOLOGIN:\n\t\tbsm_audit_record(1,\n\t\t    gettext(\"logins disabled by /etc/nologin\"), AUE_openssh);\n\t\tbreak;\n\n\tcase SSH_LOGIN_EXCEED_MAXTRIES:\n\t\tsnprintf(textbuf, sizeof(textbuf),\n\t\t    gettext(\"too many tries for user %s\"), the_authctxt->user);\n\t\tbsm_audit_record(1, textbuf, AUE_openssh);\n\t\tbreak;\n\n\tcase SSH_LOGIN_ROOT_DENIED:\n\t\tbsm_audit_record(2, gettext(\"not_console\"), AUE_openssh);\n\t\tbreak;\n\n\tcase SSH_AUTH_FAIL_PASSWD:\n\t\tbsm_audit_bad_login(\"password\");\n\t\tbreak;\n\n\tcase SSH_AUTH_FAIL_KBDINT:\n\t\tbsm_audit_bad_login(\"interactive password entry\");\n\t\tbreak;\n\n\tdefault:\n\t\tdebug(\"%s: unhandled event %d\", __func__, event);\n\t}\n}",
    "includes": [
      "#include <locale.h>",
      "#include <bsm/audit_record.h>",
      "#include <bsm/audit_uevents.h>",
      "#include <bsm/libbsm.h>",
      "#include <bsm/audit.h>",
      "#include \"xmalloc.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include <libscf.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define BSM_TEXTBUFSZ 256"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: unhandled event %d\"",
            "__func__",
            "event"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bsm_audit_bad_login",
          "args": [
            "\"interactive password entry\""
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "bsm_audit_bad_login",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit-bsm.c",
          "lines": "329-345",
          "snippet": "static void\nbsm_audit_bad_login(const char *what)\n{\n\tchar textbuf[BSM_TEXTBUFSZ];\n\n\tif (the_authctxt->valid) {\n\t\t(void) snprintf(textbuf, sizeof (textbuf),\n\t\t\tgettext(\"invalid %s for user %s\"),\n\t\t\t    what, the_authctxt->user);\n\t\tbsm_audit_record(4, textbuf, AUE_openssh);\n\t} else {\n\t\t(void) snprintf(textbuf, sizeof (textbuf),\n\t\t\tgettext(\"invalid user name \\\"%s\\\"\"),\n\t\t\t    the_authctxt->user);\n\t\tbsm_audit_record(3, textbuf, AUE_openssh);\n\t}\n}",
          "includes": [
            "#include <locale.h>",
            "#include <bsm/audit_record.h>",
            "#include <bsm/audit_uevents.h>",
            "#include <bsm/libbsm.h>",
            "#include <bsm/audit.h>",
            "#include \"xmalloc.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include <libscf.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define BSM_TEXTBUFSZ 256"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <locale.h>\n#include <bsm/audit_record.h>\n#include <bsm/audit_uevents.h>\n#include <bsm/libbsm.h>\n#include <bsm/audit.h>\n#include \"xmalloc.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include <libscf.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define BSM_TEXTBUFSZ 256\n\nstatic void\nbsm_audit_bad_login(const char *what)\n{\n\tchar textbuf[BSM_TEXTBUFSZ];\n\n\tif (the_authctxt->valid) {\n\t\t(void) snprintf(textbuf, sizeof (textbuf),\n\t\t\tgettext(\"invalid %s for user %s\"),\n\t\t\t    what, the_authctxt->user);\n\t\tbsm_audit_record(4, textbuf, AUE_openssh);\n\t} else {\n\t\t(void) snprintf(textbuf, sizeof (textbuf),\n\t\t\tgettext(\"invalid user name \\\"%s\\\"\"),\n\t\t\t    the_authctxt->user);\n\t\tbsm_audit_record(3, textbuf, AUE_openssh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bsm_audit_record",
          "args": [
            "2",
            "gettext(\"not_console\")",
            "AUE_openssh"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "bsm_audit_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit-bsm.c",
          "lines": "254-294",
          "snippet": "static void\nbsm_audit_record(int typ, char *string, au_event_t event_no)\n{\n\tint\t\tad, rc, sel;\n\tuid_t\t\tuid = -1;\n\tgid_t\t\tgid = -1;\n\tpid_t\t\tpid = getpid();\n\tAuditInfoTermID\ttid = ssh_bsm_tid;\n\n\tif (the_authctxt != NULL && the_authctxt->valid) {\n\t\tuid = the_authctxt->pw->pw_uid;\n\t\tgid = the_authctxt->pw->pw_gid;\n\t}\n\n\trc = (typ == 0) ? 0 : -1;\n\tsel = selected(the_authctxt->user, uid, event_no, rc);\n\tdebug3(\"BSM audit: typ %d rc %d \\\"%s\\\"\", typ, rc, string);\n\tif (!sel)\n\t\treturn;\t/* audit event does not match mask, do not write */\n\n\tdebug3(\"BSM audit: writing audit new record\");\n\tad = au_open();\n\n\t(void) au_write(ad, AUToSubjectFunc(uid, uid, gid, uid, gid,\n\t    pid, pid, &tid));\n\t(void) au_write(ad, au_to_text(string));\n\t(void) au_write(ad, AUToReturnFunc(typ, rc));\n\n#ifdef BROKEN_BSM_API\n\t/* The last argument is the event modifier flags. For\n\t   some seemingly undocumented reason it was added in\n\t   Solaris 11. */\n\trc = au_close(ad, AU_TO_WRITE, event_no, 0);\n#else\n\trc = au_close(ad, AU_TO_WRITE, event_no);\n#endif\n\n\tif (rc < 0)\n\t\terror(\"BSM audit: %s failed to write \\\"%s\\\" record: %s\",\n\t\t    __func__, string, strerror(errno));\n}",
          "includes": [
            "#include <locale.h>",
            "#include <bsm/audit_record.h>",
            "#include <bsm/audit_uevents.h>",
            "#include <bsm/libbsm.h>",
            "#include <bsm/audit.h>",
            "#include \"xmalloc.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include <libscf.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define AUToSubjectFunc\t\tau_to_subject",
            "#define AuditInfoTermID\t\tau_tid_t",
            "#define AUToSubjectFunc\t\tau_to_subject_ex",
            "#define AuditInfoTermID\t\tau_tid_addr_t"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <locale.h>\n#include <bsm/audit_record.h>\n#include <bsm/audit_uevents.h>\n#include <bsm/libbsm.h>\n#include <bsm/audit.h>\n#include \"xmalloc.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include <libscf.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define AUToSubjectFunc\t\tau_to_subject\n#define AuditInfoTermID\t\tau_tid_t\n#define AUToSubjectFunc\t\tau_to_subject_ex\n#define AuditInfoTermID\t\tau_tid_addr_t\n\nstatic void\nbsm_audit_record(int typ, char *string, au_event_t event_no)\n{\n\tint\t\tad, rc, sel;\n\tuid_t\t\tuid = -1;\n\tgid_t\t\tgid = -1;\n\tpid_t\t\tpid = getpid();\n\tAuditInfoTermID\ttid = ssh_bsm_tid;\n\n\tif (the_authctxt != NULL && the_authctxt->valid) {\n\t\tuid = the_authctxt->pw->pw_uid;\n\t\tgid = the_authctxt->pw->pw_gid;\n\t}\n\n\trc = (typ == 0) ? 0 : -1;\n\tsel = selected(the_authctxt->user, uid, event_no, rc);\n\tdebug3(\"BSM audit: typ %d rc %d \\\"%s\\\"\", typ, rc, string);\n\tif (!sel)\n\t\treturn;\t/* audit event does not match mask, do not write */\n\n\tdebug3(\"BSM audit: writing audit new record\");\n\tad = au_open();\n\n\t(void) au_write(ad, AUToSubjectFunc(uid, uid, gid, uid, gid,\n\t    pid, pid, &tid));\n\t(void) au_write(ad, au_to_text(string));\n\t(void) au_write(ad, AUToReturnFunc(typ, rc));\n\n#ifdef BROKEN_BSM_API\n\t/* The last argument is the event modifier flags. For\n\t   some seemingly undocumented reason it was added in\n\t   Solaris 11. */\n\trc = au_close(ad, AU_TO_WRITE, event_no, 0);\n#else\n\trc = au_close(ad, AU_TO_WRITE, event_no);\n#endif\n\n\tif (rc < 0)\n\t\terror(\"BSM audit: %s failed to write \\\"%s\\\" record: %s\",\n\t\t    __func__, string, strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "gettext",
          "args": [
            "\"not_console\""
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "textbuf",
            "sizeof(textbuf)",
            "gettext(\"too many tries for user %s\")",
            "the_authctxt->user"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gettext",
          "args": [
            "\"too many tries for user %s\""
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettext",
          "args": [
            "\"logins disabled by /etc/nologin\""
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettext",
          "args": [
            "\"sshd logout %s\""
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettext",
          "args": [
            "\"successful login %s\""
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bsm_audit_session_setup",
          "args": [],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "bsm_audit_session_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit-bsm.c",
          "lines": "296-327",
          "snippet": "static void\nbsm_audit_session_setup(void)\n{\n\tint rc;\n\tstruct AuditInfoStruct info;\n\tau_mask_t mask;\n\n\tif (the_authctxt == NULL) {\n\t\terror(\"BSM audit: session setup internal error (NULL ctxt)\");\n\t\treturn;\n\t}\n\n\tif (the_authctxt->valid)\n\t\tinfo.ai_auid = the_authctxt->pw->pw_uid;\n\telse\n\t\tinfo.ai_auid = -1;\n\tinfo.ai_asid = getpid();\n\tmask.am_success = 0;\n\tmask.am_failure = 0;\n\n\t(void) au_user_mask(the_authctxt->user, &mask);\n\n\tinfo.ai_mask.am_success  = mask.am_success;\n\tinfo.ai_mask.am_failure  = mask.am_failure;\n\n\tinfo.ai_termid = ssh_bsm_tid;\n\n\trc = SetAuditFunc(&info, sizeof(info));\n\tif (rc < 0)\n\t\terror(\"BSM audit: %s: %s failed: %s\", __func__,\n\t\t    SetAuditFuncText, strerror(errno));\n}",
          "includes": [
            "#include <locale.h>",
            "#include <bsm/audit_record.h>",
            "#include <bsm/audit_uevents.h>",
            "#include <bsm/libbsm.h>",
            "#include <bsm/audit.h>",
            "#include \"xmalloc.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include <libscf.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SetAuditFuncText\t\"setaudit\"",
            "#define\tAuditInfoStruct\t\tauditinfo",
            "#define SetAuditFuncText\t\"setaudit_addr\"",
            "#define\tAuditInfoStruct\t\tauditinfo_addr"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <locale.h>\n#include <bsm/audit_record.h>\n#include <bsm/audit_uevents.h>\n#include <bsm/libbsm.h>\n#include <bsm/audit.h>\n#include \"xmalloc.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include <libscf.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SetAuditFuncText\t\"setaudit\"\n#define\tAuditInfoStruct\t\tauditinfo\n#define SetAuditFuncText\t\"setaudit_addr\"\n#define\tAuditInfoStruct\t\tauditinfo_addr\n\nstatic void\nbsm_audit_session_setup(void)\n{\n\tint rc;\n\tstruct AuditInfoStruct info;\n\tau_mask_t mask;\n\n\tif (the_authctxt == NULL) {\n\t\terror(\"BSM audit: session setup internal error (NULL ctxt)\");\n\t\treturn;\n\t}\n\n\tif (the_authctxt->valid)\n\t\tinfo.ai_auid = the_authctxt->pw->pw_uid;\n\telse\n\t\tinfo.ai_auid = -1;\n\tinfo.ai_asid = getpid();\n\tmask.am_success = 0;\n\tmask.am_failure = 0;\n\n\t(void) au_user_mask(the_authctxt->user, &mask);\n\n\tinfo.ai_mask.am_success  = mask.am_success;\n\tinfo.ai_mask.am_failure  = mask.am_failure;\n\n\tinfo.ai_termid = ssh_bsm_tid;\n\n\trc = SetAuditFunc(&info, sizeof(info));\n\tif (rc < 0)\n\t\terror(\"BSM audit: %s: %s failed: %s\", __func__,\n\t\t    SetAuditFuncText, strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cannot_audit",
          "args": [
            "0"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <locale.h>\n#include <bsm/audit_record.h>\n#include <bsm/audit_uevents.h>\n#include <bsm/libbsm.h>\n#include <bsm/audit.h>\n#include \"xmalloc.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include <libscf.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define BSM_TEXTBUFSZ 256\n\nvoid\naudit_event(ssh_audit_event_t event)\n{\n\tchar    textbuf[BSM_TEXTBUFSZ];\n\tstatic int logged_in = 0;\n\tconst char *user = the_authctxt ? the_authctxt->user : \"(unknown user)\";\n\n\tif (cannot_audit(0))\n\t\treturn;\n\n\tswitch(event) {\n\tcase SSH_AUTH_SUCCESS:\n\t\tlogged_in = 1;\n\t\tbsm_audit_session_setup();\n\t\tsnprintf(textbuf, sizeof(textbuf),\n\t\t    gettext(\"successful login %s\"), user);\n\t\tbsm_audit_record(0, textbuf, AUE_openssh);\n\t\tbreak;\n\n\tcase SSH_CONNECTION_CLOSE:\n\t\t/*\n\t\t * We can also get a close event if the user attempted auth\n\t\t * but never succeeded.\n\t\t */\n\t\tif (logged_in) {\n\t\t\tsnprintf(textbuf, sizeof(textbuf),\n\t\t\t    gettext(\"sshd logout %s\"), the_authctxt->user);\n\t\t\tbsm_audit_record(0, textbuf, AUE_logout);\n\t\t} else {\n\t\t\tdebug(\"%s: connection closed without authentication\",\n\t\t\t    __func__);\n\t\t}\n\t\tbreak;\n\n\tcase SSH_NOLOGIN:\n\t\tbsm_audit_record(1,\n\t\t    gettext(\"logins disabled by /etc/nologin\"), AUE_openssh);\n\t\tbreak;\n\n\tcase SSH_LOGIN_EXCEED_MAXTRIES:\n\t\tsnprintf(textbuf, sizeof(textbuf),\n\t\t    gettext(\"too many tries for user %s\"), the_authctxt->user);\n\t\tbsm_audit_record(1, textbuf, AUE_openssh);\n\t\tbreak;\n\n\tcase SSH_LOGIN_ROOT_DENIED:\n\t\tbsm_audit_record(2, gettext(\"not_console\"), AUE_openssh);\n\t\tbreak;\n\n\tcase SSH_AUTH_FAIL_PASSWD:\n\t\tbsm_audit_bad_login(\"password\");\n\t\tbreak;\n\n\tcase SSH_AUTH_FAIL_KBDINT:\n\t\tbsm_audit_bad_login(\"interactive password entry\");\n\t\tbreak;\n\n\tdefault:\n\t\tdebug(\"%s: unhandled event %d\", __func__, event);\n\t}\n}"
  },
  {
    "function_name": "audit_session_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit-bsm.c",
    "lines": "387-391",
    "snippet": "void\naudit_session_close(struct logininfo *li)\n{\n\t/* not implemented */\n}",
    "includes": [
      "#include <locale.h>",
      "#include <bsm/audit_record.h>",
      "#include <bsm/audit_uevents.h>",
      "#include <bsm/libbsm.h>",
      "#include <bsm/audit.h>",
      "#include \"xmalloc.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include <libscf.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <locale.h>\n#include <bsm/audit_record.h>\n#include <bsm/audit_uevents.h>\n#include <bsm/libbsm.h>\n#include <bsm/audit.h>\n#include \"xmalloc.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include <libscf.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\naudit_session_close(struct logininfo *li)\n{\n\t/* not implemented */\n}"
  },
  {
    "function_name": "audit_session_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit-bsm.c",
    "lines": "381-385",
    "snippet": "void\naudit_session_open(struct logininfo *li)\n{\n\t/* not implemented */\n}",
    "includes": [
      "#include <locale.h>",
      "#include <bsm/audit_record.h>",
      "#include <bsm/audit_uevents.h>",
      "#include <bsm/libbsm.h>",
      "#include <bsm/audit.h>",
      "#include \"xmalloc.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include <libscf.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <locale.h>\n#include <bsm/audit_record.h>\n#include <bsm/audit_uevents.h>\n#include <bsm/libbsm.h>\n#include <bsm/audit.h>\n#include \"xmalloc.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include <libscf.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\naudit_session_open(struct logininfo *li)\n{\n\t/* not implemented */\n}"
  },
  {
    "function_name": "audit_run_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit-bsm.c",
    "lines": "375-379",
    "snippet": "void\naudit_run_command(const char *command)\n{\n\t/* not implemented */\n}",
    "includes": [
      "#include <locale.h>",
      "#include <bsm/audit_record.h>",
      "#include <bsm/audit_uevents.h>",
      "#include <bsm/libbsm.h>",
      "#include <bsm/audit.h>",
      "#include \"xmalloc.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include <libscf.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <locale.h>\n#include <bsm/audit_record.h>\n#include <bsm/audit_uevents.h>\n#include <bsm/libbsm.h>\n#include <bsm/audit.h>\n#include \"xmalloc.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include <libscf.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\naudit_run_command(const char *command)\n{\n\t/* not implemented */\n}"
  },
  {
    "function_name": "audit_connection_from",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit-bsm.c",
    "lines": "349-373",
    "snippet": "void\naudit_connection_from(const char *host, int port)\n{\n\tAuditInfoTermID *tid = &ssh_bsm_tid;\n\tchar buf[1024];\n\n\tif (cannot_audit(0))\n\t\treturn;\n\tdebug3(\"BSM audit: connection from %.100s port %d\", host, port);\n\n\t/* populate our terminal id structure */\n#if defined(HAVE_GETAUDIT_ADDR)\n\ttid->at_port = (dev_t)port;\n\taug_get_machine((char *)host, &(tid->at_addr[0]), &(tid->at_type));\n\tsnprintf(buf, sizeof(buf), \"%08x %08x %08x %08x\", tid->at_addr[0],\n\t    tid->at_addr[1], tid->at_addr[2], tid->at_addr[3]);\n\tdebug3(\"BSM audit: iptype %d machine ID %s\", (int)tid->at_type, buf);\n#else\n\t/* this is used on IPv4-only machines */\n\ttid->port = (dev_t)port;\n\ttid->machine = inet_addr(host);\n\tsnprintf(buf, sizeof(buf), \"%08x\", tid->machine);\n\tdebug3(\"BSM audit: machine ID %s\", buf);\n#endif\n}",
    "includes": [
      "#include <locale.h>",
      "#include <bsm/audit_record.h>",
      "#include <bsm/audit_uevents.h>",
      "#include <bsm/libbsm.h>",
      "#include <bsm/audit.h>",
      "#include \"xmalloc.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include <libscf.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define AuditInfoTermID\t\tau_tid_t",
      "#define AuditInfoTermID\t\tau_tid_addr_t"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"BSM audit: machine ID %s\"",
            "buf"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"%08x\"",
            "tid->machine"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inet_addr",
          "args": [
            "host"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "inet_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/inet_aton.c",
          "lines": "69-77",
          "snippet": "in_addr_t\ninet_addr(const char *cp)\n{\n\tstruct in_addr val;\n\n\tif (inet_aton(cp, &val))\n\t\treturn (val.s_addr);\n\treturn (INADDR_NONE);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nin_addr_t\ninet_addr(const char *cp)\n{\n\tstruct in_addr val;\n\n\tif (inet_aton(cp, &val))\n\t\treturn (val.s_addr);\n\treturn (INADDR_NONE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aug_get_machine",
          "args": [
            "(char *)host",
            "&(tid->at_addr[0])",
            "&(tid->at_type)"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "aug_get_machine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit-bsm.c",
          "lines": "134-168",
          "snippet": "static int\naug_get_machine(char *host, u_int32_t *addr, u_int32_t *type)\n{\n\tstruct addrinfo *ai; \n\tstruct sockaddr_in *in4;\n\tstruct sockaddr_in6 *in6;\n\tint ret = 0, r;\n\n\tif ((r = getaddrinfo(host, NULL, NULL, &ai)) != 0) {\n\t\terror(\"BSM audit: getaddrinfo failed for %.100s: %.100s\", host,\n\t\t    r == EAI_SYSTEM ? strerror(errno) : gai_strerror(r));\n\t\treturn -1;\n\t}\n\t\n\tswitch (ai->ai_family) {\n\tcase AF_INET:\n\t\tin4 = (struct sockaddr_in *)ai->ai_addr;\n\t\t*type = AU_IPv4;\n\t\tmemcpy(addr, &in4->sin_addr, sizeof(struct in_addr));\n\t\tbreak;\n#ifdef AU_IPv6\n\tcase AF_INET6: \n\t\tin6 = (struct sockaddr_in6 *)ai->ai_addr;\n\t\t*type = AU_IPv6;\n\t\tmemcpy(addr, &in6->sin6_addr, sizeof(struct in6_addr));\n\t\tbreak;\n#endif\n\tdefault:\n\t\terror(\"BSM audit: unknown address family for %.100s: %d\",\n\t\t    host, ai->ai_family);\n\t\tret = -1;\n\t}\n\tfreeaddrinfo(ai);\n\treturn ret;\n}",
          "includes": [
            "#include <locale.h>",
            "#include <bsm/audit_record.h>",
            "#include <bsm/audit_uevents.h>",
            "#include <bsm/libbsm.h>",
            "#include <bsm/audit.h>",
            "#include \"xmalloc.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include <libscf.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <locale.h>\n#include <bsm/audit_record.h>\n#include <bsm/audit_uevents.h>\n#include <bsm/libbsm.h>\n#include <bsm/audit.h>\n#include \"xmalloc.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include <libscf.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\naug_get_machine(char *host, u_int32_t *addr, u_int32_t *type)\n{\n\tstruct addrinfo *ai; \n\tstruct sockaddr_in *in4;\n\tstruct sockaddr_in6 *in6;\n\tint ret = 0, r;\n\n\tif ((r = getaddrinfo(host, NULL, NULL, &ai)) != 0) {\n\t\terror(\"BSM audit: getaddrinfo failed for %.100s: %.100s\", host,\n\t\t    r == EAI_SYSTEM ? strerror(errno) : gai_strerror(r));\n\t\treturn -1;\n\t}\n\t\n\tswitch (ai->ai_family) {\n\tcase AF_INET:\n\t\tin4 = (struct sockaddr_in *)ai->ai_addr;\n\t\t*type = AU_IPv4;\n\t\tmemcpy(addr, &in4->sin_addr, sizeof(struct in_addr));\n\t\tbreak;\n#ifdef AU_IPv6\n\tcase AF_INET6: \n\t\tin6 = (struct sockaddr_in6 *)ai->ai_addr;\n\t\t*type = AU_IPv6;\n\t\tmemcpy(addr, &in6->sin6_addr, sizeof(struct in6_addr));\n\t\tbreak;\n#endif\n\tdefault:\n\t\terror(\"BSM audit: unknown address family for %.100s: %d\",\n\t\t    host, ai->ai_family);\n\t\tret = -1;\n\t}\n\tfreeaddrinfo(ai);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cannot_audit",
          "args": [
            "0"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <locale.h>\n#include <bsm/audit_record.h>\n#include <bsm/audit_uevents.h>\n#include <bsm/libbsm.h>\n#include <bsm/audit.h>\n#include \"xmalloc.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include <libscf.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define AuditInfoTermID\t\tau_tid_t\n#define AuditInfoTermID\t\tau_tid_addr_t\n\nvoid\naudit_connection_from(const char *host, int port)\n{\n\tAuditInfoTermID *tid = &ssh_bsm_tid;\n\tchar buf[1024];\n\n\tif (cannot_audit(0))\n\t\treturn;\n\tdebug3(\"BSM audit: connection from %.100s port %d\", host, port);\n\n\t/* populate our terminal id structure */\n#if defined(HAVE_GETAUDIT_ADDR)\n\ttid->at_port = (dev_t)port;\n\taug_get_machine((char *)host, &(tid->at_addr[0]), &(tid->at_type));\n\tsnprintf(buf, sizeof(buf), \"%08x %08x %08x %08x\", tid->at_addr[0],\n\t    tid->at_addr[1], tid->at_addr[2], tid->at_addr[3]);\n\tdebug3(\"BSM audit: iptype %d machine ID %s\", (int)tid->at_type, buf);\n#else\n\t/* this is used on IPv4-only machines */\n\ttid->port = (dev_t)port;\n\ttid->machine = inet_addr(host);\n\tsnprintf(buf, sizeof(buf), \"%08x\", tid->machine);\n\tdebug3(\"BSM audit: machine ID %s\", buf);\n#endif\n}"
  },
  {
    "function_name": "bsm_audit_bad_login",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit-bsm.c",
    "lines": "329-345",
    "snippet": "static void\nbsm_audit_bad_login(const char *what)\n{\n\tchar textbuf[BSM_TEXTBUFSZ];\n\n\tif (the_authctxt->valid) {\n\t\t(void) snprintf(textbuf, sizeof (textbuf),\n\t\t\tgettext(\"invalid %s for user %s\"),\n\t\t\t    what, the_authctxt->user);\n\t\tbsm_audit_record(4, textbuf, AUE_openssh);\n\t} else {\n\t\t(void) snprintf(textbuf, sizeof (textbuf),\n\t\t\tgettext(\"invalid user name \\\"%s\\\"\"),\n\t\t\t    the_authctxt->user);\n\t\tbsm_audit_record(3, textbuf, AUE_openssh);\n\t}\n}",
    "includes": [
      "#include <locale.h>",
      "#include <bsm/audit_record.h>",
      "#include <bsm/audit_uevents.h>",
      "#include <bsm/libbsm.h>",
      "#include <bsm/audit.h>",
      "#include \"xmalloc.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include <libscf.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define BSM_TEXTBUFSZ 256"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bsm_audit_record",
          "args": [
            "3",
            "textbuf",
            "AUE_openssh"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "bsm_audit_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit-bsm.c",
          "lines": "254-294",
          "snippet": "static void\nbsm_audit_record(int typ, char *string, au_event_t event_no)\n{\n\tint\t\tad, rc, sel;\n\tuid_t\t\tuid = -1;\n\tgid_t\t\tgid = -1;\n\tpid_t\t\tpid = getpid();\n\tAuditInfoTermID\ttid = ssh_bsm_tid;\n\n\tif (the_authctxt != NULL && the_authctxt->valid) {\n\t\tuid = the_authctxt->pw->pw_uid;\n\t\tgid = the_authctxt->pw->pw_gid;\n\t}\n\n\trc = (typ == 0) ? 0 : -1;\n\tsel = selected(the_authctxt->user, uid, event_no, rc);\n\tdebug3(\"BSM audit: typ %d rc %d \\\"%s\\\"\", typ, rc, string);\n\tif (!sel)\n\t\treturn;\t/* audit event does not match mask, do not write */\n\n\tdebug3(\"BSM audit: writing audit new record\");\n\tad = au_open();\n\n\t(void) au_write(ad, AUToSubjectFunc(uid, uid, gid, uid, gid,\n\t    pid, pid, &tid));\n\t(void) au_write(ad, au_to_text(string));\n\t(void) au_write(ad, AUToReturnFunc(typ, rc));\n\n#ifdef BROKEN_BSM_API\n\t/* The last argument is the event modifier flags. For\n\t   some seemingly undocumented reason it was added in\n\t   Solaris 11. */\n\trc = au_close(ad, AU_TO_WRITE, event_no, 0);\n#else\n\trc = au_close(ad, AU_TO_WRITE, event_no);\n#endif\n\n\tif (rc < 0)\n\t\terror(\"BSM audit: %s failed to write \\\"%s\\\" record: %s\",\n\t\t    __func__, string, strerror(errno));\n}",
          "includes": [
            "#include <locale.h>",
            "#include <bsm/audit_record.h>",
            "#include <bsm/audit_uevents.h>",
            "#include <bsm/libbsm.h>",
            "#include <bsm/audit.h>",
            "#include \"xmalloc.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include <libscf.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define AUToSubjectFunc\t\tau_to_subject",
            "#define AuditInfoTermID\t\tau_tid_t",
            "#define AUToSubjectFunc\t\tau_to_subject_ex",
            "#define AuditInfoTermID\t\tau_tid_addr_t"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <locale.h>\n#include <bsm/audit_record.h>\n#include <bsm/audit_uevents.h>\n#include <bsm/libbsm.h>\n#include <bsm/audit.h>\n#include \"xmalloc.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include <libscf.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define AUToSubjectFunc\t\tau_to_subject\n#define AuditInfoTermID\t\tau_tid_t\n#define AUToSubjectFunc\t\tau_to_subject_ex\n#define AuditInfoTermID\t\tau_tid_addr_t\n\nstatic void\nbsm_audit_record(int typ, char *string, au_event_t event_no)\n{\n\tint\t\tad, rc, sel;\n\tuid_t\t\tuid = -1;\n\tgid_t\t\tgid = -1;\n\tpid_t\t\tpid = getpid();\n\tAuditInfoTermID\ttid = ssh_bsm_tid;\n\n\tif (the_authctxt != NULL && the_authctxt->valid) {\n\t\tuid = the_authctxt->pw->pw_uid;\n\t\tgid = the_authctxt->pw->pw_gid;\n\t}\n\n\trc = (typ == 0) ? 0 : -1;\n\tsel = selected(the_authctxt->user, uid, event_no, rc);\n\tdebug3(\"BSM audit: typ %d rc %d \\\"%s\\\"\", typ, rc, string);\n\tif (!sel)\n\t\treturn;\t/* audit event does not match mask, do not write */\n\n\tdebug3(\"BSM audit: writing audit new record\");\n\tad = au_open();\n\n\t(void) au_write(ad, AUToSubjectFunc(uid, uid, gid, uid, gid,\n\t    pid, pid, &tid));\n\t(void) au_write(ad, au_to_text(string));\n\t(void) au_write(ad, AUToReturnFunc(typ, rc));\n\n#ifdef BROKEN_BSM_API\n\t/* The last argument is the event modifier flags. For\n\t   some seemingly undocumented reason it was added in\n\t   Solaris 11. */\n\trc = au_close(ad, AU_TO_WRITE, event_no, 0);\n#else\n\trc = au_close(ad, AU_TO_WRITE, event_no);\n#endif\n\n\tif (rc < 0)\n\t\terror(\"BSM audit: %s failed to write \\\"%s\\\" record: %s\",\n\t\t    __func__, string, strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "textbuf",
            "sizeof (textbuf)",
            "gettext(\"invalid user name \\\"%s\\\"\")",
            "the_authctxt->user"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gettext",
          "args": [
            "\"invalid user name \\\"%s\\\"\""
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettext",
          "args": [
            "\"invalid %s for user %s\""
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <locale.h>\n#include <bsm/audit_record.h>\n#include <bsm/audit_uevents.h>\n#include <bsm/libbsm.h>\n#include <bsm/audit.h>\n#include \"xmalloc.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include <libscf.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define BSM_TEXTBUFSZ 256\n\nstatic void\nbsm_audit_bad_login(const char *what)\n{\n\tchar textbuf[BSM_TEXTBUFSZ];\n\n\tif (the_authctxt->valid) {\n\t\t(void) snprintf(textbuf, sizeof (textbuf),\n\t\t\tgettext(\"invalid %s for user %s\"),\n\t\t\t    what, the_authctxt->user);\n\t\tbsm_audit_record(4, textbuf, AUE_openssh);\n\t} else {\n\t\t(void) snprintf(textbuf, sizeof (textbuf),\n\t\t\tgettext(\"invalid user name \\\"%s\\\"\"),\n\t\t\t    the_authctxt->user);\n\t\tbsm_audit_record(3, textbuf, AUE_openssh);\n\t}\n}"
  },
  {
    "function_name": "bsm_audit_session_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit-bsm.c",
    "lines": "296-327",
    "snippet": "static void\nbsm_audit_session_setup(void)\n{\n\tint rc;\n\tstruct AuditInfoStruct info;\n\tau_mask_t mask;\n\n\tif (the_authctxt == NULL) {\n\t\terror(\"BSM audit: session setup internal error (NULL ctxt)\");\n\t\treturn;\n\t}\n\n\tif (the_authctxt->valid)\n\t\tinfo.ai_auid = the_authctxt->pw->pw_uid;\n\telse\n\t\tinfo.ai_auid = -1;\n\tinfo.ai_asid = getpid();\n\tmask.am_success = 0;\n\tmask.am_failure = 0;\n\n\t(void) au_user_mask(the_authctxt->user, &mask);\n\n\tinfo.ai_mask.am_success  = mask.am_success;\n\tinfo.ai_mask.am_failure  = mask.am_failure;\n\n\tinfo.ai_termid = ssh_bsm_tid;\n\n\trc = SetAuditFunc(&info, sizeof(info));\n\tif (rc < 0)\n\t\terror(\"BSM audit: %s: %s failed: %s\", __func__,\n\t\t    SetAuditFuncText, strerror(errno));\n}",
    "includes": [
      "#include <locale.h>",
      "#include <bsm/audit_record.h>",
      "#include <bsm/audit_uevents.h>",
      "#include <bsm/libbsm.h>",
      "#include <bsm/audit.h>",
      "#include \"xmalloc.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include <libscf.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define SetAuditFuncText\t\"setaudit\"",
      "#define\tAuditInfoStruct\t\tauditinfo",
      "#define SetAuditFuncText\t\"setaudit_addr\"",
      "#define\tAuditInfoStruct\t\tauditinfo_addr"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"BSM audit: %s: %s failed: %s\"",
            "__func__",
            "SetAuditFuncText",
            "strerror(errno)"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetAuditFunc",
          "args": [
            "&info",
            "sizeof(info)"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "au_user_mask",
          "args": [
            "the_authctxt->user",
            "&mask"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <locale.h>\n#include <bsm/audit_record.h>\n#include <bsm/audit_uevents.h>\n#include <bsm/libbsm.h>\n#include <bsm/audit.h>\n#include \"xmalloc.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include <libscf.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SetAuditFuncText\t\"setaudit\"\n#define\tAuditInfoStruct\t\tauditinfo\n#define SetAuditFuncText\t\"setaudit_addr\"\n#define\tAuditInfoStruct\t\tauditinfo_addr\n\nstatic void\nbsm_audit_session_setup(void)\n{\n\tint rc;\n\tstruct AuditInfoStruct info;\n\tau_mask_t mask;\n\n\tif (the_authctxt == NULL) {\n\t\terror(\"BSM audit: session setup internal error (NULL ctxt)\");\n\t\treturn;\n\t}\n\n\tif (the_authctxt->valid)\n\t\tinfo.ai_auid = the_authctxt->pw->pw_uid;\n\telse\n\t\tinfo.ai_auid = -1;\n\tinfo.ai_asid = getpid();\n\tmask.am_success = 0;\n\tmask.am_failure = 0;\n\n\t(void) au_user_mask(the_authctxt->user, &mask);\n\n\tinfo.ai_mask.am_success  = mask.am_success;\n\tinfo.ai_mask.am_failure  = mask.am_failure;\n\n\tinfo.ai_termid = ssh_bsm_tid;\n\n\trc = SetAuditFunc(&info, sizeof(info));\n\tif (rc < 0)\n\t\terror(\"BSM audit: %s: %s failed: %s\", __func__,\n\t\t    SetAuditFuncText, strerror(errno));\n}"
  },
  {
    "function_name": "bsm_audit_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit-bsm.c",
    "lines": "254-294",
    "snippet": "static void\nbsm_audit_record(int typ, char *string, au_event_t event_no)\n{\n\tint\t\tad, rc, sel;\n\tuid_t\t\tuid = -1;\n\tgid_t\t\tgid = -1;\n\tpid_t\t\tpid = getpid();\n\tAuditInfoTermID\ttid = ssh_bsm_tid;\n\n\tif (the_authctxt != NULL && the_authctxt->valid) {\n\t\tuid = the_authctxt->pw->pw_uid;\n\t\tgid = the_authctxt->pw->pw_gid;\n\t}\n\n\trc = (typ == 0) ? 0 : -1;\n\tsel = selected(the_authctxt->user, uid, event_no, rc);\n\tdebug3(\"BSM audit: typ %d rc %d \\\"%s\\\"\", typ, rc, string);\n\tif (!sel)\n\t\treturn;\t/* audit event does not match mask, do not write */\n\n\tdebug3(\"BSM audit: writing audit new record\");\n\tad = au_open();\n\n\t(void) au_write(ad, AUToSubjectFunc(uid, uid, gid, uid, gid,\n\t    pid, pid, &tid));\n\t(void) au_write(ad, au_to_text(string));\n\t(void) au_write(ad, AUToReturnFunc(typ, rc));\n\n#ifdef BROKEN_BSM_API\n\t/* The last argument is the event modifier flags. For\n\t   some seemingly undocumented reason it was added in\n\t   Solaris 11. */\n\trc = au_close(ad, AU_TO_WRITE, event_no, 0);\n#else\n\trc = au_close(ad, AU_TO_WRITE, event_no);\n#endif\n\n\tif (rc < 0)\n\t\terror(\"BSM audit: %s failed to write \\\"%s\\\" record: %s\",\n\t\t    __func__, string, strerror(errno));\n}",
    "includes": [
      "#include <locale.h>",
      "#include <bsm/audit_record.h>",
      "#include <bsm/audit_uevents.h>",
      "#include <bsm/libbsm.h>",
      "#include <bsm/audit.h>",
      "#include \"xmalloc.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include <libscf.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define AUToSubjectFunc\t\tau_to_subject",
      "#define AuditInfoTermID\t\tau_tid_t",
      "#define AUToSubjectFunc\t\tau_to_subject_ex",
      "#define AuditInfoTermID\t\tau_tid_addr_t"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"BSM audit: %s failed to write \\\"%s\\\" record: %s\"",
            "__func__",
            "string",
            "strerror(errno)"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "au_close",
          "args": [
            "ad",
            "AU_TO_WRITE",
            "event_no"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "au_close",
          "args": [
            "ad",
            "AU_TO_WRITE",
            "event_no",
            "0"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "au_write",
          "args": [
            "ad",
            "AUToReturnFunc(typ, rc)"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUToReturnFunc",
          "args": [
            "typ",
            "rc"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "au_write",
          "args": [
            "ad",
            "au_to_text(string)"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "au_to_text",
          "args": [
            "string"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "au_write",
          "args": [
            "ad",
            "AUToSubjectFunc(uid, uid, gid, uid, gid,\n\t    pid, pid, &tid)"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUToSubjectFunc",
          "args": [
            "uid",
            "uid",
            "gid",
            "uid",
            "gid",
            "pid",
            "pid",
            "&tid"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "au_open",
          "args": [],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"BSM audit: writing audit new record\""
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "selected",
          "args": [
            "the_authctxt->user",
            "uid",
            "event_no",
            "rc"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "selected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit-bsm.c",
          "lines": "234-252",
          "snippet": "static int\nselected(char *username, uid_t uid, au_event_t event, int sf)\n{\n\tint rc, sorf;\n\tchar naflags[512];\n\tstruct au_mask mask;\n\n\tmask.am_success = mask.am_failure = 0;\n\tif (uid < 0) {\n\t\t/* get flags for non-attributable (to a real user) events */\n\t\trc = getacna(naflags, sizeof(naflags));\n\t\tif (rc == 0)\n\t\t\t(void) getauditflagsbin(naflags, &mask);\n\t} else\n\t\trc = au_user_mask(username, &mask);\n\n\tsorf = (sf == 0) ? AU_PRS_SUCCESS : AU_PRS_FAILURE;\n\treturn(au_preselect(event, &mask, sorf, AU_PRS_REREAD));\n}",
          "includes": [
            "#include <locale.h>",
            "#include <bsm/audit_record.h>",
            "#include <bsm/audit_uevents.h>",
            "#include <bsm/libbsm.h>",
            "#include <bsm/audit.h>",
            "#include \"xmalloc.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include <libscf.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <locale.h>\n#include <bsm/audit_record.h>\n#include <bsm/audit_uevents.h>\n#include <bsm/libbsm.h>\n#include <bsm/audit.h>\n#include \"xmalloc.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include <libscf.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nselected(char *username, uid_t uid, au_event_t event, int sf)\n{\n\tint rc, sorf;\n\tchar naflags[512];\n\tstruct au_mask mask;\n\n\tmask.am_success = mask.am_failure = 0;\n\tif (uid < 0) {\n\t\t/* get flags for non-attributable (to a real user) events */\n\t\trc = getacna(naflags, sizeof(naflags));\n\t\tif (rc == 0)\n\t\t\t(void) getauditflagsbin(naflags, &mask);\n\t} else\n\t\trc = au_user_mask(username, &mask);\n\n\tsorf = (sf == 0) ? AU_PRS_SUCCESS : AU_PRS_FAILURE;\n\treturn(au_preselect(event, &mask, sorf, AU_PRS_REREAD));\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <locale.h>\n#include <bsm/audit_record.h>\n#include <bsm/audit_uevents.h>\n#include <bsm/libbsm.h>\n#include <bsm/audit.h>\n#include \"xmalloc.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include <libscf.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define AUToSubjectFunc\t\tau_to_subject\n#define AuditInfoTermID\t\tau_tid_t\n#define AUToSubjectFunc\t\tau_to_subject_ex\n#define AuditInfoTermID\t\tau_tid_addr_t\n\nstatic void\nbsm_audit_record(int typ, char *string, au_event_t event_no)\n{\n\tint\t\tad, rc, sel;\n\tuid_t\t\tuid = -1;\n\tgid_t\t\tgid = -1;\n\tpid_t\t\tpid = getpid();\n\tAuditInfoTermID\ttid = ssh_bsm_tid;\n\n\tif (the_authctxt != NULL && the_authctxt->valid) {\n\t\tuid = the_authctxt->pw->pw_uid;\n\t\tgid = the_authctxt->pw->pw_gid;\n\t}\n\n\trc = (typ == 0) ? 0 : -1;\n\tsel = selected(the_authctxt->user, uid, event_no, rc);\n\tdebug3(\"BSM audit: typ %d rc %d \\\"%s\\\"\", typ, rc, string);\n\tif (!sel)\n\t\treturn;\t/* audit event does not match mask, do not write */\n\n\tdebug3(\"BSM audit: writing audit new record\");\n\tad = au_open();\n\n\t(void) au_write(ad, AUToSubjectFunc(uid, uid, gid, uid, gid,\n\t    pid, pid, &tid));\n\t(void) au_write(ad, au_to_text(string));\n\t(void) au_write(ad, AUToReturnFunc(typ, rc));\n\n#ifdef BROKEN_BSM_API\n\t/* The last argument is the event modifier flags. For\n\t   some seemingly undocumented reason it was added in\n\t   Solaris 11. */\n\trc = au_close(ad, AU_TO_WRITE, event_no, 0);\n#else\n\trc = au_close(ad, AU_TO_WRITE, event_no);\n#endif\n\n\tif (rc < 0)\n\t\terror(\"BSM audit: %s failed to write \\\"%s\\\" record: %s\",\n\t\t    __func__, string, strerror(errno));\n}"
  },
  {
    "function_name": "selected",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit-bsm.c",
    "lines": "234-252",
    "snippet": "static int\nselected(char *username, uid_t uid, au_event_t event, int sf)\n{\n\tint rc, sorf;\n\tchar naflags[512];\n\tstruct au_mask mask;\n\n\tmask.am_success = mask.am_failure = 0;\n\tif (uid < 0) {\n\t\t/* get flags for non-attributable (to a real user) events */\n\t\trc = getacna(naflags, sizeof(naflags));\n\t\tif (rc == 0)\n\t\t\t(void) getauditflagsbin(naflags, &mask);\n\t} else\n\t\trc = au_user_mask(username, &mask);\n\n\tsorf = (sf == 0) ? AU_PRS_SUCCESS : AU_PRS_FAILURE;\n\treturn(au_preselect(event, &mask, sorf, AU_PRS_REREAD));\n}",
    "includes": [
      "#include <locale.h>",
      "#include <bsm/audit_record.h>",
      "#include <bsm/audit_uevents.h>",
      "#include <bsm/libbsm.h>",
      "#include <bsm/audit.h>",
      "#include \"xmalloc.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include <libscf.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "au_preselect",
          "args": [
            "event",
            "&mask",
            "sorf",
            "AU_PRS_REREAD"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "au_user_mask",
          "args": [
            "username",
            "&mask"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getauditflagsbin",
          "args": [
            "naflags",
            "&mask"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getacna",
          "args": [
            "naflags",
            "sizeof(naflags)"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "getacna",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit-bsm.c",
          "lines": "178-227",
          "snippet": "int\ngetacna(char *auditstring, int len)\n{\n\tscf_handle_t *handle = NULL;\n\tscf_property_t *property = NULL;\n\tscf_value_t *value = NULL;\n\tint ret = 0;\n\n\thandle = scf_handle_create(SCF_VERSION);\n\tif (handle == NULL) \n\t        return -2; /* The man page for getacna on Solaris 10 states\n\t\t\t      we should return -2 in case of error and set\n\t\t\t      errno to indicate the error. We don't bother\n\t\t\t      with errno here, though, since the only use\n\t\t\t      of this function below doesn't check for errors\n\t\t\t      anyway. \n\t\t\t   */\n\n\tret = scf_handle_bind(handle);\n\tif (ret == -1) \n\t        return -2;\n\n\tproperty = scf_property_create(handle);\n\tif (property == NULL) \n\t        return -2;\n\n\tret = scf_handle_decode_fmri(handle, \n\t     \"svc:/system/auditd:default/:properties/preselection/naflags\",\n\t\t\t\t     NULL, NULL, NULL, NULL, property, 0);\n\tif (ret == -1) \n\t        return -2;\n\n\tvalue = scf_value_create(handle);\n\tif (value == NULL) \n\t        return -2;\n\n\tret = scf_property_get_value(property, value);\n\tif (ret == -1) \n\t        return -2;\n\n\tret = scf_value_get_astring(value, auditstring, len);\n\tif (ret == -1) \n\t        return -2;\n\n\tscf_value_destroy(value);\n\tscf_property_destroy(property);\n\tscf_handle_destroy(handle);\n\n\treturn 0;\n}",
          "includes": [
            "#include <locale.h>",
            "#include <bsm/audit_record.h>",
            "#include <bsm/audit_uevents.h>",
            "#include <bsm/libbsm.h>",
            "#include <bsm/audit.h>",
            "#include \"xmalloc.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include <libscf.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <locale.h>\n#include <bsm/audit_record.h>\n#include <bsm/audit_uevents.h>\n#include <bsm/libbsm.h>\n#include <bsm/audit.h>\n#include \"xmalloc.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include <libscf.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ngetacna(char *auditstring, int len)\n{\n\tscf_handle_t *handle = NULL;\n\tscf_property_t *property = NULL;\n\tscf_value_t *value = NULL;\n\tint ret = 0;\n\n\thandle = scf_handle_create(SCF_VERSION);\n\tif (handle == NULL) \n\t        return -2; /* The man page for getacna on Solaris 10 states\n\t\t\t      we should return -2 in case of error and set\n\t\t\t      errno to indicate the error. We don't bother\n\t\t\t      with errno here, though, since the only use\n\t\t\t      of this function below doesn't check for errors\n\t\t\t      anyway. \n\t\t\t   */\n\n\tret = scf_handle_bind(handle);\n\tif (ret == -1) \n\t        return -2;\n\n\tproperty = scf_property_create(handle);\n\tif (property == NULL) \n\t        return -2;\n\n\tret = scf_handle_decode_fmri(handle, \n\t     \"svc:/system/auditd:default/:properties/preselection/naflags\",\n\t\t\t\t     NULL, NULL, NULL, NULL, property, 0);\n\tif (ret == -1) \n\t        return -2;\n\n\tvalue = scf_value_create(handle);\n\tif (value == NULL) \n\t        return -2;\n\n\tret = scf_property_get_value(property, value);\n\tif (ret == -1) \n\t        return -2;\n\n\tret = scf_value_get_astring(value, auditstring, len);\n\tif (ret == -1) \n\t        return -2;\n\n\tscf_value_destroy(value);\n\tscf_property_destroy(property);\n\tscf_handle_destroy(handle);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <locale.h>\n#include <bsm/audit_record.h>\n#include <bsm/audit_uevents.h>\n#include <bsm/libbsm.h>\n#include <bsm/audit.h>\n#include \"xmalloc.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include <libscf.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nselected(char *username, uid_t uid, au_event_t event, int sf)\n{\n\tint rc, sorf;\n\tchar naflags[512];\n\tstruct au_mask mask;\n\n\tmask.am_success = mask.am_failure = 0;\n\tif (uid < 0) {\n\t\t/* get flags for non-attributable (to a real user) events */\n\t\trc = getacna(naflags, sizeof(naflags));\n\t\tif (rc == 0)\n\t\t\t(void) getauditflagsbin(naflags, &mask);\n\t} else\n\t\trc = au_user_mask(username, &mask);\n\n\tsorf = (sf == 0) ? AU_PRS_SUCCESS : AU_PRS_FAILURE;\n\treturn(au_preselect(event, &mask, sorf, AU_PRS_REREAD));\n}"
  },
  {
    "function_name": "getacna",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit-bsm.c",
    "lines": "178-227",
    "snippet": "int\ngetacna(char *auditstring, int len)\n{\n\tscf_handle_t *handle = NULL;\n\tscf_property_t *property = NULL;\n\tscf_value_t *value = NULL;\n\tint ret = 0;\n\n\thandle = scf_handle_create(SCF_VERSION);\n\tif (handle == NULL) \n\t        return -2; /* The man page for getacna on Solaris 10 states\n\t\t\t      we should return -2 in case of error and set\n\t\t\t      errno to indicate the error. We don't bother\n\t\t\t      with errno here, though, since the only use\n\t\t\t      of this function below doesn't check for errors\n\t\t\t      anyway. \n\t\t\t   */\n\n\tret = scf_handle_bind(handle);\n\tif (ret == -1) \n\t        return -2;\n\n\tproperty = scf_property_create(handle);\n\tif (property == NULL) \n\t        return -2;\n\n\tret = scf_handle_decode_fmri(handle, \n\t     \"svc:/system/auditd:default/:properties/preselection/naflags\",\n\t\t\t\t     NULL, NULL, NULL, NULL, property, 0);\n\tif (ret == -1) \n\t        return -2;\n\n\tvalue = scf_value_create(handle);\n\tif (value == NULL) \n\t        return -2;\n\n\tret = scf_property_get_value(property, value);\n\tif (ret == -1) \n\t        return -2;\n\n\tret = scf_value_get_astring(value, auditstring, len);\n\tif (ret == -1) \n\t        return -2;\n\n\tscf_value_destroy(value);\n\tscf_property_destroy(property);\n\tscf_handle_destroy(handle);\n\n\treturn 0;\n}",
    "includes": [
      "#include <locale.h>",
      "#include <bsm/audit_record.h>",
      "#include <bsm/audit_uevents.h>",
      "#include <bsm/libbsm.h>",
      "#include <bsm/audit.h>",
      "#include \"xmalloc.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include <libscf.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scf_handle_destroy",
          "args": [
            "handle"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scf_property_destroy",
          "args": [
            "property"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scf_value_destroy",
          "args": [
            "value"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scf_value_get_astring",
          "args": [
            "value",
            "auditstring",
            "len"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scf_property_get_value",
          "args": [
            "property",
            "value"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scf_value_create",
          "args": [
            "handle"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scf_handle_decode_fmri",
          "args": [
            "handle",
            "\"svc:/system/auditd:default/:properties/preselection/naflags\"",
            "NULL",
            "NULL",
            "NULL",
            "NULL",
            "property",
            "0"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scf_property_create",
          "args": [
            "handle"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scf_handle_bind",
          "args": [
            "handle"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scf_handle_create",
          "args": [
            "SCF_VERSION"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <locale.h>\n#include <bsm/audit_record.h>\n#include <bsm/audit_uevents.h>\n#include <bsm/libbsm.h>\n#include <bsm/audit.h>\n#include \"xmalloc.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include <libscf.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\ngetacna(char *auditstring, int len)\n{\n\tscf_handle_t *handle = NULL;\n\tscf_property_t *property = NULL;\n\tscf_value_t *value = NULL;\n\tint ret = 0;\n\n\thandle = scf_handle_create(SCF_VERSION);\n\tif (handle == NULL) \n\t        return -2; /* The man page for getacna on Solaris 10 states\n\t\t\t      we should return -2 in case of error and set\n\t\t\t      errno to indicate the error. We don't bother\n\t\t\t      with errno here, though, since the only use\n\t\t\t      of this function below doesn't check for errors\n\t\t\t      anyway. \n\t\t\t   */\n\n\tret = scf_handle_bind(handle);\n\tif (ret == -1) \n\t        return -2;\n\n\tproperty = scf_property_create(handle);\n\tif (property == NULL) \n\t        return -2;\n\n\tret = scf_handle_decode_fmri(handle, \n\t     \"svc:/system/auditd:default/:properties/preselection/naflags\",\n\t\t\t\t     NULL, NULL, NULL, NULL, property, 0);\n\tif (ret == -1) \n\t        return -2;\n\n\tvalue = scf_value_create(handle);\n\tif (value == NULL) \n\t        return -2;\n\n\tret = scf_property_get_value(property, value);\n\tif (ret == -1) \n\t        return -2;\n\n\tret = scf_value_get_astring(value, auditstring, len);\n\tif (ret == -1) \n\t        return -2;\n\n\tscf_value_destroy(value);\n\tscf_property_destroy(property);\n\tscf_handle_destroy(handle);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "aug_get_machine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/audit-bsm.c",
    "lines": "134-168",
    "snippet": "static int\naug_get_machine(char *host, u_int32_t *addr, u_int32_t *type)\n{\n\tstruct addrinfo *ai; \n\tstruct sockaddr_in *in4;\n\tstruct sockaddr_in6 *in6;\n\tint ret = 0, r;\n\n\tif ((r = getaddrinfo(host, NULL, NULL, &ai)) != 0) {\n\t\terror(\"BSM audit: getaddrinfo failed for %.100s: %.100s\", host,\n\t\t    r == EAI_SYSTEM ? strerror(errno) : gai_strerror(r));\n\t\treturn -1;\n\t}\n\t\n\tswitch (ai->ai_family) {\n\tcase AF_INET:\n\t\tin4 = (struct sockaddr_in *)ai->ai_addr;\n\t\t*type = AU_IPv4;\n\t\tmemcpy(addr, &in4->sin_addr, sizeof(struct in_addr));\n\t\tbreak;\n#ifdef AU_IPv6\n\tcase AF_INET6: \n\t\tin6 = (struct sockaddr_in6 *)ai->ai_addr;\n\t\t*type = AU_IPv6;\n\t\tmemcpy(addr, &in6->sin6_addr, sizeof(struct in6_addr));\n\t\tbreak;\n#endif\n\tdefault:\n\t\terror(\"BSM audit: unknown address family for %.100s: %d\",\n\t\t    host, ai->ai_family);\n\t\tret = -1;\n\t}\n\tfreeaddrinfo(ai);\n\treturn ret;\n}",
    "includes": [
      "#include <locale.h>",
      "#include <bsm/audit_record.h>",
      "#include <bsm/audit_uevents.h>",
      "#include <bsm/libbsm.h>",
      "#include <bsm/audit.h>",
      "#include \"xmalloc.h\"",
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"log.h\"",
      "#include \"ssh.h\"",
      "#include <libscf.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "ai"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"BSM audit: unknown address family for %.100s: %d\"",
            "host",
            "ai->ai_family"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "162-170",
          "snippet": "void\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nerror(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_ERROR, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "addr",
            "&in6->sin6_addr",
            "sizeof(struct in6_addr)"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "addr",
            "&in4->sin_addr",
            "sizeof(struct in_addr)"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gai_strerror",
          "args": [
            "r"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "host",
            "NULL",
            "NULL",
            "&ai"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "getaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "154-234",
          "snippet": "int\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <locale.h>\n#include <bsm/audit_record.h>\n#include <bsm/audit_uevents.h>\n#include <bsm/libbsm.h>\n#include <bsm/audit.h>\n#include \"xmalloc.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include <libscf.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\naug_get_machine(char *host, u_int32_t *addr, u_int32_t *type)\n{\n\tstruct addrinfo *ai; \n\tstruct sockaddr_in *in4;\n\tstruct sockaddr_in6 *in6;\n\tint ret = 0, r;\n\n\tif ((r = getaddrinfo(host, NULL, NULL, &ai)) != 0) {\n\t\terror(\"BSM audit: getaddrinfo failed for %.100s: %.100s\", host,\n\t\t    r == EAI_SYSTEM ? strerror(errno) : gai_strerror(r));\n\t\treturn -1;\n\t}\n\t\n\tswitch (ai->ai_family) {\n\tcase AF_INET:\n\t\tin4 = (struct sockaddr_in *)ai->ai_addr;\n\t\t*type = AU_IPv4;\n\t\tmemcpy(addr, &in4->sin_addr, sizeof(struct in_addr));\n\t\tbreak;\n#ifdef AU_IPv6\n\tcase AF_INET6: \n\t\tin6 = (struct sockaddr_in6 *)ai->ai_addr;\n\t\t*type = AU_IPv6;\n\t\tmemcpy(addr, &in6->sin6_addr, sizeof(struct in6_addr));\n\t\tbreak;\n#endif\n\tdefault:\n\t\terror(\"BSM audit: unknown address family for %.100s: %d\",\n\t\t    host, ai->ai_family);\n\t\tret = -1;\n\t}\n\tfreeaddrinfo(ai);\n\treturn ret;\n}"
  }
]