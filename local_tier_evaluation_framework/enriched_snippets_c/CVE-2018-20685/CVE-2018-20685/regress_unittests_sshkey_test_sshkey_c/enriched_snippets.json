[
  {
    "function_name": "sshkey_tests",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/test_sshkey.c",
    "lines": "176-508",
    "snippet": "void\nsshkey_tests(void)\n{\n\tstruct sshkey *k1, *k2, *k3, *k4, *kr, *kd, *kf;\n#ifdef OPENSSL_HAS_ECC\n\tstruct sshkey *ke;\n#endif\n\tstruct sshbuf *b;\n\n\tTEST_START(\"new invalid\");\n\tk1 = sshkey_new(-42);\n\tASSERT_PTR_EQ(k1, NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"new/free KEY_UNSPEC\");\n\tk1 = sshkey_new(KEY_UNSPEC);\n\tASSERT_PTR_NE(k1, NULL);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"new/free KEY_RSA\");\n\tk1 = sshkey_new(KEY_RSA);\n\tASSERT_PTR_NE(k1, NULL);\n\tASSERT_PTR_NE(k1->rsa, NULL);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"new/free KEY_DSA\");\n\tk1 = sshkey_new(KEY_DSA);\n\tASSERT_PTR_NE(k1, NULL);\n\tASSERT_PTR_NE(k1->dsa, NULL);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n#ifdef OPENSSL_HAS_ECC\n\tTEST_START(\"new/free KEY_ECDSA\");\n\tk1 = sshkey_new(KEY_ECDSA);\n\tASSERT_PTR_NE(k1, NULL);\n\tASSERT_PTR_EQ(k1->ecdsa, NULL);  /* Can't allocate without NID */\n\tsshkey_free(k1);\n\tTEST_DONE();\n#endif\n\n\tTEST_START(\"new/free KEY_ED25519\");\n\tk1 = sshkey_new(KEY_ED25519);\n\tASSERT_PTR_NE(k1, NULL);\n\t/* These should be blank until key loaded or generated */\n\tASSERT_PTR_EQ(k1->ed25519_sk, NULL);\n\tASSERT_PTR_EQ(k1->ed25519_pk, NULL);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"generate KEY_RSA too small modulus\");\n\tASSERT_INT_EQ(sshkey_generate(KEY_RSA, 128, &k1),\n\t    SSH_ERR_KEY_LENGTH);\n\tASSERT_PTR_EQ(k1, NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"generate KEY_RSA too large modulus\");\n\tASSERT_INT_EQ(sshkey_generate(KEY_RSA, 1 << 20, &k1),\n\t    SSH_ERR_KEY_LENGTH);\n\tASSERT_PTR_EQ(k1, NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"generate KEY_DSA wrong bits\");\n\tASSERT_INT_EQ(sshkey_generate(KEY_DSA, 2048, &k1),\n\t    SSH_ERR_KEY_LENGTH);\n\tASSERT_PTR_EQ(k1, NULL);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n#ifdef OPENSSL_HAS_ECC\n\tTEST_START(\"generate KEY_ECDSA wrong bits\");\n\tASSERT_INT_EQ(sshkey_generate(KEY_ECDSA, 42, &k1),\n\t    SSH_ERR_KEY_LENGTH);\n\tASSERT_PTR_EQ(k1, NULL);\n\tsshkey_free(k1);\n\tTEST_DONE();\n#endif\n\n\tTEST_START(\"generate KEY_RSA\");\n\tASSERT_INT_EQ(sshkey_generate(KEY_RSA, 767, &kr),\n\t    SSH_ERR_KEY_LENGTH);\n\tASSERT_INT_EQ(sshkey_generate(KEY_RSA, 1024, &kr), 0);\n\tASSERT_PTR_NE(kr, NULL);\n\tASSERT_PTR_NE(kr->rsa, NULL);\n\tASSERT_PTR_NE(rsa_n(kr), NULL);\n\tASSERT_PTR_NE(rsa_e(kr), NULL);\n\tASSERT_PTR_NE(rsa_p(kr), NULL);\n\tASSERT_INT_EQ(BN_num_bits(rsa_n(kr)), 1024);\n\tTEST_DONE();\n\n\tTEST_START(\"generate KEY_DSA\");\n\tASSERT_INT_EQ(sshkey_generate(KEY_DSA, 1024, &kd), 0);\n\tASSERT_PTR_NE(kd, NULL);\n\tASSERT_PTR_NE(kd->dsa, NULL);\n\tASSERT_PTR_NE(dsa_g(kd), NULL);\n\tASSERT_PTR_NE(dsa_priv_key(kd), NULL);\n\tTEST_DONE();\n\n#ifdef OPENSSL_HAS_ECC\n\tTEST_START(\"generate KEY_ECDSA\");\n\tASSERT_INT_EQ(sshkey_generate(KEY_ECDSA, 256, &ke), 0);\n\tASSERT_PTR_NE(ke, NULL);\n\tASSERT_PTR_NE(ke->ecdsa, NULL);\n\tASSERT_PTR_NE(EC_KEY_get0_public_key(ke->ecdsa), NULL);\n\tASSERT_PTR_NE(EC_KEY_get0_private_key(ke->ecdsa), NULL);\n\tTEST_DONE();\n#endif\n\n\tTEST_START(\"generate KEY_ED25519\");\n\tASSERT_INT_EQ(sshkey_generate(KEY_ED25519, 256, &kf), 0);\n\tASSERT_PTR_NE(kf, NULL);\n\tASSERT_INT_EQ(kf->type, KEY_ED25519);\n\tASSERT_PTR_NE(kf->ed25519_pk, NULL);\n\tASSERT_PTR_NE(kf->ed25519_sk, NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"demote KEY_RSA\");\n\tASSERT_INT_EQ(sshkey_from_private(kr, &k1), 0);\n\tASSERT_PTR_NE(k1, NULL);\n\tASSERT_PTR_NE(kr, k1);\n\tASSERT_INT_EQ(k1->type, KEY_RSA);\n\tASSERT_PTR_NE(k1->rsa, NULL);\n\tASSERT_PTR_NE(rsa_n(k1), NULL);\n\tASSERT_PTR_NE(rsa_e(k1), NULL);\n\tASSERT_PTR_EQ(rsa_p(k1), NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"equal KEY_RSA/demoted KEY_RSA\");\n\tASSERT_INT_EQ(sshkey_equal(kr, k1), 1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"demote KEY_DSA\");\n\tASSERT_INT_EQ(sshkey_from_private(kd, &k1), 0);\n\tASSERT_PTR_NE(k1, NULL);\n\tASSERT_PTR_NE(kd, k1);\n\tASSERT_INT_EQ(k1->type, KEY_DSA);\n\tASSERT_PTR_NE(k1->dsa, NULL);\n\tASSERT_PTR_NE(dsa_g(k1), NULL);\n\tASSERT_PTR_EQ(dsa_priv_key(k1), NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"equal KEY_DSA/demoted KEY_DSA\");\n\tASSERT_INT_EQ(sshkey_equal(kd, k1), 1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n#ifdef OPENSSL_HAS_ECC\n\tTEST_START(\"demote KEY_ECDSA\");\n\tASSERT_INT_EQ(sshkey_from_private(ke, &k1), 0);\n\tASSERT_PTR_NE(k1, NULL);\n\tASSERT_PTR_NE(ke, k1);\n\tASSERT_INT_EQ(k1->type, KEY_ECDSA);\n\tASSERT_PTR_NE(k1->ecdsa, NULL);\n\tASSERT_INT_EQ(k1->ecdsa_nid, ke->ecdsa_nid);\n\tASSERT_PTR_NE(EC_KEY_get0_public_key(ke->ecdsa), NULL);\n\tASSERT_PTR_EQ(EC_KEY_get0_private_key(k1->ecdsa), NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"equal KEY_ECDSA/demoted KEY_ECDSA\");\n\tASSERT_INT_EQ(sshkey_equal(ke, k1), 1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n#endif\n\n\tTEST_START(\"demote KEY_ED25519\");\n\tASSERT_INT_EQ(sshkey_from_private(kf, &k1), 0);\n\tASSERT_PTR_NE(k1, NULL);\n\tASSERT_PTR_NE(kf, k1);\n\tASSERT_INT_EQ(k1->type, KEY_ED25519);\n\tASSERT_PTR_NE(k1->ed25519_pk, NULL);\n\tASSERT_PTR_EQ(k1->ed25519_sk, NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"equal KEY_ED25519/demoted KEY_ED25519\");\n\tASSERT_INT_EQ(sshkey_equal(kf, k1), 1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"equal mismatched key types\");\n\tASSERT_INT_EQ(sshkey_equal(kd, kr), 0);\n#ifdef OPENSSL_HAS_ECC\n\tASSERT_INT_EQ(sshkey_equal(kd, ke), 0);\n\tASSERT_INT_EQ(sshkey_equal(kr, ke), 0);\n\tASSERT_INT_EQ(sshkey_equal(ke, kf), 0);\n#endif\n\tASSERT_INT_EQ(sshkey_equal(kd, kf), 0);\n\tTEST_DONE();\n\n\tTEST_START(\"equal different keys\");\n\tASSERT_INT_EQ(sshkey_generate(KEY_RSA, 1024, &k1), 0);\n\tASSERT_INT_EQ(sshkey_equal(kr, k1), 0);\n\tsshkey_free(k1);\n\tASSERT_INT_EQ(sshkey_generate(KEY_DSA, 1024, &k1), 0);\n\tASSERT_INT_EQ(sshkey_equal(kd, k1), 0);\n\tsshkey_free(k1);\n#ifdef OPENSSL_HAS_ECC\n\tASSERT_INT_EQ(sshkey_generate(KEY_ECDSA, 256, &k1), 0);\n\tASSERT_INT_EQ(sshkey_equal(ke, k1), 0);\n\tsshkey_free(k1);\n#endif\n\tASSERT_INT_EQ(sshkey_generate(KEY_ED25519, 256, &k1), 0);\n\tASSERT_INT_EQ(sshkey_equal(kf, k1), 0);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tsshkey_free(kr);\n\tsshkey_free(kd);\n#ifdef OPENSSL_HAS_ECC\n\tsshkey_free(ke);\n#endif\n\tsshkey_free(kf);\n\n\tTEST_START(\"certify key\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"ed25519_1.pub\"),\n\t    &k1, NULL), 0);\n\tk2 = get_private(\"ed25519_2\");\n\tASSERT_INT_EQ(sshkey_to_certified(k1), 0);\n\tASSERT_PTR_NE(k1->cert, NULL);\n\tk1->cert->type = SSH2_CERT_TYPE_USER;\n\tk1->cert->serial = 1234;\n\tk1->cert->key_id = strdup(\"estragon\");\n\tASSERT_PTR_NE(k1->cert->key_id, NULL);\n\tk1->cert->principals = calloc(4, sizeof(*k1->cert->principals));\n\tASSERT_PTR_NE(k1->cert->principals, NULL);\n\tk1->cert->principals[0] = strdup(\"estragon\");\n\tk1->cert->principals[1] = strdup(\"vladimir\");\n\tk1->cert->principals[2] = strdup(\"pozzo\");\n\tk1->cert->principals[3] = strdup(\"lucky\");\n\tASSERT_PTR_NE(k1->cert->principals[0], NULL);\n\tASSERT_PTR_NE(k1->cert->principals[1], NULL);\n\tASSERT_PTR_NE(k1->cert->principals[2], NULL);\n\tASSERT_PTR_NE(k1->cert->principals[3], NULL);\n\tk1->cert->nprincipals = 4;\n\tk1->cert->valid_after = 0;\n\tk1->cert->valid_before = (u_int64_t)-1;\n\tsshbuf_free(k1->cert->critical);\n\tk1->cert->critical = sshbuf_new();\n\tASSERT_PTR_NE(k1->cert->critical, NULL);\n\tsshbuf_free(k1->cert->extensions);\n\tk1->cert->extensions = sshbuf_new();\n\tASSERT_PTR_NE(k1->cert->extensions, NULL);\n\tput_opt(k1->cert->critical, \"force-command\", \"/usr/bin/true\");\n\tput_opt(k1->cert->critical, \"source-address\", \"127.0.0.1\");\n\tput_opt(k1->cert->extensions, \"permit-X11-forwarding\", NULL);\n\tput_opt(k1->cert->extensions, \"permit-agent-forwarding\", NULL);\n\tASSERT_INT_EQ(sshkey_from_private(k2, &k1->cert->signature_key), 0);\n\tASSERT_INT_EQ(sshkey_certify(k1, k2, NULL), 0);\n\tb = sshbuf_new();\n\tASSERT_PTR_NE(b, NULL);\n\tASSERT_INT_EQ(sshkey_putb(k1, b), 0);\n\tASSERT_INT_EQ(sshkey_from_blob(sshbuf_ptr(b), sshbuf_len(b), &k3), 0);\n\n\tsshkey_free(k1);\n\tsshkey_free(k2);\n\tsshkey_free(k3);\n\tsshbuf_reset(b);\n\tTEST_DONE();\n\n\tTEST_START(\"sign and verify RSA\");\n\tk1 = get_private(\"rsa_1\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"rsa_2.pub\"), &k2,\n\t    NULL), 0);\n\tsignature_tests(k1, k2, \"ssh-rsa\");\n\tsshkey_free(k1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"sign and verify RSA-SHA256\");\n\tk1 = get_private(\"rsa_1\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"rsa_2.pub\"), &k2,\n\t    NULL), 0);\n\tsignature_tests(k1, k2, \"rsa-sha2-256\");\n\tsshkey_free(k1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"sign and verify RSA-SHA512\");\n\tk1 = get_private(\"rsa_1\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"rsa_2.pub\"), &k2,\n\t    NULL), 0);\n\tsignature_tests(k1, k2, \"rsa-sha2-512\");\n\tsshkey_free(k1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"sign and verify DSA\");\n\tk1 = get_private(\"dsa_1\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"dsa_2.pub\"), &k2,\n\t    NULL), 0);\n\tsignature_tests(k1, k2, NULL);\n\tsshkey_free(k1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n#ifdef OPENSSL_HAS_ECC\n\tTEST_START(\"sign and verify ECDSA\");\n\tk1 = get_private(\"ecdsa_1\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"ecdsa_2.pub\"), &k2,\n\t    NULL), 0);\n\tsignature_tests(k1, k2, NULL);\n\tsshkey_free(k1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n#endif\n\n\tTEST_START(\"sign and verify ED25519\");\n\tk1 = get_private(\"ed25519_1\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"ed25519_2.pub\"), &k2,\n\t    NULL), 0);\n\tsignature_tests(k1, k2, NULL);\n\tsshkey_free(k1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"nested certificate\");\n\tASSERT_INT_EQ(sshkey_load_cert(test_data_file(\"rsa_1\"), &k1), 0);\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"rsa_1.pub\"), &k2,\n\t    NULL), 0);\n\tk3 = get_private(\"rsa_1\");\n\tbuild_cert(b, k2, \"ssh-rsa-cert-v01@openssh.com\", k3, k1, NULL);\n\tASSERT_INT_EQ(sshkey_from_blob(sshbuf_ptr(b), sshbuf_len(b), &k4),\n\t    SSH_ERR_KEY_CERT_INVALID_SIGN_KEY);\n\tASSERT_PTR_EQ(k4, NULL);\n\tsshkey_free(k1);\n\tsshkey_free(k2);\n\tsshkey_free(k3);\n\tsshbuf_free(b);\n\tTEST_DONE();\n\n}",
    "includes": [
      "#include \"ssh2.h\"",
      "#include \"common.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"../test_helper/test_helper.h\"",
      "# include <openssl/ec.h>",
      "#include <openssl/dsa.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/bn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sshkey_tests(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_free",
          "args": [
            "k3"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "552-606",
          "snippet": "void\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tRSA_free(k->rsa);\n\t\tk->rsa = NULL;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tDSA_free(k->dsa);\n\t\tk->dsa = NULL;\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tEC_KEY_free(k->ecdsa);\n\t\tk->ecdsa = NULL;\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tfreezero(k->ed25519_pk, ED25519_PK_SZ);\n\t\tk->ed25519_pk = NULL;\n\t\tfreezero(k->ed25519_sk, ED25519_SK_SZ);\n\t\tk->ed25519_sk = NULL;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\t\tk->xmss_pk = NULL;\n\t\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\t\tk->xmss_sk = NULL;\n\t\tsshkey_xmss_free_state(k);\n\t\tfree(k->xmss_name);\n\t\tk->xmss_name = NULL;\n\t\tfree(k->xmss_filename);\n\t\tk->xmss_filename = NULL;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k, sizeof(*k));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_EQ",
          "args": [
            "k4",
            "NULL"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_from_blob(sshbuf_ptr(b), sshbuf_len(b), &k4)",
            "SSH_ERR_KEY_CERT_INVALID_SIGN_KEY"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_from_blob",
          "args": [
            "sshbuf_ptr(b)",
            "sshbuf_len(b)",
            "&k4"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2263-2274",
          "snippet": "int\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "b"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "b"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_cert",
          "args": [
            "b",
            "k2",
            "\"ssh-rsa-cert-v01@openssh.com\"",
            "k3",
            "k1",
            "NULL"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "build_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/test_sshkey.c",
          "lines": "53-112",
          "snippet": "static void\nbuild_cert(struct sshbuf *b, const struct sshkey *k, const char *type,\n    const struct sshkey *sign_key, const struct sshkey *ca_key,\n    const char *sig_alg)\n{\n\tstruct sshbuf *ca_buf, *pk, *principals, *critopts, *exts;\n\tu_char *sigblob;\n\tsize_t siglen;\n\n\tca_buf = sshbuf_new();\n\tASSERT_PTR_NE(ca_buf, NULL);\n\tASSERT_INT_EQ(sshkey_putb(ca_key, ca_buf), 0);\n\n\t/*\n\t * Get the public key serialisation by rendering the key and skipping\n\t * the type string. This is a bit of a hack :/\n\t */\n\tpk = sshbuf_new();\n\tASSERT_PTR_NE(pk, NULL);\n\tASSERT_INT_EQ(sshkey_putb_plain(k, pk), 0);\n\tASSERT_INT_EQ(sshbuf_skip_string(pk), 0);\n\n\tprincipals = sshbuf_new();\n\tASSERT_PTR_NE(principals, NULL);\n\tASSERT_INT_EQ(sshbuf_put_cstring(principals, \"gsamsa\"), 0);\n\tASSERT_INT_EQ(sshbuf_put_cstring(principals, \"gregor\"), 0);\n\n\tcritopts = sshbuf_new();\n\tASSERT_PTR_NE(critopts, NULL);\n\tput_opt(critopts, \"force-command\", \"/usr/local/bin/nethack\");\n\tput_opt(critopts, \"source-address\", \"192.168.0.0/24,127.0.0.1,::1\");\n\n\texts = sshbuf_new();\n\tASSERT_PTR_NE(exts, NULL);\n\tput_opt(critopts, \"permit-X11-forwarding\", NULL);\n\n\tASSERT_INT_EQ(sshbuf_put_cstring(b, type), 0);\n\tASSERT_INT_EQ(sshbuf_put_cstring(b, \"noncenoncenonce!\"), 0); /* nonce */\n\tASSERT_INT_EQ(sshbuf_putb(b, pk), 0); /* public key serialisation */\n\tASSERT_INT_EQ(sshbuf_put_u64(b, 1234), 0); /* serial */\n\tASSERT_INT_EQ(sshbuf_put_u32(b, SSH2_CERT_TYPE_USER), 0); /* type */\n\tASSERT_INT_EQ(sshbuf_put_cstring(b, \"gregor\"), 0); /* key ID */\n\tASSERT_INT_EQ(sshbuf_put_stringb(b, principals), 0); /* principals */\n\tASSERT_INT_EQ(sshbuf_put_u64(b, 0), 0); /* start */\n\tASSERT_INT_EQ(sshbuf_put_u64(b, 0xffffffffffffffffULL), 0); /* end */\n\tASSERT_INT_EQ(sshbuf_put_stringb(b, critopts), 0); /* options */\n\tASSERT_INT_EQ(sshbuf_put_stringb(b, exts), 0); /* extensions */\n\tASSERT_INT_EQ(sshbuf_put_string(b, NULL, 0), 0); /* reserved */\n\tASSERT_INT_EQ(sshbuf_put_stringb(b, ca_buf), 0); /* signature key */\n\tASSERT_INT_EQ(sshkey_sign(sign_key, &sigblob, &siglen,\n\t    sshbuf_ptr(b), sshbuf_len(b), sig_alg, 0), 0);\n\tASSERT_INT_EQ(sshbuf_put_string(b, sigblob, siglen), 0); /* signature */\n\n\tfree(sigblob);\n\tsshbuf_free(ca_buf);\n\tsshbuf_free(exts);\n\tsshbuf_free(critopts);\n\tsshbuf_free(principals);\n\tsshbuf_free(pk);\n}",
          "includes": [
            "#include \"ssh2.h\"",
            "#include \"common.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/bn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh2.h\"\n#include \"common.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n# include <openssl/ec.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nbuild_cert(struct sshbuf *b, const struct sshkey *k, const char *type,\n    const struct sshkey *sign_key, const struct sshkey *ca_key,\n    const char *sig_alg)\n{\n\tstruct sshbuf *ca_buf, *pk, *principals, *critopts, *exts;\n\tu_char *sigblob;\n\tsize_t siglen;\n\n\tca_buf = sshbuf_new();\n\tASSERT_PTR_NE(ca_buf, NULL);\n\tASSERT_INT_EQ(sshkey_putb(ca_key, ca_buf), 0);\n\n\t/*\n\t * Get the public key serialisation by rendering the key and skipping\n\t * the type string. This is a bit of a hack :/\n\t */\n\tpk = sshbuf_new();\n\tASSERT_PTR_NE(pk, NULL);\n\tASSERT_INT_EQ(sshkey_putb_plain(k, pk), 0);\n\tASSERT_INT_EQ(sshbuf_skip_string(pk), 0);\n\n\tprincipals = sshbuf_new();\n\tASSERT_PTR_NE(principals, NULL);\n\tASSERT_INT_EQ(sshbuf_put_cstring(principals, \"gsamsa\"), 0);\n\tASSERT_INT_EQ(sshbuf_put_cstring(principals, \"gregor\"), 0);\n\n\tcritopts = sshbuf_new();\n\tASSERT_PTR_NE(critopts, NULL);\n\tput_opt(critopts, \"force-command\", \"/usr/local/bin/nethack\");\n\tput_opt(critopts, \"source-address\", \"192.168.0.0/24,127.0.0.1,::1\");\n\n\texts = sshbuf_new();\n\tASSERT_PTR_NE(exts, NULL);\n\tput_opt(critopts, \"permit-X11-forwarding\", NULL);\n\n\tASSERT_INT_EQ(sshbuf_put_cstring(b, type), 0);\n\tASSERT_INT_EQ(sshbuf_put_cstring(b, \"noncenoncenonce!\"), 0); /* nonce */\n\tASSERT_INT_EQ(sshbuf_putb(b, pk), 0); /* public key serialisation */\n\tASSERT_INT_EQ(sshbuf_put_u64(b, 1234), 0); /* serial */\n\tASSERT_INT_EQ(sshbuf_put_u32(b, SSH2_CERT_TYPE_USER), 0); /* type */\n\tASSERT_INT_EQ(sshbuf_put_cstring(b, \"gregor\"), 0); /* key ID */\n\tASSERT_INT_EQ(sshbuf_put_stringb(b, principals), 0); /* principals */\n\tASSERT_INT_EQ(sshbuf_put_u64(b, 0), 0); /* start */\n\tASSERT_INT_EQ(sshbuf_put_u64(b, 0xffffffffffffffffULL), 0); /* end */\n\tASSERT_INT_EQ(sshbuf_put_stringb(b, critopts), 0); /* options */\n\tASSERT_INT_EQ(sshbuf_put_stringb(b, exts), 0); /* extensions */\n\tASSERT_INT_EQ(sshbuf_put_string(b, NULL, 0), 0); /* reserved */\n\tASSERT_INT_EQ(sshbuf_put_stringb(b, ca_buf), 0); /* signature key */\n\tASSERT_INT_EQ(sshkey_sign(sign_key, &sigblob, &siglen,\n\t    sshbuf_ptr(b), sshbuf_len(b), sig_alg, 0), 0);\n\tASSERT_INT_EQ(sshbuf_put_string(b, sigblob, siglen), 0); /* signature */\n\n\tfree(sigblob);\n\tsshbuf_free(ca_buf);\n\tsshbuf_free(exts);\n\tsshbuf_free(critopts);\n\tsshbuf_free(principals);\n\tsshbuf_free(pk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_private",
          "args": [
            "\"rsa_1\""
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "get_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/test_sshkey.c",
          "lines": "164-174",
          "snippet": "static struct sshkey *\nget_private(const char *n)\n{\n\tstruct sshbuf *b;\n\tstruct sshkey *ret;\n\n\tb = load_file(n);\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(b, \"\", &ret, NULL), 0);\n\tsshbuf_free(b);\n\treturn ret;\n}",
          "includes": [
            "#include \"ssh2.h\"",
            "#include \"common.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/bn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh2.h\"\n#include \"common.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n# include <openssl/ec.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshkey *\nget_private(const char *n)\n{\n\tstruct sshbuf *b;\n\tstruct sshkey *ret;\n\n\tb = load_file(n);\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(b, \"\", &ret, NULL), 0);\n\tsshbuf_free(b);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_load_public(test_data_file(\"rsa_1.pub\"), &k2,\n\t    NULL)",
            "0"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_load_public",
          "args": [
            "test_data_file(\"rsa_1.pub\")",
            "&k2",
            "NULL"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_load_public",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "312-354",
          "snippet": "int\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tsshkey_free(pub);\n\n\t/* try .pub suffix */\n\tif (asprintf(&file, \"%s.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t}\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(pub, filename, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\tsshkey_free(pub);\n\n\t/* try .pub suffix */\n\tif (asprintf(&file, \"%s.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, commentp)) == 0) {\n\t\tif (keyp != NULL) {\n\t\t\t*keyp = pub;\n\t\t\tpub = NULL;\n\t\t}\n\t\tr = 0;\n\t}\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_data_file",
          "args": [
            "\"rsa_1.pub\""
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "test_data_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/test_helper.c",
          "lines": "181-196",
          "snippet": "const char *\ntest_data_file(const char *name)\n{\n\tstatic char ret[PATH_MAX];\n\n\tif (data_dir != NULL)\n\t\tsnprintf(ret, sizeof(ret), \"%s/%s\", data_dir, name);\n\telse\n\t\tstrlcpy(ret, name, sizeof(ret));\n\tif (access(ret, F_OK) != 0) {\n\t\tfprintf(stderr, \"Cannot access data file %s: %s\\n\",\n\t\t    ret, strerror(errno));\n\t\texit(1);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "# include <vis.h>",
            "#include <openssl/bn.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *data_dir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n# include <vis.h>\n#include <openssl/bn.h>\n#include <signal.h>\n#include <unistd.h>\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *data_dir = NULL;\n\nconst char *\ntest_data_file(const char *name)\n{\n\tstatic char ret[PATH_MAX];\n\n\tif (data_dir != NULL)\n\t\tsnprintf(ret, sizeof(ret), \"%s/%s\", data_dir, name);\n\telse\n\t\tstrlcpy(ret, name, sizeof(ret));\n\tif (access(ret, F_OK) != 0) {\n\t\tfprintf(stderr, \"Cannot access data file %s: %s\\n\",\n\t\t    ret, strerror(errno));\n\t\texit(1);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_load_cert(test_data_file(\"rsa_1\"), &k1)",
            "0"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_load_cert",
          "args": [
            "test_data_file(\"rsa_1\")",
            "&k1"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_load_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfile.c",
          "lines": "357-385",
          "snippet": "int\nsshkey_load_cert(const char *filename, struct sshkey **keyp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\n\tif (asprintf(&file, \"%s-cert.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, NULL)) != 0)\n\t\tgoto out;\n\t/* success */\n\tif (keyp != NULL) {\n\t\t*keyp = pub;\n\t\tpub = NULL;\n\t}\n\tr = 0;\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}",
          "includes": [
            "#include \"krl.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"atomicio.h\"",
            "#include \"misc.h\"",
            "#include \"authfile.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"cipher.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"krl.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"cipher.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_load_cert(const char *filename, struct sshkey **keyp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\n\tif (asprintf(&file, \"%s-cert.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_try_load_public(pub, file, NULL)) != 0)\n\t\tgoto out;\n\t/* success */\n\tif (keyp != NULL) {\n\t\t*keyp = pub;\n\t\tpub = NULL;\n\t}\n\tr = 0;\n out:\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"nested certificate\""
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signature_tests",
          "args": [
            "k1",
            "k2",
            "NULL"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "signature_tests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/test_sshkey.c",
          "lines": "147-162",
          "snippet": "static void\nsignature_tests(struct sshkey *k, struct sshkey *bad, const char *sig_alg)\n{\n\tu_char i, buf[2049];\n\tsize_t lens[] = {\n\t\t1, 2, 7, 8, 9, 15, 16, 17, 31, 32, 33, 127, 128, 129,\n\t\t255, 256, 257, 1023, 1024, 1025, 2047, 2048, 2049\n\t};\n\n\tfor (i = 0; i < (sizeof(lens)/sizeof(lens[0])); i++) {\n\t\ttest_subtest_info(\"%s key, banana length %zu\",\n\t\t    sshkey_type(k), lens[i]);\n\t\tbanana(buf, lens[i]);\n\t\tsignature_test(k, bad, sig_alg, buf, lens[i]);\n\t}\n}",
          "includes": [
            "#include \"ssh2.h\"",
            "#include \"common.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/bn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh2.h\"\n#include \"common.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n# include <openssl/ec.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsignature_tests(struct sshkey *k, struct sshkey *bad, const char *sig_alg)\n{\n\tu_char i, buf[2049];\n\tsize_t lens[] = {\n\t\t1, 2, 7, 8, 9, 15, 16, 17, 31, 32, 33, 127, 128, 129,\n\t\t255, 256, 257, 1023, 1024, 1025, 2047, 2048, 2049\n\t};\n\n\tfor (i = 0; i < (sizeof(lens)/sizeof(lens[0])); i++) {\n\t\ttest_subtest_info(\"%s key, banana length %zu\",\n\t\t    sshkey_type(k), lens[i]);\n\t\tbanana(buf, lens[i]);\n\t\tsignature_test(k, bad, sig_alg, buf, lens[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_load_public(test_data_file(\"ed25519_2.pub\"), &k2,\n\t    NULL)",
            "0"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"sign and verify ED25519\""
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_load_public(test_data_file(\"ecdsa_2.pub\"), &k2,\n\t    NULL)",
            "0"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"sign and verify ECDSA\""
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_load_public(test_data_file(\"dsa_2.pub\"), &k2,\n\t    NULL)",
            "0"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"sign and verify DSA\""
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_load_public(test_data_file(\"rsa_2.pub\"), &k2,\n\t    NULL)",
            "0"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"sign and verify RSA-SHA512\""
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_load_public(test_data_file(\"rsa_2.pub\"), &k2,\n\t    NULL)",
            "0"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"sign and verify RSA-SHA256\""
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_load_public(test_data_file(\"rsa_2.pub\"), &k2,\n\t    NULL)",
            "0"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"sign and verify RSA\""
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_reset",
          "args": [
            "b"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "168-188",
          "snippet": "void\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t/* Nonsensical. Just make buffer appear empty */\n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\t(void) sshbuf_check_sanity(buf);\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, SSHBUF_SIZE_INIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_from_blob(sshbuf_ptr(b), sshbuf_len(b), &k3)",
            "0"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_putb(k1, b)",
            "0"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_putb",
          "args": [
            "k1",
            "b"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_putb_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "842-846",
          "snippet": "int\nsshkey_putb_plain(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn to_blob_buf(key, b, 1, SSHKEY_SERIALIZE_DEFAULT);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_putb_plain(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn to_blob_buf(key, b, 1, SSHKEY_SERIALIZE_DEFAULT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "b",
            "NULL"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_certify(k1, k2, NULL)",
            "0"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_certify",
          "args": [
            "k1",
            "k2",
            "NULL"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_certify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2667-2671",
          "snippet": "int\nsshkey_certify(struct sshkey *k, struct sshkey *ca, const char *alg)\n{\n\treturn sshkey_certify_custom(k, ca, alg, default_key_sign, NULL);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_certify(struct sshkey *k, struct sshkey *ca, const char *alg)\n{\n\treturn sshkey_certify_custom(k, ca, alg, default_key_sign, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_from_private(k2, &k1->cert->signature_key)",
            "0"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_from_private",
          "args": [
            "k2",
            "&k1->cert->signature_key"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_from_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1726-1868",
          "snippet": "int\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n#endif /* WITH_OPENSSL */\n\n\t*pkp = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDSA_get0_pqg(k->dsa, &dsa_p, &dsa_q, &dsa_g);\n\t\tDSA_get0_key(k->dsa, &dsa_pub_key, NULL);\n\t\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!DSA_set0_pqg(n->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL; /* transferred */\n\t\tif (!DSA_set0_key(n->dsa, dsa_pub_key_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tdsa_pub_key_dup = NULL; /* transferred */\n\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->ecdsa_nid = k->ecdsa_nid;\n\t\tn->ecdsa = EC_KEY_new_by_curve_name(k->ecdsa_nid);\n\t\tif (n->ecdsa == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (EC_KEY_set_public_key(n->ecdsa,\n\t\t    EC_KEY_get0_public_key(k->ecdsa)) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tRSA_get0_key(k->rsa, &rsa_n, &rsa_e, NULL);\n\t\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!RSA_set0_key(n->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n_dup = rsa_e_dup = NULL; /* transferred */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (k->ed25519_pk != NULL) {\n\t\t\tif ((n->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->ed25519_pk, k->ed25519_pk, ED25519_PK_SZ);\n\t\t}\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_xmss_init(n, k->xmss_name)) != 0)\n\t\t\tgoto out;\n\t\tif (k->xmss_pk != NULL) {\n\t\t\tsize_t pklen = sshkey_xmss_pklen(k);\n\t\t\tif (pklen == 0 || sshkey_xmss_pklen(n) != pklen) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((n->xmss_pk = malloc(pklen)) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(n->xmss_pk, k->xmss_pk, pklen);\n\t\t}\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\tr = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t/* success */\n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n#ifdef WITH_OPENSSL\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n#endif\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_opt",
          "args": [
            "k1->cert->extensions",
            "\"permit-agent-forwarding\"",
            "NULL"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "put_opt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/test_sshkey.c",
          "lines": "39-51",
          "snippet": "static void\nput_opt(struct sshbuf *b, const char *name, const char *value)\n{\n\tstruct sshbuf *sect;\n\n\tsect = sshbuf_new();\n\tASSERT_PTR_NE(sect, NULL);\n\tASSERT_INT_EQ(sshbuf_put_cstring(b, name), 0);\n\tif (value != NULL)\n\t\tASSERT_INT_EQ(sshbuf_put_cstring(sect, value), 0);\n\tASSERT_INT_EQ(sshbuf_put_stringb(b, sect), 0);\n\tsshbuf_free(sect);\n}",
          "includes": [
            "#include \"ssh2.h\"",
            "#include \"common.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/bn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh2.h\"\n#include \"common.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n# include <openssl/ec.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nput_opt(struct sshbuf *b, const char *name, const char *value)\n{\n\tstruct sshbuf *sect;\n\n\tsect = sshbuf_new();\n\tASSERT_PTR_NE(sect, NULL);\n\tASSERT_INT_EQ(sshbuf_put_cstring(b, name), 0);\n\tif (value != NULL)\n\t\tASSERT_INT_EQ(sshbuf_put_cstring(sect, value), 0);\n\tASSERT_INT_EQ(sshbuf_put_stringb(b, sect), 0);\n\tsshbuf_free(sect);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1->cert->extensions",
            "NULL"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1->cert->critical",
            "NULL"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1->cert->principals[3]",
            "NULL"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1->cert->principals[2]",
            "NULL"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1->cert->principals[1]",
            "NULL"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1->cert->principals[0]",
            "NULL"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"lucky\""
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1->cert->principals",
            "NULL"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "4",
            "sizeof(*k1->cert->principals)"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1->cert->key_id",
            "NULL"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1->cert",
            "NULL"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_to_certified(k1)",
            "0"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_to_certified",
          "args": [
            "k1"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_to_certified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2462-2494",
          "snippet": "int\nsshkey_to_certified(struct sshkey *k)\n{\n\tint newtype;\n\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\t\tnewtype = KEY_RSA_CERT;\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tnewtype = KEY_DSA_CERT;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\t\tnewtype = KEY_ECDSA_CERT;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tnewtype = KEY_ED25519_CERT;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tnewtype = KEY_XMSS_CERT;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif ((k->cert = cert_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tk->type = newtype;\n\treturn 0;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_to_certified(struct sshkey *k)\n{\n\tint newtype;\n\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\t\tnewtype = KEY_RSA_CERT;\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tnewtype = KEY_DSA_CERT;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\t\tnewtype = KEY_ECDSA_CERT;\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\t\tnewtype = KEY_ED25519_CERT;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tnewtype = KEY_XMSS_CERT;\n\t\tbreak;\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif ((k->cert = cert_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tk->type = newtype;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_load_public(test_data_file(\"ed25519_1.pub\"),\n\t    &k1, NULL)",
            "0"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"certify key\""
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(kf, k1)",
            "0"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_equal",
          "args": [
            "kf",
            "k1"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "704-714",
          "snippet": "int\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_generate(KEY_ED25519, 256, &k1)",
            "0"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_generate",
          "args": [
            "KEY_ED25519",
            "256",
            "&k1"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_generate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "1605-1654",
          "snippet": "int\nsshkey_generate(int type, u_int bits, struct sshkey **keyp)\n{\n\tstruct sshkey *k;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (keyp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*keyp = NULL;\n\tif ((k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tswitch (type) {\n\tcase KEY_ED25519:\n\t\tif ((k->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL ||\n\t\t    (k->ed25519_sk = malloc(ED25519_SK_SZ)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tbreak;\n\t\t}\n\t\tcrypto_sign_ed25519_keypair(k->ed25519_pk, k->ed25519_sk);\n\t\tret = 0;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tret = sshkey_xmss_generate_private_key(k, bits);\n\t\tbreak;\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\t\tret = dsa_generate_private_key(bits, &k->dsa);\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tret = ecdsa_generate_private_key(bits, &k->ecdsa_nid,\n\t\t    &k->ecdsa);\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\t\tret = rsa_generate_private_key(bits, &k->rsa);\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tdefault:\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif (ret == 0) {\n\t\tk->type = type;\n\t\t*keyp = k;\n\t} else\n\t\tsshkey_free(k);\n\treturn ret;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_generate(int type, u_int bits, struct sshkey **keyp)\n{\n\tstruct sshkey *k;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (keyp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*keyp = NULL;\n\tif ((k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tswitch (type) {\n\tcase KEY_ED25519:\n\t\tif ((k->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL ||\n\t\t    (k->ed25519_sk = malloc(ED25519_SK_SZ)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tbreak;\n\t\t}\n\t\tcrypto_sign_ed25519_keypair(k->ed25519_pk, k->ed25519_sk);\n\t\tret = 0;\n\t\tbreak;\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\t\tret = sshkey_xmss_generate_private_key(k, bits);\n\t\tbreak;\n#endif /* WITH_XMSS */\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\t\tret = dsa_generate_private_key(bits, &k->dsa);\n\t\tbreak;\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tret = ecdsa_generate_private_key(bits, &k->ecdsa_nid,\n\t\t    &k->ecdsa);\n\t\tbreak;\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA:\n\t\tret = rsa_generate_private_key(bits, &k->rsa);\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tdefault:\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif (ret == 0) {\n\t\tk->type = type;\n\t\t*keyp = k;\n\t} else\n\t\tsshkey_free(k);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(ke, k1)",
            "0"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_generate(KEY_ECDSA, 256, &k1)",
            "0"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(kd, k1)",
            "0"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_generate(KEY_DSA, 1024, &k1)",
            "0"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(kr, k1)",
            "0"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_generate(KEY_RSA, 1024, &k1)",
            "0"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"equal different keys\""
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(kd, kf)",
            "0"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(ke, kf)",
            "0"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(kr, ke)",
            "0"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(kd, ke)",
            "0"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(kd, kr)",
            "0"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"equal mismatched key types\""
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(kf, k1)",
            "1"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"equal KEY_ED25519/demoted KEY_ED25519\""
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_EQ",
          "args": [
            "k1->ed25519_sk",
            "NULL"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1->ed25519_pk",
            "NULL"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "k1->type",
            "KEY_ED25519"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "kf",
            "k1"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1",
            "NULL"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_from_private(kf, &k1)",
            "0"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"demote KEY_ED25519\""
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(ke, k1)",
            "1"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"equal KEY_ECDSA/demoted KEY_ECDSA\""
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_EQ",
          "args": [
            "EC_KEY_get0_private_key(k1->ecdsa)",
            "NULL"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_private_key",
          "args": [
            "k1->ecdsa"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "EC_KEY_get0_public_key(ke->ecdsa)",
            "NULL"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_public_key",
          "args": [
            "ke->ecdsa"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "k1->ecdsa_nid",
            "ke->ecdsa_nid"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1->ecdsa",
            "NULL"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "k1->type",
            "KEY_ECDSA"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "ke",
            "k1"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1",
            "NULL"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_from_private(ke, &k1)",
            "0"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"demote KEY_ECDSA\""
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(kd, k1)",
            "1"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"equal KEY_DSA/demoted KEY_DSA\""
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_EQ",
          "args": [
            "dsa_priv_key(k1)",
            "NULL"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsa_priv_key",
          "args": [
            "k1"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_priv_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/common.c",
          "lines": "153-162",
          "snippet": "const BIGNUM *\ndsa_priv_key(struct sshkey *k)\n{\n\tconst BIGNUM *priv_key = NULL;\n\n\tASSERT_PTR_NE(k, NULL);\n\tASSERT_PTR_NE(k->dsa, NULL);\n\tDSA_get0_key(k->dsa, NULL, &priv_key);\n\treturn priv_key;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/objects.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst BIGNUM *\ndsa_priv_key(struct sshkey *k)\n{\n\tconst BIGNUM *priv_key = NULL;\n\n\tASSERT_PTR_NE(k, NULL);\n\tASSERT_PTR_NE(k->dsa, NULL);\n\tDSA_get0_key(k->dsa, NULL, &priv_key);\n\treturn priv_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "dsa_g(k1)",
            "NULL"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsa_g",
          "args": [
            "k1"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "dsa_g",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/common.c",
          "lines": "131-140",
          "snippet": "const BIGNUM *\ndsa_g(struct sshkey *k)\n{\n\tconst BIGNUM *g = NULL;\n\n\tASSERT_PTR_NE(k, NULL);\n\tASSERT_PTR_NE(k->dsa, NULL);\n\tDSA_get0_pqg(k->dsa, NULL, NULL, &g);\n\treturn g;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/objects.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst BIGNUM *\ndsa_g(struct sshkey *k)\n{\n\tconst BIGNUM *g = NULL;\n\n\tASSERT_PTR_NE(k, NULL);\n\tASSERT_PTR_NE(k->dsa, NULL);\n\tDSA_get0_pqg(k->dsa, NULL, NULL, &g);\n\treturn g;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1->dsa",
            "NULL"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "k1->type",
            "KEY_DSA"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "kd",
            "k1"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1",
            "NULL"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_from_private(kd, &k1)",
            "0"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"demote KEY_DSA\""
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_equal(kr, k1)",
            "1"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"equal KEY_RSA/demoted KEY_RSA\""
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_EQ",
          "args": [
            "rsa_p(k1)",
            "NULL"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsa_p",
          "args": [
            "k1"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "rsa_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/common.c",
          "lines": "109-118",
          "snippet": "const BIGNUM *\nrsa_p(struct sshkey *k)\n{\n\tconst BIGNUM *p = NULL;\n\n\tASSERT_PTR_NE(k, NULL);\n\tASSERT_PTR_NE(k->rsa, NULL);\n\tRSA_get0_factors(k->rsa, &p, NULL);\n\treturn p;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/objects.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst BIGNUM *\nrsa_p(struct sshkey *k)\n{\n\tconst BIGNUM *p = NULL;\n\n\tASSERT_PTR_NE(k, NULL);\n\tASSERT_PTR_NE(k->rsa, NULL);\n\tRSA_get0_factors(k->rsa, &p, NULL);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "rsa_e(k1)",
            "NULL"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsa_e",
          "args": [
            "k1"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "rsa_e",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/common.c",
          "lines": "98-107",
          "snippet": "const BIGNUM *\nrsa_e(struct sshkey *k)\n{\n\tconst BIGNUM *e = NULL;\n\n\tASSERT_PTR_NE(k, NULL);\n\tASSERT_PTR_NE(k->rsa, NULL);\n\tRSA_get0_key(k->rsa, NULL, &e, NULL);\n\treturn e;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/objects.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst BIGNUM *\nrsa_e(struct sshkey *k)\n{\n\tconst BIGNUM *e = NULL;\n\n\tASSERT_PTR_NE(k, NULL);\n\tASSERT_PTR_NE(k->rsa, NULL);\n\tRSA_get0_key(k->rsa, NULL, &e, NULL);\n\treturn e;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "rsa_n(k1)",
            "NULL"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsa_n",
          "args": [
            "k1"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "rsa_n",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/common.c",
          "lines": "87-96",
          "snippet": "const BIGNUM *\nrsa_n(struct sshkey *k)\n{\n\tconst BIGNUM *n = NULL;\n\n\tASSERT_PTR_NE(k, NULL);\n\tASSERT_PTR_NE(k->rsa, NULL);\n\tRSA_get0_key(k->rsa, &n, NULL, NULL);\n\treturn n;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/objects.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst BIGNUM *\nrsa_n(struct sshkey *k)\n{\n\tconst BIGNUM *n = NULL;\n\n\tASSERT_PTR_NE(k, NULL);\n\tASSERT_PTR_NE(k->rsa, NULL);\n\tRSA_get0_key(k->rsa, &n, NULL, NULL);\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1->rsa",
            "NULL"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "k1->type",
            "KEY_RSA"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "kr",
            "k1"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1",
            "NULL"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_from_private(kr, &k1)",
            "0"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"demote KEY_RSA\""
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "kf->ed25519_sk",
            "NULL"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "kf->ed25519_pk",
            "NULL"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "kf->type",
            "KEY_ED25519"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "kf",
            "NULL"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_generate(KEY_ED25519, 256, &kf)",
            "0"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"generate KEY_ED25519\""
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "EC_KEY_get0_private_key(ke->ecdsa)",
            "NULL"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_private_key",
          "args": [
            "ke->ecdsa"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "EC_KEY_get0_public_key(ke->ecdsa)",
            "NULL"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_public_key",
          "args": [
            "ke->ecdsa"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "ke->ecdsa",
            "NULL"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "ke",
            "NULL"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_generate(KEY_ECDSA, 256, &ke)",
            "0"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"generate KEY_ECDSA\""
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "dsa_priv_key(kd)",
            "NULL"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "dsa_g(kd)",
            "NULL"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "kd->dsa",
            "NULL"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "kd",
            "NULL"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_generate(KEY_DSA, 1024, &kd)",
            "0"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"generate KEY_DSA\""
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "BN_num_bits(rsa_n(kr))",
            "1024"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_num_bits",
          "args": [
            "rsa_n(kr)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "rsa_p(kr)",
            "NULL"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "rsa_e(kr)",
            "NULL"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "rsa_n(kr)",
            "NULL"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "kr->rsa",
            "NULL"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "kr",
            "NULL"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_generate(KEY_RSA, 1024, &kr)",
            "0"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_generate(KEY_RSA, 767, &kr)",
            "SSH_ERR_KEY_LENGTH"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"generate KEY_RSA\""
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_EQ",
          "args": [
            "k1",
            "NULL"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_generate(KEY_ECDSA, 42, &k1)",
            "SSH_ERR_KEY_LENGTH"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"generate KEY_ECDSA wrong bits\""
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_EQ",
          "args": [
            "k1",
            "NULL"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_generate(KEY_DSA, 2048, &k1)",
            "SSH_ERR_KEY_LENGTH"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"generate KEY_DSA wrong bits\""
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_EQ",
          "args": [
            "k1",
            "NULL"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_generate(KEY_RSA, 1 << 20, &k1)",
            "SSH_ERR_KEY_LENGTH"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"generate KEY_RSA too large modulus\""
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_EQ",
          "args": [
            "k1",
            "NULL"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_generate(KEY_RSA, 128, &k1)",
            "SSH_ERR_KEY_LENGTH"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"generate KEY_RSA too small modulus\""
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_EQ",
          "args": [
            "k1->ed25519_pk",
            "NULL"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_EQ",
          "args": [
            "k1->ed25519_sk",
            "NULL"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1",
            "NULL"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_new",
          "args": [
            "KEY_ED25519"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "485-550",
          "snippet": "struct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n#ifdef WITH_OPENSSL\n\tRSA *rsa;\n\tDSA *dsa;\n#endif /* WITH_OPENSSL */\n\n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa = NULL;\n\tk->ecdsa_nid = -1;\n\tk->dsa = NULL;\n\tk->rsa = NULL;\n\tk->cert = NULL;\n\tk->ed25519_sk = NULL;\n\tk->ed25519_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_pk = NULL;\n\tswitch (k->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_RSA_CERT:\n\t\tif ((rsa = RSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->rsa = rsa;\n\t\tbreak;\n\tcase KEY_DSA:\n\tcase KEY_DSA_CERT:\n\t\tif ((dsa = DSA_new()) == NULL) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t\tk->dsa = dsa;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\t\t/* Cannot do anything until we know the group */\n\t\tbreak;\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\t/* no need to prealloc */\n\t\tbreak;\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tfree(k);\n\t\treturn NULL;\n\t}\n\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"new/free KEY_ED25519\""
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_EQ",
          "args": [
            "k1->ecdsa",
            "NULL"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1",
            "NULL"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"new/free KEY_ECDSA\""
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1->dsa",
            "NULL"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1",
            "NULL"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"new/free KEY_DSA\""
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1->rsa",
            "NULL"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1",
            "NULL"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"new/free KEY_RSA\""
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "k1",
            "NULL"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"new/free KEY_UNSPEC\""
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_DONE",
          "args": [],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_EQ",
          "args": [
            "k1",
            "NULL"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_START",
          "args": [
            "\"new invalid\""
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh2.h\"\n#include \"common.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n# include <openssl/ec.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid sshkey_tests(void);\n\nvoid\nsshkey_tests(void)\n{\n\tstruct sshkey *k1, *k2, *k3, *k4, *kr, *kd, *kf;\n#ifdef OPENSSL_HAS_ECC\n\tstruct sshkey *ke;\n#endif\n\tstruct sshbuf *b;\n\n\tTEST_START(\"new invalid\");\n\tk1 = sshkey_new(-42);\n\tASSERT_PTR_EQ(k1, NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"new/free KEY_UNSPEC\");\n\tk1 = sshkey_new(KEY_UNSPEC);\n\tASSERT_PTR_NE(k1, NULL);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"new/free KEY_RSA\");\n\tk1 = sshkey_new(KEY_RSA);\n\tASSERT_PTR_NE(k1, NULL);\n\tASSERT_PTR_NE(k1->rsa, NULL);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"new/free KEY_DSA\");\n\tk1 = sshkey_new(KEY_DSA);\n\tASSERT_PTR_NE(k1, NULL);\n\tASSERT_PTR_NE(k1->dsa, NULL);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n#ifdef OPENSSL_HAS_ECC\n\tTEST_START(\"new/free KEY_ECDSA\");\n\tk1 = sshkey_new(KEY_ECDSA);\n\tASSERT_PTR_NE(k1, NULL);\n\tASSERT_PTR_EQ(k1->ecdsa, NULL);  /* Can't allocate without NID */\n\tsshkey_free(k1);\n\tTEST_DONE();\n#endif\n\n\tTEST_START(\"new/free KEY_ED25519\");\n\tk1 = sshkey_new(KEY_ED25519);\n\tASSERT_PTR_NE(k1, NULL);\n\t/* These should be blank until key loaded or generated */\n\tASSERT_PTR_EQ(k1->ed25519_sk, NULL);\n\tASSERT_PTR_EQ(k1->ed25519_pk, NULL);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"generate KEY_RSA too small modulus\");\n\tASSERT_INT_EQ(sshkey_generate(KEY_RSA, 128, &k1),\n\t    SSH_ERR_KEY_LENGTH);\n\tASSERT_PTR_EQ(k1, NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"generate KEY_RSA too large modulus\");\n\tASSERT_INT_EQ(sshkey_generate(KEY_RSA, 1 << 20, &k1),\n\t    SSH_ERR_KEY_LENGTH);\n\tASSERT_PTR_EQ(k1, NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"generate KEY_DSA wrong bits\");\n\tASSERT_INT_EQ(sshkey_generate(KEY_DSA, 2048, &k1),\n\t    SSH_ERR_KEY_LENGTH);\n\tASSERT_PTR_EQ(k1, NULL);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n#ifdef OPENSSL_HAS_ECC\n\tTEST_START(\"generate KEY_ECDSA wrong bits\");\n\tASSERT_INT_EQ(sshkey_generate(KEY_ECDSA, 42, &k1),\n\t    SSH_ERR_KEY_LENGTH);\n\tASSERT_PTR_EQ(k1, NULL);\n\tsshkey_free(k1);\n\tTEST_DONE();\n#endif\n\n\tTEST_START(\"generate KEY_RSA\");\n\tASSERT_INT_EQ(sshkey_generate(KEY_RSA, 767, &kr),\n\t    SSH_ERR_KEY_LENGTH);\n\tASSERT_INT_EQ(sshkey_generate(KEY_RSA, 1024, &kr), 0);\n\tASSERT_PTR_NE(kr, NULL);\n\tASSERT_PTR_NE(kr->rsa, NULL);\n\tASSERT_PTR_NE(rsa_n(kr), NULL);\n\tASSERT_PTR_NE(rsa_e(kr), NULL);\n\tASSERT_PTR_NE(rsa_p(kr), NULL);\n\tASSERT_INT_EQ(BN_num_bits(rsa_n(kr)), 1024);\n\tTEST_DONE();\n\n\tTEST_START(\"generate KEY_DSA\");\n\tASSERT_INT_EQ(sshkey_generate(KEY_DSA, 1024, &kd), 0);\n\tASSERT_PTR_NE(kd, NULL);\n\tASSERT_PTR_NE(kd->dsa, NULL);\n\tASSERT_PTR_NE(dsa_g(kd), NULL);\n\tASSERT_PTR_NE(dsa_priv_key(kd), NULL);\n\tTEST_DONE();\n\n#ifdef OPENSSL_HAS_ECC\n\tTEST_START(\"generate KEY_ECDSA\");\n\tASSERT_INT_EQ(sshkey_generate(KEY_ECDSA, 256, &ke), 0);\n\tASSERT_PTR_NE(ke, NULL);\n\tASSERT_PTR_NE(ke->ecdsa, NULL);\n\tASSERT_PTR_NE(EC_KEY_get0_public_key(ke->ecdsa), NULL);\n\tASSERT_PTR_NE(EC_KEY_get0_private_key(ke->ecdsa), NULL);\n\tTEST_DONE();\n#endif\n\n\tTEST_START(\"generate KEY_ED25519\");\n\tASSERT_INT_EQ(sshkey_generate(KEY_ED25519, 256, &kf), 0);\n\tASSERT_PTR_NE(kf, NULL);\n\tASSERT_INT_EQ(kf->type, KEY_ED25519);\n\tASSERT_PTR_NE(kf->ed25519_pk, NULL);\n\tASSERT_PTR_NE(kf->ed25519_sk, NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"demote KEY_RSA\");\n\tASSERT_INT_EQ(sshkey_from_private(kr, &k1), 0);\n\tASSERT_PTR_NE(k1, NULL);\n\tASSERT_PTR_NE(kr, k1);\n\tASSERT_INT_EQ(k1->type, KEY_RSA);\n\tASSERT_PTR_NE(k1->rsa, NULL);\n\tASSERT_PTR_NE(rsa_n(k1), NULL);\n\tASSERT_PTR_NE(rsa_e(k1), NULL);\n\tASSERT_PTR_EQ(rsa_p(k1), NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"equal KEY_RSA/demoted KEY_RSA\");\n\tASSERT_INT_EQ(sshkey_equal(kr, k1), 1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"demote KEY_DSA\");\n\tASSERT_INT_EQ(sshkey_from_private(kd, &k1), 0);\n\tASSERT_PTR_NE(k1, NULL);\n\tASSERT_PTR_NE(kd, k1);\n\tASSERT_INT_EQ(k1->type, KEY_DSA);\n\tASSERT_PTR_NE(k1->dsa, NULL);\n\tASSERT_PTR_NE(dsa_g(k1), NULL);\n\tASSERT_PTR_EQ(dsa_priv_key(k1), NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"equal KEY_DSA/demoted KEY_DSA\");\n\tASSERT_INT_EQ(sshkey_equal(kd, k1), 1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n#ifdef OPENSSL_HAS_ECC\n\tTEST_START(\"demote KEY_ECDSA\");\n\tASSERT_INT_EQ(sshkey_from_private(ke, &k1), 0);\n\tASSERT_PTR_NE(k1, NULL);\n\tASSERT_PTR_NE(ke, k1);\n\tASSERT_INT_EQ(k1->type, KEY_ECDSA);\n\tASSERT_PTR_NE(k1->ecdsa, NULL);\n\tASSERT_INT_EQ(k1->ecdsa_nid, ke->ecdsa_nid);\n\tASSERT_PTR_NE(EC_KEY_get0_public_key(ke->ecdsa), NULL);\n\tASSERT_PTR_EQ(EC_KEY_get0_private_key(k1->ecdsa), NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"equal KEY_ECDSA/demoted KEY_ECDSA\");\n\tASSERT_INT_EQ(sshkey_equal(ke, k1), 1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n#endif\n\n\tTEST_START(\"demote KEY_ED25519\");\n\tASSERT_INT_EQ(sshkey_from_private(kf, &k1), 0);\n\tASSERT_PTR_NE(k1, NULL);\n\tASSERT_PTR_NE(kf, k1);\n\tASSERT_INT_EQ(k1->type, KEY_ED25519);\n\tASSERT_PTR_NE(k1->ed25519_pk, NULL);\n\tASSERT_PTR_EQ(k1->ed25519_sk, NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"equal KEY_ED25519/demoted KEY_ED25519\");\n\tASSERT_INT_EQ(sshkey_equal(kf, k1), 1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"equal mismatched key types\");\n\tASSERT_INT_EQ(sshkey_equal(kd, kr), 0);\n#ifdef OPENSSL_HAS_ECC\n\tASSERT_INT_EQ(sshkey_equal(kd, ke), 0);\n\tASSERT_INT_EQ(sshkey_equal(kr, ke), 0);\n\tASSERT_INT_EQ(sshkey_equal(ke, kf), 0);\n#endif\n\tASSERT_INT_EQ(sshkey_equal(kd, kf), 0);\n\tTEST_DONE();\n\n\tTEST_START(\"equal different keys\");\n\tASSERT_INT_EQ(sshkey_generate(KEY_RSA, 1024, &k1), 0);\n\tASSERT_INT_EQ(sshkey_equal(kr, k1), 0);\n\tsshkey_free(k1);\n\tASSERT_INT_EQ(sshkey_generate(KEY_DSA, 1024, &k1), 0);\n\tASSERT_INT_EQ(sshkey_equal(kd, k1), 0);\n\tsshkey_free(k1);\n#ifdef OPENSSL_HAS_ECC\n\tASSERT_INT_EQ(sshkey_generate(KEY_ECDSA, 256, &k1), 0);\n\tASSERT_INT_EQ(sshkey_equal(ke, k1), 0);\n\tsshkey_free(k1);\n#endif\n\tASSERT_INT_EQ(sshkey_generate(KEY_ED25519, 256, &k1), 0);\n\tASSERT_INT_EQ(sshkey_equal(kf, k1), 0);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tsshkey_free(kr);\n\tsshkey_free(kd);\n#ifdef OPENSSL_HAS_ECC\n\tsshkey_free(ke);\n#endif\n\tsshkey_free(kf);\n\n\tTEST_START(\"certify key\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"ed25519_1.pub\"),\n\t    &k1, NULL), 0);\n\tk2 = get_private(\"ed25519_2\");\n\tASSERT_INT_EQ(sshkey_to_certified(k1), 0);\n\tASSERT_PTR_NE(k1->cert, NULL);\n\tk1->cert->type = SSH2_CERT_TYPE_USER;\n\tk1->cert->serial = 1234;\n\tk1->cert->key_id = strdup(\"estragon\");\n\tASSERT_PTR_NE(k1->cert->key_id, NULL);\n\tk1->cert->principals = calloc(4, sizeof(*k1->cert->principals));\n\tASSERT_PTR_NE(k1->cert->principals, NULL);\n\tk1->cert->principals[0] = strdup(\"estragon\");\n\tk1->cert->principals[1] = strdup(\"vladimir\");\n\tk1->cert->principals[2] = strdup(\"pozzo\");\n\tk1->cert->principals[3] = strdup(\"lucky\");\n\tASSERT_PTR_NE(k1->cert->principals[0], NULL);\n\tASSERT_PTR_NE(k1->cert->principals[1], NULL);\n\tASSERT_PTR_NE(k1->cert->principals[2], NULL);\n\tASSERT_PTR_NE(k1->cert->principals[3], NULL);\n\tk1->cert->nprincipals = 4;\n\tk1->cert->valid_after = 0;\n\tk1->cert->valid_before = (u_int64_t)-1;\n\tsshbuf_free(k1->cert->critical);\n\tk1->cert->critical = sshbuf_new();\n\tASSERT_PTR_NE(k1->cert->critical, NULL);\n\tsshbuf_free(k1->cert->extensions);\n\tk1->cert->extensions = sshbuf_new();\n\tASSERT_PTR_NE(k1->cert->extensions, NULL);\n\tput_opt(k1->cert->critical, \"force-command\", \"/usr/bin/true\");\n\tput_opt(k1->cert->critical, \"source-address\", \"127.0.0.1\");\n\tput_opt(k1->cert->extensions, \"permit-X11-forwarding\", NULL);\n\tput_opt(k1->cert->extensions, \"permit-agent-forwarding\", NULL);\n\tASSERT_INT_EQ(sshkey_from_private(k2, &k1->cert->signature_key), 0);\n\tASSERT_INT_EQ(sshkey_certify(k1, k2, NULL), 0);\n\tb = sshbuf_new();\n\tASSERT_PTR_NE(b, NULL);\n\tASSERT_INT_EQ(sshkey_putb(k1, b), 0);\n\tASSERT_INT_EQ(sshkey_from_blob(sshbuf_ptr(b), sshbuf_len(b), &k3), 0);\n\n\tsshkey_free(k1);\n\tsshkey_free(k2);\n\tsshkey_free(k3);\n\tsshbuf_reset(b);\n\tTEST_DONE();\n\n\tTEST_START(\"sign and verify RSA\");\n\tk1 = get_private(\"rsa_1\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"rsa_2.pub\"), &k2,\n\t    NULL), 0);\n\tsignature_tests(k1, k2, \"ssh-rsa\");\n\tsshkey_free(k1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"sign and verify RSA-SHA256\");\n\tk1 = get_private(\"rsa_1\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"rsa_2.pub\"), &k2,\n\t    NULL), 0);\n\tsignature_tests(k1, k2, \"rsa-sha2-256\");\n\tsshkey_free(k1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"sign and verify RSA-SHA512\");\n\tk1 = get_private(\"rsa_1\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"rsa_2.pub\"), &k2,\n\t    NULL), 0);\n\tsignature_tests(k1, k2, \"rsa-sha2-512\");\n\tsshkey_free(k1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"sign and verify DSA\");\n\tk1 = get_private(\"dsa_1\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"dsa_2.pub\"), &k2,\n\t    NULL), 0);\n\tsignature_tests(k1, k2, NULL);\n\tsshkey_free(k1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n#ifdef OPENSSL_HAS_ECC\n\tTEST_START(\"sign and verify ECDSA\");\n\tk1 = get_private(\"ecdsa_1\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"ecdsa_2.pub\"), &k2,\n\t    NULL), 0);\n\tsignature_tests(k1, k2, NULL);\n\tsshkey_free(k1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n#endif\n\n\tTEST_START(\"sign and verify ED25519\");\n\tk1 = get_private(\"ed25519_1\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"ed25519_2.pub\"), &k2,\n\t    NULL), 0);\n\tsignature_tests(k1, k2, NULL);\n\tsshkey_free(k1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"nested certificate\");\n\tASSERT_INT_EQ(sshkey_load_cert(test_data_file(\"rsa_1\"), &k1), 0);\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"rsa_1.pub\"), &k2,\n\t    NULL), 0);\n\tk3 = get_private(\"rsa_1\");\n\tbuild_cert(b, k2, \"ssh-rsa-cert-v01@openssh.com\", k3, k1, NULL);\n\tASSERT_INT_EQ(sshkey_from_blob(sshbuf_ptr(b), sshbuf_len(b), &k4),\n\t    SSH_ERR_KEY_CERT_INVALID_SIGN_KEY);\n\tASSERT_PTR_EQ(k4, NULL);\n\tsshkey_free(k1);\n\tsshkey_free(k2);\n\tsshkey_free(k3);\n\tsshbuf_free(b);\n\tTEST_DONE();\n\n}"
  },
  {
    "function_name": "get_private",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/test_sshkey.c",
    "lines": "164-174",
    "snippet": "static struct sshkey *\nget_private(const char *n)\n{\n\tstruct sshbuf *b;\n\tstruct sshkey *ret;\n\n\tb = load_file(n);\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(b, \"\", &ret, NULL), 0);\n\tsshbuf_free(b);\n\treturn ret;\n}",
    "includes": [
      "#include \"ssh2.h\"",
      "#include \"common.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"../test_helper/test_helper.h\"",
      "# include <openssl/ec.h>",
      "#include <openssl/dsa.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/bn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_parse_private_fileblob(b, \"\", &ret, NULL)",
            "0"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_parse_private_fileblob",
          "args": [
            "b",
            "\"\"",
            "&ret",
            "NULL"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_parse_private_fileblob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "4067-4078",
          "snippet": "int\nsshkey_parse_private_fileblob(struct sshbuf *buffer, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\treturn sshkey_parse_private_fileblob_type(buffer, KEY_UNSPEC,\n\t    passphrase, keyp, commentp);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_parse_private_fileblob(struct sshbuf *buffer, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\treturn sshkey_parse_private_fileblob_type(buffer, KEY_UNSPEC,\n\t    passphrase, keyp, commentp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_file",
          "args": [
            "n"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "load_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/common.c",
          "lines": "41-52",
          "snippet": "struct sshbuf *\nload_file(const char *name)\n{\n\tint fd;\n\tstruct sshbuf *ret;\n\n\tASSERT_PTR_NE(ret = sshbuf_new(), NULL);\n\tASSERT_INT_NE(fd = open(test_data_file(name), O_RDONLY), -1);\n\tASSERT_INT_EQ(sshkey_load_file(fd, ret), 0);\n\tclose(fd);\n\treturn ret;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"sshbuf.h\"",
            "#include \"sshkey.h\"",
            "#include \"authfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/objects.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/bn.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n# include <openssl/ec.h>\n#include <openssl/objects.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nload_file(const char *name)\n{\n\tint fd;\n\tstruct sshbuf *ret;\n\n\tASSERT_PTR_NE(ret = sshbuf_new(), NULL);\n\tASSERT_INT_NE(fd = open(test_data_file(name), O_RDONLY), -1);\n\tASSERT_INT_EQ(sshkey_load_file(fd, ret), 0);\n\tclose(fd);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh2.h\"\n#include \"common.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n# include <openssl/ec.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshkey *\nget_private(const char *n)\n{\n\tstruct sshbuf *b;\n\tstruct sshkey *ret;\n\n\tb = load_file(n);\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(b, \"\", &ret, NULL), 0);\n\tsshbuf_free(b);\n\treturn ret;\n}"
  },
  {
    "function_name": "signature_tests",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/test_sshkey.c",
    "lines": "147-162",
    "snippet": "static void\nsignature_tests(struct sshkey *k, struct sshkey *bad, const char *sig_alg)\n{\n\tu_char i, buf[2049];\n\tsize_t lens[] = {\n\t\t1, 2, 7, 8, 9, 15, 16, 17, 31, 32, 33, 127, 128, 129,\n\t\t255, 256, 257, 1023, 1024, 1025, 2047, 2048, 2049\n\t};\n\n\tfor (i = 0; i < (sizeof(lens)/sizeof(lens[0])); i++) {\n\t\ttest_subtest_info(\"%s key, banana length %zu\",\n\t\t    sshkey_type(k), lens[i]);\n\t\tbanana(buf, lens[i]);\n\t\tsignature_test(k, bad, sig_alg, buf, lens[i]);\n\t}\n}",
    "includes": [
      "#include \"ssh2.h\"",
      "#include \"common.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"../test_helper/test_helper.h\"",
      "# include <openssl/ec.h>",
      "#include <openssl/dsa.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/bn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signature_test",
          "args": [
            "k",
            "bad",
            "sig_alg",
            "buf",
            "lens[i]"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "signature_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/test_sshkey.c",
          "lines": "114-130",
          "snippet": "static void\nsignature_test(struct sshkey *k, struct sshkey *bad, const char *sig_alg,\n    const u_char *d, size_t l)\n{\n\tsize_t len;\n\tu_char *sig;\n\n\tASSERT_INT_EQ(sshkey_sign(k, &sig, &len, d, l, sig_alg, 0), 0);\n\tASSERT_SIZE_T_GT(len, 8);\n\tASSERT_PTR_NE(sig, NULL);\n\tASSERT_INT_EQ(sshkey_verify(k, sig, len, d, l, NULL, 0), 0);\n\tASSERT_INT_NE(sshkey_verify(bad, sig, len, d, l, NULL, 0), 0);\n\t/* Fuzz test is more comprehensive, this is just a smoke test */\n\tsig[len - 5] ^= 0x10;\n\tASSERT_INT_NE(sshkey_verify(k, sig, len, d, l, NULL, 0), 0);\n\tfree(sig);\n}",
          "includes": [
            "#include \"ssh2.h\"",
            "#include \"common.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/bn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh2.h\"\n#include \"common.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n# include <openssl/ec.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsignature_test(struct sshkey *k, struct sshkey *bad, const char *sig_alg,\n    const u_char *d, size_t l)\n{\n\tsize_t len;\n\tu_char *sig;\n\n\tASSERT_INT_EQ(sshkey_sign(k, &sig, &len, d, l, sig_alg, 0), 0);\n\tASSERT_SIZE_T_GT(len, 8);\n\tASSERT_PTR_NE(sig, NULL);\n\tASSERT_INT_EQ(sshkey_verify(k, sig, len, d, l, NULL, 0), 0);\n\tASSERT_INT_NE(sshkey_verify(bad, sig, len, d, l, NULL, 0), 0);\n\t/* Fuzz test is more comprehensive, this is just a smoke test */\n\tsig[len - 5] ^= 0x10;\n\tASSERT_INT_NE(sshkey_verify(k, sig, len, d, l, NULL, 0), 0);\n\tfree(sig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "banana",
          "args": [
            "buf",
            "lens[i]"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "banana",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/test_sshkey.c",
          "lines": "132-145",
          "snippet": "static void\nbanana(u_char *s, size_t l)\n{\n\tsize_t o;\n\tconst u_char the_banana[] = { 'b', 'a', 'n', 'a', 'n', 'a' };\n\n\tfor (o = 0; o < l; o += sizeof(the_banana)) {\n\t\tif (l - o < sizeof(the_banana)) {\n\t\t\tmemcpy(s + o, \"nanananana\", l - o);\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(s + o, banana, sizeof(the_banana));\n\t}\n}",
          "includes": [
            "#include \"ssh2.h\"",
            "#include \"common.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/bn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh2.h\"\n#include \"common.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n# include <openssl/ec.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nbanana(u_char *s, size_t l)\n{\n\tsize_t o;\n\tconst u_char the_banana[] = { 'b', 'a', 'n', 'a', 'n', 'a' };\n\n\tfor (o = 0; o < l; o += sizeof(the_banana)) {\n\t\tif (l - o < sizeof(the_banana)) {\n\t\t\tmemcpy(s + o, \"nanananana\", l - o);\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(s + o, banana, sizeof(the_banana));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_subtest_info",
          "args": [
            "\"%s key, banana length %zu\"",
            "sshkey_type(k)",
            "lens[i]"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "test_subtest_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/test_helper/test_helper.c",
          "lines": "252-260",
          "snippet": "void\ntest_subtest_info(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvsnprintf(subtest_info, sizeof(subtest_info), fmt, ap);\n\tva_end(ap);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include \"test_helper.h\"",
            "# include <vis.h>",
            "#include <openssl/bn.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <assert.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "# include <stdint.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char subtest_info[512];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include \"test_helper.h\"\n# include <vis.h>\n#include <openssl/bn.h>\n#include <signal.h>\n#include <unistd.h>\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n# include <stdint.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char subtest_info[512];\n\nvoid\ntest_subtest_info(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvsnprintf(subtest_info, sizeof(subtest_info), fmt, ap);\n\tva_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type",
          "args": [
            "k"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh2.h\"\n#include \"common.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n# include <openssl/ec.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsignature_tests(struct sshkey *k, struct sshkey *bad, const char *sig_alg)\n{\n\tu_char i, buf[2049];\n\tsize_t lens[] = {\n\t\t1, 2, 7, 8, 9, 15, 16, 17, 31, 32, 33, 127, 128, 129,\n\t\t255, 256, 257, 1023, 1024, 1025, 2047, 2048, 2049\n\t};\n\n\tfor (i = 0; i < (sizeof(lens)/sizeof(lens[0])); i++) {\n\t\ttest_subtest_info(\"%s key, banana length %zu\",\n\t\t    sshkey_type(k), lens[i]);\n\t\tbanana(buf, lens[i]);\n\t\tsignature_test(k, bad, sig_alg, buf, lens[i]);\n\t}\n}"
  },
  {
    "function_name": "banana",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/test_sshkey.c",
    "lines": "132-145",
    "snippet": "static void\nbanana(u_char *s, size_t l)\n{\n\tsize_t o;\n\tconst u_char the_banana[] = { 'b', 'a', 'n', 'a', 'n', 'a' };\n\n\tfor (o = 0; o < l; o += sizeof(the_banana)) {\n\t\tif (l - o < sizeof(the_banana)) {\n\t\t\tmemcpy(s + o, \"nanananana\", l - o);\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(s + o, banana, sizeof(the_banana));\n\t}\n}",
    "includes": [
      "#include \"ssh2.h\"",
      "#include \"common.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"../test_helper/test_helper.h\"",
      "# include <openssl/ec.h>",
      "#include <openssl/dsa.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/bn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "s + o",
            "banana",
            "sizeof(the_banana)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "s + o",
            "\"nanananana\"",
            "l - o"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh2.h\"\n#include \"common.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n# include <openssl/ec.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nbanana(u_char *s, size_t l)\n{\n\tsize_t o;\n\tconst u_char the_banana[] = { 'b', 'a', 'n', 'a', 'n', 'a' };\n\n\tfor (o = 0; o < l; o += sizeof(the_banana)) {\n\t\tif (l - o < sizeof(the_banana)) {\n\t\t\tmemcpy(s + o, \"nanananana\", l - o);\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(s + o, banana, sizeof(the_banana));\n\t}\n}"
  },
  {
    "function_name": "signature_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/test_sshkey.c",
    "lines": "114-130",
    "snippet": "static void\nsignature_test(struct sshkey *k, struct sshkey *bad, const char *sig_alg,\n    const u_char *d, size_t l)\n{\n\tsize_t len;\n\tu_char *sig;\n\n\tASSERT_INT_EQ(sshkey_sign(k, &sig, &len, d, l, sig_alg, 0), 0);\n\tASSERT_SIZE_T_GT(len, 8);\n\tASSERT_PTR_NE(sig, NULL);\n\tASSERT_INT_EQ(sshkey_verify(k, sig, len, d, l, NULL, 0), 0);\n\tASSERT_INT_NE(sshkey_verify(bad, sig, len, d, l, NULL, 0), 0);\n\t/* Fuzz test is more comprehensive, this is just a smoke test */\n\tsig[len - 5] ^= 0x10;\n\tASSERT_INT_NE(sshkey_verify(k, sig, len, d, l, NULL, 0), 0);\n\tfree(sig);\n}",
    "includes": [
      "#include \"ssh2.h\"",
      "#include \"common.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"../test_helper/test_helper.h\"",
      "# include <openssl/ec.h>",
      "#include <openssl/dsa.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/bn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sig"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_NE",
          "args": [
            "sshkey_verify(k, sig, len, d, l, NULL, 0)",
            "0"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_verify",
          "args": [
            "k",
            "sig",
            "len",
            "d",
            "l",
            "NULL",
            "0"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2427-2459",
          "snippet": "int\nsshkey_verify(const struct sshkey *key,\n    const u_char *sig, size_t siglen,\n    const u_char *data, size_t dlen, const char *alg, u_int compat)\n{\n\tif (siglen == 0 || dlen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_verify(key, sig, siglen, data, dlen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_verify(key, sig, siglen, data, dlen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_verify(key, sig, siglen, data, dlen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_verify(key, sig, siglen, data, dlen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_verify(key, sig, siglen, data, dlen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_verify(const struct sshkey *key,\n    const u_char *sig, size_t siglen,\n    const u_char *data, size_t dlen, const char *alg, u_int compat)\n{\n\tif (siglen == 0 || dlen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_verify(key, sig, siglen, data, dlen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_verify(key, sig, siglen, data, dlen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_verify(key, sig, siglen, data, dlen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_verify(key, sig, siglen, data, dlen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_verify(key, sig, siglen, data, dlen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_NE",
          "args": [
            "sshkey_verify(bad, sig, len, d, l, NULL, 0)",
            "0"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_verify(k, sig, len, d, l, NULL, 0)",
            "0"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "sig",
            "NULL"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_SIZE_T_GT",
          "args": [
            "len",
            "8"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_sign(k, &sig, &len, d, l, sig_alg, 0)",
            "0"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_sign",
          "args": [
            "k",
            "&sig",
            "&len",
            "d",
            "l",
            "sig_alg",
            "0"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2385-2421",
          "snippet": "int\nsshkey_sign(const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_sign(key, sigp, lenp, data, datalen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_sign(key, sigp, lenp, data, datalen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_sign(key, sigp, lenp, data, datalen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_sign(key, sigp, lenp, data, datalen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_sign(key, sigp, lenp, data, datalen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_sign(const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_sign(key, sigp, lenp, data, datalen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_sign(key, sigp, lenp, data, datalen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_sign(key, sigp, lenp, data, datalen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_sign(key, sigp, lenp, data, datalen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_sign(key, sigp, lenp, data, datalen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh2.h\"\n#include \"common.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n# include <openssl/ec.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nsignature_test(struct sshkey *k, struct sshkey *bad, const char *sig_alg,\n    const u_char *d, size_t l)\n{\n\tsize_t len;\n\tu_char *sig;\n\n\tASSERT_INT_EQ(sshkey_sign(k, &sig, &len, d, l, sig_alg, 0), 0);\n\tASSERT_SIZE_T_GT(len, 8);\n\tASSERT_PTR_NE(sig, NULL);\n\tASSERT_INT_EQ(sshkey_verify(k, sig, len, d, l, NULL, 0), 0);\n\tASSERT_INT_NE(sshkey_verify(bad, sig, len, d, l, NULL, 0), 0);\n\t/* Fuzz test is more comprehensive, this is just a smoke test */\n\tsig[len - 5] ^= 0x10;\n\tASSERT_INT_NE(sshkey_verify(k, sig, len, d, l, NULL, 0), 0);\n\tfree(sig);\n}"
  },
  {
    "function_name": "build_cert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/test_sshkey.c",
    "lines": "53-112",
    "snippet": "static void\nbuild_cert(struct sshbuf *b, const struct sshkey *k, const char *type,\n    const struct sshkey *sign_key, const struct sshkey *ca_key,\n    const char *sig_alg)\n{\n\tstruct sshbuf *ca_buf, *pk, *principals, *critopts, *exts;\n\tu_char *sigblob;\n\tsize_t siglen;\n\n\tca_buf = sshbuf_new();\n\tASSERT_PTR_NE(ca_buf, NULL);\n\tASSERT_INT_EQ(sshkey_putb(ca_key, ca_buf), 0);\n\n\t/*\n\t * Get the public key serialisation by rendering the key and skipping\n\t * the type string. This is a bit of a hack :/\n\t */\n\tpk = sshbuf_new();\n\tASSERT_PTR_NE(pk, NULL);\n\tASSERT_INT_EQ(sshkey_putb_plain(k, pk), 0);\n\tASSERT_INT_EQ(sshbuf_skip_string(pk), 0);\n\n\tprincipals = sshbuf_new();\n\tASSERT_PTR_NE(principals, NULL);\n\tASSERT_INT_EQ(sshbuf_put_cstring(principals, \"gsamsa\"), 0);\n\tASSERT_INT_EQ(sshbuf_put_cstring(principals, \"gregor\"), 0);\n\n\tcritopts = sshbuf_new();\n\tASSERT_PTR_NE(critopts, NULL);\n\tput_opt(critopts, \"force-command\", \"/usr/local/bin/nethack\");\n\tput_opt(critopts, \"source-address\", \"192.168.0.0/24,127.0.0.1,::1\");\n\n\texts = sshbuf_new();\n\tASSERT_PTR_NE(exts, NULL);\n\tput_opt(critopts, \"permit-X11-forwarding\", NULL);\n\n\tASSERT_INT_EQ(sshbuf_put_cstring(b, type), 0);\n\tASSERT_INT_EQ(sshbuf_put_cstring(b, \"noncenoncenonce!\"), 0); /* nonce */\n\tASSERT_INT_EQ(sshbuf_putb(b, pk), 0); /* public key serialisation */\n\tASSERT_INT_EQ(sshbuf_put_u64(b, 1234), 0); /* serial */\n\tASSERT_INT_EQ(sshbuf_put_u32(b, SSH2_CERT_TYPE_USER), 0); /* type */\n\tASSERT_INT_EQ(sshbuf_put_cstring(b, \"gregor\"), 0); /* key ID */\n\tASSERT_INT_EQ(sshbuf_put_stringb(b, principals), 0); /* principals */\n\tASSERT_INT_EQ(sshbuf_put_u64(b, 0), 0); /* start */\n\tASSERT_INT_EQ(sshbuf_put_u64(b, 0xffffffffffffffffULL), 0); /* end */\n\tASSERT_INT_EQ(sshbuf_put_stringb(b, critopts), 0); /* options */\n\tASSERT_INT_EQ(sshbuf_put_stringb(b, exts), 0); /* extensions */\n\tASSERT_INT_EQ(sshbuf_put_string(b, NULL, 0), 0); /* reserved */\n\tASSERT_INT_EQ(sshbuf_put_stringb(b, ca_buf), 0); /* signature key */\n\tASSERT_INT_EQ(sshkey_sign(sign_key, &sigblob, &siglen,\n\t    sshbuf_ptr(b), sshbuf_len(b), sig_alg, 0), 0);\n\tASSERT_INT_EQ(sshbuf_put_string(b, sigblob, siglen), 0); /* signature */\n\n\tfree(sigblob);\n\tsshbuf_free(ca_buf);\n\tsshbuf_free(exts);\n\tsshbuf_free(critopts);\n\tsshbuf_free(principals);\n\tsshbuf_free(pk);\n}",
    "includes": [
      "#include \"ssh2.h\"",
      "#include \"common.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"../test_helper/test_helper.h\"",
      "# include <openssl/ec.h>",
      "#include <openssl/dsa.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/bn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "pk"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sigblob"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshbuf_put_string(b, sigblob, siglen)",
            "0"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "b",
            "sigblob",
            "siglen"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_sign(sign_key, &sigblob, &siglen,\n\t    sshbuf_ptr(b), sshbuf_len(b), sig_alg, 0)",
            "0"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_sign",
          "args": [
            "sign_key",
            "&sigblob",
            "&siglen",
            "sshbuf_ptr(b)",
            "sshbuf_len(b)",
            "sig_alg",
            "0"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "2385-2421",
          "snippet": "int\nsshkey_sign(const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_sign(key, sigp, lenp, data, datalen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_sign(key, sigp, lenp, data, datalen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_sign(key, sigp, lenp, data, datalen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_sign(key, sigp, lenp, data, datalen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_sign(key, sigp, lenp, data, datalen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_sign(const struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *alg, u_int compat)\n{\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA_CERT:\n\tcase KEY_DSA:\n\t\treturn ssh_dss_sign(key, sigp, lenp, data, datalen, compat);\n# ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA:\n\t\treturn ssh_ecdsa_sign(key, sigp, lenp, data, datalen, compat);\n# endif /* OPENSSL_HAS_ECC */\n\tcase KEY_RSA_CERT:\n\tcase KEY_RSA:\n\t\treturn ssh_rsa_sign(key, sigp, lenp, data, datalen, alg);\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_ED25519_CERT:\n\t\treturn ssh_ed25519_sign(key, sigp, lenp, data, datalen, compat);\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n\tcase KEY_XMSS_CERT:\n\t\treturn ssh_xmss_sign(key, sigp, lenp, data, datalen, compat);\n#endif /* WITH_XMSS */\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "b"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "b"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshbuf_put_stringb(b, ca_buf)",
            "0"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_put_stringb",
          "args": [
            "b",
            "ca_buf"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "371-375",
          "snippet": "int\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshbuf_put_string(b, NULL, 0)",
            "0"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshbuf_put_stringb(b, exts)",
            "0"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshbuf_put_stringb(b, critopts)",
            "0"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshbuf_put_u64(b, 0xffffffffffffffffULL)",
            "0"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u64",
          "args": [
            "b",
            "0xffffffffffffffffULL"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "299-309",
          "snippet": "int\nsshbuf_put_u64(struct sshbuf *buf, u_int64_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 8, &p)) < 0)\n\t\treturn r;\n\tPOKE_U64(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u64(struct sshbuf *buf, u_int64_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 8, &p)) < 0)\n\t\treturn r;\n\tPOKE_U64(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshbuf_put_u64(b, 0)",
            "0"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshbuf_put_stringb(b, principals)",
            "0"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshbuf_put_cstring(b, \"gregor\")",
            "0"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "b",
            "\"gregor\""
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshbuf_put_u32(b, SSH2_CERT_TYPE_USER)",
            "0"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_put_u32",
          "args": [
            "b",
            "SSH2_CERT_TYPE_USER"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "311-321",
          "snippet": "int\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_u32(struct sshbuf *buf, u_int32_t val)\n{\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(buf, 4, &p)) < 0)\n\t\treturn r;\n\tPOKE_U32(p, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshbuf_put_u64(b, 1234)",
            "0"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshbuf_putb(b, pk)",
            "0"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_putb",
          "args": [
            "b",
            "pk"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_putb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "248-252",
          "snippet": "int\nsshbuf_putb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_putb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshbuf_put_cstring(b, \"noncenoncenonce!\")",
            "0"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshbuf_put_cstring(b, type)",
            "0"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_opt",
          "args": [
            "critopts",
            "\"permit-X11-forwarding\"",
            "NULL"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "put_opt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/test_sshkey.c",
          "lines": "39-51",
          "snippet": "static void\nput_opt(struct sshbuf *b, const char *name, const char *value)\n{\n\tstruct sshbuf *sect;\n\n\tsect = sshbuf_new();\n\tASSERT_PTR_NE(sect, NULL);\n\tASSERT_INT_EQ(sshbuf_put_cstring(b, name), 0);\n\tif (value != NULL)\n\t\tASSERT_INT_EQ(sshbuf_put_cstring(sect, value), 0);\n\tASSERT_INT_EQ(sshbuf_put_stringb(b, sect), 0);\n\tsshbuf_free(sect);\n}",
          "includes": [
            "#include \"ssh2.h\"",
            "#include \"common.h\"",
            "#include \"authfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"../test_helper/test_helper.h\"",
            "# include <openssl/ec.h>",
            "#include <openssl/dsa.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/bn.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh2.h\"\n#include \"common.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n# include <openssl/ec.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nput_opt(struct sshbuf *b, const char *name, const char *value)\n{\n\tstruct sshbuf *sect;\n\n\tsect = sshbuf_new();\n\tASSERT_PTR_NE(sect, NULL);\n\tASSERT_INT_EQ(sshbuf_put_cstring(b, name), 0);\n\tif (value != NULL)\n\t\tASSERT_INT_EQ(sshbuf_put_cstring(sect, value), 0);\n\tASSERT_INT_EQ(sshbuf_put_stringb(b, sect), 0);\n\tsshbuf_free(sect);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "exts",
            "NULL"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "critopts",
            "NULL"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshbuf_put_cstring(principals, \"gregor\")",
            "0"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshbuf_put_cstring(principals, \"gsamsa\")",
            "0"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "principals",
            "NULL"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshbuf_skip_string(pk)",
            "0"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_skip_string",
          "args": [
            "pk"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_putb_plain(k, pk)",
            "0"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshkey_putb_plain",
          "args": [
            "k",
            "pk"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_putb_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "842-846",
          "snippet": "int\nsshkey_putb_plain(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn to_blob_buf(key, b, 1, SSHKEY_SERIALIZE_DEFAULT);\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_putb_plain(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn to_blob_buf(key, b, 1, SSHKEY_SERIALIZE_DEFAULT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "pk",
            "NULL"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshkey_putb(ca_key, ca_buf)",
            "0"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "ca_buf",
            "NULL"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh2.h\"\n#include \"common.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n# include <openssl/ec.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nbuild_cert(struct sshbuf *b, const struct sshkey *k, const char *type,\n    const struct sshkey *sign_key, const struct sshkey *ca_key,\n    const char *sig_alg)\n{\n\tstruct sshbuf *ca_buf, *pk, *principals, *critopts, *exts;\n\tu_char *sigblob;\n\tsize_t siglen;\n\n\tca_buf = sshbuf_new();\n\tASSERT_PTR_NE(ca_buf, NULL);\n\tASSERT_INT_EQ(sshkey_putb(ca_key, ca_buf), 0);\n\n\t/*\n\t * Get the public key serialisation by rendering the key and skipping\n\t * the type string. This is a bit of a hack :/\n\t */\n\tpk = sshbuf_new();\n\tASSERT_PTR_NE(pk, NULL);\n\tASSERT_INT_EQ(sshkey_putb_plain(k, pk), 0);\n\tASSERT_INT_EQ(sshbuf_skip_string(pk), 0);\n\n\tprincipals = sshbuf_new();\n\tASSERT_PTR_NE(principals, NULL);\n\tASSERT_INT_EQ(sshbuf_put_cstring(principals, \"gsamsa\"), 0);\n\tASSERT_INT_EQ(sshbuf_put_cstring(principals, \"gregor\"), 0);\n\n\tcritopts = sshbuf_new();\n\tASSERT_PTR_NE(critopts, NULL);\n\tput_opt(critopts, \"force-command\", \"/usr/local/bin/nethack\");\n\tput_opt(critopts, \"source-address\", \"192.168.0.0/24,127.0.0.1,::1\");\n\n\texts = sshbuf_new();\n\tASSERT_PTR_NE(exts, NULL);\n\tput_opt(critopts, \"permit-X11-forwarding\", NULL);\n\n\tASSERT_INT_EQ(sshbuf_put_cstring(b, type), 0);\n\tASSERT_INT_EQ(sshbuf_put_cstring(b, \"noncenoncenonce!\"), 0); /* nonce */\n\tASSERT_INT_EQ(sshbuf_putb(b, pk), 0); /* public key serialisation */\n\tASSERT_INT_EQ(sshbuf_put_u64(b, 1234), 0); /* serial */\n\tASSERT_INT_EQ(sshbuf_put_u32(b, SSH2_CERT_TYPE_USER), 0); /* type */\n\tASSERT_INT_EQ(sshbuf_put_cstring(b, \"gregor\"), 0); /* key ID */\n\tASSERT_INT_EQ(sshbuf_put_stringb(b, principals), 0); /* principals */\n\tASSERT_INT_EQ(sshbuf_put_u64(b, 0), 0); /* start */\n\tASSERT_INT_EQ(sshbuf_put_u64(b, 0xffffffffffffffffULL), 0); /* end */\n\tASSERT_INT_EQ(sshbuf_put_stringb(b, critopts), 0); /* options */\n\tASSERT_INT_EQ(sshbuf_put_stringb(b, exts), 0); /* extensions */\n\tASSERT_INT_EQ(sshbuf_put_string(b, NULL, 0), 0); /* reserved */\n\tASSERT_INT_EQ(sshbuf_put_stringb(b, ca_buf), 0); /* signature key */\n\tASSERT_INT_EQ(sshkey_sign(sign_key, &sigblob, &siglen,\n\t    sshbuf_ptr(b), sshbuf_len(b), sig_alg, 0), 0);\n\tASSERT_INT_EQ(sshbuf_put_string(b, sigblob, siglen), 0); /* signature */\n\n\tfree(sigblob);\n\tsshbuf_free(ca_buf);\n\tsshbuf_free(exts);\n\tsshbuf_free(critopts);\n\tsshbuf_free(principals);\n\tsshbuf_free(pk);\n}"
  },
  {
    "function_name": "put_opt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/unittests/sshkey/test_sshkey.c",
    "lines": "39-51",
    "snippet": "static void\nput_opt(struct sshbuf *b, const char *name, const char *value)\n{\n\tstruct sshbuf *sect;\n\n\tsect = sshbuf_new();\n\tASSERT_PTR_NE(sect, NULL);\n\tASSERT_INT_EQ(sshbuf_put_cstring(b, name), 0);\n\tif (value != NULL)\n\t\tASSERT_INT_EQ(sshbuf_put_cstring(sect, value), 0);\n\tASSERT_INT_EQ(sshbuf_put_stringb(b, sect), 0);\n\tsshbuf_free(sect);\n}",
    "includes": [
      "#include \"ssh2.h\"",
      "#include \"common.h\"",
      "#include \"authfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"ssherr.h\"",
      "#include \"../test_helper/test_helper.h\"",
      "# include <openssl/ec.h>",
      "#include <openssl/dsa.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/bn.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "sect"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshbuf_put_stringb(b, sect)",
            "0"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_put_stringb",
          "args": [
            "b",
            "sect"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_stringb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "371-375",
          "snippet": "int\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_stringb(struct sshbuf *buf, const struct sshbuf *v)\n{\n\treturn sshbuf_put_string(buf, sshbuf_ptr(v), sshbuf_len(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshbuf_put_cstring(sect, value)",
            "0"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "sect",
            "value"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_INT_EQ",
          "args": [
            "sshbuf_put_cstring(b, name)",
            "0"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PTR_NE",
          "args": [
            "sect",
            "NULL"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh2.h\"\n#include \"common.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"../test_helper/test_helper.h\"\n# include <openssl/ec.h>\n#include <openssl/dsa.h>\n#include <openssl/rsa.h>\n#include <openssl/bn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\nput_opt(struct sshbuf *b, const char *name, const char *value)\n{\n\tstruct sshbuf *sect;\n\n\tsect = sshbuf_new();\n\tASSERT_PTR_NE(sect, NULL);\n\tASSERT_INT_EQ(sshbuf_put_cstring(b, name), 0);\n\tif (value != NULL)\n\t\tASSERT_INT_EQ(sshbuf_put_cstring(sect, value), 0);\n\tASSERT_INT_EQ(sshbuf_put_stringb(b, sect), 0);\n\tsshbuf_free(sect);\n}"
  }
]