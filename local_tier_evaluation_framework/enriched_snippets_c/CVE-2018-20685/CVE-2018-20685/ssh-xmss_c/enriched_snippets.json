[
  {
    "function_name": "ssh_xmss_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-xmss.c",
    "lines": "114-191",
    "snippet": "int\nssh_xmss_verify(const struct sshkey *key,\n    const u_char *signature, size_t signaturelen,\n    const u_char *data, size_t datalen, u_int compat)\n{\n\tstruct sshbuf *b = NULL;\n\tchar *ktype = NULL;\n\tconst u_char *sigblob;\n\tu_char *sm = NULL, *m = NULL;\n\tsize_t len, required_siglen;\n\tunsigned long long smlen = 0, mlen = 0;\n\tint r, ret;\n\n\tif (key == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_XMSS ||\n\t    key->xmss_pk == NULL ||\n\t    sshkey_xmss_params(key) == NULL ||\n\t    signature == NULL || signaturelen == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshkey_xmss_siglen(key, &required_siglen)) != 0)\n\t\treturn r;\n\tif (datalen >= INT_MAX - required_siglen)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif ((b = sshbuf_from(signature, signaturelen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_get_cstring(b, &ktype, NULL)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, &sigblob, &len)) != 0)\n\t\tgoto out;\n\tif (strcmp(\"ssh-xmss@openssh.com\", ktype) != 0) {\n\t\tr = SSH_ERR_KEY_TYPE_MISMATCH;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(b) != 0) {\n\t\tr = SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\t\tgoto out;\n\t}\n\tif (len != required_siglen) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (datalen >= SIZE_MAX - len) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tsmlen = len + datalen;\n\tmlen = smlen;\n\tif ((sm = malloc(smlen)) == NULL || (m = malloc(mlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tmemcpy(sm, sigblob, len);\n\tmemcpy(sm+len, data, datalen);\n\tif ((ret = xmss_sign_open(m, &mlen, sm, smlen,\n\t    key->xmss_pk, sshkey_xmss_params(key))) != 0) {\n\t\tdebug2(\"%s: crypto_sign_xmss_open failed: %d\",\n\t\t    __func__, ret);\n\t}\n\tif (ret != 0 || mlen != datalen) {\n\t\tr = SSH_ERR_SIGNATURE_INVALID;\n\t\tgoto out;\n\t}\n\t/* XXX compare 'm' and 'data' ? */\n\t/* success */\n\tr = 0;\n out:\n\tif (sm != NULL) {\n\t\texplicit_bzero(sm, smlen);\n\t\tfree(sm);\n\t}\n\tif (m != NULL) {\n\t\texplicit_bzero(m, smlen); /* NB mlen may be invalid if r != 0 */\n\t\tfree(m);\n\t}\n\tsshbuf_free(b);\n\tfree(ktype);\n\treturn r;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"ssh.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ktype"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "m",
            "smlen"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"%s: crypto_sign_xmss_open failed: %d\"",
            "__func__",
            "ret"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmss_sign_open",
          "args": [
            "m",
            "&mlen",
            "sm",
            "smlen",
            "key->xmss_pk",
            "sshkey_xmss_params(key)"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "xmss_sign_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "663-743",
          "snippet": "int xmss_sign_open(unsigned char *msg, unsigned long long *msglen, const unsigned char *sig_msg, unsigned long long sig_msg_len, const unsigned char *pk, const xmss_params *params)\n{\n  unsigned int n = params->n;\n\n  unsigned long long i, m_len;\n  unsigned long idx=0;\n  unsigned char wots_pk[params->wots_par.keysize];\n  unsigned char pkhash[n];\n  unsigned char root[n];\n  unsigned char msg_h[n];\n  unsigned char hash_key[3*n];\n\n  unsigned char pub_seed[n];\n  memcpy(pub_seed, pk+n, n);\n\n  // Init addresses\n  uint32_t ots_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n  uint32_t ltree_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n  uint32_t node_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n\n  setType(ots_addr, 0);\n  setType(ltree_addr, 1);\n  setType(node_addr, 2);\n\n  // Extract index\n  idx = ((unsigned long)sig_msg[0] << 24) | ((unsigned long)sig_msg[1] << 16) | ((unsigned long)sig_msg[2] << 8) | sig_msg[3];\n  printf(\"verify:: idx = %lu\\n\", idx);\n  \n  // Generate hash key (R || root || idx)\n  memcpy(hash_key, sig_msg+4,n);\n  memcpy(hash_key+n, pk, n);\n  to_byte(hash_key+2*n, idx, n);\n  \n  sig_msg += (n+4);\n  sig_msg_len -= (n+4);\n\n  // hash message \n  unsigned long long tmp_sig_len = params->wots_par.keysize+params->h*n;\n  m_len = sig_msg_len - tmp_sig_len;\n  h_msg(msg_h, sig_msg + tmp_sig_len, m_len, hash_key, 3*n, n);\n\n  //-----------------------\n  // Verify signature\n  //-----------------------\n\n  // Prepare Address\n  setOTSADRS(ots_addr, idx);\n  // Check WOTS signature\n  wots_pkFromSig(wots_pk, sig_msg, msg_h, &(params->wots_par), pub_seed, ots_addr);\n\n  sig_msg += params->wots_par.keysize;\n  sig_msg_len -= params->wots_par.keysize;\n\n  // Compute Ltree\n  setLtreeADRS(ltree_addr, idx);\n  l_tree(pkhash, wots_pk, params, pub_seed, ltree_addr);\n\n  // Compute root\n  validate_authpath(root, pkhash, idx, sig_msg, params, pub_seed, node_addr);\n\n  sig_msg += params->h*n;\n  sig_msg_len -= params->h*n;\n\n  for (i = 0; i < n; i++)\n    if (root[i] != pk[i])\n      goto fail;\n\n  *msglen = sig_msg_len;\n  for (i = 0; i < *msglen; i++)\n    msg[i] = sig_msg[i];\n\n  return 0;\n\n\nfail:\n  *msglen = sig_msg_len;\n  for (i = 0; i < *msglen; i++)\n    msg[i] = 0;\n  *msglen = -1;\n  return -1;\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint xmss_sign_open(unsigned char *msg, unsigned long long *msglen, const unsigned char *sig_msg, unsigned long long sig_msg_len, const unsigned char *pk, const xmss_params *params)\n{\n  unsigned int n = params->n;\n\n  unsigned long long i, m_len;\n  unsigned long idx=0;\n  unsigned char wots_pk[params->wots_par.keysize];\n  unsigned char pkhash[n];\n  unsigned char root[n];\n  unsigned char msg_h[n];\n  unsigned char hash_key[3*n];\n\n  unsigned char pub_seed[n];\n  memcpy(pub_seed, pk+n, n);\n\n  // Init addresses\n  uint32_t ots_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n  uint32_t ltree_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n  uint32_t node_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n\n  setType(ots_addr, 0);\n  setType(ltree_addr, 1);\n  setType(node_addr, 2);\n\n  // Extract index\n  idx = ((unsigned long)sig_msg[0] << 24) | ((unsigned long)sig_msg[1] << 16) | ((unsigned long)sig_msg[2] << 8) | sig_msg[3];\n  printf(\"verify:: idx = %lu\\n\", idx);\n  \n  // Generate hash key (R || root || idx)\n  memcpy(hash_key, sig_msg+4,n);\n  memcpy(hash_key+n, pk, n);\n  to_byte(hash_key+2*n, idx, n);\n  \n  sig_msg += (n+4);\n  sig_msg_len -= (n+4);\n\n  // hash message \n  unsigned long long tmp_sig_len = params->wots_par.keysize+params->h*n;\n  m_len = sig_msg_len - tmp_sig_len;\n  h_msg(msg_h, sig_msg + tmp_sig_len, m_len, hash_key, 3*n, n);\n\n  //-----------------------\n  // Verify signature\n  //-----------------------\n\n  // Prepare Address\n  setOTSADRS(ots_addr, idx);\n  // Check WOTS signature\n  wots_pkFromSig(wots_pk, sig_msg, msg_h, &(params->wots_par), pub_seed, ots_addr);\n\n  sig_msg += params->wots_par.keysize;\n  sig_msg_len -= params->wots_par.keysize;\n\n  // Compute Ltree\n  setLtreeADRS(ltree_addr, idx);\n  l_tree(pkhash, wots_pk, params, pub_seed, ltree_addr);\n\n  // Compute root\n  validate_authpath(root, pkhash, idx, sig_msg, params, pub_seed, node_addr);\n\n  sig_msg += params->h*n;\n  sig_msg_len -= params->h*n;\n\n  for (i = 0; i < n; i++)\n    if (root[i] != pk[i])\n      goto fail;\n\n  *msglen = sig_msg_len;\n  for (i = 0; i < *msglen; i++)\n    msg[i] = sig_msg[i];\n\n  return 0;\n\n\nfail:\n  *msglen = sig_msg_len;\n  for (i = 0; i < *msglen; i++)\n    msg[i] = 0;\n  *msglen = -1;\n  return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_params",
          "args": [
            "key"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "210-218",
          "snippet": "void *\nsshkey_xmss_params(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\treturn &state->params;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid *\nsshkey_xmss_params(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\treturn &state->params;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sm+len",
            "data",
            "datalen"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sm",
            "sigblob",
            "len"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "mlen"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "b"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"ssh-xmss@openssh.com\"",
            "ktype"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_string_direct",
          "args": [
            "b",
            "&sigblob",
            "&len"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_string_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "123-147",
          "snippet": "int\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_string_direct(struct sshbuf *buf, const u_char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) < 0)\n\t\treturn r;\n\tif (valp != NULL)\n\t\t*valp = p;\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (sshbuf_consume(buf, len + 4) != 0) {\n\t\t/* Shouldn't happen */\n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tSSHBUF_ABORT();\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_get_cstring",
          "args": [
            "b",
            "&ktype",
            "NULL"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_get_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "180-213",
          "snippet": "int\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_get_cstring(struct sshbuf *buf, char **valp, size_t *lenp)\n{\n\tsize_t len;\n\tconst u_char *p, *z;\n\tint r;\n\n\tif (valp != NULL)\n\t\t*valp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif ((r = sshbuf_peek_string_direct(buf, &p, &len)) != 0)\n\t\treturn r;\n\t/* Allow a \\0 only at the end of the string */\n\tif (len > 0 &&\n\t    (z = memchr(p , '\\0', len)) != NULL && z < p + len - 1) {\n\t\tSSHBUF_DBG((\"SSH_ERR_INVALID_FORMAT\"));\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_skip_string(buf)) != 0)\n\t\treturn -1;\n\tif (valp != NULL) {\n\t\tif ((*valp = malloc(len + 1)) == NULL) {\n\t\t\tSSHBUF_DBG((\"SSH_ERR_ALLOC_FAIL\"));\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tif (len != 0)\n\t\t\tmemcpy(*valp, p, len);\n\t\t(*valp)[len] = '\\0';\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = (size_t)len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_from",
          "args": [
            "signature",
            "signaturelen"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_from",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "87-102",
          "snippet": "struct sshbuf *\nsshbuf_from(const void *blob, size_t len)\n{\n\tstruct sshbuf *ret;\n\n\tif (blob == NULL || len > SSHBUF_SIZE_MAX ||\n\t    (ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = ret->size = ret->max_size = len;\n\tret->readonly = 1;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tret->cd = blob;\n\tret->d = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_from(const void *blob, size_t len)\n{\n\tstruct sshbuf *ret;\n\n\tif (blob == NULL || len > SSHBUF_SIZE_MAX ||\n\t    (ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = ret->size = ret->max_size = len;\n\tret->readonly = 1;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tret->cd = blob;\n\tret->d = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_siglen",
          "args": [
            "key",
            "&required_siglen"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_siglen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "230-243",
          "snippet": "int\nsshkey_xmss_siglen(const struct sshkey *key, size_t *lenp)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (lenp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t*lenp = 4 + state->n +\n\t    state->params.wots_par.keysize +\n\t    state->h * state->n;\n\treturn 0;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_siglen(const struct sshkey *key, size_t *lenp)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (lenp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t*lenp = 4 + state->n +\n\t    state->params.wots_par.keysize +\n\t    state->h * state->n;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_plain",
          "args": [
            "key->type"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"ssh.h\"\n#include \"ssherr.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_xmss_verify(const struct sshkey *key,\n    const u_char *signature, size_t signaturelen,\n    const u_char *data, size_t datalen, u_int compat)\n{\n\tstruct sshbuf *b = NULL;\n\tchar *ktype = NULL;\n\tconst u_char *sigblob;\n\tu_char *sm = NULL, *m = NULL;\n\tsize_t len, required_siglen;\n\tunsigned long long smlen = 0, mlen = 0;\n\tint r, ret;\n\n\tif (key == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_XMSS ||\n\t    key->xmss_pk == NULL ||\n\t    sshkey_xmss_params(key) == NULL ||\n\t    signature == NULL || signaturelen == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshkey_xmss_siglen(key, &required_siglen)) != 0)\n\t\treturn r;\n\tif (datalen >= INT_MAX - required_siglen)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif ((b = sshbuf_from(signature, signaturelen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_get_cstring(b, &ktype, NULL)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, &sigblob, &len)) != 0)\n\t\tgoto out;\n\tif (strcmp(\"ssh-xmss@openssh.com\", ktype) != 0) {\n\t\tr = SSH_ERR_KEY_TYPE_MISMATCH;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(b) != 0) {\n\t\tr = SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\t\tgoto out;\n\t}\n\tif (len != required_siglen) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (datalen >= SIZE_MAX - len) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tsmlen = len + datalen;\n\tmlen = smlen;\n\tif ((sm = malloc(smlen)) == NULL || (m = malloc(mlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tmemcpy(sm, sigblob, len);\n\tmemcpy(sm+len, data, datalen);\n\tif ((ret = xmss_sign_open(m, &mlen, sm, smlen,\n\t    key->xmss_pk, sshkey_xmss_params(key))) != 0) {\n\t\tdebug2(\"%s: crypto_sign_xmss_open failed: %d\",\n\t\t    __func__, ret);\n\t}\n\tif (ret != 0 || mlen != datalen) {\n\t\tr = SSH_ERR_SIGNATURE_INVALID;\n\t\tgoto out;\n\t}\n\t/* XXX compare 'm' and 'data' ? */\n\t/* success */\n\tr = 0;\n out:\n\tif (sm != NULL) {\n\t\texplicit_bzero(sm, smlen);\n\t\tfree(sm);\n\t}\n\tif (m != NULL) {\n\t\texplicit_bzero(m, smlen); /* NB mlen may be invalid if r != 0 */\n\t\tfree(m);\n\t}\n\tsshbuf_free(b);\n\tfree(ktype);\n\treturn r;\n}"
  },
  {
    "function_name": "ssh_xmss_sign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-xmss.c",
    "lines": "38-112",
    "snippet": "int\nssh_xmss_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, u_int compat)\n{\n\tu_char *sig = NULL;\n\tsize_t slen = 0, len = 0, required_siglen;\n\tunsigned long long smlen;\n\tint r, ret;\n\tstruct sshbuf *b = NULL;\n\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\n\tif (key == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_XMSS ||\n\t    key->xmss_sk == NULL ||\n\t    sshkey_xmss_params(key) == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshkey_xmss_siglen(key, &required_siglen)) != 0)\n\t\treturn r;\n\tif (datalen >= INT_MAX - required_siglen)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tsmlen = slen = datalen + required_siglen;\n\tif ((sig = malloc(slen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_xmss_get_state(key, error)) != 0)\n\t\tgoto out;\n\tif ((ret = xmss_sign(key->xmss_sk, sshkey_xmss_bds_state(key), sig, &smlen,\n\t    data, datalen, sshkey_xmss_params(key))) != 0 || smlen <= datalen) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT; /* XXX better error? */\n\t\tgoto out;\n\t}\n\t/* encode signature */\n\tif ((b = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_cstring(b, \"ssh-xmss@openssh.com\")) != 0 ||\n\t    (r = sshbuf_put_string(b, sig, smlen - datalen)) != 0)\n\t\tgoto out;\n\tlen = sshbuf_len(b);\n\tif (sigp != NULL) {\n\t\tif ((*sigp = malloc(len)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*sigp, sshbuf_ptr(b), len);\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\t/* success */\n\tr = 0;\n out:\n\tif ((ret = sshkey_xmss_update_state(key, error)) != 0) {\n\t\t/* discard signature since we cannot update the state */\n\t\tif (r == 0 && sigp != NULL && *sigp != NULL) {\n\t\t\texplicit_bzero(*sigp, len);\n\t\t\tfree(*sigp);\n\t\t}\n\t\tif (sigp != NULL)\n\t\t\t*sigp = NULL;\n\t\tif (lenp != NULL)\n\t\t\t*lenp = 0;\n\t\tr = ret;\n\t}\n\tsshbuf_free(b);\n\tif (sig != NULL) {\n\t\texplicit_bzero(sig, slen);\n\t\tfree(sig);\n\t}\n\n\treturn r;\n}",
    "includes": [
      "#include \"xmss_fast.h\"",
      "#include \"ssh.h\"",
      "#include \"ssherr.h\"",
      "#include \"sshkey-xmss.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"log.h\"",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <limits.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sig"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/smult_curve25519_ref.c",
          "lines": "50-60",
          "snippet": "static void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;"
          ],
          "called_functions": [],
          "contextual_snippet": "static const unsigned int minusp[32] = {\n 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128\n} ;\n\nstatic void freeze(unsigned int a[32])\n{\n  unsigned int aorig[32];\n  unsigned int j;\n  unsigned int negative;\n\n  for (j = 0;j < 32;++j) aorig[j] = a[j];\n  add(a,a,minusp);\n  negative = -((a[31] >> 7) & 1);\n  for (j = 0;j < 32;++j) a[j] ^= negative & (aorig[j] ^ a[j]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "explicit_bzero",
          "args": [
            "sig",
            "slen"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "explicit_bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/explicit_bzero.c",
          "lines": "36-53",
          "snippet": "void\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"includes.h\"\n\nvoid\nexplicit_bzero(void *p, size_t n)\n{\n\tif (n == 0)\n\t\treturn;\n\t/*\n\t * clang -fsanitize=memory needs to intercept memset-like functions\n\t * to correctly detect memory initialisation. Make sure one is called\n\t * directly since our indirection trick above successfully confuses it.\n\t */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n\tmemset(p, 0, n);\n# endif\n#endif\n\n\tssh_bzero(p, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_free",
          "args": [
            "b"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "133-166",
          "snippet": "void\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t/*\n\t * The following will leak on insane buffers, but this is the safest\n\t * course of action - an invalid pointer or already-freed pointer may\n\t * have been passed to us and continuing to scribble over memory would\n\t * be bad.\n\t */\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\t/*\n\t * If we are a child, the free our parent to decrement its reference\n\t * count and possibly free it.\n\t */\n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\t/*\n\t * If we are a parent with still-extant children, then don't free just\n\t * yet. The last child's call to sshbuf_free should decrement our\n\t * refcount to 0 and trigger the actual free.\n\t */\n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\texplicit_bzero(buf, sizeof(*buf));\n\tfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_update_state",
          "args": [
            "key",
            "error"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_update_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "565-674",
          "snippet": "int\nsshkey_xmss_update_state(const struct sshkey *k, sshkey_printfn *pr)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tstruct sshbuf *b = NULL, *enc = NULL;\n\tu_int32_t idx = 0;\n\tunsigned char buf[4];\n\tchar *filename = NULL;\n\tchar *statefile = NULL, *ostatefile = NULL, *nstatefile = NULL;\n\tint fd = -1;\n\tint ret = SSH_ERR_INVALID_ARGUMENT;\n\n\tif (state == NULL || !state->allow_update)\n\t\treturn ret;\n\tif (state->maxidx) {\n\t\t/* no update since the number of signatures is limited */\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\tidx = PEEK_U32(k->xmss_sk);\n\tif (idx == state->idx) {\n\t\t/* no signature happened, no need to update */\n\t\tret = 0;\n\t\tgoto done;\n\t} else if (idx != state->idx + 1) {\n\t\tPRINT(\"%s: more than one signature happened: idx %u state %u\",\n\t\t     __func__, idx, state->idx);\n\t\tgoto done;\n\t}\n\tstate->idx = idx;\n\tif ((filename = k->xmss_filename) == NULL)\n\t\tgoto done;\n\tif (asprintf(&statefile, \"%s.state\", filename) < 0 ||\n\t    asprintf(&ostatefile, \"%s.ostate\", filename) < 0 ||\n\t    asprintf(&nstatefile, \"%s.nstate\", filename) < 0) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto done;\n\t}\n\tunlink(nstatefile);\n\tif ((b = sshbuf_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto done;\n\t}\n\tif ((ret = sshkey_xmss_serialize_state(k, b)) != 0) {\n\t\tPRINT(\"%s: SERLIALIZE FAILED: %d\", __func__, ret);\n\t\tgoto done;\n\t}\n\tif ((ret = sshkey_xmss_encrypt_state(k, b, &enc)) != 0) {\n\t\tPRINT(\"%s: ENCRYPT FAILED: %d\", __func__, ret);\n\t\tgoto done;\n\t}\n\tif ((fd = open(nstatefile, O_CREAT|O_WRONLY|O_EXCL, 0600)) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: open new state file: %s\", __func__, nstatefile);\n\t\tgoto done;\n\t}\n\tPOKE_U32(buf, sshbuf_len(enc));\n\tif (atomicio(vwrite, fd, buf, sizeof(buf)) != sizeof(buf)) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: write new state file hdr: %s\", __func__, nstatefile);\n\t\tclose(fd);\n\t\tgoto done;\n\t}\n\tif (atomicio(vwrite, fd, sshbuf_mutable_ptr(enc), sshbuf_len(enc)) !=\n\t    sshbuf_len(enc)) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: write new state file data: %s\", __func__, nstatefile);\n\t\tclose(fd);\n\t\tgoto done;\n\t}\n\tif (fsync(fd) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: sync new state file: %s\", __func__, nstatefile);\n\t\tclose(fd);\n\t\tgoto done;\n\t}\n\tif (close(fd) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: close new state file: %s\", __func__, nstatefile);\n\t\tgoto done;\n\t}\n\tif (state->have_state) {\n\t\tunlink(ostatefile);\n\t\tif (link(statefile, ostatefile)) {\n\t\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\t\tPRINT(\"%s: backup state %s to %s\", __func__, statefile,\n\t\t\t    ostatefile);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tif (rename(nstatefile, statefile) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: rename %s to %s\", __func__, nstatefile, statefile);\n\t\tgoto done;\n\t}\n\tret = 0;\ndone:\n\tif (state->lockfd != -1) {\n\t\tclose(state->lockfd);\n\t\tstate->lockfd = -1;\n\t}\n\tif (nstatefile)\n\t\tunlink(nstatefile);\n\tfree(statefile);\n\tfree(ostatefile);\n\tfree(nstatefile);\n\tsshbuf_free(b);\n\tsshbuf_free(enc);\n\treturn ret;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_update_state(const struct sshkey *k, sshkey_printfn *pr)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tstruct sshbuf *b = NULL, *enc = NULL;\n\tu_int32_t idx = 0;\n\tunsigned char buf[4];\n\tchar *filename = NULL;\n\tchar *statefile = NULL, *ostatefile = NULL, *nstatefile = NULL;\n\tint fd = -1;\n\tint ret = SSH_ERR_INVALID_ARGUMENT;\n\n\tif (state == NULL || !state->allow_update)\n\t\treturn ret;\n\tif (state->maxidx) {\n\t\t/* no update since the number of signatures is limited */\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\tidx = PEEK_U32(k->xmss_sk);\n\tif (idx == state->idx) {\n\t\t/* no signature happened, no need to update */\n\t\tret = 0;\n\t\tgoto done;\n\t} else if (idx != state->idx + 1) {\n\t\tPRINT(\"%s: more than one signature happened: idx %u state %u\",\n\t\t     __func__, idx, state->idx);\n\t\tgoto done;\n\t}\n\tstate->idx = idx;\n\tif ((filename = k->xmss_filename) == NULL)\n\t\tgoto done;\n\tif (asprintf(&statefile, \"%s.state\", filename) < 0 ||\n\t    asprintf(&ostatefile, \"%s.ostate\", filename) < 0 ||\n\t    asprintf(&nstatefile, \"%s.nstate\", filename) < 0) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto done;\n\t}\n\tunlink(nstatefile);\n\tif ((b = sshbuf_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto done;\n\t}\n\tif ((ret = sshkey_xmss_serialize_state(k, b)) != 0) {\n\t\tPRINT(\"%s: SERLIALIZE FAILED: %d\", __func__, ret);\n\t\tgoto done;\n\t}\n\tif ((ret = sshkey_xmss_encrypt_state(k, b, &enc)) != 0) {\n\t\tPRINT(\"%s: ENCRYPT FAILED: %d\", __func__, ret);\n\t\tgoto done;\n\t}\n\tif ((fd = open(nstatefile, O_CREAT|O_WRONLY|O_EXCL, 0600)) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: open new state file: %s\", __func__, nstatefile);\n\t\tgoto done;\n\t}\n\tPOKE_U32(buf, sshbuf_len(enc));\n\tif (atomicio(vwrite, fd, buf, sizeof(buf)) != sizeof(buf)) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: write new state file hdr: %s\", __func__, nstatefile);\n\t\tclose(fd);\n\t\tgoto done;\n\t}\n\tif (atomicio(vwrite, fd, sshbuf_mutable_ptr(enc), sshbuf_len(enc)) !=\n\t    sshbuf_len(enc)) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: write new state file data: %s\", __func__, nstatefile);\n\t\tclose(fd);\n\t\tgoto done;\n\t}\n\tif (fsync(fd) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: sync new state file: %s\", __func__, nstatefile);\n\t\tclose(fd);\n\t\tgoto done;\n\t}\n\tif (close(fd) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: close new state file: %s\", __func__, nstatefile);\n\t\tgoto done;\n\t}\n\tif (state->have_state) {\n\t\tunlink(ostatefile);\n\t\tif (link(statefile, ostatefile)) {\n\t\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\t\tPRINT(\"%s: backup state %s to %s\", __func__, statefile,\n\t\t\t    ostatefile);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tif (rename(nstatefile, statefile) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: rename %s to %s\", __func__, nstatefile, statefile);\n\t\tgoto done;\n\t}\n\tret = 0;\ndone:\n\tif (state->lockfd != -1) {\n\t\tclose(state->lockfd);\n\t\tstate->lockfd = -1;\n\t}\n\tif (nstatefile)\n\t\tunlink(nstatefile);\n\tfree(statefile);\n\tfree(ostatefile);\n\tfree(nstatefile);\n\tsshbuf_free(b);\n\tsshbuf_free(enc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*sigp",
            "sshbuf_ptr(b)",
            "len"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sshbuf_ptr",
          "args": [
            "b"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "268-274",
          "snippet": "const u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "xmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "39-50",
          "snippet": "void *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxmalloc(size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0)\n\t\tfatal(\"xmalloc: zero size\");\n\tptr = malloc(size);\n\tif (ptr == NULL)\n\t\tfatal(\"xmalloc: out of memory (allocating %zu bytes)\", size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_len",
          "args": [
            "b"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "252-258",
          "snippet": "size_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_string",
          "args": [
            "b",
            "sig",
            "smlen - datalen"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "347-363",
          "snippet": "int\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_string(struct sshbuf *buf, const void *v, size_t len)\n{\n\tu_char *d;\n\tint r;\n\n\tif (len > SSHBUF_SIZE_MAX - 4) {\n\t\tSSHBUF_DBG((\"SSH_ERR_NO_BUFFER_SPACE\"));\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t}\n\tif ((r = sshbuf_reserve(buf, len + 4, &d)) < 0)\n\t\treturn r;\n\tPOKE_U32(d, len);\n\tif (len != 0)\n\t\tmemcpy(d + 4, v, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_put_cstring",
          "args": [
            "b",
            "\"ssh-xmss@openssh.com\""
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_put_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf-getput-basic.c",
          "lines": "365-369",
          "snippet": "int\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}",
          "includes": [
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshbuf_put_cstring(struct sshbuf *buf, const char *v)\n{\n\treturn sshbuf_put_string(buf, v, v == NULL ? 0 : strlen(v));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshbuf_new",
          "args": [],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "sshbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshbuf.c",
          "lines": "68-85",
          "snippet": "struct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmss_sign",
          "args": [
            "key->xmss_sk",
            "sshkey_xmss_bds_state(key)",
            "sig",
            "&smlen",
            "data",
            "datalen",
            "sshkey_xmss_params(key)"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "xmss_sign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmss_fast.c",
          "lines": "551-658",
          "snippet": "int xmss_sign(unsigned char *sk, bds_state *state, unsigned char *sig_msg, unsigned long long *sig_msg_len, const unsigned char *msg, unsigned long long msglen, const xmss_params *params)\n{\n  unsigned int h = params->h;\n  unsigned int n = params->n;\n  unsigned int k = params->k;\n  uint16_t i = 0;\n\n  // Extract SK\n  unsigned long idx = ((unsigned long)sk[0] << 24) | ((unsigned long)sk[1] << 16) | ((unsigned long)sk[2] << 8) | sk[3];\n  unsigned char sk_seed[n];\n  memcpy(sk_seed, sk+4, n);\n  unsigned char sk_prf[n];\n  memcpy(sk_prf, sk+4+n, n);\n  unsigned char pub_seed[n];\n  memcpy(pub_seed, sk+4+2*n, n);\n  \n  // index as 32 bytes string\n  unsigned char idx_bytes_32[32];\n  to_byte(idx_bytes_32, idx, 32);\n  \n  unsigned char hash_key[3*n]; \n  \n  // Update SK\n  sk[0] = ((idx + 1) >> 24) & 255;\n  sk[1] = ((idx + 1) >> 16) & 255;\n  sk[2] = ((idx + 1) >> 8) & 255;\n  sk[3] = (idx + 1) & 255;\n  // -- Secret key for this non-forward-secure version is now updated.\n  // -- A productive implementation should use a file handle instead and write the updated secret key at this point!\n\n  // Init working params\n  unsigned char R[n];\n  unsigned char msg_h[n];\n  unsigned char ots_seed[n];\n  uint32_t ots_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n\n  // ---------------------------------\n  // Message Hashing\n  // ---------------------------------\n\n  // Message Hash:\n  // First compute pseudorandom value\n  prf(R, idx_bytes_32, sk_prf, n);\n  // Generate hash key (R || root || idx)\n  memcpy(hash_key, R, n);\n  memcpy(hash_key+n, sk+4+3*n, n);\n  to_byte(hash_key+2*n, idx, n);\n  // Then use it for message digest\n  h_msg(msg_h, msg, msglen, hash_key, 3*n, n);\n\n  // Start collecting signature\n  *sig_msg_len = 0;\n\n  // Copy index to signature\n  sig_msg[0] = (idx >> 24) & 255;\n  sig_msg[1] = (idx >> 16) & 255;\n  sig_msg[2] = (idx >> 8) & 255;\n  sig_msg[3] = idx & 255;\n\n  sig_msg += 4;\n  *sig_msg_len += 4;\n\n  // Copy R to signature\n  for (i = 0; i < n; i++)\n    sig_msg[i] = R[i];\n\n  sig_msg += n;\n  *sig_msg_len += n;\n\n  // ----------------------------------\n  // Now we start to \"really sign\"\n  // ----------------------------------\n\n  // Prepare Address\n  setType(ots_addr, 0);\n  setOTSADRS(ots_addr, idx);\n\n  // Compute seed for OTS key pair\n  get_seed(ots_seed, sk_seed, n, ots_addr);\n\n  // Compute WOTS signature\n  wots_sign(sig_msg, msg_h, ots_seed, &(params->wots_par), pub_seed, ots_addr);\n\n  sig_msg += params->wots_par.keysize;\n  *sig_msg_len += params->wots_par.keysize;\n\n  // the auth path was already computed during the previous round\n  memcpy(sig_msg, state->auth, h*n);\n\n  if (idx < (1U << h) - 1) {\n    bds_round(state, idx, sk_seed, params, pub_seed, ots_addr);\n    bds_treehash_update(state, (h - k) >> 1, sk_seed, params, pub_seed, ots_addr);\n  }\n\n/* TODO: save key/bds state here! */\n\n  sig_msg += params->h*n;\n  *sig_msg_len += params->h*n;\n\n  //Whipe secret elements?\n  //zerobytes(tsk, CRYPTO_SECRETKEYBYTES);\n\n\n  memcpy(sig_msg, msg, msglen);\n  *sig_msg_len += msglen;\n\n  return 0;\n}",
          "includes": [
            "#include \"stdio.h\"",
            "#include \"xmss_hash_address.h\"",
            "#include \"xmss_commons.h\"",
            "#include \"xmss_hash.h\"",
            "#include \"xmss_wots.h\"",
            "#include \"crypto_api.h\"",
            "#include \"xmss_fast.h\"",
            "#include <stdint.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdio.h\"\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n#include \"xmss_wots.h\"\n#include \"crypto_api.h\"\n#include \"xmss_fast.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint xmss_sign(unsigned char *sk, bds_state *state, unsigned char *sig_msg, unsigned long long *sig_msg_len, const unsigned char *msg, unsigned long long msglen, const xmss_params *params)\n{\n  unsigned int h = params->h;\n  unsigned int n = params->n;\n  unsigned int k = params->k;\n  uint16_t i = 0;\n\n  // Extract SK\n  unsigned long idx = ((unsigned long)sk[0] << 24) | ((unsigned long)sk[1] << 16) | ((unsigned long)sk[2] << 8) | sk[3];\n  unsigned char sk_seed[n];\n  memcpy(sk_seed, sk+4, n);\n  unsigned char sk_prf[n];\n  memcpy(sk_prf, sk+4+n, n);\n  unsigned char pub_seed[n];\n  memcpy(pub_seed, sk+4+2*n, n);\n  \n  // index as 32 bytes string\n  unsigned char idx_bytes_32[32];\n  to_byte(idx_bytes_32, idx, 32);\n  \n  unsigned char hash_key[3*n]; \n  \n  // Update SK\n  sk[0] = ((idx + 1) >> 24) & 255;\n  sk[1] = ((idx + 1) >> 16) & 255;\n  sk[2] = ((idx + 1) >> 8) & 255;\n  sk[3] = (idx + 1) & 255;\n  // -- Secret key for this non-forward-secure version is now updated.\n  // -- A productive implementation should use a file handle instead and write the updated secret key at this point!\n\n  // Init working params\n  unsigned char R[n];\n  unsigned char msg_h[n];\n  unsigned char ots_seed[n];\n  uint32_t ots_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n\n  // ---------------------------------\n  // Message Hashing\n  // ---------------------------------\n\n  // Message Hash:\n  // First compute pseudorandom value\n  prf(R, idx_bytes_32, sk_prf, n);\n  // Generate hash key (R || root || idx)\n  memcpy(hash_key, R, n);\n  memcpy(hash_key+n, sk+4+3*n, n);\n  to_byte(hash_key+2*n, idx, n);\n  // Then use it for message digest\n  h_msg(msg_h, msg, msglen, hash_key, 3*n, n);\n\n  // Start collecting signature\n  *sig_msg_len = 0;\n\n  // Copy index to signature\n  sig_msg[0] = (idx >> 24) & 255;\n  sig_msg[1] = (idx >> 16) & 255;\n  sig_msg[2] = (idx >> 8) & 255;\n  sig_msg[3] = idx & 255;\n\n  sig_msg += 4;\n  *sig_msg_len += 4;\n\n  // Copy R to signature\n  for (i = 0; i < n; i++)\n    sig_msg[i] = R[i];\n\n  sig_msg += n;\n  *sig_msg_len += n;\n\n  // ----------------------------------\n  // Now we start to \"really sign\"\n  // ----------------------------------\n\n  // Prepare Address\n  setType(ots_addr, 0);\n  setOTSADRS(ots_addr, idx);\n\n  // Compute seed for OTS key pair\n  get_seed(ots_seed, sk_seed, n, ots_addr);\n\n  // Compute WOTS signature\n  wots_sign(sig_msg, msg_h, ots_seed, &(params->wots_par), pub_seed, ots_addr);\n\n  sig_msg += params->wots_par.keysize;\n  *sig_msg_len += params->wots_par.keysize;\n\n  // the auth path was already computed during the previous round\n  memcpy(sig_msg, state->auth, h*n);\n\n  if (idx < (1U << h) - 1) {\n    bds_round(state, idx, sk_seed, params, pub_seed, ots_addr);\n    bds_treehash_update(state, (h - k) >> 1, sk_seed, params, pub_seed, ots_addr);\n  }\n\n/* TODO: save key/bds state here! */\n\n  sig_msg += params->h*n;\n  *sig_msg_len += params->h*n;\n\n  //Whipe secret elements?\n  //zerobytes(tsk, CRYPTO_SECRETKEYBYTES);\n\n\n  memcpy(sig_msg, msg, msglen);\n  *sig_msg_len += msglen;\n\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_params",
          "args": [
            "key"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "210-218",
          "snippet": "void *\nsshkey_xmss_params(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\treturn &state->params;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid *\nsshkey_xmss_params(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\treturn &state->params;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_bds_state",
          "args": [
            "key"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_bds_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "220-228",
          "snippet": "void *\nsshkey_xmss_bds_state(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\treturn &state->bds;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid *\nsshkey_xmss_bds_state(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\treturn &state->bds;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_get_state",
          "args": [
            "key",
            "error"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_get_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "442-530",
          "snippet": "int\nsshkey_xmss_get_state(const struct sshkey *k, sshkey_printfn *pr)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_int32_t idx = 0;\n\tchar *filename = NULL;\n\tchar *statefile = NULL, *ostatefile = NULL, *lockfile = NULL;\n\tint lockfd = -1, have_state = 0, have_ostate, tries = 0;\n\tint ret = SSH_ERR_INVALID_ARGUMENT, r;\n\n\tif (state == NULL)\n\t\tgoto done;\n\t/*\n\t * If maxidx is set, then we are allowed a limited number\n\t * of signatures, but don't need to access the disk.\n\t * Otherwise we need to deal with the on-disk state.\n\t */\n\tif (state->maxidx) {\n\t\t/* xmss_sk always contains the current state */\n\t\tidx = PEEK_U32(k->xmss_sk);\n\t\tif (idx < state->maxidx) {\n\t\t\tstate->allow_update = 1;\n\t\t\treturn 0;\n\t\t}\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif ((filename = k->xmss_filename) == NULL)\n\t\tgoto done;\n\tif (asprintf(&lockfile, \"%s.lock\", filename) < 0 ||\n\t    asprintf(&statefile, \"%s.state\", filename) < 0 ||\n\t    asprintf(&ostatefile, \"%s.ostate\", filename) < 0) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto done;\n\t}\n\tif ((lockfd = open(lockfile, O_CREAT|O_RDONLY, 0600)) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: cannot open/create: %s\", __func__, lockfile);\n\t\tgoto done;\n\t}\n\twhile (flock(lockfd, LOCK_EX|LOCK_NB) < 0) {\n\t\tif (errno != EWOULDBLOCK) {\n\t\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\t\tPRINT(\"%s: cannot lock: %s\", __func__, lockfile);\n\t\t\tgoto done;\n\t\t}\n\t\tif (++tries > 10) {\n\t\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\t\tPRINT(\"%s: giving up on: %s\", __func__, lockfile);\n\t\t\tgoto done;\n\t\t}\n\t\tusleep(1000*100*tries);\n\t}\n\t/* XXX no longer const */\n\tif ((r = sshkey_xmss_get_state_from_file((struct sshkey *)k,\n\t    statefile, &have_state, pr)) != 0) {\n\t\tif ((r = sshkey_xmss_get_state_from_file((struct sshkey *)k,\n\t\t    ostatefile, &have_ostate, pr)) == 0) {\n\t\t\tstate->allow_update = 1;\n\t\t\tr = sshkey_xmss_forward_state(k, 1);\n\t\t\tstate->idx = PEEK_U32(k->xmss_sk);\n\t\t\tstate->allow_update = 0;\n\t\t}\n\t}\n\tif (!have_state && !have_ostate) {\n\t\t/* check that bds state is initialized */\n\t\tif (state->bds.auth == NULL)\n\t\t\tgoto done;\n\t\tPRINT(\"%s: start from scratch idx 0: %u\", __func__, state->idx);\n\t} else if (r != 0) {\n\t\tret = r;\n\t\tgoto done;\n\t}\n\tif (state->idx + 1 < state->idx) {\n\t\tPRINT(\"%s: state wrap: %u\", __func__, state->idx);\n\t\tgoto done;\n\t}\n\tstate->have_state = have_state;\n\tstate->lockfd = lockfd;\n\tstate->allow_update = 1;\n\tlockfd = -1;\n\tret = 0;\ndone:\n\tif (lockfd != -1)\n\t\tclose(lockfd);\n\tfree(lockfile);\n\tfree(statefile);\n\tfree(ostatefile);\n\treturn ret;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_get_state(const struct sshkey *k, sshkey_printfn *pr)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_int32_t idx = 0;\n\tchar *filename = NULL;\n\tchar *statefile = NULL, *ostatefile = NULL, *lockfile = NULL;\n\tint lockfd = -1, have_state = 0, have_ostate, tries = 0;\n\tint ret = SSH_ERR_INVALID_ARGUMENT, r;\n\n\tif (state == NULL)\n\t\tgoto done;\n\t/*\n\t * If maxidx is set, then we are allowed a limited number\n\t * of signatures, but don't need to access the disk.\n\t * Otherwise we need to deal with the on-disk state.\n\t */\n\tif (state->maxidx) {\n\t\t/* xmss_sk always contains the current state */\n\t\tidx = PEEK_U32(k->xmss_sk);\n\t\tif (idx < state->maxidx) {\n\t\t\tstate->allow_update = 1;\n\t\t\treturn 0;\n\t\t}\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif ((filename = k->xmss_filename) == NULL)\n\t\tgoto done;\n\tif (asprintf(&lockfile, \"%s.lock\", filename) < 0 ||\n\t    asprintf(&statefile, \"%s.state\", filename) < 0 ||\n\t    asprintf(&ostatefile, \"%s.ostate\", filename) < 0) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto done;\n\t}\n\tif ((lockfd = open(lockfile, O_CREAT|O_RDONLY, 0600)) < 0) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"%s: cannot open/create: %s\", __func__, lockfile);\n\t\tgoto done;\n\t}\n\twhile (flock(lockfd, LOCK_EX|LOCK_NB) < 0) {\n\t\tif (errno != EWOULDBLOCK) {\n\t\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\t\tPRINT(\"%s: cannot lock: %s\", __func__, lockfile);\n\t\t\tgoto done;\n\t\t}\n\t\tif (++tries > 10) {\n\t\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\t\tPRINT(\"%s: giving up on: %s\", __func__, lockfile);\n\t\t\tgoto done;\n\t\t}\n\t\tusleep(1000*100*tries);\n\t}\n\t/* XXX no longer const */\n\tif ((r = sshkey_xmss_get_state_from_file((struct sshkey *)k,\n\t    statefile, &have_state, pr)) != 0) {\n\t\tif ((r = sshkey_xmss_get_state_from_file((struct sshkey *)k,\n\t\t    ostatefile, &have_ostate, pr)) == 0) {\n\t\t\tstate->allow_update = 1;\n\t\t\tr = sshkey_xmss_forward_state(k, 1);\n\t\t\tstate->idx = PEEK_U32(k->xmss_sk);\n\t\t\tstate->allow_update = 0;\n\t\t}\n\t}\n\tif (!have_state && !have_ostate) {\n\t\t/* check that bds state is initialized */\n\t\tif (state->bds.auth == NULL)\n\t\t\tgoto done;\n\t\tPRINT(\"%s: start from scratch idx 0: %u\", __func__, state->idx);\n\t} else if (r != 0) {\n\t\tret = r;\n\t\tgoto done;\n\t}\n\tif (state->idx + 1 < state->idx) {\n\t\tPRINT(\"%s: state wrap: %u\", __func__, state->idx);\n\t\tgoto done;\n\t}\n\tstate->have_state = have_state;\n\tstate->lockfd = lockfd;\n\tstate->allow_update = 1;\n\tlockfd = -1;\n\tret = 0;\ndone:\n\tif (lockfd != -1)\n\t\tclose(lockfd);\n\tfree(lockfile);\n\tfree(statefile);\n\tfree(ostatefile);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_xmss_siglen",
          "args": [
            "key",
            "&required_siglen"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_xmss_siglen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey-xmss.c",
          "lines": "230-243",
          "snippet": "int\nsshkey_xmss_siglen(const struct sshkey *key, size_t *lenp)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (lenp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t*lenp = 4 + state->n +\n\t    state->params.wots_par.keysize +\n\t    state->h * state->n;\n\treturn 0;\n}",
          "includes": [
            "#include \"xmss_fast.h\"",
            "#include \"atomicio.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "# include <sys/file.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <sys/uio.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"atomicio.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n# include <sys/file.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_xmss_siglen(const struct sshkey *key, size_t *lenp)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (lenp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t*lenp = 4 + state->n +\n\t    state->params.wots_par.keysize +\n\t    state->h * state->n;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sshkey_type_plain",
          "args": [
            "key->type"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "sshkey_type_plain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshkey.c",
          "lines": "341-358",
          "snippet": "int\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}",
          "includes": [
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include \"xmss_fast.h\"",
            "#include \"match.h\"",
            "#include \"sshkey-xmss.h\"",
            "#include \"sshkey.h\"",
            "#include \"digest.h\"",
            "#include \"cipher.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include <util.h>",
            "#include <resolv.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"crypto_api.h\"",
            "#include <openssl/pem.h>",
            "#include <openssl/err.h>",
            "#include <openssl/evp.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"openbsd-compat/openssl-compat.h\"\n#include \"xmss_fast.h\"\n#include \"match.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"cipher.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include <util.h>\n#include <resolv.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <errno.h>\n#include \"crypto_api.h\"\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xmss_fast.h\"\n#include \"ssh.h\"\n#include \"ssherr.h\"\n#include \"sshkey-xmss.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <limits.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nssh_xmss_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, u_int compat)\n{\n\tu_char *sig = NULL;\n\tsize_t slen = 0, len = 0, required_siglen;\n\tunsigned long long smlen;\n\tint r, ret;\n\tstruct sshbuf *b = NULL;\n\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\n\tif (key == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_XMSS ||\n\t    key->xmss_sk == NULL ||\n\t    sshkey_xmss_params(key) == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshkey_xmss_siglen(key, &required_siglen)) != 0)\n\t\treturn r;\n\tif (datalen >= INT_MAX - required_siglen)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tsmlen = slen = datalen + required_siglen;\n\tif ((sig = malloc(slen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_xmss_get_state(key, error)) != 0)\n\t\tgoto out;\n\tif ((ret = xmss_sign(key->xmss_sk, sshkey_xmss_bds_state(key), sig, &smlen,\n\t    data, datalen, sshkey_xmss_params(key))) != 0 || smlen <= datalen) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT; /* XXX better error? */\n\t\tgoto out;\n\t}\n\t/* encode signature */\n\tif ((b = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_cstring(b, \"ssh-xmss@openssh.com\")) != 0 ||\n\t    (r = sshbuf_put_string(b, sig, smlen - datalen)) != 0)\n\t\tgoto out;\n\tlen = sshbuf_len(b);\n\tif (sigp != NULL) {\n\t\tif ((*sigp = malloc(len)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*sigp, sshbuf_ptr(b), len);\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\t/* success */\n\tr = 0;\n out:\n\tif ((ret = sshkey_xmss_update_state(key, error)) != 0) {\n\t\t/* discard signature since we cannot update the state */\n\t\tif (r == 0 && sigp != NULL && *sigp != NULL) {\n\t\t\texplicit_bzero(*sigp, len);\n\t\t\tfree(*sigp);\n\t\t}\n\t\tif (sigp != NULL)\n\t\t\t*sigp = NULL;\n\t\tif (lenp != NULL)\n\t\t\t*lenp = 0;\n\t\tr = ret;\n\t}\n\tsshbuf_free(b);\n\tif (sig != NULL) {\n\t\texplicit_bzero(sig, slen);\n\t\tfree(sig);\n\t}\n\n\treturn r;\n}"
  }
]