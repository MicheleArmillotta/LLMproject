[
  {
    "function_name": "socks_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
    "lines": "1448-1663",
    "snippet": "int\nsocks_connect(const char *host, const char *port,\n    struct addrinfo hints __attribute__ ((__unused__)),\n    const char *proxyhost, const char *proxyport, struct addrinfo proxyhints,\n    int socksv, const char *proxyuser)\n{\n\tint proxyfd, r, authretry = 0;\n\tsize_t hlen, wlen = 0;\n\tunsigned char buf[1024];\n\tsize_t cnt;\n\tstruct sockaddr_storage addr;\n\tstruct sockaddr_in *in4 = (struct sockaddr_in *)&addr;\n\tstruct sockaddr_in6 *in6 = (struct sockaddr_in6 *)&addr;\n\tin_port_t serverport;\n\tconst char *proxypass = NULL;\n\n\tif (proxyport == NULL)\n\t\tproxyport = (socksv == -1) ? HTTP_PROXY_PORT : SOCKS_PORT;\n\n\t/* Abuse API to lookup port */\n\tif (decode_addrport(\"0.0.0.0\", port, (struct sockaddr *)&addr,\n\t    sizeof(addr), 1, 1) == -1)\n\t\terrx(1, \"unknown port \\\"%.64s\\\"\", port);\n\tserverport = in4->sin_port;\n\n again:\n\tif (authretry++ > 3)\n\t\terrx(1, \"Too many authentication failures\");\n\n\tproxyfd = remote_connect(proxyhost, proxyport, proxyhints);\n\n\tif (proxyfd < 0)\n\t\treturn (-1);\n\n\tif (socksv == 5) {\n\t\tif (decode_addrport(host, port, (struct sockaddr *)&addr,\n\t\t    sizeof(addr), 0, 1) == -1)\n\t\t\taddr.ss_family = 0; /* used in switch below */\n\n\t\t/* Version 5, one method: no authentication */\n\t\tbuf[0] = SOCKS_V5;\n\t\tbuf[1] = 1;\n\t\tbuf[2] = SOCKS_NOAUTH;\n\t\tcnt = atomicio(vwrite, proxyfd, buf, 3);\n\t\tif (cnt != 3)\n\t\t\terr(1, \"write failed (%zu/3)\", cnt);\n\n\t\tcnt = atomicio(read, proxyfd, buf, 2);\n\t\tif (cnt != 2)\n\t\t\terr(1, \"read failed (%zu/3)\", cnt);\n\n\t\tif (buf[1] == SOCKS_NOMETHOD)\n\t\t\terrx(1, \"authentication method negotiation failed\");\n\n\t\tswitch (addr.ss_family) {\n\t\tcase 0:\n\t\t\t/* Version 5, connect: domain name */\n\n\t\t\t/* Max domain name length is 255 bytes */\n\t\t\thlen = strlen(host);\n\t\t\tif (hlen > 255)\n\t\t\t\terrx(1, \"host name too long for SOCKS5\");\n\t\t\tbuf[0] = SOCKS_V5;\n\t\t\tbuf[1] = SOCKS_CONNECT;\n\t\t\tbuf[2] = 0;\n\t\t\tbuf[3] = SOCKS_DOMAIN;\n\t\t\tbuf[4] = hlen;\n\t\t\tmemcpy(buf + 5, host, hlen);\t\t\t\n\t\t\tmemcpy(buf + 5 + hlen, &serverport, sizeof serverport);\n\t\t\twlen = 7 + hlen;\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\t\t/* Version 5, connect: IPv4 address */\n\t\t\tbuf[0] = SOCKS_V5;\n\t\t\tbuf[1] = SOCKS_CONNECT;\n\t\t\tbuf[2] = 0;\n\t\t\tbuf[3] = SOCKS_IPV4;\n\t\t\tmemcpy(buf + 4, &in4->sin_addr, sizeof in4->sin_addr);\n\t\t\tmemcpy(buf + 8, &in4->sin_port, sizeof in4->sin_port);\n\t\t\twlen = 10;\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\t/* Version 5, connect: IPv6 address */\n\t\t\tbuf[0] = SOCKS_V5;\n\t\t\tbuf[1] = SOCKS_CONNECT;\n\t\t\tbuf[2] = 0;\n\t\t\tbuf[3] = SOCKS_IPV6;\n\t\t\tmemcpy(buf + 4, &in6->sin6_addr, sizeof in6->sin6_addr);\n\t\t\tmemcpy(buf + 20, &in6->sin6_port,\n\t\t\t    sizeof in6->sin6_port);\n\t\t\twlen = 22;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terrx(1, \"internal error: silly AF\");\n\t\t}\n\n\t\tcnt = atomicio(vwrite, proxyfd, buf, wlen);\n\t\tif (cnt != wlen)\n\t\t\terr(1, \"write failed (%zu/%zu)\", cnt, wlen);\n\n\t\tcnt = atomicio(read, proxyfd, buf, 4);\n\t\tif (cnt != 4)\n\t\t\terr(1, \"read failed (%zu/4)\", cnt);\n\t\tif (buf[1] != 0)\n\t\t\terrx(1, \"connection failed, SOCKS error %d\", buf[1]);\n\t\tswitch (buf[3]) {\n\t\tcase SOCKS_IPV4:\n\t\t\tcnt = atomicio(read, proxyfd, buf + 4, 6);\n\t\t\tif (cnt != 6)\n\t\t\t\terr(1, \"read failed (%zu/6)\", cnt);\n\t\t\tbreak;\n\t\tcase SOCKS_IPV6:\n\t\t\tcnt = atomicio(read, proxyfd, buf + 4, 18);\n\t\t\tif (cnt != 18)\n\t\t\t\terr(1, \"read failed (%zu/18)\", cnt);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terrx(1, \"connection failed, unsupported address type\");\n\t\t}\n\t} else if (socksv == 4) {\n\t\t/* This will exit on lookup failure */\n\t\tdecode_addrport(host, port, (struct sockaddr *)&addr,\n\t\t    sizeof(addr), 1, 0);\n\n\t\t/* Version 4 */\n\t\tbuf[0] = SOCKS_V4;\n\t\tbuf[1] = SOCKS_CONNECT;\t/* connect */\n\t\tmemcpy(buf + 2, &in4->sin_port, sizeof in4->sin_port);\n\t\tmemcpy(buf + 4, &in4->sin_addr, sizeof in4->sin_addr);\n\t\tbuf[8] = 0;\t/* empty username */\n\t\twlen = 9;\n\n\t\tcnt = atomicio(vwrite, proxyfd, buf, wlen);\n\t\tif (cnt != wlen)\n\t\t\terr(1, \"write failed (%zu/%zu)\", cnt, wlen);\n\n\t\tcnt = atomicio(read, proxyfd, buf, 8);\n\t\tif (cnt != 8)\n\t\t\terr(1, \"read failed (%zu/8)\", cnt);\n\t\tif (buf[1] != 90)\n\t\t\terrx(1, \"connection failed, SOCKS error %d\", buf[1]);\n\t} else if (socksv == -1) {\n\t\t/* HTTP proxy CONNECT */\n\n\t\t/* Disallow bad chars in hostname */\n\t\tif (strcspn(host, \"\\r\\n\\t []:\") != strlen(host))\n\t\t\terrx(1, \"Invalid hostname\");\n\n\t\t/* Try to be sane about numeric IPv6 addresses */\n\t\tif (strchr(host, ':') != NULL) {\n\t\t\tr = snprintf(buf, sizeof(buf),\n\t\t\t    \"CONNECT [%s]:%d HTTP/1.0\\r\\n\",\n\t\t\t    host, ntohs(serverport));\n\t\t} else {\n\t\t\tr = snprintf(buf, sizeof(buf),\n\t\t\t    \"CONNECT %s:%d HTTP/1.0\\r\\n\",\n\t\t\t    host, ntohs(serverport));\n\t\t}\n\t\tif (r == -1 || (size_t)r >= sizeof(buf))\n\t\t\terrx(1, \"hostname too long\");\n\t\tr = strlen(buf);\n\n\t\tcnt = atomicio(vwrite, proxyfd, buf, r);\n\t\tif (cnt != (size_t)r)\n\t\t\terr(1, \"write failed (%zu/%d)\", cnt, r);\n\n\t\tif (authretry > 1) {\n\t\t\tchar resp[1024];\n\n\t\t\tproxypass = getproxypass(proxyuser, proxyhost);\n\t\t\tr = snprintf(buf, sizeof(buf), \"%s:%s\",\n\t\t\t    proxyuser, proxypass);\n\t\t\tif (r == -1 || (size_t)r >= sizeof(buf) ||\n\t\t\t    b64_ntop(buf, strlen(buf), resp,\n\t\t\t    sizeof(resp)) == -1)\n\t\t\t\terrx(1, \"Proxy username/password too long\");\n\t\t\tr = snprintf(buf, sizeof(buf), \"Proxy-Authorization: \"\n\t\t\t    \"Basic %s\\r\\n\", resp);\n\t\t\tif (r == -1 || (size_t)r >= sizeof(buf))\n\t\t\t\terrx(1, \"Proxy auth response too long\");\n\t\t\tr = strlen(buf);\n\t\t\tif ((cnt = atomicio(vwrite, proxyfd, buf, r)) != (size_t)r)\n\t\t\t\terr(1, \"write failed (%zu/%d)\", cnt, r);\n\t\t}\n\n\t\t/* Terminate headers */\n\t\tif ((r = atomicio(vwrite, proxyfd, \"\\r\\n\", 2)) != 2)\n\t\t\terr(1, \"write failed (2/%d)\", r);\n\n\t\t/* Read status reply */\n\t\tproxy_read_line(proxyfd, buf, sizeof(buf));\n\t\tif (proxyuser != NULL &&\n\t\t    strncmp(buf, \"HTTP/1.0 407 \", 12) == 0) {\n\t\t\tif (authretry > 1) {\n\t\t\t\tfprintf(stderr, \"Proxy authentication \"\n\t\t\t\t    \"failed\\n\");\n\t\t\t}\n\t\t\tclose(proxyfd);\n\t\t\tgoto again;\n\t\t} else if (strncmp(buf, \"HTTP/1.0 200 \", 12) != 0 &&\n\t\t    strncmp(buf, \"HTTP/1.1 200 \", 12) != 0)\n\t\t\terrx(1, \"Proxy error: \\\"%s\\\"\", buf);\n\n\t\t/* Headers continue until we hit an empty line */\n\t\tfor (r = 0; r < HTTP_MAXHDRS; r++) {\n\t\t\tproxy_read_line(proxyfd, buf, sizeof(buf));\n\t\t\tif (*buf == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*buf != '\\0')\n\t\t\terrx(1, \"Too many proxy headers received\");\n\t} else\n\t\terrx(1, \"Unknown proxy protocol %d\", socksv);\n\n\treturn (proxyfd);\n}",
    "includes": [
      "#include <resolv.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "# include <err.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/uio.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define SOCKS_IPV6\t4",
      "#define SOCKS_DOMAIN\t3",
      "#define SOCKS_IPV4\t1",
      "#define SOCKS_CONNECT\t1",
      "#define SOCKS_NOMETHOD\t0xff",
      "#define SOCKS_NOAUTH\t0",
      "#define SOCKS_V4\t4",
      "#define SOCKS_V5\t5",
      "#define HTTP_MAXHDRS\t64",
      "#define HTTP_PROXY_PORT\t\"3128\"",
      "#define SOCKS_PORT\t\"1080\""
    ],
    "globals_used": [
      "int\tlocal_listen(char *, char *, struct addrinfo);",
      "int\tremote_connect(const char *, const char *, struct addrinfo);",
      "int\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int, const char *);",
      "ssize_t drainbuf(int, unsigned char *, size_t *);",
      "ssize_t fillbuf(int, unsigned char *, size_t *);",
      "int\tremote_connect(const char *, const char *, struct addrinfo);",
      "int\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int,\n\t    const char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"Unknown proxy protocol %d\"",
            "socksv"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "errx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-err.c",
          "lines": "52-62",
          "snippet": "void\nerrx(int r, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(r);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\nvoid\nerrx(int r, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proxy_read_line",
          "args": [
            "proxyfd",
            "buf",
            "sizeof(buf)"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "proxy_read_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "1413-1433",
          "snippet": "static int\nproxy_read_line(int fd, char *buf, size_t bufsz)\n{\n\tsize_t off;\n\n\tfor(off = 0;;) {\n\t\tif (off >= bufsz)\n\t\t\terrx(1, \"proxy read too long\");\n\t\tif (atomicio(read, fd, buf + off, 1) != 1)\n\t\t\terr(1, \"proxy read\");\n\t\t/* Skip CR */\n\t\tif (buf[off] == '\\r')\n\t\t\tcontinue;\n\t\tif (buf[off] == '\\n') {\n\t\t\tbuf[off] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t}\n\treturn (off);\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ssize_t drainbuf(int, unsigned char *, size_t *);",
            "ssize_t fillbuf(int, unsigned char *, size_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nssize_t drainbuf(int, unsigned char *, size_t *);\nssize_t fillbuf(int, unsigned char *, size_t *);\n\nstatic int\nproxy_read_line(int fd, char *buf, size_t bufsz)\n{\n\tsize_t off;\n\n\tfor(off = 0;;) {\n\t\tif (off >= bufsz)\n\t\t\terrx(1, \"proxy read too long\");\n\t\tif (atomicio(read, fd, buf + off, 1) != 1)\n\t\t\terr(1, \"proxy read\");\n\t\t/* Skip CR */\n\t\tif (buf[off] == '\\r')\n\t\t\tcontinue;\n\t\tif (buf[off] == '\\n') {\n\t\t\tbuf[off] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t}\n\treturn (off);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"HTTP/1.1 200 \"",
            "12"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "g_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "422-435",
          "snippet": "static int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "proxyfd"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Proxy authentication \"\n\t\t\t\t    \"failed\\n\""
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"write failed (2/%d)\"",
            "r"
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "run_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1323-1346",
          "snippet": "void\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void run_err(const char *,...);",
            "int errs, remin, remout;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid run_err(const char *,...);\nint errs, remin, remout;\n\nvoid\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomicio",
          "args": [
            "vwrite",
            "proxyfd",
            "\"\\r\\n\"",
            "2"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "atomiciov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "165-170",
          "snippet": "size_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"Proxy-Authorization: \"\n\t\t\t    \"Basic %s\\r\\n\"",
            "resp"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "b64_ntop",
          "args": [
            "buf",
            "strlen(buf)",
            "resp",
            "sizeof(resp)"
          ],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "b64_ntop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/base64.c",
          "lines": "133-185",
          "snippet": "int\nb64_ntop(u_char const *src, size_t srclength, char *target, size_t targsize)\n{\n\tsize_t datalength = 0;\n\tu_char input[3];\n\tu_char output[4];\n\tu_int i;\n\n\twhile (2 < srclength) {\n\t\tinput[0] = *src++;\n\t\tinput[1] = *src++;\n\t\tinput[2] = *src++;\n\t\tsrclength -= 3;\n\n\t\toutput[0] = input[0] >> 2;\n\t\toutput[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);\n\t\toutput[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);\n\t\toutput[3] = input[2] & 0x3f;\n\n\t\tif (datalength + 4 > targsize)\n\t\t\treturn (-1);\n\t\ttarget[datalength++] = Base64[output[0]];\n\t\ttarget[datalength++] = Base64[output[1]];\n\t\ttarget[datalength++] = Base64[output[2]];\n\t\ttarget[datalength++] = Base64[output[3]];\n\t}\n    \n\t/* Now we worry about padding. */\n\tif (0 != srclength) {\n\t\t/* Get what's left. */\n\t\tinput[0] = input[1] = input[2] = '\\0';\n\t\tfor (i = 0; i < srclength; i++)\n\t\t\tinput[i] = *src++;\n\t\n\t\toutput[0] = input[0] >> 2;\n\t\toutput[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);\n\t\toutput[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);\n\n\t\tif (datalength + 4 > targsize)\n\t\t\treturn (-1);\n\t\ttarget[datalength++] = Base64[output[0]];\n\t\ttarget[datalength++] = Base64[output[1]];\n\t\tif (srclength == 1)\n\t\t\ttarget[datalength++] = Pad64;\n\t\telse\n\t\t\ttarget[datalength++] = Base64[output[2]];\n\t\ttarget[datalength++] = Pad64;\n\t}\n\tif (datalength >= targsize)\n\t\treturn (-1);\n\ttarget[datalength] = '\\0';\t/* Returned value doesn't count \\0. */\n\treturn (datalength);\n}",
          "includes": [
            "#include \"base64.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base64.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nb64_ntop(u_char const *src, size_t srclength, char *target, size_t targsize)\n{\n\tsize_t datalength = 0;\n\tu_char input[3];\n\tu_char output[4];\n\tu_int i;\n\n\twhile (2 < srclength) {\n\t\tinput[0] = *src++;\n\t\tinput[1] = *src++;\n\t\tinput[2] = *src++;\n\t\tsrclength -= 3;\n\n\t\toutput[0] = input[0] >> 2;\n\t\toutput[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);\n\t\toutput[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);\n\t\toutput[3] = input[2] & 0x3f;\n\n\t\tif (datalength + 4 > targsize)\n\t\t\treturn (-1);\n\t\ttarget[datalength++] = Base64[output[0]];\n\t\ttarget[datalength++] = Base64[output[1]];\n\t\ttarget[datalength++] = Base64[output[2]];\n\t\ttarget[datalength++] = Base64[output[3]];\n\t}\n    \n\t/* Now we worry about padding. */\n\tif (0 != srclength) {\n\t\t/* Get what's left. */\n\t\tinput[0] = input[1] = input[2] = '\\0';\n\t\tfor (i = 0; i < srclength; i++)\n\t\t\tinput[i] = *src++;\n\t\n\t\toutput[0] = input[0] >> 2;\n\t\toutput[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);\n\t\toutput[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);\n\n\t\tif (datalength + 4 > targsize)\n\t\t\treturn (-1);\n\t\ttarget[datalength++] = Base64[output[0]];\n\t\ttarget[datalength++] = Base64[output[1]];\n\t\tif (srclength == 1)\n\t\t\ttarget[datalength++] = Pad64;\n\t\telse\n\t\t\ttarget[datalength++] = Base64[output[2]];\n\t\ttarget[datalength++] = Pad64;\n\t}\n\tif (datalength >= targsize)\n\t\treturn (-1);\n\ttarget[datalength] = '\\0';\t/* Returned value doesn't count \\0. */\n\treturn (datalength);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getproxypass",
          "args": [
            "proxyuser",
            "proxyhost"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "getproxypass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "1435-1446",
          "snippet": "static const char *\ngetproxypass(const char *proxyuser, const char *proxyhost)\n{\n\tchar prompt[512];\n\tstatic char pw[256];\n\n\tsnprintf(prompt, sizeof(prompt), \"Proxy password for %s@%s: \",\n\t   proxyuser, proxyhost);\n\tif (readpassphrase(prompt, pw, sizeof(pw), RPP_REQUIRE_TTY) == NULL)\n\t\terrx(1, \"Unable to read proxy passphrase\");\n\treturn (pw);\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\ngetproxypass(const char *proxyuser, const char *proxyhost)\n{\n\tchar prompt[512];\n\tstatic char pw[256];\n\n\tsnprintf(prompt, sizeof(prompt), \"Proxy password for %s@%s: \",\n\t   proxyuser, proxyhost);\n\tif (readpassphrase(prompt, pw, sizeof(pw), RPP_REQUIRE_TTY) == NULL)\n\t\terrx(1, \"Unable to read proxy passphrase\");\n\treturn (pw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "serverport"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "serverport"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "host",
            "':'"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "host"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "host",
            "\"\\r\\n\\t []:\""
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf + 4",
            "&in4->sin_addr",
            "sizeof in4->sin_addr"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf + 2",
            "&in4->sin_port",
            "sizeof in4->sin_port"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_addrport",
          "args": [
            "host",
            "port",
            "(struct sockaddr *)&addr",
            "sizeof(addr)",
            "1",
            "0"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "decode_addrport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "1384-1411",
          "snippet": "static int\ndecode_addrport(const char *h, const char *p, struct sockaddr *addr,\n    socklen_t addrlen, int v4only, int numeric)\n{\n\tint r;\n\tstruct addrinfo hints, *res;\n\n\tbzero(&hints, sizeof(hints));\n\thints.ai_family = v4only ? PF_INET : PF_UNSPEC;\n\thints.ai_flags = numeric ? AI_NUMERICHOST : 0;\n\thints.ai_socktype = SOCK_STREAM;\n\tr = getaddrinfo(h, p, &hints, &res);\n\t/* Don't fatal when attempting to convert a numeric address */\n\tif (r != 0) {\n\t\tif (!numeric) {\n\t\t\terrx(1, \"getaddrinfo(\\\"%.64s\\\", \\\"%.64s\\\"): %s\", h, p,\n\t\t\t    gai_strerror(r));\n\t\t}\n\t\treturn (-1);\n\t}\n\tif (addrlen < res->ai_addrlen) {\n\t\tfreeaddrinfo(res);\n\t\terrx(1, \"internal error: addrlen < res->ai_addrlen\");\n\t}\n\tmemcpy(addr, res->ai_addr, res->ai_addrlen);\n\tfreeaddrinfo(res);\n\treturn (0);\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tlocal_listen(char *, char *, struct addrinfo);",
            "int\tremote_connect(const char *, const char *, struct addrinfo);",
            "int\ttimeout_connect(int, const struct sockaddr *, socklen_t);",
            "int\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int, const char *);",
            "void\treport_connect(const struct sockaddr *, socklen_t);",
            "int\tremote_connect(const char *, const char *, struct addrinfo);",
            "int\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int,\n\t    const char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tlocal_listen(char *, char *, struct addrinfo);\nint\tremote_connect(const char *, const char *, struct addrinfo);\nint\ttimeout_connect(int, const struct sockaddr *, socklen_t);\nint\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int, const char *);\nvoid\treport_connect(const struct sockaddr *, socklen_t);\nint\tremote_connect(const char *, const char *, struct addrinfo);\nint\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int,\n\t    const char *);\n\nstatic int\ndecode_addrport(const char *h, const char *p, struct sockaddr *addr,\n    socklen_t addrlen, int v4only, int numeric)\n{\n\tint r;\n\tstruct addrinfo hints, *res;\n\n\tbzero(&hints, sizeof(hints));\n\thints.ai_family = v4only ? PF_INET : PF_UNSPEC;\n\thints.ai_flags = numeric ? AI_NUMERICHOST : 0;\n\thints.ai_socktype = SOCK_STREAM;\n\tr = getaddrinfo(h, p, &hints, &res);\n\t/* Don't fatal when attempting to convert a numeric address */\n\tif (r != 0) {\n\t\tif (!numeric) {\n\t\t\terrx(1, \"getaddrinfo(\\\"%.64s\\\", \\\"%.64s\\\"): %s\", h, p,\n\t\t\t    gai_strerror(r));\n\t\t}\n\t\treturn (-1);\n\t}\n\tif (addrlen < res->ai_addrlen) {\n\t\tfreeaddrinfo(res);\n\t\terrx(1, \"internal error: addrlen < res->ai_addrlen\");\n\t}\n\tmemcpy(addr, res->ai_addr, res->ai_addrlen);\n\tfreeaddrinfo(res);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf + 20",
            "&in6->sin6_port",
            "sizeof in6->sin6_port"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf + 4",
            "&in6->sin6_addr",
            "sizeof in6->sin6_addr"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf + 8",
            "&in4->sin_port",
            "sizeof in4->sin_port"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf + 4",
            "&in4->sin_addr",
            "sizeof in4->sin_addr"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf + 5 + hlen",
            "&serverport",
            "sizeof serverport"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf + 5",
            "host",
            "hlen"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "host"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remote_connect",
          "args": [
            "proxyhost",
            "proxyport",
            "proxyhints"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "remote_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "603-663",
          "snippet": "int\nremote_connect(const char *host, const char *port, struct addrinfo hints)\n{\n\tstruct addrinfo *res, *res0;\n\tint s, error;\n#if defined(SO_RTABLE) || defined(SO_BINDANY)\n\tint on = 1;\n#endif\n\n\tif ((error = getaddrinfo(host, port, &hints, &res)))\n\t\terrx(1, \"getaddrinfo: %s\", gai_strerror(error));\n\n\tres0 = res;\n\tdo {\n\t\tif ((s = socket(res0->ai_family, res0->ai_socktype,\n\t\t    res0->ai_protocol)) < 0)\n\t\t\tcontinue;\n\n#ifdef SO_RTABLE\n\t\tif (rtableid >= 0 && (setsockopt(s, SOL_SOCKET, SO_RTABLE,\n\t\t    &rtableid, sizeof(rtableid)) == -1))\n\t\t\terr(1, \"setsockopt SO_RTABLE\");\n#endif\n\t\t/* Bind to a local port or source address if specified. */\n\t\tif (sflag || pflag) {\n\t\t\tstruct addrinfo ahints, *ares;\n\n#ifdef SO_BINDANY\n\t\t\t/* try SO_BINDANY, but don't insist */\n\t\t\tsetsockopt(s, SOL_SOCKET, SO_BINDANY, &on, sizeof(on));\n#endif\n\t\t\tmemset(&ahints, 0, sizeof(struct addrinfo));\n\t\t\tahints.ai_family = res0->ai_family;\n\t\t\tahints.ai_socktype = uflag ? SOCK_DGRAM : SOCK_STREAM;\n\t\t\tahints.ai_protocol = uflag ? IPPROTO_UDP : IPPROTO_TCP;\n\t\t\tahints.ai_flags = AI_PASSIVE;\n\t\t\tif ((error = getaddrinfo(sflag, pflag, &ahints, &ares)))\n\t\t\t\terrx(1, \"getaddrinfo: %s\", gai_strerror(error));\n\n\t\t\tif (bind(s, (struct sockaddr *)ares->ai_addr,\n\t\t\t    ares->ai_addrlen) < 0)\n\t\t\t\terr(1, \"bind failed\");\n\t\t\tfreeaddrinfo(ares);\n\t\t}\n\n\t\tset_common_sockopts(s);\n\n\t\tif (timeout_connect(s, res0->ai_addr, res0->ai_addrlen) == 0)\n\t\t\tbreak;\n\t\telse if (vflag)\n\t\t\twarn(\"connect to %s port %s (%s) failed\", host, port,\n\t\t\t    uflag ? \"udp\" : \"tcp\");\n\n\t\tclose(s);\n\t\ts = -1;\n\t} while ((res0 = res0->ai_next) != NULL);\n\n\tfreeaddrinfo(res);\n\n\treturn (s);\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char   *pflag;",
            "char   *sflag;",
            "int\tuflag;",
            "int\tvflag;",
            "int\trtableid = -1;",
            "int\tlocal_listen(char *, char *, struct addrinfo);",
            "int\tremote_connect(const char *, const char *, struct addrinfo);",
            "int\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int, const char *);",
            "void\tset_common_sockopts(int);",
            "int\tremote_connect(const char *, const char *, struct addrinfo);",
            "int\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int,\n\t    const char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar   *pflag;\nchar   *sflag;\nint\tuflag;\nint\tvflag;\nint\trtableid = -1;\nint\tlocal_listen(char *, char *, struct addrinfo);\nint\tremote_connect(const char *, const char *, struct addrinfo);\nint\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int, const char *);\nvoid\tset_common_sockopts(int);\nint\tremote_connect(const char *, const char *, struct addrinfo);\nint\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int,\n\t    const char *);\n\nint\nremote_connect(const char *host, const char *port, struct addrinfo hints)\n{\n\tstruct addrinfo *res, *res0;\n\tint s, error;\n#if defined(SO_RTABLE) || defined(SO_BINDANY)\n\tint on = 1;\n#endif\n\n\tif ((error = getaddrinfo(host, port, &hints, &res)))\n\t\terrx(1, \"getaddrinfo: %s\", gai_strerror(error));\n\n\tres0 = res;\n\tdo {\n\t\tif ((s = socket(res0->ai_family, res0->ai_socktype,\n\t\t    res0->ai_protocol)) < 0)\n\t\t\tcontinue;\n\n#ifdef SO_RTABLE\n\t\tif (rtableid >= 0 && (setsockopt(s, SOL_SOCKET, SO_RTABLE,\n\t\t    &rtableid, sizeof(rtableid)) == -1))\n\t\t\terr(1, \"setsockopt SO_RTABLE\");\n#endif\n\t\t/* Bind to a local port or source address if specified. */\n\t\tif (sflag || pflag) {\n\t\t\tstruct addrinfo ahints, *ares;\n\n#ifdef SO_BINDANY\n\t\t\t/* try SO_BINDANY, but don't insist */\n\t\t\tsetsockopt(s, SOL_SOCKET, SO_BINDANY, &on, sizeof(on));\n#endif\n\t\t\tmemset(&ahints, 0, sizeof(struct addrinfo));\n\t\t\tahints.ai_family = res0->ai_family;\n\t\t\tahints.ai_socktype = uflag ? SOCK_DGRAM : SOCK_STREAM;\n\t\t\tahints.ai_protocol = uflag ? IPPROTO_UDP : IPPROTO_TCP;\n\t\t\tahints.ai_flags = AI_PASSIVE;\n\t\t\tif ((error = getaddrinfo(sflag, pflag, &ahints, &ares)))\n\t\t\t\terrx(1, \"getaddrinfo: %s\", gai_strerror(error));\n\n\t\t\tif (bind(s, (struct sockaddr *)ares->ai_addr,\n\t\t\t    ares->ai_addrlen) < 0)\n\t\t\t\terr(1, \"bind failed\");\n\t\t\tfreeaddrinfo(ares);\n\t\t}\n\n\t\tset_common_sockopts(s);\n\n\t\tif (timeout_connect(s, res0->ai_addr, res0->ai_addrlen) == 0)\n\t\t\tbreak;\n\t\telse if (vflag)\n\t\t\twarn(\"connect to %s port %s (%s) failed\", host, port,\n\t\t\t    uflag ? \"udp\" : \"tcp\");\n\n\t\tclose(s);\n\t\ts = -1;\n\t} while ((res0 = res0->ai_next) != NULL);\n\n\tfreeaddrinfo(res);\n\n\treturn (s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SOCKS_IPV6\t4\n#define SOCKS_DOMAIN\t3\n#define SOCKS_IPV4\t1\n#define SOCKS_CONNECT\t1\n#define SOCKS_NOMETHOD\t0xff\n#define SOCKS_NOAUTH\t0\n#define SOCKS_V4\t4\n#define SOCKS_V5\t5\n#define HTTP_MAXHDRS\t64\n#define HTTP_PROXY_PORT\t\"3128\"\n#define SOCKS_PORT\t\"1080\"\n\nint\tlocal_listen(char *, char *, struct addrinfo);\nint\tremote_connect(const char *, const char *, struct addrinfo);\nint\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int, const char *);\nssize_t drainbuf(int, unsigned char *, size_t *);\nssize_t fillbuf(int, unsigned char *, size_t *);\nint\tremote_connect(const char *, const char *, struct addrinfo);\nint\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int,\n\t    const char *);\n\nint\nsocks_connect(const char *host, const char *port,\n    struct addrinfo hints __attribute__ ((__unused__)),\n    const char *proxyhost, const char *proxyport, struct addrinfo proxyhints,\n    int socksv, const char *proxyuser)\n{\n\tint proxyfd, r, authretry = 0;\n\tsize_t hlen, wlen = 0;\n\tunsigned char buf[1024];\n\tsize_t cnt;\n\tstruct sockaddr_storage addr;\n\tstruct sockaddr_in *in4 = (struct sockaddr_in *)&addr;\n\tstruct sockaddr_in6 *in6 = (struct sockaddr_in6 *)&addr;\n\tin_port_t serverport;\n\tconst char *proxypass = NULL;\n\n\tif (proxyport == NULL)\n\t\tproxyport = (socksv == -1) ? HTTP_PROXY_PORT : SOCKS_PORT;\n\n\t/* Abuse API to lookup port */\n\tif (decode_addrport(\"0.0.0.0\", port, (struct sockaddr *)&addr,\n\t    sizeof(addr), 1, 1) == -1)\n\t\terrx(1, \"unknown port \\\"%.64s\\\"\", port);\n\tserverport = in4->sin_port;\n\n again:\n\tif (authretry++ > 3)\n\t\terrx(1, \"Too many authentication failures\");\n\n\tproxyfd = remote_connect(proxyhost, proxyport, proxyhints);\n\n\tif (proxyfd < 0)\n\t\treturn (-1);\n\n\tif (socksv == 5) {\n\t\tif (decode_addrport(host, port, (struct sockaddr *)&addr,\n\t\t    sizeof(addr), 0, 1) == -1)\n\t\t\taddr.ss_family = 0; /* used in switch below */\n\n\t\t/* Version 5, one method: no authentication */\n\t\tbuf[0] = SOCKS_V5;\n\t\tbuf[1] = 1;\n\t\tbuf[2] = SOCKS_NOAUTH;\n\t\tcnt = atomicio(vwrite, proxyfd, buf, 3);\n\t\tif (cnt != 3)\n\t\t\terr(1, \"write failed (%zu/3)\", cnt);\n\n\t\tcnt = atomicio(read, proxyfd, buf, 2);\n\t\tif (cnt != 2)\n\t\t\terr(1, \"read failed (%zu/3)\", cnt);\n\n\t\tif (buf[1] == SOCKS_NOMETHOD)\n\t\t\terrx(1, \"authentication method negotiation failed\");\n\n\t\tswitch (addr.ss_family) {\n\t\tcase 0:\n\t\t\t/* Version 5, connect: domain name */\n\n\t\t\t/* Max domain name length is 255 bytes */\n\t\t\thlen = strlen(host);\n\t\t\tif (hlen > 255)\n\t\t\t\terrx(1, \"host name too long for SOCKS5\");\n\t\t\tbuf[0] = SOCKS_V5;\n\t\t\tbuf[1] = SOCKS_CONNECT;\n\t\t\tbuf[2] = 0;\n\t\t\tbuf[3] = SOCKS_DOMAIN;\n\t\t\tbuf[4] = hlen;\n\t\t\tmemcpy(buf + 5, host, hlen);\t\t\t\n\t\t\tmemcpy(buf + 5 + hlen, &serverport, sizeof serverport);\n\t\t\twlen = 7 + hlen;\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\t\t/* Version 5, connect: IPv4 address */\n\t\t\tbuf[0] = SOCKS_V5;\n\t\t\tbuf[1] = SOCKS_CONNECT;\n\t\t\tbuf[2] = 0;\n\t\t\tbuf[3] = SOCKS_IPV4;\n\t\t\tmemcpy(buf + 4, &in4->sin_addr, sizeof in4->sin_addr);\n\t\t\tmemcpy(buf + 8, &in4->sin_port, sizeof in4->sin_port);\n\t\t\twlen = 10;\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\t/* Version 5, connect: IPv6 address */\n\t\t\tbuf[0] = SOCKS_V5;\n\t\t\tbuf[1] = SOCKS_CONNECT;\n\t\t\tbuf[2] = 0;\n\t\t\tbuf[3] = SOCKS_IPV6;\n\t\t\tmemcpy(buf + 4, &in6->sin6_addr, sizeof in6->sin6_addr);\n\t\t\tmemcpy(buf + 20, &in6->sin6_port,\n\t\t\t    sizeof in6->sin6_port);\n\t\t\twlen = 22;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terrx(1, \"internal error: silly AF\");\n\t\t}\n\n\t\tcnt = atomicio(vwrite, proxyfd, buf, wlen);\n\t\tif (cnt != wlen)\n\t\t\terr(1, \"write failed (%zu/%zu)\", cnt, wlen);\n\n\t\tcnt = atomicio(read, proxyfd, buf, 4);\n\t\tif (cnt != 4)\n\t\t\terr(1, \"read failed (%zu/4)\", cnt);\n\t\tif (buf[1] != 0)\n\t\t\terrx(1, \"connection failed, SOCKS error %d\", buf[1]);\n\t\tswitch (buf[3]) {\n\t\tcase SOCKS_IPV4:\n\t\t\tcnt = atomicio(read, proxyfd, buf + 4, 6);\n\t\t\tif (cnt != 6)\n\t\t\t\terr(1, \"read failed (%zu/6)\", cnt);\n\t\t\tbreak;\n\t\tcase SOCKS_IPV6:\n\t\t\tcnt = atomicio(read, proxyfd, buf + 4, 18);\n\t\t\tif (cnt != 18)\n\t\t\t\terr(1, \"read failed (%zu/18)\", cnt);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terrx(1, \"connection failed, unsupported address type\");\n\t\t}\n\t} else if (socksv == 4) {\n\t\t/* This will exit on lookup failure */\n\t\tdecode_addrport(host, port, (struct sockaddr *)&addr,\n\t\t    sizeof(addr), 1, 0);\n\n\t\t/* Version 4 */\n\t\tbuf[0] = SOCKS_V4;\n\t\tbuf[1] = SOCKS_CONNECT;\t/* connect */\n\t\tmemcpy(buf + 2, &in4->sin_port, sizeof in4->sin_port);\n\t\tmemcpy(buf + 4, &in4->sin_addr, sizeof in4->sin_addr);\n\t\tbuf[8] = 0;\t/* empty username */\n\t\twlen = 9;\n\n\t\tcnt = atomicio(vwrite, proxyfd, buf, wlen);\n\t\tif (cnt != wlen)\n\t\t\terr(1, \"write failed (%zu/%zu)\", cnt, wlen);\n\n\t\tcnt = atomicio(read, proxyfd, buf, 8);\n\t\tif (cnt != 8)\n\t\t\terr(1, \"read failed (%zu/8)\", cnt);\n\t\tif (buf[1] != 90)\n\t\t\terrx(1, \"connection failed, SOCKS error %d\", buf[1]);\n\t} else if (socksv == -1) {\n\t\t/* HTTP proxy CONNECT */\n\n\t\t/* Disallow bad chars in hostname */\n\t\tif (strcspn(host, \"\\r\\n\\t []:\") != strlen(host))\n\t\t\terrx(1, \"Invalid hostname\");\n\n\t\t/* Try to be sane about numeric IPv6 addresses */\n\t\tif (strchr(host, ':') != NULL) {\n\t\t\tr = snprintf(buf, sizeof(buf),\n\t\t\t    \"CONNECT [%s]:%d HTTP/1.0\\r\\n\",\n\t\t\t    host, ntohs(serverport));\n\t\t} else {\n\t\t\tr = snprintf(buf, sizeof(buf),\n\t\t\t    \"CONNECT %s:%d HTTP/1.0\\r\\n\",\n\t\t\t    host, ntohs(serverport));\n\t\t}\n\t\tif (r == -1 || (size_t)r >= sizeof(buf))\n\t\t\terrx(1, \"hostname too long\");\n\t\tr = strlen(buf);\n\n\t\tcnt = atomicio(vwrite, proxyfd, buf, r);\n\t\tif (cnt != (size_t)r)\n\t\t\terr(1, \"write failed (%zu/%d)\", cnt, r);\n\n\t\tif (authretry > 1) {\n\t\t\tchar resp[1024];\n\n\t\t\tproxypass = getproxypass(proxyuser, proxyhost);\n\t\t\tr = snprintf(buf, sizeof(buf), \"%s:%s\",\n\t\t\t    proxyuser, proxypass);\n\t\t\tif (r == -1 || (size_t)r >= sizeof(buf) ||\n\t\t\t    b64_ntop(buf, strlen(buf), resp,\n\t\t\t    sizeof(resp)) == -1)\n\t\t\t\terrx(1, \"Proxy username/password too long\");\n\t\t\tr = snprintf(buf, sizeof(buf), \"Proxy-Authorization: \"\n\t\t\t    \"Basic %s\\r\\n\", resp);\n\t\t\tif (r == -1 || (size_t)r >= sizeof(buf))\n\t\t\t\terrx(1, \"Proxy auth response too long\");\n\t\t\tr = strlen(buf);\n\t\t\tif ((cnt = atomicio(vwrite, proxyfd, buf, r)) != (size_t)r)\n\t\t\t\terr(1, \"write failed (%zu/%d)\", cnt, r);\n\t\t}\n\n\t\t/* Terminate headers */\n\t\tif ((r = atomicio(vwrite, proxyfd, \"\\r\\n\", 2)) != 2)\n\t\t\terr(1, \"write failed (2/%d)\", r);\n\n\t\t/* Read status reply */\n\t\tproxy_read_line(proxyfd, buf, sizeof(buf));\n\t\tif (proxyuser != NULL &&\n\t\t    strncmp(buf, \"HTTP/1.0 407 \", 12) == 0) {\n\t\t\tif (authretry > 1) {\n\t\t\t\tfprintf(stderr, \"Proxy authentication \"\n\t\t\t\t    \"failed\\n\");\n\t\t\t}\n\t\t\tclose(proxyfd);\n\t\t\tgoto again;\n\t\t} else if (strncmp(buf, \"HTTP/1.0 200 \", 12) != 0 &&\n\t\t    strncmp(buf, \"HTTP/1.1 200 \", 12) != 0)\n\t\t\terrx(1, \"Proxy error: \\\"%s\\\"\", buf);\n\n\t\t/* Headers continue until we hit an empty line */\n\t\tfor (r = 0; r < HTTP_MAXHDRS; r++) {\n\t\t\tproxy_read_line(proxyfd, buf, sizeof(buf));\n\t\t\tif (*buf == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*buf != '\\0')\n\t\t\terrx(1, \"Too many proxy headers received\");\n\t} else\n\t\terrx(1, \"Unknown proxy protocol %d\", socksv);\n\n\treturn (proxyfd);\n}"
  },
  {
    "function_name": "getproxypass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
    "lines": "1435-1446",
    "snippet": "static const char *\ngetproxypass(const char *proxyuser, const char *proxyhost)\n{\n\tchar prompt[512];\n\tstatic char pw[256];\n\n\tsnprintf(prompt, sizeof(prompt), \"Proxy password for %s@%s: \",\n\t   proxyuser, proxyhost);\n\tif (readpassphrase(prompt, pw, sizeof(pw), RPP_REQUIRE_TTY) == NULL)\n\t\terrx(1, \"Unable to read proxy passphrase\");\n\treturn (pw);\n}",
    "includes": [
      "#include <resolv.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "# include <err.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/uio.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"Unable to read proxy passphrase\""
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "errx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-err.c",
          "lines": "52-62",
          "snippet": "void\nerrx(int r, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(r);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\nvoid\nerrx(int r, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "readpassphrase",
          "args": [
            "prompt",
            "pw",
            "sizeof(pw)",
            "RPP_REQUIRE_TTY"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "readpassphrase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/readpassphrase.c",
          "lines": "53-193",
          "snippet": "char *\nreadpassphrase(const char *prompt, char *buf, size_t bufsiz, int flags)\n{\n\tssize_t nr;\n\tint input, output, save_errno, i, need_restart;\n\tchar ch, *p, *end;\n\tstruct termios term, oterm;\n\tstruct sigaction sa, savealrm, saveint, savehup, savequit, saveterm;\n\tstruct sigaction savetstp, savettin, savettou, savepipe;\n\n\t/* I suppose we could alloc on demand in this case (XXX). */\n\tif (bufsiz == 0) {\n\t\terrno = EINVAL;\n\t\treturn(NULL);\n\t}\n\nrestart:\n\tfor (i = 0; i < _NSIG; i++)\n\t\tsigno[i] = 0;\n\tnr = -1;\n\tsave_errno = 0;\n\tneed_restart = 0;\n\t/*\n\t * Read and write to /dev/tty if available.  If not, read from\n\t * stdin and write to stderr unless a tty is required.\n\t */\n\tif ((flags & RPP_STDIN) ||\n\t    (input = output = open(_PATH_TTY, O_RDWR)) == -1) {\n\t\tif (flags & RPP_REQUIRE_TTY) {\n\t\t\terrno = ENOTTY;\n\t\t\treturn(NULL);\n\t\t}\n\t\tinput = STDIN_FILENO;\n\t\toutput = STDERR_FILENO;\n\t}\n\n\t/*\n\t * Turn off echo if possible.\n\t * If we are using a tty but are not the foreground pgrp this will\n\t * generate SIGTTOU, so do it *before* installing the signal handlers.\n\t */\n\tif (input != STDIN_FILENO && tcgetattr(input, &oterm) == 0) {\n\t\tmemcpy(&term, &oterm, sizeof(term));\n\t\tif (!(flags & RPP_ECHO_ON))\n\t\t\tterm.c_lflag &= ~(ECHO | ECHONL);\n#ifdef VSTATUS\n\t\tif (term.c_cc[VSTATUS] != _POSIX_VDISABLE)\n\t\t\tterm.c_cc[VSTATUS] = _POSIX_VDISABLE;\n#endif\n\t\t(void)tcsetattr(input, TCSAFLUSH|TCSASOFT, &term);\n\t} else {\n\t\tmemset(&term, 0, sizeof(term));\n\t\tterm.c_lflag |= ECHO;\n\t\tmemset(&oterm, 0, sizeof(oterm));\n\t\toterm.c_lflag |= ECHO;\n\t}\n\n\t/*\n\t * Catch signals that would otherwise cause the user to end\n\t * up with echo turned off in the shell.  Don't worry about\n\t * things like SIGXCPU and SIGVTALRM for now.\n\t */\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = 0;\t\t/* don't restart system calls */\n\tsa.sa_handler = handler;\n\t(void)sigaction(SIGALRM, &sa, &savealrm);\n\t(void)sigaction(SIGHUP, &sa, &savehup);\n\t(void)sigaction(SIGINT, &sa, &saveint);\n\t(void)sigaction(SIGPIPE, &sa, &savepipe);\n\t(void)sigaction(SIGQUIT, &sa, &savequit);\n\t(void)sigaction(SIGTERM, &sa, &saveterm);\n\t(void)sigaction(SIGTSTP, &sa, &savetstp);\n\t(void)sigaction(SIGTTIN, &sa, &savettin);\n\t(void)sigaction(SIGTTOU, &sa, &savettou);\n\n\tif (!(flags & RPP_STDIN))\n\t\t(void)write(output, prompt, strlen(prompt));\n\tend = buf + bufsiz - 1;\n\tp = buf;\n\twhile ((nr = read(input, &ch, 1)) == 1 && ch != '\\n' && ch != '\\r') {\n\t\tif (p < end) {\n\t\t\tif ((flags & RPP_SEVENBIT))\n\t\t\t\tch &= 0x7f;\n\t\t\tif (isalpha((unsigned char)ch)) {\n\t\t\t\tif ((flags & RPP_FORCELOWER))\n\t\t\t\t\tch = (char)tolower((unsigned char)ch);\n\t\t\t\tif ((flags & RPP_FORCEUPPER))\n\t\t\t\t\tch = (char)toupper((unsigned char)ch);\n\t\t\t}\n\t\t\t*p++ = ch;\n\t\t}\n\t}\n\t*p = '\\0';\n\tsave_errno = errno;\n\tif (!(term.c_lflag & ECHO))\n\t\t(void)write(output, \"\\n\", 1);\n\n\t/* Restore old terminal settings and signals. */\n\tif (memcmp(&term, &oterm, sizeof(term)) != 0) {\n\t\tconst int sigttou = signo[SIGTTOU];\n\n\t\t/* Ignore SIGTTOU generated when we are not the fg pgrp. */\n\t\twhile (tcsetattr(input, TCSAFLUSH|TCSASOFT, &oterm) == -1 &&\n\t\t    errno == EINTR && !signo[SIGTTOU])\n\t\t\tcontinue;\n\t\tsigno[SIGTTOU] = sigttou;\n\t}\n\t(void)sigaction(SIGALRM, &savealrm, NULL);\n\t(void)sigaction(SIGHUP, &savehup, NULL);\n\t(void)sigaction(SIGINT, &saveint, NULL);\n\t(void)sigaction(SIGQUIT, &savequit, NULL);\n\t(void)sigaction(SIGPIPE, &savepipe, NULL);\n\t(void)sigaction(SIGTERM, &saveterm, NULL);\n\t(void)sigaction(SIGTSTP, &savetstp, NULL);\n\t(void)sigaction(SIGTTIN, &savettin, NULL);\n\t(void)sigaction(SIGTTOU, &savettou, NULL);\n\tif (input != STDIN_FILENO)\n\t\t(void)close(input);\n\n\t/*\n\t * If we were interrupted by a signal, resend it to ourselves\n\t * now that we have restored the signal handlers.\n\t */\n\tfor (i = 0; i < _NSIG; i++) {\n\t\tif (signo[i]) {\n\t\t\tkill(getpid(), i);\n\t\t\tswitch (i) {\n\t\t\tcase SIGTSTP:\n\t\t\tcase SIGTTIN:\n\t\t\tcase SIGTTOU:\n\t\t\t\tneed_restart = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (need_restart)\n\t\tgoto restart;\n\n\tif (save_errno)\n\t\terrno = save_errno;\n\treturn(nr == -1 ? NULL : buf);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <readpassphrase.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <termios.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <errno.h>\n#include <readpassphrase.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <signal.h>\n#include <termios.h>\n#include \"includes.h\"\n\nchar *\nreadpassphrase(const char *prompt, char *buf, size_t bufsiz, int flags)\n{\n\tssize_t nr;\n\tint input, output, save_errno, i, need_restart;\n\tchar ch, *p, *end;\n\tstruct termios term, oterm;\n\tstruct sigaction sa, savealrm, saveint, savehup, savequit, saveterm;\n\tstruct sigaction savetstp, savettin, savettou, savepipe;\n\n\t/* I suppose we could alloc on demand in this case (XXX). */\n\tif (bufsiz == 0) {\n\t\terrno = EINVAL;\n\t\treturn(NULL);\n\t}\n\nrestart:\n\tfor (i = 0; i < _NSIG; i++)\n\t\tsigno[i] = 0;\n\tnr = -1;\n\tsave_errno = 0;\n\tneed_restart = 0;\n\t/*\n\t * Read and write to /dev/tty if available.  If not, read from\n\t * stdin and write to stderr unless a tty is required.\n\t */\n\tif ((flags & RPP_STDIN) ||\n\t    (input = output = open(_PATH_TTY, O_RDWR)) == -1) {\n\t\tif (flags & RPP_REQUIRE_TTY) {\n\t\t\terrno = ENOTTY;\n\t\t\treturn(NULL);\n\t\t}\n\t\tinput = STDIN_FILENO;\n\t\toutput = STDERR_FILENO;\n\t}\n\n\t/*\n\t * Turn off echo if possible.\n\t * If we are using a tty but are not the foreground pgrp this will\n\t * generate SIGTTOU, so do it *before* installing the signal handlers.\n\t */\n\tif (input != STDIN_FILENO && tcgetattr(input, &oterm) == 0) {\n\t\tmemcpy(&term, &oterm, sizeof(term));\n\t\tif (!(flags & RPP_ECHO_ON))\n\t\t\tterm.c_lflag &= ~(ECHO | ECHONL);\n#ifdef VSTATUS\n\t\tif (term.c_cc[VSTATUS] != _POSIX_VDISABLE)\n\t\t\tterm.c_cc[VSTATUS] = _POSIX_VDISABLE;\n#endif\n\t\t(void)tcsetattr(input, TCSAFLUSH|TCSASOFT, &term);\n\t} else {\n\t\tmemset(&term, 0, sizeof(term));\n\t\tterm.c_lflag |= ECHO;\n\t\tmemset(&oterm, 0, sizeof(oterm));\n\t\toterm.c_lflag |= ECHO;\n\t}\n\n\t/*\n\t * Catch signals that would otherwise cause the user to end\n\t * up with echo turned off in the shell.  Don't worry about\n\t * things like SIGXCPU and SIGVTALRM for now.\n\t */\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = 0;\t\t/* don't restart system calls */\n\tsa.sa_handler = handler;\n\t(void)sigaction(SIGALRM, &sa, &savealrm);\n\t(void)sigaction(SIGHUP, &sa, &savehup);\n\t(void)sigaction(SIGINT, &sa, &saveint);\n\t(void)sigaction(SIGPIPE, &sa, &savepipe);\n\t(void)sigaction(SIGQUIT, &sa, &savequit);\n\t(void)sigaction(SIGTERM, &sa, &saveterm);\n\t(void)sigaction(SIGTSTP, &sa, &savetstp);\n\t(void)sigaction(SIGTTIN, &sa, &savettin);\n\t(void)sigaction(SIGTTOU, &sa, &savettou);\n\n\tif (!(flags & RPP_STDIN))\n\t\t(void)write(output, prompt, strlen(prompt));\n\tend = buf + bufsiz - 1;\n\tp = buf;\n\twhile ((nr = read(input, &ch, 1)) == 1 && ch != '\\n' && ch != '\\r') {\n\t\tif (p < end) {\n\t\t\tif ((flags & RPP_SEVENBIT))\n\t\t\t\tch &= 0x7f;\n\t\t\tif (isalpha((unsigned char)ch)) {\n\t\t\t\tif ((flags & RPP_FORCELOWER))\n\t\t\t\t\tch = (char)tolower((unsigned char)ch);\n\t\t\t\tif ((flags & RPP_FORCEUPPER))\n\t\t\t\t\tch = (char)toupper((unsigned char)ch);\n\t\t\t}\n\t\t\t*p++ = ch;\n\t\t}\n\t}\n\t*p = '\\0';\n\tsave_errno = errno;\n\tif (!(term.c_lflag & ECHO))\n\t\t(void)write(output, \"\\n\", 1);\n\n\t/* Restore old terminal settings and signals. */\n\tif (memcmp(&term, &oterm, sizeof(term)) != 0) {\n\t\tconst int sigttou = signo[SIGTTOU];\n\n\t\t/* Ignore SIGTTOU generated when we are not the fg pgrp. */\n\t\twhile (tcsetattr(input, TCSAFLUSH|TCSASOFT, &oterm) == -1 &&\n\t\t    errno == EINTR && !signo[SIGTTOU])\n\t\t\tcontinue;\n\t\tsigno[SIGTTOU] = sigttou;\n\t}\n\t(void)sigaction(SIGALRM, &savealrm, NULL);\n\t(void)sigaction(SIGHUP, &savehup, NULL);\n\t(void)sigaction(SIGINT, &saveint, NULL);\n\t(void)sigaction(SIGQUIT, &savequit, NULL);\n\t(void)sigaction(SIGPIPE, &savepipe, NULL);\n\t(void)sigaction(SIGTERM, &saveterm, NULL);\n\t(void)sigaction(SIGTSTP, &savetstp, NULL);\n\t(void)sigaction(SIGTTIN, &savettin, NULL);\n\t(void)sigaction(SIGTTOU, &savettou, NULL);\n\tif (input != STDIN_FILENO)\n\t\t(void)close(input);\n\n\t/*\n\t * If we were interrupted by a signal, resend it to ourselves\n\t * now that we have restored the signal handlers.\n\t */\n\tfor (i = 0; i < _NSIG; i++) {\n\t\tif (signo[i]) {\n\t\t\tkill(getpid(), i);\n\t\t\tswitch (i) {\n\t\t\tcase SIGTSTP:\n\t\t\tcase SIGTTIN:\n\t\t\tcase SIGTTOU:\n\t\t\t\tneed_restart = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (need_restart)\n\t\tgoto restart;\n\n\tif (save_errno)\n\t\terrno = save_errno;\n\treturn(nr == -1 ? NULL : buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "prompt",
            "sizeof(prompt)",
            "\"Proxy password for %s@%s: \"",
            "proxyuser",
            "proxyhost"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\ngetproxypass(const char *proxyuser, const char *proxyhost)\n{\n\tchar prompt[512];\n\tstatic char pw[256];\n\n\tsnprintf(prompt, sizeof(prompt), \"Proxy password for %s@%s: \",\n\t   proxyuser, proxyhost);\n\tif (readpassphrase(prompt, pw, sizeof(pw), RPP_REQUIRE_TTY) == NULL)\n\t\terrx(1, \"Unable to read proxy passphrase\");\n\treturn (pw);\n}"
  },
  {
    "function_name": "proxy_read_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
    "lines": "1413-1433",
    "snippet": "static int\nproxy_read_line(int fd, char *buf, size_t bufsz)\n{\n\tsize_t off;\n\n\tfor(off = 0;;) {\n\t\tif (off >= bufsz)\n\t\t\terrx(1, \"proxy read too long\");\n\t\tif (atomicio(read, fd, buf + off, 1) != 1)\n\t\t\terr(1, \"proxy read\");\n\t\t/* Skip CR */\n\t\tif (buf[off] == '\\r')\n\t\t\tcontinue;\n\t\tif (buf[off] == '\\n') {\n\t\t\tbuf[off] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t}\n\treturn (off);\n}",
    "includes": [
      "#include <resolv.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "# include <err.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/uio.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ssize_t drainbuf(int, unsigned char *, size_t *);",
      "ssize_t fillbuf(int, unsigned char *, size_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"proxy read\""
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "run_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1323-1346",
          "snippet": "void\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void run_err(const char *,...);",
            "int errs, remin, remout;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid run_err(const char *,...);\nint errs, remin, remout;\n\nvoid\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomicio",
          "args": [
            "read",
            "fd",
            "buf + off",
            "1"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "atomiciov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "165-170",
          "snippet": "size_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"proxy read too long\""
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "errx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-err.c",
          "lines": "52-62",
          "snippet": "void\nerrx(int r, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(r);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\nvoid\nerrx(int r, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(r);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nssize_t drainbuf(int, unsigned char *, size_t *);\nssize_t fillbuf(int, unsigned char *, size_t *);\n\nstatic int\nproxy_read_line(int fd, char *buf, size_t bufsz)\n{\n\tsize_t off;\n\n\tfor(off = 0;;) {\n\t\tif (off >= bufsz)\n\t\t\terrx(1, \"proxy read too long\");\n\t\tif (atomicio(read, fd, buf + off, 1) != 1)\n\t\t\terr(1, \"proxy read\");\n\t\t/* Skip CR */\n\t\tif (buf[off] == '\\r')\n\t\t\tcontinue;\n\t\tif (buf[off] == '\\n') {\n\t\t\tbuf[off] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t}\n\treturn (off);\n}"
  },
  {
    "function_name": "decode_addrport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
    "lines": "1384-1411",
    "snippet": "static int\ndecode_addrport(const char *h, const char *p, struct sockaddr *addr,\n    socklen_t addrlen, int v4only, int numeric)\n{\n\tint r;\n\tstruct addrinfo hints, *res;\n\n\tbzero(&hints, sizeof(hints));\n\thints.ai_family = v4only ? PF_INET : PF_UNSPEC;\n\thints.ai_flags = numeric ? AI_NUMERICHOST : 0;\n\thints.ai_socktype = SOCK_STREAM;\n\tr = getaddrinfo(h, p, &hints, &res);\n\t/* Don't fatal when attempting to convert a numeric address */\n\tif (r != 0) {\n\t\tif (!numeric) {\n\t\t\terrx(1, \"getaddrinfo(\\\"%.64s\\\", \\\"%.64s\\\"): %s\", h, p,\n\t\t\t    gai_strerror(r));\n\t\t}\n\t\treturn (-1);\n\t}\n\tif (addrlen < res->ai_addrlen) {\n\t\tfreeaddrinfo(res);\n\t\terrx(1, \"internal error: addrlen < res->ai_addrlen\");\n\t}\n\tmemcpy(addr, res->ai_addr, res->ai_addrlen);\n\tfreeaddrinfo(res);\n\treturn (0);\n}",
    "includes": [
      "#include <resolv.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "# include <err.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/uio.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tlocal_listen(char *, char *, struct addrinfo);",
      "int\tremote_connect(const char *, const char *, struct addrinfo);",
      "int\ttimeout_connect(int, const struct sockaddr *, socklen_t);",
      "int\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int, const char *);",
      "void\treport_connect(const struct sockaddr *, socklen_t);",
      "int\tremote_connect(const char *, const char *, struct addrinfo);",
      "int\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int,\n\t    const char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "res"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "addr",
            "res->ai_addr",
            "res->ai_addrlen"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"internal error: addrlen < res->ai_addrlen\""
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "errx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-err.c",
          "lines": "52-62",
          "snippet": "void\nerrx(int r, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(r);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\nvoid\nerrx(int r, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gai_strerror",
          "args": [
            "r"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "h",
            "p",
            "&hints",
            "&res"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "getaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "154-234",
          "snippet": "int\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&hints",
            "sizeof(hints)"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "288-292",
          "snippet": "void\nbzero(void *b, size_t n)\n{\n\t(void)memset(b, 0, n);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nbzero(void *b, size_t n)\n{\n\t(void)memset(b, 0, n);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tlocal_listen(char *, char *, struct addrinfo);\nint\tremote_connect(const char *, const char *, struct addrinfo);\nint\ttimeout_connect(int, const struct sockaddr *, socklen_t);\nint\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int, const char *);\nvoid\treport_connect(const struct sockaddr *, socklen_t);\nint\tremote_connect(const char *, const char *, struct addrinfo);\nint\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int,\n\t    const char *);\n\nstatic int\ndecode_addrport(const char *h, const char *p, struct sockaddr *addr,\n    socklen_t addrlen, int v4only, int numeric)\n{\n\tint r;\n\tstruct addrinfo hints, *res;\n\n\tbzero(&hints, sizeof(hints));\n\thints.ai_family = v4only ? PF_INET : PF_UNSPEC;\n\thints.ai_flags = numeric ? AI_NUMERICHOST : 0;\n\thints.ai_socktype = SOCK_STREAM;\n\tr = getaddrinfo(h, p, &hints, &res);\n\t/* Don't fatal when attempting to convert a numeric address */\n\tif (r != 0) {\n\t\tif (!numeric) {\n\t\t\terrx(1, \"getaddrinfo(\\\"%.64s\\\", \\\"%.64s\\\"): %s\", h, p,\n\t\t\t    gai_strerror(r));\n\t\t}\n\t\treturn (-1);\n\t}\n\tif (addrlen < res->ai_addrlen) {\n\t\tfreeaddrinfo(res);\n\t\terrx(1, \"internal error: addrlen < res->ai_addrlen\");\n\t}\n\tmemcpy(addr, res->ai_addr, res->ai_addrlen);\n\tfreeaddrinfo(res);\n\treturn (0);\n}"
  },
  {
    "function_name": "usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
    "lines": "1312-1322",
    "snippet": "void\nusage(int ret)\n{\n\tfprintf(stderr,\n\t    \"usage: nc [-46DdFhklNnrStUuvz] [-I length] [-i interval] [-O length]\\n\"\n\t    \"\\t  [-P proxy_username] [-p source_port] [-s source] [-T ToS]\\n\"\n\t    \"\\t  [-V rtable] [-w timeout] [-X proxy_protocol]\\n\"\n\t    \"\\t  [-x proxy_address[:port]] [destination] [port]\\n\");\n\tif (ret)\n\t\texit(1);\n}",
    "includes": [
      "#include <resolv.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "# include <err.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/uio.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int timeout = -1;",
      "void\tusage(int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"usage: nc [-46DdFhklNnrStUuvz] [-I length] [-i interval] [-O length]\\n\"\n\t    \"\\t  [-P proxy_username] [-p source_port] [-s source] [-T ToS]\\n\"\n\t    \"\\t  [-V rtable] [-w timeout] [-X proxy_protocol]\\n\"\n\t    \"\\t  [-x proxy_address[:port]] [destination] [port]\\n\""
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint timeout = -1;\nvoid\tusage(int);\n\nvoid\nusage(int ret)\n{\n\tfprintf(stderr,\n\t    \"usage: nc [-46DdFhklNnrStUuvz] [-I length] [-i interval] [-O length]\\n\"\n\t    \"\\t  [-P proxy_username] [-p source_port] [-s source] [-T ToS]\\n\"\n\t    \"\\t  [-V rtable] [-w timeout] [-X proxy_protocol]\\n\"\n\t    \"\\t  [-x proxy_address[:port]] [destination] [port]\\n\");\n\tif (ret)\n\t\texit(1);\n}"
  },
  {
    "function_name": "help",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
    "lines": "1275-1310",
    "snippet": "void\nhelp(void)\n{\n\tusage(0);\n\tfprintf(stderr, \"\\tCommand Summary:\\n\\\n\t\\t-4\t\tUse IPv4\\n\\\n\t\\t-6\t\tUse IPv6\\n\\\n\t\\t-D\t\tEnable the debug socket option\\n\\\n\t\\t-d\t\tDetach from stdin\\n\\\n\t\\t-F\t\tPass socket fd\\n\\\n\t\\t-h\t\tThis help text\\n\\\n\t\\t-I length\tTCP receive buffer length\\n\\\n\t\\t-i secs\\t\tDelay interval for lines sent, ports scanned\\n\\\n\t\\t-k\t\tKeep inbound sockets open for multiple connects\\n\\\n\t\\t-l\t\tListen mode, for inbound connects\\n\\\n\t\\t-N\t\tShutdown the network socket after EOF on stdin\\n\\\n\t\\t-n\t\tSuppress name/port resolutions\\n\\\n\t\\t-O length\tTCP send buffer length\\n\\\n\t\\t-P proxyuser\\tUsername for proxy authentication\\n\\\n\t\\t-p port\\t\tSpecify local port for remote connects\\n\\\n\t\\t-r\t\tRandomize remote ports\\n\\\n\t\\t-S\t\tEnable the TCP MD5 signature option\\n\\\n\t\\t-s addr\\t\tLocal source address\\n\\\n\t\\t-T toskeyword\\tSet IP Type of Service\\n\\\n\t\\t-t\t\tAnswer TELNET negotiation\\n\\\n\t\\t-U\t\tUse UNIX domain socket\\n\\\n\t\\t-u\t\tUDP mode\\n\\\n\t\\t-V rtable\tSpecify alternate routing table\\n\\\n\t\\t-v\t\tVerbose\\n\\\n\t\\t-w secs\\t\tTimeout for connects and final net reads\\n\\\n\t\\t-X proto\tProxy protocol: \\\"4\\\", \\\"5\\\" (SOCKS) or \\\"connect\\\"\\n\\\n\t\\t-x addr[:port]\\tSpecify proxy address and port\\n\\\n\t\\t-z\t\tZero-I/O mode [used for scanning]\\n\\\n\tPort numbers can be individual or ranges: lo-hi [inclusive]\\n\");\n\texit(1);\n}",
    "includes": [
      "#include <resolv.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "# include <err.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/uio.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\thelp(void);",
      "void\tusage(int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\tCommand Summary:\\n\\\n\t\\t-4\t\tUse IPv4\\n\\\n\t\\t-6\t\tUse IPv6\\n\\\n\t\\t-D\t\tEnable the debug socket option\\n\\\n\t\\t-d\t\tDetach from stdin\\n\\\n\t\\t-F\t\tPass socket fd\\n\\\n\t\\t-h\t\tThis help text\\n\\\n\t\\t-I length\tTCP receive buffer length\\n\\\n\t\\t-i secs\\t\tDelay interval for lines sent, ports scanned\\n\\\n\t\\t-k\t\tKeep inbound sockets open for multiple connects\\n\\\n\t\\t-l\t\tListen mode, for inbound connects\\n\\\n\t\\t-N\t\tShutdown the network socket after EOF on stdin\\n\\\n\t\\t-n\t\tSuppress name/port resolutions\\n\\\n\t\\t-O length\tTCP send buffer length\\n\\\n\t\\t-P proxyuser\\tUsername for proxy authentication\\n\\\n\t\\t-p port\\t\tSpecify local port for remote connects\\n\\\n\t\\t-r\t\tRandomize remote ports\\n\\\n\t\\t-S\t\tEnable the TCP MD5 signature option\\n\\\n\t\\t-s addr\\t\tLocal source address\\n\\\n\t\\t-T toskeyword\\tSet IP Type of Service\\n\\\n\t\\t-t\t\tAnswer TELNET negotiation\\n\\\n\t\\t-U\t\tUse UNIX domain socket\\n\\\n\t\\t-u\t\tUDP mode\\n\\\n\t\\t-V rtable\tSpecify alternate routing table\\n\\\n\t\\t-v\t\tVerbose\\n\\\n\t\\t-w secs\\t\tTimeout for connects and final net reads\\n\\\n\t\\t-X proto\tProxy protocol: \\\"4\\\", \\\"5\\\" (SOCKS) or \\\"connect\\\"\\n\\\n\t\\t-x addr[:port]\\tSpecify proxy address and port\\n\\\n\t\\t-z\t\tZero-I/O mode [used for scanning]\\n\\\n\tPort numbers can be individual or ranges: lo-hi [inclusive]\\n\""
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [
            "0"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "1312-1322",
          "snippet": "void\nusage(int ret)\n{\n\tfprintf(stderr,\n\t    \"usage: nc [-46DdFhklNnrStUuvz] [-I length] [-i interval] [-O length]\\n\"\n\t    \"\\t  [-P proxy_username] [-p source_port] [-s source] [-T ToS]\\n\"\n\t    \"\\t  [-V rtable] [-w timeout] [-X proxy_protocol]\\n\"\n\t    \"\\t  [-x proxy_address[:port]] [destination] [port]\\n\");\n\tif (ret)\n\t\texit(1);\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int timeout = -1;",
            "void\tusage(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint timeout = -1;\nvoid\tusage(int);\n\nvoid\nusage(int ret)\n{\n\tfprintf(stderr,\n\t    \"usage: nc [-46DdFhklNnrStUuvz] [-I length] [-i interval] [-O length]\\n\"\n\t    \"\\t  [-P proxy_username] [-p source_port] [-s source] [-T ToS]\\n\"\n\t    \"\\t  [-V rtable] [-w timeout] [-X proxy_protocol]\\n\"\n\t    \"\\t  [-x proxy_address[:port]] [destination] [port]\\n\");\n\tif (ret)\n\t\texit(1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\thelp(void);\nvoid\tusage(int);\n\nvoid\nhelp(void)\n{\n\tusage(0);\n\tfprintf(stderr, \"\\tCommand Summary:\\n\\\n\t\\t-4\t\tUse IPv4\\n\\\n\t\\t-6\t\tUse IPv6\\n\\\n\t\\t-D\t\tEnable the debug socket option\\n\\\n\t\\t-d\t\tDetach from stdin\\n\\\n\t\\t-F\t\tPass socket fd\\n\\\n\t\\t-h\t\tThis help text\\n\\\n\t\\t-I length\tTCP receive buffer length\\n\\\n\t\\t-i secs\\t\tDelay interval for lines sent, ports scanned\\n\\\n\t\\t-k\t\tKeep inbound sockets open for multiple connects\\n\\\n\t\\t-l\t\tListen mode, for inbound connects\\n\\\n\t\\t-N\t\tShutdown the network socket after EOF on stdin\\n\\\n\t\\t-n\t\tSuppress name/port resolutions\\n\\\n\t\\t-O length\tTCP send buffer length\\n\\\n\t\\t-P proxyuser\\tUsername for proxy authentication\\n\\\n\t\\t-p port\\t\tSpecify local port for remote connects\\n\\\n\t\\t-r\t\tRandomize remote ports\\n\\\n\t\\t-S\t\tEnable the TCP MD5 signature option\\n\\\n\t\\t-s addr\\t\tLocal source address\\n\\\n\t\\t-T toskeyword\\tSet IP Type of Service\\n\\\n\t\\t-t\t\tAnswer TELNET negotiation\\n\\\n\t\\t-U\t\tUse UNIX domain socket\\n\\\n\t\\t-u\t\tUDP mode\\n\\\n\t\\t-V rtable\tSpecify alternate routing table\\n\\\n\t\\t-v\t\tVerbose\\n\\\n\t\\t-w secs\\t\tTimeout for connects and final net reads\\n\\\n\t\\t-X proto\tProxy protocol: \\\"4\\\", \\\"5\\\" (SOCKS) or \\\"connect\\\"\\n\\\n\t\\t-x addr[:port]\\tSpecify proxy address and port\\n\\\n\t\\t-z\t\tZero-I/O mode [used for scanning]\\n\\\n\tPort numbers can be individual or ranges: lo-hi [inclusive]\\n\");\n\texit(1);\n}"
  },
  {
    "function_name": "report_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
    "lines": "1249-1273",
    "snippet": "void\nreport_connect(const struct sockaddr *sa, socklen_t salen)\n{\n\tchar remote_host[NI_MAXHOST];\n\tchar remote_port[NI_MAXSERV];\n\tint herr;\n\tint flags = NI_NUMERICSERV;\n\t\n\tif (nflag)\n\t\tflags |= NI_NUMERICHOST;\n\t\n\tif ((herr = getnameinfo(sa, salen,\n\t    remote_host, sizeof(remote_host),\n\t    remote_port, sizeof(remote_port),\n\t    flags)) != 0) {\n\t\tif (herr == EAI_SYSTEM)\n\t\t\terr(1, \"getnameinfo\");\n\t\telse\n\t\t\terrx(1, \"getnameinfo: %s\", gai_strerror(herr));\n\t}\n\t\n\tfprintf(stderr,\n\t    \"Connection from %s %s \"\n\t    \"received!\\n\", remote_host, remote_port);\n}",
    "includes": [
      "#include <resolv.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "# include <err.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/uio.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tnflag;",
      "int\ttimeout_connect(int, const struct sockaddr *, socklen_t);",
      "void\treport_connect(const struct sockaddr *, socklen_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Connection from %s %s \"\n\t    \"received!\\n\"",
            "remote_host",
            "remote_port"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"getnameinfo: %s\"",
            "gai_strerror(herr)"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "errx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-err.c",
          "lines": "52-62",
          "snippet": "void\nerrx(int r, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(r);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\nvoid\nerrx(int r, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gai_strerror",
          "args": [
            "herr"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"getnameinfo\""
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "run_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1323-1346",
          "snippet": "void\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void run_err(const char *,...);",
            "int errs, remin, remout;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid run_err(const char *,...);\nint errs, remin, remout;\n\nvoid\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getnameinfo",
          "args": [
            "sa",
            "salen",
            "remote_host",
            "sizeof(remote_host)",
            "remote_port",
            "sizeof(remote_port)",
            "flags"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "sshaix_getnameinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/port-aix.c",
          "lines": "415-434",
          "snippet": "int\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}",
          "includes": [
            "#  include <stdlib.h>",
            "#include \"port-aix.h\"",
            "# include <usersec.h>",
            "#  include <sys/audit.h>",
            "# include <userpw.h>",
            "# include <login.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <uinfo.h>",
            "# include <netdb.h>",
            "#include <errno.h>",
            "#include \"log.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssh.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <stdlib.h>\n#include \"port-aix.h\"\n# include <usersec.h>\n#  include <sys/audit.h>\n# include <userpw.h>\n# include <login.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <uinfo.h>\n# include <netdb.h>\n#include <errno.h>\n#include \"log.h\"\n#include \"ssh_api.h\"\n#include \"ssh.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include \"includes.h\"\n\nint\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tnflag;\nint\ttimeout_connect(int, const struct sockaddr *, socklen_t);\nvoid\treport_connect(const struct sockaddr *, socklen_t);\n\nvoid\nreport_connect(const struct sockaddr *sa, socklen_t salen)\n{\n\tchar remote_host[NI_MAXHOST];\n\tchar remote_port[NI_MAXSERV];\n\tint herr;\n\tint flags = NI_NUMERICSERV;\n\t\n\tif (nflag)\n\t\tflags |= NI_NUMERICHOST;\n\t\n\tif ((herr = getnameinfo(sa, salen,\n\t    remote_host, sizeof(remote_host),\n\t    remote_port, sizeof(remote_port),\n\t    flags)) != 0) {\n\t\tif (herr == EAI_SYSTEM)\n\t\t\terr(1, \"getnameinfo\");\n\t\telse\n\t\t\terrx(1, \"getnameinfo: %s\", gai_strerror(herr));\n\t}\n\t\n\tfprintf(stderr,\n\t    \"Connection from %s %s \"\n\t    \"received!\\n\", remote_host, remote_port);\n}"
  },
  {
    "function_name": "map_tos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
    "lines": "1201-1247",
    "snippet": "int\nmap_tos(char *s, int *val)\n{\n\t/* DiffServ Codepoints and other TOS mappings */\n\tconst struct toskeywords {\n\t\tconst char\t*keyword;\n\t\tint\t\t val;\n\t} *t, toskeywords[] = {\n\t\t{ \"af11\",\t\tIPTOS_DSCP_AF11 },\n\t\t{ \"af12\",\t\tIPTOS_DSCP_AF12 },\n\t\t{ \"af13\",\t\tIPTOS_DSCP_AF13 },\n\t\t{ \"af21\",\t\tIPTOS_DSCP_AF21 },\n\t\t{ \"af22\",\t\tIPTOS_DSCP_AF22 },\n\t\t{ \"af23\",\t\tIPTOS_DSCP_AF23 },\n\t\t{ \"af31\",\t\tIPTOS_DSCP_AF31 },\n\t\t{ \"af32\",\t\tIPTOS_DSCP_AF32 },\n\t\t{ \"af33\",\t\tIPTOS_DSCP_AF33 },\n\t\t{ \"af41\",\t\tIPTOS_DSCP_AF41 },\n\t\t{ \"af42\",\t\tIPTOS_DSCP_AF42 },\n\t\t{ \"af43\",\t\tIPTOS_DSCP_AF43 },\n\t\t{ \"critical\",\t\tIPTOS_PREC_CRITIC_ECP },\n\t\t{ \"cs0\",\t\tIPTOS_DSCP_CS0 },\n\t\t{ \"cs1\",\t\tIPTOS_DSCP_CS1 },\n\t\t{ \"cs2\",\t\tIPTOS_DSCP_CS2 },\n\t\t{ \"cs3\",\t\tIPTOS_DSCP_CS3 },\n\t\t{ \"cs4\",\t\tIPTOS_DSCP_CS4 },\n\t\t{ \"cs5\",\t\tIPTOS_DSCP_CS5 },\n\t\t{ \"cs6\",\t\tIPTOS_DSCP_CS6 },\n\t\t{ \"cs7\",\t\tIPTOS_DSCP_CS7 },\n\t\t{ \"ef\",\t\t\tIPTOS_DSCP_EF },\n\t\t{ \"inetcontrol\",\tIPTOS_PREC_INTERNETCONTROL },\n\t\t{ \"lowdelay\",\t\tIPTOS_LOWDELAY },\n\t\t{ \"netcontrol\",\t\tIPTOS_PREC_NETCONTROL },\n\t\t{ \"reliability\",\tIPTOS_RELIABILITY },\n\t\t{ \"throughput\",\t\tIPTOS_THROUGHPUT },\n\t\t{ NULL, \t\t-1 },\n\t};\n\n\tfor (t = toskeywords; t->keyword != NULL; t++) {\n\t\tif (strcmp(s, t->keyword) == 0) {\n\t\t\t*val = t->val;\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <resolv.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "# include <err.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/uio.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tmap_tos(char *, int *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "t->keyword"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tmap_tos(char *, int *);\n\nint\nmap_tos(char *s, int *val)\n{\n\t/* DiffServ Codepoints and other TOS mappings */\n\tconst struct toskeywords {\n\t\tconst char\t*keyword;\n\t\tint\t\t val;\n\t} *t, toskeywords[] = {\n\t\t{ \"af11\",\t\tIPTOS_DSCP_AF11 },\n\t\t{ \"af12\",\t\tIPTOS_DSCP_AF12 },\n\t\t{ \"af13\",\t\tIPTOS_DSCP_AF13 },\n\t\t{ \"af21\",\t\tIPTOS_DSCP_AF21 },\n\t\t{ \"af22\",\t\tIPTOS_DSCP_AF22 },\n\t\t{ \"af23\",\t\tIPTOS_DSCP_AF23 },\n\t\t{ \"af31\",\t\tIPTOS_DSCP_AF31 },\n\t\t{ \"af32\",\t\tIPTOS_DSCP_AF32 },\n\t\t{ \"af33\",\t\tIPTOS_DSCP_AF33 },\n\t\t{ \"af41\",\t\tIPTOS_DSCP_AF41 },\n\t\t{ \"af42\",\t\tIPTOS_DSCP_AF42 },\n\t\t{ \"af43\",\t\tIPTOS_DSCP_AF43 },\n\t\t{ \"critical\",\t\tIPTOS_PREC_CRITIC_ECP },\n\t\t{ \"cs0\",\t\tIPTOS_DSCP_CS0 },\n\t\t{ \"cs1\",\t\tIPTOS_DSCP_CS1 },\n\t\t{ \"cs2\",\t\tIPTOS_DSCP_CS2 },\n\t\t{ \"cs3\",\t\tIPTOS_DSCP_CS3 },\n\t\t{ \"cs4\",\t\tIPTOS_DSCP_CS4 },\n\t\t{ \"cs5\",\t\tIPTOS_DSCP_CS5 },\n\t\t{ \"cs6\",\t\tIPTOS_DSCP_CS6 },\n\t\t{ \"cs7\",\t\tIPTOS_DSCP_CS7 },\n\t\t{ \"ef\",\t\t\tIPTOS_DSCP_EF },\n\t\t{ \"inetcontrol\",\tIPTOS_PREC_INTERNETCONTROL },\n\t\t{ \"lowdelay\",\t\tIPTOS_LOWDELAY },\n\t\t{ \"netcontrol\",\t\tIPTOS_PREC_NETCONTROL },\n\t\t{ \"reliability\",\tIPTOS_RELIABILITY },\n\t\t{ \"throughput\",\t\tIPTOS_THROUGHPUT },\n\t\t{ NULL, \t\t-1 },\n\t};\n\n\tfor (t = toskeywords; t->keyword != NULL; t++) {\n\t\tif (strcmp(s, t->keyword) == 0) {\n\t\t\t*val = t->val;\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "set_common_sockopts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
    "lines": "1167-1199",
    "snippet": "void\nset_common_sockopts(int s)\n{\n\tint x = 1;\n\n#ifdef TCP_MD5SIG\n\tif (Sflag) {\n\t\tif (setsockopt(s, IPPROTO_TCP, TCP_MD5SIG,\n\t\t\t&x, sizeof(x)) == -1)\n\t\t\terr(1, \"setsockopt\");\n\t}\n#endif\n\tif (Dflag) {\n\t\tif (setsockopt(s, SOL_SOCKET, SO_DEBUG,\n\t\t\t&x, sizeof(x)) == -1)\n\t\t\terr(1, \"setsockopt\");\n\t}\n\tif (Tflag != -1) {\n\t\tif (setsockopt(s, IPPROTO_IP, IP_TOS,\n\t\t    &Tflag, sizeof(Tflag)) == -1)\n\t\t\terr(1, \"set IP ToS\");\n\t}\n\tif (Iflag) {\n\t\tif (setsockopt(s, SOL_SOCKET, SO_RCVBUF,\n\t\t    &Iflag, sizeof(Iflag)) == -1)\n\t\t\terr(1, \"set TCP receive buffer size\");\n\t}\n\tif (Oflag) {\n\t\tif (setsockopt(s, SOL_SOCKET, SO_SNDBUF,\n\t\t    &Oflag, sizeof(Oflag)) == -1)\n\t\t\terr(1, \"set TCP send buffer size\");\n\t}\n}",
    "includes": [
      "#include <resolv.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "# include <err.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/uio.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tDflag;",
      "int\tIflag;",
      "int\tOflag;",
      "int\tSflag;",
      "int\tTflag = -1;",
      "void\tset_common_sockopts(int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"set TCP send buffer size\""
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "run_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1323-1346",
          "snippet": "void\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void run_err(const char *,...);",
            "int errs, remin, remout;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid run_err(const char *,...);\nint errs, remin, remout;\n\nvoid\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "s",
            "SOL_SOCKET",
            "SO_SNDBUF",
            "&Oflag",
            "sizeof(Oflag)"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "s",
            "SOL_SOCKET",
            "SO_RCVBUF",
            "&Iflag",
            "sizeof(Iflag)"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "s",
            "IPPROTO_IP",
            "IP_TOS",
            "&Tflag",
            "sizeof(Tflag)"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "s",
            "SOL_SOCKET",
            "SO_DEBUG",
            "&x",
            "sizeof(x)"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "s",
            "IPPROTO_TCP",
            "TCP_MD5SIG",
            "&x",
            "sizeof(x)"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tDflag;\nint\tIflag;\nint\tOflag;\nint\tSflag;\nint\tTflag = -1;\nvoid\tset_common_sockopts(int);\n\nvoid\nset_common_sockopts(int s)\n{\n\tint x = 1;\n\n#ifdef TCP_MD5SIG\n\tif (Sflag) {\n\t\tif (setsockopt(s, IPPROTO_TCP, TCP_MD5SIG,\n\t\t\t&x, sizeof(x)) == -1)\n\t\t\terr(1, \"setsockopt\");\n\t}\n#endif\n\tif (Dflag) {\n\t\tif (setsockopt(s, SOL_SOCKET, SO_DEBUG,\n\t\t\t&x, sizeof(x)) == -1)\n\t\t\terr(1, \"setsockopt\");\n\t}\n\tif (Tflag != -1) {\n\t\tif (setsockopt(s, IPPROTO_IP, IP_TOS,\n\t\t    &Tflag, sizeof(Tflag)) == -1)\n\t\t\terr(1, \"set IP ToS\");\n\t}\n\tif (Iflag) {\n\t\tif (setsockopt(s, SOL_SOCKET, SO_RCVBUF,\n\t\t    &Iflag, sizeof(Iflag)) == -1)\n\t\t\terr(1, \"set TCP receive buffer size\");\n\t}\n\tif (Oflag) {\n\t\tif (setsockopt(s, SOL_SOCKET, SO_SNDBUF,\n\t\t    &Oflag, sizeof(Oflag)) == -1)\n\t\t\terr(1, \"set TCP send buffer size\");\n\t}\n}"
  },
  {
    "function_name": "udptest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
    "lines": "1153-1165",
    "snippet": "int\nudptest(int s)\n{\n\tint i, ret;\n\n\tfor (i = 0; i <= 3; i++) {\n\t\tif (write(s, \"X\", 1) == 1)\n\t\t\tret = 1;\n\t\telse\n\t\t\tret = -1;\n\t}\n\treturn (ret);\n}",
    "includes": [
      "#include <resolv.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "# include <err.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/uio.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tudptest(int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write",
          "args": [
            "s",
            "\"X\"",
            "1"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tudptest(int);\n\nint\nudptest(int s)\n{\n\tint i, ret;\n\n\tfor (i = 0; i <= 3; i++) {\n\t\tif (write(s, \"X\", 1) == 1)\n\t\t\tret = 1;\n\t\telse\n\t\t\tret = -1;\n\t}\n\treturn (ret);\n}"
  },
  {
    "function_name": "build_ports",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
    "lines": "1091-1146",
    "snippet": "void\nbuild_ports(char *p)\n{\n\tconst char *errstr;\n\tchar *n;\n\tint hi, lo, cp;\n\tint x = 0;\n\n\tif ((n = strchr(p, '-')) != NULL) {\n\t\t*n = '\\0';\n\t\tn++;\n\n\t\t/* Make sure the ports are in order: lowest->highest. */\n\t\thi = strtonum(n, 1, PORT_MAX, &errstr);\n\t\tif (errstr)\n\t\t\terrx(1, \"port number %s: %s\", errstr, n);\n\t\tlo = strtonum(p, 1, PORT_MAX, &errstr);\n\t\tif (errstr)\n\t\t\terrx(1, \"port number %s: %s\", errstr, p);\n\n\t\tif (lo > hi) {\n\t\t\tcp = hi;\n\t\t\thi = lo;\n\t\t\tlo = cp;\n\t\t}\n\n\t\t/* Load ports sequentially. */\n\t\tfor (cp = lo; cp <= hi; cp++) {\n\t\t\tportlist[x] = calloc(1, PORT_MAX_LEN);\n\t\t\tif (portlist[x] == NULL)\n\t\t\t\terrx(1, \"calloc\");\n\t\t\tsnprintf(portlist[x], PORT_MAX_LEN, \"%d\", cp);\n\t\t\tx++;\n\t\t}\n\n\t\t/* Randomly swap ports. */\n\t\tif (rflag) {\n\t\t\tint y;\n\t\t\tchar *c;\n\n\t\t\tfor (x = 0; x <= (hi - lo); x++) {\n\t\t\t\ty = (arc4random() & 0xFFFF) % (hi - lo);\n\t\t\t\tc = portlist[x];\n\t\t\t\tportlist[x] = portlist[y];\n\t\t\t\tportlist[y] = c;\n\t\t\t}\n\t\t}\n\t} else {\n\t\thi = strtonum(p, 1, PORT_MAX, &errstr);\n\t\tif (errstr)\n\t\t\terrx(1, \"port number %s: %s\", errstr, p);\n\t\tportlist[0] = strdup(p);\n\t\tif (portlist[0] == NULL)\n\t\t\terrx(1, \"strdup\");\n\t}\n}",
    "includes": [
      "#include <resolv.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "# include <err.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/uio.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define PORT_MAX_LEN\t6",
      "#define PORT_MAX\t65535"
    ],
    "globals_used": [
      "int\trflag;",
      "char *portlist[PORT_MAX+1];",
      "void\tbuild_ports(char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"strdup\""
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "errx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-err.c",
          "lines": "52-62",
          "snippet": "void\nerrx(int r, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(r);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\nvoid\nerrx(int r, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtonum",
          "args": [
            "p",
            "1",
            "PORT_MAX",
            "&errstr"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "strtonum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strtonum.c",
          "lines": "33-70",
          "snippet": "long long\nstrtonum(const char *numstr, long long minval, long long maxval,\n    const char **errstrp)\n{\n\tlong long ll = 0;\n\tchar *ep;\n\tint error = 0;\n\tstruct errval {\n\t\tconst char *errstr;\n\t\tint err;\n\t} ev[4] = {\n\t\t{ NULL,\t\t0 },\n\t\t{ \"invalid\",\tEINVAL },\n\t\t{ \"too small\",\tERANGE },\n\t\t{ \"too large\",\tERANGE },\n\t};\n\n\tev[0].err = errno;\n\terrno = 0;\n\tif (minval > maxval)\n\t\terror = INVALID;\n\telse {\n\t\tll = strtoll(numstr, &ep, 10);\n\t\tif (numstr == ep || *ep != '\\0')\n\t\t\terror = INVALID;\n\t\telse if ((ll == LLONG_MIN && errno == ERANGE) || ll < minval)\n\t\t\terror = TOOSMALL;\n\t\telse if ((ll == LLONG_MAX && errno == ERANGE) || ll > maxval)\n\t\t\terror = TOOLARGE;\n\t}\n\tif (errstrp != NULL)\n\t\t*errstrp = ev[error].errstr;\n\terrno = ev[error].err;\n\tif (error)\n\t\tll = 0;\n\n\treturn (ll);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define TOOLARGE \t3",
            "#define TOOSMALL \t2",
            "#define INVALID \t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\n#define TOOLARGE \t3\n#define TOOSMALL \t2\n#define INVALID \t1\n\nlong long\nstrtonum(const char *numstr, long long minval, long long maxval,\n    const char **errstrp)\n{\n\tlong long ll = 0;\n\tchar *ep;\n\tint error = 0;\n\tstruct errval {\n\t\tconst char *errstr;\n\t\tint err;\n\t} ev[4] = {\n\t\t{ NULL,\t\t0 },\n\t\t{ \"invalid\",\tEINVAL },\n\t\t{ \"too small\",\tERANGE },\n\t\t{ \"too large\",\tERANGE },\n\t};\n\n\tev[0].err = errno;\n\terrno = 0;\n\tif (minval > maxval)\n\t\terror = INVALID;\n\telse {\n\t\tll = strtoll(numstr, &ep, 10);\n\t\tif (numstr == ep || *ep != '\\0')\n\t\t\terror = INVALID;\n\t\telse if ((ll == LLONG_MIN && errno == ERANGE) || ll < minval)\n\t\t\terror = TOOSMALL;\n\t\telse if ((ll == LLONG_MAX && errno == ERANGE) || ll > maxval)\n\t\t\terror = TOOLARGE;\n\t}\n\tif (errstrp != NULL)\n\t\t*errstrp = ev[error].errstr;\n\terrno = ev[error].err;\n\tif (error)\n\t\tll = 0;\n\n\treturn (ll);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arc4random",
          "args": [],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "arc4random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/arc4random.c",
          "lines": "235-244",
          "snippet": "u_int32_t\narc4random(void)\n{\n\tu_int32_t val;\n\n\t_ARC4_LOCK();\n\t_rs_random_u32(&val);\n\t_ARC4_UNLOCK();\n\treturn val;\n}",
          "includes": [
            "#include <machine/pctr.h>",
            "#include <stdio.h>",
            "#include \"chacha_private.h\"",
            "#include \"log.h\"",
            "#include <openssl/err.h>",
            "#include <openssl/rand.h>",
            "# include <sys/random.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/pctr.h>\n#include <stdio.h>\n#include \"chacha_private.h\"\n#include \"log.h\"\n#include <openssl/err.h>\n#include <openssl/rand.h>\n# include <sys/random.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int32_t\narc4random(void)\n{\n\tu_int32_t val;\n\n\t_ARC4_LOCK();\n\t_rs_random_u32(&val);\n\t_ARC4_UNLOCK();\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "portlist[x]",
            "PORT_MAX_LEN",
            "\"%d\"",
            "cp"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "PORT_MAX_LEN"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "xcalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "52-66",
          "snippet": "void *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nvoid *\nxcalloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\n\tif (size == 0 || nmemb == 0)\n\t\tfatal(\"xcalloc: zero size\");\n\tif (SIZE_MAX / nmemb < size)\n\t\tfatal(\"xcalloc: nmemb * size > SIZE_MAX\");\n\tptr = calloc(nmemb, size);\n\tif (ptr == NULL)\n\t\tfatal(\"xcalloc: out of memory (allocating %zu bytes)\",\n\t\t    size * nmemb);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "'-'"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "g_strchr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "1025-1033",
          "snippet": "static Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define PORT_MAX_LEN\t6\n#define PORT_MAX\t65535\n\nint\trflag;\nchar *portlist[PORT_MAX+1];\nvoid\tbuild_ports(char *);\n\nvoid\nbuild_ports(char *p)\n{\n\tconst char *errstr;\n\tchar *n;\n\tint hi, lo, cp;\n\tint x = 0;\n\n\tif ((n = strchr(p, '-')) != NULL) {\n\t\t*n = '\\0';\n\t\tn++;\n\n\t\t/* Make sure the ports are in order: lowest->highest. */\n\t\thi = strtonum(n, 1, PORT_MAX, &errstr);\n\t\tif (errstr)\n\t\t\terrx(1, \"port number %s: %s\", errstr, n);\n\t\tlo = strtonum(p, 1, PORT_MAX, &errstr);\n\t\tif (errstr)\n\t\t\terrx(1, \"port number %s: %s\", errstr, p);\n\n\t\tif (lo > hi) {\n\t\t\tcp = hi;\n\t\t\thi = lo;\n\t\t\tlo = cp;\n\t\t}\n\n\t\t/* Load ports sequentially. */\n\t\tfor (cp = lo; cp <= hi; cp++) {\n\t\t\tportlist[x] = calloc(1, PORT_MAX_LEN);\n\t\t\tif (portlist[x] == NULL)\n\t\t\t\terrx(1, \"calloc\");\n\t\t\tsnprintf(portlist[x], PORT_MAX_LEN, \"%d\", cp);\n\t\t\tx++;\n\t\t}\n\n\t\t/* Randomly swap ports. */\n\t\tif (rflag) {\n\t\t\tint y;\n\t\t\tchar *c;\n\n\t\t\tfor (x = 0; x <= (hi - lo); x++) {\n\t\t\t\ty = (arc4random() & 0xFFFF) % (hi - lo);\n\t\t\t\tc = portlist[x];\n\t\t\t\tportlist[x] = portlist[y];\n\t\t\t\tportlist[y] = c;\n\t\t\t}\n\t\t}\n\t} else {\n\t\thi = strtonum(p, 1, PORT_MAX, &errstr);\n\t\tif (errstr)\n\t\t\terrx(1, \"port number %s: %s\", errstr, p);\n\t\tportlist[0] = strdup(p);\n\t\tif (portlist[0] == NULL)\n\t\t\terrx(1, \"strdup\");\n\t}\n}"
  },
  {
    "function_name": "atelnet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
    "lines": "1056-1084",
    "snippet": "void\natelnet(int nfd, unsigned char *buf, unsigned int size)\n{\n\tunsigned char *p, *end;\n\tunsigned char obuf[4];\n\n\tif (size < 3)\n\t\treturn;\n\tend = buf + size - 2;\n\n\tfor (p = buf; p < end; p++) {\n\t\tif (*p != IAC)\n\t\t\tcontinue;\n\n\t\tobuf[0] = IAC;\n\t\tp++;\n\t\tif ((*p == WILL) || (*p == WONT))\n\t\t\tobuf[1] = DONT;\n\t\telse if ((*p == DO) || (*p == DONT))\n\t\t\tobuf[1] = WONT;\n\t\telse\n\t\t\tcontinue;\n\n\t\tp++;\n\t\tobuf[2] = *p;\n\t\tif (atomicio(vwrite, nfd, obuf, 3) != 3)\n\t\t\twarn(\"Write Error!\");\n\t}\n}",
    "includes": [
      "#include <resolv.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "# include <err.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/uio.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define WILL\t251",
      "#define WONT\t252",
      "#define DO\t253",
      "#define DONT\t254",
      "#define IAC\t255"
    ],
    "globals_used": [
      "void\tatelnet(int, unsigned char *, unsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "warn",
          "args": [
            "\"Write Error!\""
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "warn_changed_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect.c",
          "lines": "1487-1508",
          "snippet": "static void\nwarn_changed_key(struct sshkey *host_key)\n{\n\tchar *fp;\n\n\tfp = sshkey_fingerprint(host_key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT);\n\tif (fp == NULL)\n\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\n\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\terror(\"@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\");\n\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\terror(\"IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\");\n\terror(\"Someone could be eavesdropping on you right now (man-in-the-middle attack)!\");\n\terror(\"It is also possible that a host key has just been changed.\");\n\terror(\"The fingerprint for the %s key sent by the remote host is\\n%s.\",\n\t    sshkey_type(host_key), fp);\n\terror(\"Please contact your system administrator.\");\n\n\tfree(fp);\n}",
          "includes": [
            "#include \"authfd.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"version.h\"",
            "#include \"ssh2.h\"",
            "#include \"monitor_fdpass.h\"",
            "#include \"dns.h\"",
            "#include \"atomicio.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"sshkey.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"hostfile.h\"",
            "#include \"xmalloc.h\"",
            "# include <ifaddrs.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#include <pwd.h>",
            "#include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern Options options;",
            "static int show_other_keys(struct hostkeys *, struct sshkey *);",
            "static void warn_changed_key(struct sshkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"authfd.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"version.h\"\n#include \"ssh2.h\"\n#include \"monitor_fdpass.h\"\n#include \"dns.h\"\n#include \"atomicio.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"sshconnect.h\"\n#include \"sshkey.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"hostfile.h\"\n#include \"xmalloc.h\"\n# include <ifaddrs.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <poll.h>\n#include <pwd.h>\n#include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern Options options;\nstatic int show_other_keys(struct hostkeys *, struct sshkey *);\nstatic void warn_changed_key(struct sshkey *);\n\nstatic void\nwarn_changed_key(struct sshkey *host_key)\n{\n\tchar *fp;\n\n\tfp = sshkey_fingerprint(host_key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT);\n\tif (fp == NULL)\n\t\tfatal(\"%s: sshkey_fingerprint fail\", __func__);\n\n\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\terror(\"@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\");\n\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\terror(\"IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\");\n\terror(\"Someone could be eavesdropping on you right now (man-in-the-middle attack)!\");\n\terror(\"It is also possible that a host key has just been changed.\");\n\terror(\"The fingerprint for the %s key sent by the remote host is\\n%s.\",\n\t    sshkey_type(host_key), fp);\n\terror(\"Please contact your system administrator.\");\n\n\tfree(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomicio",
          "args": [
            "vwrite",
            "nfd",
            "obuf",
            "3"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "atomiciov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/atomicio.c",
          "lines": "165-170",
          "snippet": "size_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}",
          "includes": [
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atomicio.h\"\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nsize_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define WILL\t251\n#define WONT\t252\n#define DO\t253\n#define DONT\t254\n#define IAC\t255\n\nvoid\tatelnet(int, unsigned char *, unsigned int);\n\nvoid\natelnet(int nfd, unsigned char *buf, unsigned int size)\n{\n\tunsigned char *p, *end;\n\tunsigned char obuf[4];\n\n\tif (size < 3)\n\t\treturn;\n\tend = buf + size - 2;\n\n\tfor (p = buf; p < end; p++) {\n\t\tif (*p != IAC)\n\t\t\tcontinue;\n\n\t\tobuf[0] = IAC;\n\t\tp++;\n\t\tif ((*p == WILL) || (*p == WONT))\n\t\t\tobuf[1] = DONT;\n\t\telse if ((*p == DO) || (*p == DONT))\n\t\t\tobuf[1] = WONT;\n\t\telse\n\t\t\tcontinue;\n\n\t\tp++;\n\t\tobuf[2] = *p;\n\t\tif (atomicio(vwrite, nfd, obuf, 3) != 3)\n\t\t\twarn(\"Write Error!\");\n\t}\n}"
  },
  {
    "function_name": "fdpass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
    "lines": "995-1053",
    "snippet": "void\nfdpass(int nfd)\n{\n#if defined(HAVE_SENDMSG) && (defined(HAVE_ACCRIGHTS_IN_MSGHDR) || defined(HAVE_CONTROL_IN_MSGHDR))\n\tstruct msghdr msg;\n#ifndef HAVE_ACCRIGHTS_IN_MSGHDR\n\tunion {\n\t\tstruct cmsghdr hdr;\n\t\tchar buf[CMSG_SPACE(sizeof(int))];\n\t} cmsgbuf;\n\tstruct cmsghdr *cmsg;\n#endif\n\tstruct iovec vec;\n\tchar ch = '\\0';\n\tstruct pollfd pfd;\n\tssize_t r;\n\n\tmemset(&msg, 0, sizeof(msg));\n#ifdef HAVE_ACCRIGHTS_IN_MSGHDR\n\tmsg.msg_accrights = (caddr_t)&nfd;\n\tmsg.msg_accrightslen = sizeof(nfd);\n#else\n\tmemset(&cmsgbuf, 0, sizeof(cmsgbuf));\n\tmsg.msg_control = (caddr_t)&cmsgbuf.buf;\n\tmsg.msg_controllen = sizeof(cmsgbuf.buf);\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\t*(int *)CMSG_DATA(cmsg) = nfd;\n#endif\n\n\tvec.iov_base = &ch;\n\tvec.iov_len = 1;\n\tmsg.msg_iov = &vec;\n\tmsg.msg_iovlen = 1;\n\n\tbzero(&pfd, sizeof(pfd));\n\tpfd.fd = STDOUT_FILENO;\n\tfor (;;) {\n\t\tr = sendmsg(STDOUT_FILENO, &msg, 0);\n\t\tif (r == -1) {\n\t\t\tif (errno == EAGAIN || errno == EINTR) {\n\t\t\t\tpfd.events = POLLOUT;\n\t\t\t\tif (poll(&pfd, 1, -1) == -1)\n\t\t\t\t\terr(1, \"poll\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr(1, \"sendmsg\");\n\t\t} else if (r == -1)\n\t\t\terrx(1, \"sendmsg: unexpected return value %zd\", r);\n\t\telse\n\t\t\tbreak;\n\t}\n\texit(0);\n#else\n\terrx(1, \"%s: file descriptor passing not supported\", __func__);\n#endif\n}",
    "includes": [
      "#include <resolv.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "# include <err.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/uio.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"%s: file descriptor passing not supported\"",
            "__func__"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "errx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-err.c",
          "lines": "52-62",
          "snippet": "void\nerrx(int r, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(r);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\nvoid\nerrx(int r, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"sendmsg\""
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "run_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1323-1346",
          "snippet": "void\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void run_err(const char *,...);",
            "int errs, remin, remout;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid run_err(const char *,...);\nint errs, remin, remout;\n\nvoid\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll",
          "args": [
            "&pfd",
            "1",
            "-1"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "after_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "888-941",
          "snippet": "static void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t/* Find sockets entry */\n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror(\"%s: no socket for fd %d\", __func__, pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Process events */\n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0) {\n\t\t\t\tgoto close_sock;\n\t\t\t}\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int sockets_alloc = 0;",
            "SocketEntry *sockets = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int sockets_alloc = 0;\nSocketEntry *sockets = NULL;\n\nstatic void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t/* Find sockets entry */\n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror(\"%s: no socket for fd %d\", __func__, pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Process events */\n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0) {\n\t\t\t\tgoto close_sock;\n\t\t\t}\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sendmsg",
          "args": [
            "STDOUT_FILENO",
            "&msg",
            "0"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&pfd",
            "sizeof(pfd)"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "bzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "288-292",
          "snippet": "void\nbzero(void *b, size_t n)\n{\n\t(void)memset(b, 0, n);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nbzero(void *b, size_t n)\n{\n\t(void)memset(b, 0, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CMSG_DATA",
          "args": [
            "cmsg"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_LEN",
          "args": [
            "sizeof(int)"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_FIRSTHDR",
          "args": [
            "&msg"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&cmsgbuf",
            "0",
            "sizeof(cmsgbuf)"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&msg",
            "0",
            "sizeof(msg)"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_SPACE",
          "args": [
            "sizeof(int)"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfdpass(int nfd)\n{\n#if defined(HAVE_SENDMSG) && (defined(HAVE_ACCRIGHTS_IN_MSGHDR) || defined(HAVE_CONTROL_IN_MSGHDR))\n\tstruct msghdr msg;\n#ifndef HAVE_ACCRIGHTS_IN_MSGHDR\n\tunion {\n\t\tstruct cmsghdr hdr;\n\t\tchar buf[CMSG_SPACE(sizeof(int))];\n\t} cmsgbuf;\n\tstruct cmsghdr *cmsg;\n#endif\n\tstruct iovec vec;\n\tchar ch = '\\0';\n\tstruct pollfd pfd;\n\tssize_t r;\n\n\tmemset(&msg, 0, sizeof(msg));\n#ifdef HAVE_ACCRIGHTS_IN_MSGHDR\n\tmsg.msg_accrights = (caddr_t)&nfd;\n\tmsg.msg_accrightslen = sizeof(nfd);\n#else\n\tmemset(&cmsgbuf, 0, sizeof(cmsgbuf));\n\tmsg.msg_control = (caddr_t)&cmsgbuf.buf;\n\tmsg.msg_controllen = sizeof(cmsgbuf.buf);\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\t*(int *)CMSG_DATA(cmsg) = nfd;\n#endif\n\n\tvec.iov_base = &ch;\n\tvec.iov_len = 1;\n\tmsg.msg_iov = &vec;\n\tmsg.msg_iovlen = 1;\n\n\tbzero(&pfd, sizeof(pfd));\n\tpfd.fd = STDOUT_FILENO;\n\tfor (;;) {\n\t\tr = sendmsg(STDOUT_FILENO, &msg, 0);\n\t\tif (r == -1) {\n\t\t\tif (errno == EAGAIN || errno == EINTR) {\n\t\t\t\tpfd.events = POLLOUT;\n\t\t\t\tif (poll(&pfd, 1, -1) == -1)\n\t\t\t\t\terr(1, \"poll\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr(1, \"sendmsg\");\n\t\t} else if (r == -1)\n\t\t\terrx(1, \"sendmsg: unexpected return value %zd\", r);\n\t\telse\n\t\t\tbreak;\n\t}\n\texit(0);\n#else\n\terrx(1, \"%s: file descriptor passing not supported\", __func__);\n#endif\n}"
  },
  {
    "function_name": "fillbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
    "lines": "975-989",
    "snippet": "ssize_t\nfillbuf(int fd, unsigned char *buf, size_t *bufpos)\n{\n\tsize_t num = BUFSIZE - *bufpos;\n\tssize_t n;\n\n\tn = read(fd, buf + *bufpos, num);\n\t/* don't treat EAGAIN, EINTR as error */\n\tif (n == -1 && (errno == EAGAIN || errno == EINTR))\n\t\tn = -2;\n\tif (n <= 0)\n\t\treturn n;\n\t*bufpos += n;\n\treturn n;\n}",
    "includes": [
      "#include <resolv.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "# include <err.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/uio.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define BUFSIZE 16384"
    ],
    "globals_used": [
      "ssize_t drainbuf(int, unsigned char *, size_t *);",
      "ssize_t fillbuf(int, unsigned char *, size_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "buf + *bufpos",
            "num"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "proxy_read_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "1413-1433",
          "snippet": "static int\nproxy_read_line(int fd, char *buf, size_t bufsz)\n{\n\tsize_t off;\n\n\tfor(off = 0;;) {\n\t\tif (off >= bufsz)\n\t\t\terrx(1, \"proxy read too long\");\n\t\tif (atomicio(read, fd, buf + off, 1) != 1)\n\t\t\terr(1, \"proxy read\");\n\t\t/* Skip CR */\n\t\tif (buf[off] == '\\r')\n\t\t\tcontinue;\n\t\tif (buf[off] == '\\n') {\n\t\t\tbuf[off] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t}\n\treturn (off);\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ssize_t drainbuf(int, unsigned char *, size_t *);",
            "ssize_t fillbuf(int, unsigned char *, size_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nssize_t drainbuf(int, unsigned char *, size_t *);\nssize_t fillbuf(int, unsigned char *, size_t *);\n\nstatic int\nproxy_read_line(int fd, char *buf, size_t bufsz)\n{\n\tsize_t off;\n\n\tfor(off = 0;;) {\n\t\tif (off >= bufsz)\n\t\t\terrx(1, \"proxy read too long\");\n\t\tif (atomicio(read, fd, buf + off, 1) != 1)\n\t\t\terr(1, \"proxy read\");\n\t\t/* Skip CR */\n\t\tif (buf[off] == '\\r')\n\t\t\tcontinue;\n\t\tif (buf[off] == '\\n') {\n\t\t\tbuf[off] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t}\n\treturn (off);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define BUFSIZE 16384\n\nssize_t drainbuf(int, unsigned char *, size_t *);\nssize_t fillbuf(int, unsigned char *, size_t *);\n\nssize_t\nfillbuf(int fd, unsigned char *buf, size_t *bufpos)\n{\n\tsize_t num = BUFSIZE - *bufpos;\n\tssize_t n;\n\n\tn = read(fd, buf + *bufpos, num);\n\t/* don't treat EAGAIN, EINTR as error */\n\tif (n == -1 && (errno == EAGAIN || errno == EINTR))\n\t\tn = -2;\n\tif (n <= 0)\n\t\treturn n;\n\t*bufpos += n;\n\treturn n;\n}"
  },
  {
    "function_name": "drainbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
    "lines": "954-972",
    "snippet": "ssize_t\ndrainbuf(int fd, unsigned char *buf, size_t *bufpos)\n{\n\tssize_t n;\n\tssize_t adjust;\n\n\tn = write(fd, buf, *bufpos);\n\t/* don't treat EAGAIN, EINTR as error */\n\tif (n == -1 && (errno == EAGAIN || errno == EINTR))\n\t\tn = -2;\n\tif (n <= 0)\n\t\treturn n;\n\t/* adjust buffer */\n\tadjust = *bufpos - n;\n\tif (adjust > 0)\n\t\tmemmove(buf, buf + n, adjust);\n\t*bufpos -= n;\n\treturn n;\n}",
    "includes": [
      "#include <resolv.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "# include <err.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/uio.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ssize_t drainbuf(int, unsigned char *, size_t *);",
      "ssize_t fillbuf(int, unsigned char *, size_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "buf",
            "buf + n",
            "adjust"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "buf",
            "*bufpos"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nssize_t drainbuf(int, unsigned char *, size_t *);\nssize_t fillbuf(int, unsigned char *, size_t *);\n\nssize_t\ndrainbuf(int fd, unsigned char *buf, size_t *bufpos)\n{\n\tssize_t n;\n\tssize_t adjust;\n\n\tn = write(fd, buf, *bufpos);\n\t/* don't treat EAGAIN, EINTR as error */\n\tif (n == -1 && (errno == EAGAIN || errno == EINTR))\n\t\tn = -2;\n\tif (n <= 0)\n\t\treturn n;\n\t/* adjust buffer */\n\tadjust = *bufpos - n;\n\tif (adjust > 0)\n\t\tmemmove(buf, buf + n, adjust);\n\t*bufpos -= n;\n\treturn n;\n}"
  },
  {
    "function_name": "readwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
    "lines": "772-952",
    "snippet": "void\nreadwrite(int net_fd)\n{\n\tstruct pollfd pfd[4];\n\tint stdin_fd = STDIN_FILENO;\n\tint stdout_fd = STDOUT_FILENO;\n\tunsigned char netinbuf[BUFSIZE];\n\tsize_t netinbufpos = 0;\n\tunsigned char stdinbuf[BUFSIZE];\n\tsize_t stdinbufpos = 0;\n\tint n, num_fds;\n\tssize_t ret;\n\n\t/* don't read from stdin if requested */\n\tif (dflag)\n\t\tstdin_fd = -1;\n\n\t/* stdin */\n\tpfd[POLL_STDIN].fd = stdin_fd;\n\tpfd[POLL_STDIN].events = POLLIN;\n\n\t/* network out */\n\tpfd[POLL_NETOUT].fd = net_fd;\n\tpfd[POLL_NETOUT].events = 0;\n\n\t/* network in */\n\tpfd[POLL_NETIN].fd = net_fd;\n\tpfd[POLL_NETIN].events = POLLIN;\n\n\t/* stdout */\n\tpfd[POLL_STDOUT].fd = stdout_fd;\n\tpfd[POLL_STDOUT].events = 0;\n\n\twhile (1) {\n\t\t/* both inputs are gone, buffers are empty, we are done */\n\t\tif (pfd[POLL_STDIN].fd == -1 && pfd[POLL_NETIN].fd == -1\n\t\t    && stdinbufpos == 0 && netinbufpos == 0) {\n\t\t\tclose(net_fd);\n\t\t\treturn;\n\t\t}\n\t\t/* both outputs are gone, we can't continue */\n\t\tif (pfd[POLL_NETOUT].fd == -1 && pfd[POLL_STDOUT].fd == -1) {\n\t\t\tclose(net_fd);\n\t\t\treturn;\n\t\t}\n\t\t/* listen and net in gone, queues empty, done */\n\t\tif (lflag && pfd[POLL_NETIN].fd == -1\n\t\t    && stdinbufpos == 0 && netinbufpos == 0) {\n\t\t\tclose(net_fd);\n\t\t\treturn;\n\t\t}\n\n\t\t/* help says -i is for \"wait between lines sent\". We read and\n\t\t * write arbitrary amounts of data, and we don't want to start\n\t\t * scanning for newlines, so this is as good as it gets */\n\t\tif (iflag)\n\t\t\tsleep(iflag);\n\n\t\t/* poll */\n\t\tnum_fds = poll(pfd, 4, timeout);\n\n\t\t/* treat poll errors */\n\t\tif (num_fds == -1) {\n\t\t\tclose(net_fd);\n\t\t\terr(1, \"polling error\");\n\t\t}\n\n\t\t/* timeout happened */\n\t\tif (num_fds == 0)\n\t\t\treturn;\n\n\t\t/* treat socket error conditions */\n\t\tfor (n = 0; n < 4; n++) {\n\t\t\tif (pfd[n].revents & (POLLERR|POLLNVAL)) {\n\t\t\t\tpfd[n].fd = -1;\n\t\t\t}\n\t\t}\n\t\t/* reading is possible after HUP */\n\t\tif (pfd[POLL_STDIN].events & POLLIN &&\n\t\t    pfd[POLL_STDIN].revents & POLLHUP &&\n\t\t    ! (pfd[POLL_STDIN].revents & POLLIN))\n\t\t\t\tpfd[POLL_STDIN].fd = -1;\n\n\t\tif (pfd[POLL_NETIN].events & POLLIN &&\n\t\t    pfd[POLL_NETIN].revents & POLLHUP &&\n\t\t    ! (pfd[POLL_NETIN].revents & POLLIN))\n\t\t\t\tpfd[POLL_NETIN].fd = -1;\n\n\t\tif (pfd[POLL_NETOUT].revents & POLLHUP) {\n\t\t\tif (Nflag)\n\t\t\t\tshutdown(pfd[POLL_NETOUT].fd, SHUT_WR);\n\t\t\tpfd[POLL_NETOUT].fd = -1;\n\t\t}\n\t\t/* if HUP, stop watching stdout */\n\t\tif (pfd[POLL_STDOUT].revents & POLLHUP)\n\t\t\tpfd[POLL_STDOUT].fd = -1;\n\t\t/* if no net out, stop watching stdin */\n\t\tif (pfd[POLL_NETOUT].fd == -1)\n\t\t\tpfd[POLL_STDIN].fd = -1;\n\t\t/* if no stdout, stop watching net in */\n\t\tif (pfd[POLL_STDOUT].fd == -1) {\n\t\t\tif (pfd[POLL_NETIN].fd != -1)\n\t\t\t\tshutdown(pfd[POLL_NETIN].fd, SHUT_RD);\n\t\t\tpfd[POLL_NETIN].fd = -1;\n\t\t}\n\n\t\t/* try to read from stdin */\n\t\tif (pfd[POLL_STDIN].revents & POLLIN && stdinbufpos < BUFSIZE) {\n\t\t\tret = fillbuf(pfd[POLL_STDIN].fd, stdinbuf,\n\t\t\t    &stdinbufpos);\n\t\t\t/* error or eof on stdin - remove from pfd */\n\t\t\tif (ret == 0 || ret == -1)\n\t\t\t\tpfd[POLL_STDIN].fd = -1;\n\t\t\t/* read something - poll net out */\n\t\t\tif (stdinbufpos > 0)\n\t\t\t\tpfd[POLL_NETOUT].events = POLLOUT;\n\t\t\t/* filled buffer - remove self from polling */\n\t\t\tif (stdinbufpos == BUFSIZE)\n\t\t\t\tpfd[POLL_STDIN].events = 0;\n\t\t}\n\t\t/* try to write to network */\n\t\tif (pfd[POLL_NETOUT].revents & POLLOUT && stdinbufpos > 0) {\n\t\t\tret = drainbuf(pfd[POLL_NETOUT].fd, stdinbuf,\n\t\t\t    &stdinbufpos);\n\t\t\tif (ret == -1)\n\t\t\t\tpfd[POLL_NETOUT].fd = -1;\n\t\t\t/* buffer empty - remove self from polling */\n\t\t\tif (stdinbufpos == 0)\n\t\t\t\tpfd[POLL_NETOUT].events = 0;\n\t\t\t/* buffer no longer full - poll stdin again */\n\t\t\tif (stdinbufpos < BUFSIZE)\n\t\t\t\tpfd[POLL_STDIN].events = POLLIN;\n\t\t}\n\t\t/* try to read from network */\n\t\tif (pfd[POLL_NETIN].revents & POLLIN && netinbufpos < BUFSIZE) {\n\t\t\tret = fillbuf(pfd[POLL_NETIN].fd, netinbuf,\n\t\t\t    &netinbufpos);\n\t\t\tif (ret == -1)\n\t\t\t\tpfd[POLL_NETIN].fd = -1;\n\t\t\t/* eof on net in - remove from pfd */\n\t\t\tif (ret == 0) {\n\t\t\t\tshutdown(pfd[POLL_NETIN].fd, SHUT_RD);\n\t\t\t\tpfd[POLL_NETIN].fd = -1;\n\t\t\t}\n\t\t\t/* read something - poll stdout */\n\t\t\tif (netinbufpos > 0)\n\t\t\t\tpfd[POLL_STDOUT].events = POLLOUT;\n\t\t\t/* filled buffer - remove self from polling */\n\t\t\tif (netinbufpos == BUFSIZE)\n\t\t\t\tpfd[POLL_NETIN].events = 0;\n\t\t\t/* handle telnet */\n\t\t\tif (tflag)\n\t\t\t\tatelnet(pfd[POLL_NETIN].fd, netinbuf,\n\t\t\t\t    netinbufpos);\n\t\t}\n\t\t/* try to write to stdout */\n\t\tif (pfd[POLL_STDOUT].revents & POLLOUT && netinbufpos > 0) {\n\t\t\tret = drainbuf(pfd[POLL_STDOUT].fd, netinbuf,\n\t\t\t    &netinbufpos);\n\t\t\tif (ret == -1)\n\t\t\t\tpfd[POLL_STDOUT].fd = -1;\n\t\t\t/* buffer empty - remove self from polling */\n\t\t\tif (netinbufpos == 0)\n\t\t\t\tpfd[POLL_STDOUT].events = 0;\n\t\t\t/* buffer no longer full - poll net in again */\n\t\t\tif (netinbufpos < BUFSIZE)\n\t\t\t\tpfd[POLL_NETIN].events = POLLIN;\n\t\t}\n\n\t\t/* stdin gone and queue empty? */\n\t\tif (pfd[POLL_STDIN].fd == -1 && stdinbufpos == 0) {\n\t\t\tif (pfd[POLL_NETOUT].fd != -1 && Nflag)\n\t\t\t\tshutdown(pfd[POLL_NETOUT].fd, SHUT_WR);\n\t\t\tpfd[POLL_NETOUT].fd = -1;\n\t\t}\n\t\t/* net in gone and queue empty? */\n\t\tif (pfd[POLL_NETIN].fd == -1 && netinbufpos == 0) {\n\t\t\tpfd[POLL_STDOUT].fd = -1;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <resolv.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "# include <err.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/uio.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define BUFSIZE 16384",
      "#define POLL_STDOUT 3",
      "#define POLL_NETIN 2",
      "#define POLL_NETOUT 1",
      "#define POLL_STDIN 0"
    ],
    "globals_used": [
      "int\tdflag;",
      "unsigned int iflag;",
      "int\tlflag;",
      "int\tNflag;",
      "int\ttflag;",
      "int timeout = -1;",
      "void\tatelnet(int, unsigned char *, unsigned int);",
      "void\thelp(void);",
      "void\treadwrite(int);",
      "ssize_t drainbuf(int, unsigned char *, size_t *);",
      "ssize_t fillbuf(int, unsigned char *, size_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "shutdown",
          "args": [
            "pfd[POLL_NETOUT].fd",
            "SHUT_WR"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "chan_shutdown_extended_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/nchan.c",
          "lines": "429-446",
          "snippet": "static void\nchan_shutdown_extended_read(struct ssh *ssh, Channel *c)\n{\n\tif (c->type == SSH_CHANNEL_LARVAL || c->efd == -1)\n\t\treturn;\n\tif (c->extended_usage != CHAN_EXTENDED_READ &&\n\t    c->extended_usage != CHAN_EXTENDED_IGNORE)\n\t\treturn;\n\tdebug2(\"channel %d: %s (i%d o%d sock %d wfd %d efd %d [%s])\",\n\t    c->self, __func__, c->istate, c->ostate, c->sock, c->rfd, c->efd,\n\t    channel_format_extended_usage(c));\n\tif (channel_close_fd(ssh, &c->efd) < 0) {\n\t\tlogit(\"channel %d: %s: close() failed for \"\n\t\t    \"extended fd %d [i%d o%d]: %.100s\",\n\t\t    c->self, __func__, c->efd, c->istate, c->ostate,\n\t\t    strerror(errno));\n\t}\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"packet.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tchan_send_eof2(struct ssh *, Channel *);",
            "static void\tchan_send_eow2(struct ssh *, Channel *);",
            "static void\tchan_shutdown_write(struct ssh *, Channel *);",
            "static void\tchan_shutdown_read(struct ssh *, Channel *);",
            "static void\tchan_shutdown_extended_read(struct ssh *, Channel *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nstatic void\nchan_shutdown_extended_read(struct ssh *ssh, Channel *c)\n{\n\tif (c->type == SSH_CHANNEL_LARVAL || c->efd == -1)\n\t\treturn;\n\tif (c->extended_usage != CHAN_EXTENDED_READ &&\n\t    c->extended_usage != CHAN_EXTENDED_IGNORE)\n\t\treturn;\n\tdebug2(\"channel %d: %s (i%d o%d sock %d wfd %d efd %d [%s])\",\n\t    c->self, __func__, c->istate, c->ostate, c->sock, c->rfd, c->efd,\n\t    channel_format_extended_usage(c));\n\tif (channel_close_fd(ssh, &c->efd) < 0) {\n\t\tlogit(\"channel %d: %s: close() failed for \"\n\t\t    \"extended fd %d [i%d o%d]: %.100s\",\n\t\t    c->self, __func__, c->efd, c->istate, c->ostate,\n\t\t    strerror(errno));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "drainbuf",
          "args": [
            "pfd[POLL_STDOUT].fd",
            "netinbuf",
            "&netinbufpos"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "drainbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "954-972",
          "snippet": "ssize_t\ndrainbuf(int fd, unsigned char *buf, size_t *bufpos)\n{\n\tssize_t n;\n\tssize_t adjust;\n\n\tn = write(fd, buf, *bufpos);\n\t/* don't treat EAGAIN, EINTR as error */\n\tif (n == -1 && (errno == EAGAIN || errno == EINTR))\n\t\tn = -2;\n\tif (n <= 0)\n\t\treturn n;\n\t/* adjust buffer */\n\tadjust = *bufpos - n;\n\tif (adjust > 0)\n\t\tmemmove(buf, buf + n, adjust);\n\t*bufpos -= n;\n\treturn n;\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ssize_t drainbuf(int, unsigned char *, size_t *);",
            "ssize_t fillbuf(int, unsigned char *, size_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nssize_t drainbuf(int, unsigned char *, size_t *);\nssize_t fillbuf(int, unsigned char *, size_t *);\n\nssize_t\ndrainbuf(int fd, unsigned char *buf, size_t *bufpos)\n{\n\tssize_t n;\n\tssize_t adjust;\n\n\tn = write(fd, buf, *bufpos);\n\t/* don't treat EAGAIN, EINTR as error */\n\tif (n == -1 && (errno == EAGAIN || errno == EINTR))\n\t\tn = -2;\n\tif (n <= 0)\n\t\treturn n;\n\t/* adjust buffer */\n\tadjust = *bufpos - n;\n\tif (adjust > 0)\n\t\tmemmove(buf, buf + n, adjust);\n\t*bufpos -= n;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atelnet",
          "args": [
            "pfd[POLL_NETIN].fd",
            "netinbuf",
            "netinbufpos"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "atelnet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "1056-1084",
          "snippet": "void\natelnet(int nfd, unsigned char *buf, unsigned int size)\n{\n\tunsigned char *p, *end;\n\tunsigned char obuf[4];\n\n\tif (size < 3)\n\t\treturn;\n\tend = buf + size - 2;\n\n\tfor (p = buf; p < end; p++) {\n\t\tif (*p != IAC)\n\t\t\tcontinue;\n\n\t\tobuf[0] = IAC;\n\t\tp++;\n\t\tif ((*p == WILL) || (*p == WONT))\n\t\t\tobuf[1] = DONT;\n\t\telse if ((*p == DO) || (*p == DONT))\n\t\t\tobuf[1] = WONT;\n\t\telse\n\t\t\tcontinue;\n\n\t\tp++;\n\t\tobuf[2] = *p;\n\t\tif (atomicio(vwrite, nfd, obuf, 3) != 3)\n\t\t\twarn(\"Write Error!\");\n\t}\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define WILL\t251",
            "#define WONT\t252",
            "#define DO\t253",
            "#define DONT\t254",
            "#define IAC\t255"
          ],
          "globals_used": [
            "void\tatelnet(int, unsigned char *, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define WILL\t251\n#define WONT\t252\n#define DO\t253\n#define DONT\t254\n#define IAC\t255\n\nvoid\tatelnet(int, unsigned char *, unsigned int);\n\nvoid\natelnet(int nfd, unsigned char *buf, unsigned int size)\n{\n\tunsigned char *p, *end;\n\tunsigned char obuf[4];\n\n\tif (size < 3)\n\t\treturn;\n\tend = buf + size - 2;\n\n\tfor (p = buf; p < end; p++) {\n\t\tif (*p != IAC)\n\t\t\tcontinue;\n\n\t\tobuf[0] = IAC;\n\t\tp++;\n\t\tif ((*p == WILL) || (*p == WONT))\n\t\t\tobuf[1] = DONT;\n\t\telse if ((*p == DO) || (*p == DONT))\n\t\t\tobuf[1] = WONT;\n\t\telse\n\t\t\tcontinue;\n\n\t\tp++;\n\t\tobuf[2] = *p;\n\t\tif (atomicio(vwrite, nfd, obuf, 3) != 3)\n\t\t\twarn(\"Write Error!\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fillbuf",
          "args": [
            "pfd[POLL_NETIN].fd",
            "netinbuf",
            "&netinbufpos"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "fillbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "975-989",
          "snippet": "ssize_t\nfillbuf(int fd, unsigned char *buf, size_t *bufpos)\n{\n\tsize_t num = BUFSIZE - *bufpos;\n\tssize_t n;\n\n\tn = read(fd, buf + *bufpos, num);\n\t/* don't treat EAGAIN, EINTR as error */\n\tif (n == -1 && (errno == EAGAIN || errno == EINTR))\n\t\tn = -2;\n\tif (n <= 0)\n\t\treturn n;\n\t*bufpos += n;\n\treturn n;\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define BUFSIZE 16384"
          ],
          "globals_used": [
            "ssize_t drainbuf(int, unsigned char *, size_t *);",
            "ssize_t fillbuf(int, unsigned char *, size_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define BUFSIZE 16384\n\nssize_t drainbuf(int, unsigned char *, size_t *);\nssize_t fillbuf(int, unsigned char *, size_t *);\n\nssize_t\nfillbuf(int fd, unsigned char *buf, size_t *bufpos)\n{\n\tsize_t num = BUFSIZE - *bufpos;\n\tssize_t n;\n\n\tn = read(fd, buf + *bufpos, num);\n\t/* don't treat EAGAIN, EINTR as error */\n\tif (n == -1 && (errno == EAGAIN || errno == EINTR))\n\t\tn = -2;\n\tif (n <= 0)\n\t\treturn n;\n\t*bufpos += n;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"polling error\""
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "run_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1323-1346",
          "snippet": "void\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void run_err(const char *,...);",
            "int errs, remin, remout;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid run_err(const char *,...);\nint errs, remin, remout;\n\nvoid\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "net_fd"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll",
          "args": [
            "pfd",
            "4",
            "timeout"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "after_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "888-941",
          "snippet": "static void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t/* Find sockets entry */\n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror(\"%s: no socket for fd %d\", __func__, pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Process events */\n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0) {\n\t\t\t\tgoto close_sock;\n\t\t\t}\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int sockets_alloc = 0;",
            "SocketEntry *sockets = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int sockets_alloc = 0;\nSocketEntry *sockets = NULL;\n\nstatic void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t/* Find sockets entry */\n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror(\"%s: no socket for fd %d\", __func__, pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Process events */\n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0) {\n\t\t\t\tgoto close_sock;\n\t\t\t}\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "iflag"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "usleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "171-178",
          "snippet": "int usleep(unsigned int useconds)\n{\n\tstruct timespec ts;\n\n\tts.tv_sec = useconds / 1000000;\n\tts.tv_nsec = (useconds % 1000000) * 1000;\n\treturn nanosleep(&ts, NULL);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint usleep(unsigned int useconds)\n{\n\tstruct timespec ts;\n\n\tts.tv_sec = useconds / 1000000;\n\tts.tv_nsec = (useconds % 1000000) * 1000;\n\treturn nanosleep(&ts, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define BUFSIZE 16384\n#define POLL_STDOUT 3\n#define POLL_NETIN 2\n#define POLL_NETOUT 1\n#define POLL_STDIN 0\n\nint\tdflag;\nunsigned int iflag;\nint\tlflag;\nint\tNflag;\nint\ttflag;\nint timeout = -1;\nvoid\tatelnet(int, unsigned char *, unsigned int);\nvoid\thelp(void);\nvoid\treadwrite(int);\nssize_t drainbuf(int, unsigned char *, size_t *);\nssize_t fillbuf(int, unsigned char *, size_t *);\n\nvoid\nreadwrite(int net_fd)\n{\n\tstruct pollfd pfd[4];\n\tint stdin_fd = STDIN_FILENO;\n\tint stdout_fd = STDOUT_FILENO;\n\tunsigned char netinbuf[BUFSIZE];\n\tsize_t netinbufpos = 0;\n\tunsigned char stdinbuf[BUFSIZE];\n\tsize_t stdinbufpos = 0;\n\tint n, num_fds;\n\tssize_t ret;\n\n\t/* don't read from stdin if requested */\n\tif (dflag)\n\t\tstdin_fd = -1;\n\n\t/* stdin */\n\tpfd[POLL_STDIN].fd = stdin_fd;\n\tpfd[POLL_STDIN].events = POLLIN;\n\n\t/* network out */\n\tpfd[POLL_NETOUT].fd = net_fd;\n\tpfd[POLL_NETOUT].events = 0;\n\n\t/* network in */\n\tpfd[POLL_NETIN].fd = net_fd;\n\tpfd[POLL_NETIN].events = POLLIN;\n\n\t/* stdout */\n\tpfd[POLL_STDOUT].fd = stdout_fd;\n\tpfd[POLL_STDOUT].events = 0;\n\n\twhile (1) {\n\t\t/* both inputs are gone, buffers are empty, we are done */\n\t\tif (pfd[POLL_STDIN].fd == -1 && pfd[POLL_NETIN].fd == -1\n\t\t    && stdinbufpos == 0 && netinbufpos == 0) {\n\t\t\tclose(net_fd);\n\t\t\treturn;\n\t\t}\n\t\t/* both outputs are gone, we can't continue */\n\t\tif (pfd[POLL_NETOUT].fd == -1 && pfd[POLL_STDOUT].fd == -1) {\n\t\t\tclose(net_fd);\n\t\t\treturn;\n\t\t}\n\t\t/* listen and net in gone, queues empty, done */\n\t\tif (lflag && pfd[POLL_NETIN].fd == -1\n\t\t    && stdinbufpos == 0 && netinbufpos == 0) {\n\t\t\tclose(net_fd);\n\t\t\treturn;\n\t\t}\n\n\t\t/* help says -i is for \"wait between lines sent\". We read and\n\t\t * write arbitrary amounts of data, and we don't want to start\n\t\t * scanning for newlines, so this is as good as it gets */\n\t\tif (iflag)\n\t\t\tsleep(iflag);\n\n\t\t/* poll */\n\t\tnum_fds = poll(pfd, 4, timeout);\n\n\t\t/* treat poll errors */\n\t\tif (num_fds == -1) {\n\t\t\tclose(net_fd);\n\t\t\terr(1, \"polling error\");\n\t\t}\n\n\t\t/* timeout happened */\n\t\tif (num_fds == 0)\n\t\t\treturn;\n\n\t\t/* treat socket error conditions */\n\t\tfor (n = 0; n < 4; n++) {\n\t\t\tif (pfd[n].revents & (POLLERR|POLLNVAL)) {\n\t\t\t\tpfd[n].fd = -1;\n\t\t\t}\n\t\t}\n\t\t/* reading is possible after HUP */\n\t\tif (pfd[POLL_STDIN].events & POLLIN &&\n\t\t    pfd[POLL_STDIN].revents & POLLHUP &&\n\t\t    ! (pfd[POLL_STDIN].revents & POLLIN))\n\t\t\t\tpfd[POLL_STDIN].fd = -1;\n\n\t\tif (pfd[POLL_NETIN].events & POLLIN &&\n\t\t    pfd[POLL_NETIN].revents & POLLHUP &&\n\t\t    ! (pfd[POLL_NETIN].revents & POLLIN))\n\t\t\t\tpfd[POLL_NETIN].fd = -1;\n\n\t\tif (pfd[POLL_NETOUT].revents & POLLHUP) {\n\t\t\tif (Nflag)\n\t\t\t\tshutdown(pfd[POLL_NETOUT].fd, SHUT_WR);\n\t\t\tpfd[POLL_NETOUT].fd = -1;\n\t\t}\n\t\t/* if HUP, stop watching stdout */\n\t\tif (pfd[POLL_STDOUT].revents & POLLHUP)\n\t\t\tpfd[POLL_STDOUT].fd = -1;\n\t\t/* if no net out, stop watching stdin */\n\t\tif (pfd[POLL_NETOUT].fd == -1)\n\t\t\tpfd[POLL_STDIN].fd = -1;\n\t\t/* if no stdout, stop watching net in */\n\t\tif (pfd[POLL_STDOUT].fd == -1) {\n\t\t\tif (pfd[POLL_NETIN].fd != -1)\n\t\t\t\tshutdown(pfd[POLL_NETIN].fd, SHUT_RD);\n\t\t\tpfd[POLL_NETIN].fd = -1;\n\t\t}\n\n\t\t/* try to read from stdin */\n\t\tif (pfd[POLL_STDIN].revents & POLLIN && stdinbufpos < BUFSIZE) {\n\t\t\tret = fillbuf(pfd[POLL_STDIN].fd, stdinbuf,\n\t\t\t    &stdinbufpos);\n\t\t\t/* error or eof on stdin - remove from pfd */\n\t\t\tif (ret == 0 || ret == -1)\n\t\t\t\tpfd[POLL_STDIN].fd = -1;\n\t\t\t/* read something - poll net out */\n\t\t\tif (stdinbufpos > 0)\n\t\t\t\tpfd[POLL_NETOUT].events = POLLOUT;\n\t\t\t/* filled buffer - remove self from polling */\n\t\t\tif (stdinbufpos == BUFSIZE)\n\t\t\t\tpfd[POLL_STDIN].events = 0;\n\t\t}\n\t\t/* try to write to network */\n\t\tif (pfd[POLL_NETOUT].revents & POLLOUT && stdinbufpos > 0) {\n\t\t\tret = drainbuf(pfd[POLL_NETOUT].fd, stdinbuf,\n\t\t\t    &stdinbufpos);\n\t\t\tif (ret == -1)\n\t\t\t\tpfd[POLL_NETOUT].fd = -1;\n\t\t\t/* buffer empty - remove self from polling */\n\t\t\tif (stdinbufpos == 0)\n\t\t\t\tpfd[POLL_NETOUT].events = 0;\n\t\t\t/* buffer no longer full - poll stdin again */\n\t\t\tif (stdinbufpos < BUFSIZE)\n\t\t\t\tpfd[POLL_STDIN].events = POLLIN;\n\t\t}\n\t\t/* try to read from network */\n\t\tif (pfd[POLL_NETIN].revents & POLLIN && netinbufpos < BUFSIZE) {\n\t\t\tret = fillbuf(pfd[POLL_NETIN].fd, netinbuf,\n\t\t\t    &netinbufpos);\n\t\t\tif (ret == -1)\n\t\t\t\tpfd[POLL_NETIN].fd = -1;\n\t\t\t/* eof on net in - remove from pfd */\n\t\t\tif (ret == 0) {\n\t\t\t\tshutdown(pfd[POLL_NETIN].fd, SHUT_RD);\n\t\t\t\tpfd[POLL_NETIN].fd = -1;\n\t\t\t}\n\t\t\t/* read something - poll stdout */\n\t\t\tif (netinbufpos > 0)\n\t\t\t\tpfd[POLL_STDOUT].events = POLLOUT;\n\t\t\t/* filled buffer - remove self from polling */\n\t\t\tif (netinbufpos == BUFSIZE)\n\t\t\t\tpfd[POLL_NETIN].events = 0;\n\t\t\t/* handle telnet */\n\t\t\tif (tflag)\n\t\t\t\tatelnet(pfd[POLL_NETIN].fd, netinbuf,\n\t\t\t\t    netinbufpos);\n\t\t}\n\t\t/* try to write to stdout */\n\t\tif (pfd[POLL_STDOUT].revents & POLLOUT && netinbufpos > 0) {\n\t\t\tret = drainbuf(pfd[POLL_STDOUT].fd, netinbuf,\n\t\t\t    &netinbufpos);\n\t\t\tif (ret == -1)\n\t\t\t\tpfd[POLL_STDOUT].fd = -1;\n\t\t\t/* buffer empty - remove self from polling */\n\t\t\tif (netinbufpos == 0)\n\t\t\t\tpfd[POLL_STDOUT].events = 0;\n\t\t\t/* buffer no longer full - poll net in again */\n\t\t\tif (netinbufpos < BUFSIZE)\n\t\t\t\tpfd[POLL_NETIN].events = POLLIN;\n\t\t}\n\n\t\t/* stdin gone and queue empty? */\n\t\tif (pfd[POLL_STDIN].fd == -1 && stdinbufpos == 0) {\n\t\t\tif (pfd[POLL_NETOUT].fd != -1 && Nflag)\n\t\t\t\tshutdown(pfd[POLL_NETOUT].fd, SHUT_WR);\n\t\t\tpfd[POLL_NETOUT].fd = -1;\n\t\t}\n\t\t/* net in gone and queue empty? */\n\t\tif (pfd[POLL_NETIN].fd == -1 && netinbufpos == 0) {\n\t\t\tpfd[POLL_STDOUT].fd = -1;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "local_listen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
    "lines": "707-766",
    "snippet": "int\nlocal_listen(char *host, char *port, struct addrinfo hints)\n{\n\tstruct addrinfo *res, *res0;\n\tint s, ret, x = 1;\n\tint error;\n\n\t/* Allow nodename to be null. */\n\thints.ai_flags |= AI_PASSIVE;\n\n\t/*\n\t * In the case of binding to a wildcard address\n\t * default to binding to an ipv4 address.\n\t */\n\tif (host == NULL && hints.ai_family == AF_UNSPEC)\n\t\thints.ai_family = AF_INET;\n\n\tif ((error = getaddrinfo(host, port, &hints, &res)))\n\t\terrx(1, \"getaddrinfo: %s\", gai_strerror(error));\n\n\tres0 = res;\n\tdo {\n\t\tif ((s = socket(res0->ai_family, res0->ai_socktype,\n\t\t    res0->ai_protocol)) < 0)\n\t\t\tcontinue;\n\n#ifdef SO_RTABLE\n\t\tif (rtableid >= 0 && (setsockopt(s, SOL_SOCKET, SO_RTABLE,\n\t\t    &rtableid, sizeof(rtableid)) == -1))\n\t\t\terr(1, \"setsockopt SO_RTABLE\");\n#endif\n#ifdef SO_REUSEPORT\n\t\tret = setsockopt(s, SOL_SOCKET, SO_REUSEPORT, &x, sizeof(x));\n\t\tif (ret == -1)\n\t\t\terr(1, \"setsockopt SO_REUSEPORT\");\n#endif\n#ifdef SO_REUSEADDR\n\t\tret = setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &x, sizeof(x));\n\t\tif (ret == -1)\n\t\t\terr(1, \"setsockopt SO_REUSEADDR\");\n#endif\n\t\tset_common_sockopts(s);\n\n\t\tif (bind(s, (struct sockaddr *)res0->ai_addr,\n\t\t    res0->ai_addrlen) == 0)\n\t\t\tbreak;\n\n\t\tclose(s);\n\t\ts = -1;\n\t} while ((res0 = res0->ai_next) != NULL);\n\n\tif (!uflag && s != -1) {\n\t\tif (listen(s, 1) < 0)\n\t\t\terr(1, \"listen\");\n\t}\n\n\tfreeaddrinfo(res);\n\n\treturn (s);\n}",
    "includes": [
      "#include <resolv.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "# include <err.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/uio.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tuflag;",
      "int\trtableid = -1;",
      "int\tlocal_listen(char *, char *, struct addrinfo);",
      "int\tremote_connect(const char *, const char *, struct addrinfo);",
      "int\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int, const char *);",
      "void\tset_common_sockopts(int);",
      "int\tremote_connect(const char *, const char *, struct addrinfo);",
      "int\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int,\n\t    const char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "res"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"listen\""
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "run_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1323-1346",
          "snippet": "void\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void run_err(const char *,...);",
            "int errs, remin, remout;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid run_err(const char *,...);\nint errs, remin, remout;\n\nvoid\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "listen",
          "args": [
            "s",
            "1"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "open_listen_match_streamlocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3931-3943",
          "snippet": "static int\nopen_listen_match_streamlocal(struct permission *allowed_open,\n    const char *requestedpath)\n{\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->listen_port != PORT_STREAMLOCAL)\n\t\treturn 0;\n\tif (allowed_open->listen_path == NULL ||\n\t    strcmp(allowed_open->listen_path, requestedpath) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nopen_listen_match_streamlocal(struct permission *allowed_open,\n    const char *requestedpath)\n{\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->listen_port != PORT_STREAMLOCAL)\n\t\treturn 0;\n\tif (allowed_open->listen_path == NULL ||\n\t    strcmp(allowed_open->listen_path, requestedpath) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "s"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "s",
            "(struct sockaddr *)res0->ai_addr",
            "res0->ai_addrlen"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_common_sockopts",
          "args": [
            "s"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "set_common_sockopts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "1167-1199",
          "snippet": "void\nset_common_sockopts(int s)\n{\n\tint x = 1;\n\n#ifdef TCP_MD5SIG\n\tif (Sflag) {\n\t\tif (setsockopt(s, IPPROTO_TCP, TCP_MD5SIG,\n\t\t\t&x, sizeof(x)) == -1)\n\t\t\terr(1, \"setsockopt\");\n\t}\n#endif\n\tif (Dflag) {\n\t\tif (setsockopt(s, SOL_SOCKET, SO_DEBUG,\n\t\t\t&x, sizeof(x)) == -1)\n\t\t\terr(1, \"setsockopt\");\n\t}\n\tif (Tflag != -1) {\n\t\tif (setsockopt(s, IPPROTO_IP, IP_TOS,\n\t\t    &Tflag, sizeof(Tflag)) == -1)\n\t\t\terr(1, \"set IP ToS\");\n\t}\n\tif (Iflag) {\n\t\tif (setsockopt(s, SOL_SOCKET, SO_RCVBUF,\n\t\t    &Iflag, sizeof(Iflag)) == -1)\n\t\t\terr(1, \"set TCP receive buffer size\");\n\t}\n\tif (Oflag) {\n\t\tif (setsockopt(s, SOL_SOCKET, SO_SNDBUF,\n\t\t    &Oflag, sizeof(Oflag)) == -1)\n\t\t\terr(1, \"set TCP send buffer size\");\n\t}\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tDflag;",
            "int\tIflag;",
            "int\tOflag;",
            "int\tSflag;",
            "int\tTflag = -1;",
            "void\tset_common_sockopts(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tDflag;\nint\tIflag;\nint\tOflag;\nint\tSflag;\nint\tTflag = -1;\nvoid\tset_common_sockopts(int);\n\nvoid\nset_common_sockopts(int s)\n{\n\tint x = 1;\n\n#ifdef TCP_MD5SIG\n\tif (Sflag) {\n\t\tif (setsockopt(s, IPPROTO_TCP, TCP_MD5SIG,\n\t\t\t&x, sizeof(x)) == -1)\n\t\t\terr(1, \"setsockopt\");\n\t}\n#endif\n\tif (Dflag) {\n\t\tif (setsockopt(s, SOL_SOCKET, SO_DEBUG,\n\t\t\t&x, sizeof(x)) == -1)\n\t\t\terr(1, \"setsockopt\");\n\t}\n\tif (Tflag != -1) {\n\t\tif (setsockopt(s, IPPROTO_IP, IP_TOS,\n\t\t    &Tflag, sizeof(Tflag)) == -1)\n\t\t\terr(1, \"set IP ToS\");\n\t}\n\tif (Iflag) {\n\t\tif (setsockopt(s, SOL_SOCKET, SO_RCVBUF,\n\t\t    &Iflag, sizeof(Iflag)) == -1)\n\t\t\terr(1, \"set TCP receive buffer size\");\n\t}\n\tif (Oflag) {\n\t\tif (setsockopt(s, SOL_SOCKET, SO_SNDBUF,\n\t\t    &Oflag, sizeof(Oflag)) == -1)\n\t\t\terr(1, \"set TCP send buffer size\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "s",
            "SOL_SOCKET",
            "SO_REUSEADDR",
            "&x",
            "sizeof(x)"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "s",
            "SOL_SOCKET",
            "SO_REUSEPORT",
            "&x",
            "sizeof(x)"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "s",
            "SOL_SOCKET",
            "SO_RTABLE",
            "&rtableid",
            "sizeof(rtableid)"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "res0->ai_family",
            "res0->ai_socktype",
            "res0->ai_protocol"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "67-111",
          "snippet": "static char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"getaddrinfo: %s\"",
            "gai_strerror(error)"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "errx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-err.c",
          "lines": "52-62",
          "snippet": "void\nerrx(int r, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(r);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\nvoid\nerrx(int r, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gai_strerror",
          "args": [
            "error"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "host",
            "port",
            "&hints",
            "&res"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "getaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "154-234",
          "snippet": "int\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tuflag;\nint\trtableid = -1;\nint\tlocal_listen(char *, char *, struct addrinfo);\nint\tremote_connect(const char *, const char *, struct addrinfo);\nint\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int, const char *);\nvoid\tset_common_sockopts(int);\nint\tremote_connect(const char *, const char *, struct addrinfo);\nint\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int,\n\t    const char *);\n\nint\nlocal_listen(char *host, char *port, struct addrinfo hints)\n{\n\tstruct addrinfo *res, *res0;\n\tint s, ret, x = 1;\n\tint error;\n\n\t/* Allow nodename to be null. */\n\thints.ai_flags |= AI_PASSIVE;\n\n\t/*\n\t * In the case of binding to a wildcard address\n\t * default to binding to an ipv4 address.\n\t */\n\tif (host == NULL && hints.ai_family == AF_UNSPEC)\n\t\thints.ai_family = AF_INET;\n\n\tif ((error = getaddrinfo(host, port, &hints, &res)))\n\t\terrx(1, \"getaddrinfo: %s\", gai_strerror(error));\n\n\tres0 = res;\n\tdo {\n\t\tif ((s = socket(res0->ai_family, res0->ai_socktype,\n\t\t    res0->ai_protocol)) < 0)\n\t\t\tcontinue;\n\n#ifdef SO_RTABLE\n\t\tif (rtableid >= 0 && (setsockopt(s, SOL_SOCKET, SO_RTABLE,\n\t\t    &rtableid, sizeof(rtableid)) == -1))\n\t\t\terr(1, \"setsockopt SO_RTABLE\");\n#endif\n#ifdef SO_REUSEPORT\n\t\tret = setsockopt(s, SOL_SOCKET, SO_REUSEPORT, &x, sizeof(x));\n\t\tif (ret == -1)\n\t\t\terr(1, \"setsockopt SO_REUSEPORT\");\n#endif\n#ifdef SO_REUSEADDR\n\t\tret = setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &x, sizeof(x));\n\t\tif (ret == -1)\n\t\t\terr(1, \"setsockopt SO_REUSEADDR\");\n#endif\n\t\tset_common_sockopts(s);\n\n\t\tif (bind(s, (struct sockaddr *)res0->ai_addr,\n\t\t    res0->ai_addrlen) == 0)\n\t\t\tbreak;\n\n\t\tclose(s);\n\t\ts = -1;\n\t} while ((res0 = res0->ai_next) != NULL);\n\n\tif (!uflag && s != -1) {\n\t\tif (listen(s, 1) < 0)\n\t\t\terr(1, \"listen\");\n\t}\n\n\tfreeaddrinfo(res);\n\n\treturn (s);\n}"
  },
  {
    "function_name": "timeout_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
    "lines": "665-700",
    "snippet": "int\ntimeout_connect(int s, const struct sockaddr *name, socklen_t namelen)\n{\n\tstruct pollfd pfd;\n\tsocklen_t optlen;\n\tint flags = 0, optval;\n\tint ret;\n\n\tif (timeout != -1) {\n\t\tflags = fcntl(s, F_GETFL, 0);\n\t\tif (fcntl(s, F_SETFL, flags | O_NONBLOCK) == -1)\n\t\t\terr(1, \"set non-blocking mode\");\n\t}\n\n\tif ((ret = connect(s, name, namelen)) != 0 && errno == EINPROGRESS) {\n\t\tpfd.fd = s;\n\t\tpfd.events = POLLOUT;\n\t\tif ((ret = poll(&pfd, 1, timeout)) == 1) {\n\t\t\toptlen = sizeof(optval);\n\t\t\tif ((ret = getsockopt(s, SOL_SOCKET, SO_ERROR,\n\t\t\t    &optval, &optlen)) == 0) {\n\t\t\t\terrno = optval;\n\t\t\t\tret = optval == 0 ? 0 : -1;\n\t\t\t}\n\t\t} else if (ret == 0) {\n\t\t\terrno = ETIMEDOUT;\n\t\t\tret = -1;\n\t\t} else\n\t\t\terr(1, \"poll failed\");\n\t}\n\n\tif (timeout != -1 && fcntl(s, F_SETFL, flags) == -1)\n\t\terr(1, \"restoring flags\");\n\n\treturn (ret);\n}",
    "includes": [
      "#include <resolv.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "# include <err.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/uio.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int timeout = -1;",
      "int\ttimeout_connect(int, const struct sockaddr *, socklen_t);",
      "void\treport_connect(const struct sockaddr *, socklen_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"restoring flags\""
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "run_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1323-1346",
          "snippet": "void\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void run_err(const char *,...);",
            "int errs, remin, remout;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid run_err(const char *,...);\nint errs, remin, remout;\n\nvoid\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "s",
            "F_SETFL",
            "flags"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getsockopt",
          "args": [
            "s",
            "SOL_SOCKET",
            "SO_ERROR",
            "&optval",
            "&optlen"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll",
          "args": [
            "&pfd",
            "1",
            "timeout"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "after_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-agent.c",
          "lines": "888-941",
          "snippet": "static void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t/* Find sockets entry */\n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror(\"%s: no socket for fd %d\", __func__, pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Process events */\n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0) {\n\t\t\t\tgoto close_sock;\n\t\t\t}\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ssh-pkcs11.h\"",
            "#include \"match.h\"",
            "#include \"ssherr.h\"",
            "#include \"digest.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "# include <util.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "# include <paths.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"openbsd-compat/openssl-compat.h\"",
            "#include <openssl/evp.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "# include <sys/un.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int sockets_alloc = 0;",
            "SocketEntry *sockets = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-pkcs11.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n# include <util.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n# include <paths.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#include <openssl/evp.h>\n#include \"openbsd-compat/sys-queue.h\"\n# include <sys/un.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nu_int sockets_alloc = 0;\nSocketEntry *sockets = NULL;\n\nstatic void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t/* Find sockets entry */\n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror(\"%s: no socket for fd %d\", __func__, pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Process events */\n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0) {\n\t\t\t\tgoto close_sock;\n\t\t\t}\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "s",
            "name",
            "namelen"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "timeout_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "665-700",
          "snippet": "int\ntimeout_connect(int s, const struct sockaddr *name, socklen_t namelen)\n{\n\tstruct pollfd pfd;\n\tsocklen_t optlen;\n\tint flags = 0, optval;\n\tint ret;\n\n\tif (timeout != -1) {\n\t\tflags = fcntl(s, F_GETFL, 0);\n\t\tif (fcntl(s, F_SETFL, flags | O_NONBLOCK) == -1)\n\t\t\terr(1, \"set non-blocking mode\");\n\t}\n\n\tif ((ret = connect(s, name, namelen)) != 0 && errno == EINPROGRESS) {\n\t\tpfd.fd = s;\n\t\tpfd.events = POLLOUT;\n\t\tif ((ret = poll(&pfd, 1, timeout)) == 1) {\n\t\t\toptlen = sizeof(optval);\n\t\t\tif ((ret = getsockopt(s, SOL_SOCKET, SO_ERROR,\n\t\t\t    &optval, &optlen)) == 0) {\n\t\t\t\terrno = optval;\n\t\t\t\tret = optval == 0 ? 0 : -1;\n\t\t\t}\n\t\t} else if (ret == 0) {\n\t\t\terrno = ETIMEDOUT;\n\t\t\tret = -1;\n\t\t} else\n\t\t\terr(1, \"poll failed\");\n\t}\n\n\tif (timeout != -1 && fcntl(s, F_SETFL, flags) == -1)\n\t\terr(1, \"restoring flags\");\n\n\treturn (ret);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "s",
            "F_SETFL",
            "flags | O_NONBLOCK"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "s",
            "F_GETFL",
            "0"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint timeout = -1;\nint\ttimeout_connect(int, const struct sockaddr *, socklen_t);\nvoid\treport_connect(const struct sockaddr *, socklen_t);\n\nint\ntimeout_connect(int s, const struct sockaddr *name, socklen_t namelen)\n{\n\tstruct pollfd pfd;\n\tsocklen_t optlen;\n\tint flags = 0, optval;\n\tint ret;\n\n\tif (timeout != -1) {\n\t\tflags = fcntl(s, F_GETFL, 0);\n\t\tif (fcntl(s, F_SETFL, flags | O_NONBLOCK) == -1)\n\t\t\terr(1, \"set non-blocking mode\");\n\t}\n\n\tif ((ret = connect(s, name, namelen)) != 0 && errno == EINPROGRESS) {\n\t\tpfd.fd = s;\n\t\tpfd.events = POLLOUT;\n\t\tif ((ret = poll(&pfd, 1, timeout)) == 1) {\n\t\t\toptlen = sizeof(optval);\n\t\t\tif ((ret = getsockopt(s, SOL_SOCKET, SO_ERROR,\n\t\t\t    &optval, &optlen)) == 0) {\n\t\t\t\terrno = optval;\n\t\t\t\tret = optval == 0 ? 0 : -1;\n\t\t\t}\n\t\t} else if (ret == 0) {\n\t\t\terrno = ETIMEDOUT;\n\t\t\tret = -1;\n\t\t} else\n\t\t\terr(1, \"poll failed\");\n\t}\n\n\tif (timeout != -1 && fcntl(s, F_SETFL, flags) == -1)\n\t\terr(1, \"restoring flags\");\n\n\treturn (ret);\n}"
  },
  {
    "function_name": "remote_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
    "lines": "603-663",
    "snippet": "int\nremote_connect(const char *host, const char *port, struct addrinfo hints)\n{\n\tstruct addrinfo *res, *res0;\n\tint s, error;\n#if defined(SO_RTABLE) || defined(SO_BINDANY)\n\tint on = 1;\n#endif\n\n\tif ((error = getaddrinfo(host, port, &hints, &res)))\n\t\terrx(1, \"getaddrinfo: %s\", gai_strerror(error));\n\n\tres0 = res;\n\tdo {\n\t\tif ((s = socket(res0->ai_family, res0->ai_socktype,\n\t\t    res0->ai_protocol)) < 0)\n\t\t\tcontinue;\n\n#ifdef SO_RTABLE\n\t\tif (rtableid >= 0 && (setsockopt(s, SOL_SOCKET, SO_RTABLE,\n\t\t    &rtableid, sizeof(rtableid)) == -1))\n\t\t\terr(1, \"setsockopt SO_RTABLE\");\n#endif\n\t\t/* Bind to a local port or source address if specified. */\n\t\tif (sflag || pflag) {\n\t\t\tstruct addrinfo ahints, *ares;\n\n#ifdef SO_BINDANY\n\t\t\t/* try SO_BINDANY, but don't insist */\n\t\t\tsetsockopt(s, SOL_SOCKET, SO_BINDANY, &on, sizeof(on));\n#endif\n\t\t\tmemset(&ahints, 0, sizeof(struct addrinfo));\n\t\t\tahints.ai_family = res0->ai_family;\n\t\t\tahints.ai_socktype = uflag ? SOCK_DGRAM : SOCK_STREAM;\n\t\t\tahints.ai_protocol = uflag ? IPPROTO_UDP : IPPROTO_TCP;\n\t\t\tahints.ai_flags = AI_PASSIVE;\n\t\t\tif ((error = getaddrinfo(sflag, pflag, &ahints, &ares)))\n\t\t\t\terrx(1, \"getaddrinfo: %s\", gai_strerror(error));\n\n\t\t\tif (bind(s, (struct sockaddr *)ares->ai_addr,\n\t\t\t    ares->ai_addrlen) < 0)\n\t\t\t\terr(1, \"bind failed\");\n\t\t\tfreeaddrinfo(ares);\n\t\t}\n\n\t\tset_common_sockopts(s);\n\n\t\tif (timeout_connect(s, res0->ai_addr, res0->ai_addrlen) == 0)\n\t\t\tbreak;\n\t\telse if (vflag)\n\t\t\twarn(\"connect to %s port %s (%s) failed\", host, port,\n\t\t\t    uflag ? \"udp\" : \"tcp\");\n\n\t\tclose(s);\n\t\ts = -1;\n\t} while ((res0 = res0->ai_next) != NULL);\n\n\tfreeaddrinfo(res);\n\n\treturn (s);\n}",
    "includes": [
      "#include <resolv.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "# include <err.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/uio.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char   *pflag;",
      "char   *sflag;",
      "int\tuflag;",
      "int\tvflag;",
      "int\trtableid = -1;",
      "int\tlocal_listen(char *, char *, struct addrinfo);",
      "int\tremote_connect(const char *, const char *, struct addrinfo);",
      "int\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int, const char *);",
      "void\tset_common_sockopts(int);",
      "int\tremote_connect(const char *, const char *, struct addrinfo);",
      "int\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int,\n\t    const char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "res"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "freeaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "109-119",
          "snippet": "void\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "s"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn",
          "args": [
            "\"connect to %s port %s (%s) failed\"",
            "host",
            "port",
            "uflag ? \"udp\" : \"tcp\""
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "warn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-err.c",
          "lines": "66-76",
          "snippet": "void\nwarn(const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tfprintf(stderr, \"%s: \", strerror(errno));\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\nvoid\nwarn(const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tfprintf(stderr, \"%s: \", strerror(errno));\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timeout_connect",
          "args": [
            "s",
            "res0->ai_addr",
            "res0->ai_addrlen"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "timeout_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "665-700",
          "snippet": "int\ntimeout_connect(int s, const struct sockaddr *name, socklen_t namelen)\n{\n\tstruct pollfd pfd;\n\tsocklen_t optlen;\n\tint flags = 0, optval;\n\tint ret;\n\n\tif (timeout != -1) {\n\t\tflags = fcntl(s, F_GETFL, 0);\n\t\tif (fcntl(s, F_SETFL, flags | O_NONBLOCK) == -1)\n\t\t\terr(1, \"set non-blocking mode\");\n\t}\n\n\tif ((ret = connect(s, name, namelen)) != 0 && errno == EINPROGRESS) {\n\t\tpfd.fd = s;\n\t\tpfd.events = POLLOUT;\n\t\tif ((ret = poll(&pfd, 1, timeout)) == 1) {\n\t\t\toptlen = sizeof(optval);\n\t\t\tif ((ret = getsockopt(s, SOL_SOCKET, SO_ERROR,\n\t\t\t    &optval, &optlen)) == 0) {\n\t\t\t\terrno = optval;\n\t\t\t\tret = optval == 0 ? 0 : -1;\n\t\t\t}\n\t\t} else if (ret == 0) {\n\t\t\terrno = ETIMEDOUT;\n\t\t\tret = -1;\n\t\t} else\n\t\t\terr(1, \"poll failed\");\n\t}\n\n\tif (timeout != -1 && fcntl(s, F_SETFL, flags) == -1)\n\t\terr(1, \"restoring flags\");\n\n\treturn (ret);\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int timeout = -1;",
            "int\ttimeout_connect(int, const struct sockaddr *, socklen_t);",
            "void\treport_connect(const struct sockaddr *, socklen_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint timeout = -1;\nint\ttimeout_connect(int, const struct sockaddr *, socklen_t);\nvoid\treport_connect(const struct sockaddr *, socklen_t);\n\nint\ntimeout_connect(int s, const struct sockaddr *name, socklen_t namelen)\n{\n\tstruct pollfd pfd;\n\tsocklen_t optlen;\n\tint flags = 0, optval;\n\tint ret;\n\n\tif (timeout != -1) {\n\t\tflags = fcntl(s, F_GETFL, 0);\n\t\tif (fcntl(s, F_SETFL, flags | O_NONBLOCK) == -1)\n\t\t\terr(1, \"set non-blocking mode\");\n\t}\n\n\tif ((ret = connect(s, name, namelen)) != 0 && errno == EINPROGRESS) {\n\t\tpfd.fd = s;\n\t\tpfd.events = POLLOUT;\n\t\tif ((ret = poll(&pfd, 1, timeout)) == 1) {\n\t\t\toptlen = sizeof(optval);\n\t\t\tif ((ret = getsockopt(s, SOL_SOCKET, SO_ERROR,\n\t\t\t    &optval, &optlen)) == 0) {\n\t\t\t\terrno = optval;\n\t\t\t\tret = optval == 0 ? 0 : -1;\n\t\t\t}\n\t\t} else if (ret == 0) {\n\t\t\terrno = ETIMEDOUT;\n\t\t\tret = -1;\n\t\t} else\n\t\t\terr(1, \"poll failed\");\n\t}\n\n\tif (timeout != -1 && fcntl(s, F_SETFL, flags) == -1)\n\t\terr(1, \"restoring flags\");\n\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_common_sockopts",
          "args": [
            "s"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "set_common_sockopts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "1167-1199",
          "snippet": "void\nset_common_sockopts(int s)\n{\n\tint x = 1;\n\n#ifdef TCP_MD5SIG\n\tif (Sflag) {\n\t\tif (setsockopt(s, IPPROTO_TCP, TCP_MD5SIG,\n\t\t\t&x, sizeof(x)) == -1)\n\t\t\terr(1, \"setsockopt\");\n\t}\n#endif\n\tif (Dflag) {\n\t\tif (setsockopt(s, SOL_SOCKET, SO_DEBUG,\n\t\t\t&x, sizeof(x)) == -1)\n\t\t\terr(1, \"setsockopt\");\n\t}\n\tif (Tflag != -1) {\n\t\tif (setsockopt(s, IPPROTO_IP, IP_TOS,\n\t\t    &Tflag, sizeof(Tflag)) == -1)\n\t\t\terr(1, \"set IP ToS\");\n\t}\n\tif (Iflag) {\n\t\tif (setsockopt(s, SOL_SOCKET, SO_RCVBUF,\n\t\t    &Iflag, sizeof(Iflag)) == -1)\n\t\t\terr(1, \"set TCP receive buffer size\");\n\t}\n\tif (Oflag) {\n\t\tif (setsockopt(s, SOL_SOCKET, SO_SNDBUF,\n\t\t    &Oflag, sizeof(Oflag)) == -1)\n\t\t\terr(1, \"set TCP send buffer size\");\n\t}\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tDflag;",
            "int\tIflag;",
            "int\tOflag;",
            "int\tSflag;",
            "int\tTflag = -1;",
            "void\tset_common_sockopts(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tDflag;\nint\tIflag;\nint\tOflag;\nint\tSflag;\nint\tTflag = -1;\nvoid\tset_common_sockopts(int);\n\nvoid\nset_common_sockopts(int s)\n{\n\tint x = 1;\n\n#ifdef TCP_MD5SIG\n\tif (Sflag) {\n\t\tif (setsockopt(s, IPPROTO_TCP, TCP_MD5SIG,\n\t\t\t&x, sizeof(x)) == -1)\n\t\t\terr(1, \"setsockopt\");\n\t}\n#endif\n\tif (Dflag) {\n\t\tif (setsockopt(s, SOL_SOCKET, SO_DEBUG,\n\t\t\t&x, sizeof(x)) == -1)\n\t\t\terr(1, \"setsockopt\");\n\t}\n\tif (Tflag != -1) {\n\t\tif (setsockopt(s, IPPROTO_IP, IP_TOS,\n\t\t    &Tflag, sizeof(Tflag)) == -1)\n\t\t\terr(1, \"set IP ToS\");\n\t}\n\tif (Iflag) {\n\t\tif (setsockopt(s, SOL_SOCKET, SO_RCVBUF,\n\t\t    &Iflag, sizeof(Iflag)) == -1)\n\t\t\terr(1, \"set TCP receive buffer size\");\n\t}\n\tif (Oflag) {\n\t\tif (setsockopt(s, SOL_SOCKET, SO_SNDBUF,\n\t\t    &Oflag, sizeof(Oflag)) == -1)\n\t\t\terr(1, \"set TCP send buffer size\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"bind failed\""
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "run_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1323-1346",
          "snippet": "void\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void run_err(const char *,...);",
            "int errs, remin, remout;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid run_err(const char *,...);\nint errs, remin, remout;\n\nvoid\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "s",
            "(struct sockaddr *)ares->ai_addr",
            "ares->ai_addrlen"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"getaddrinfo: %s\"",
            "gai_strerror(error)"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "errx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-err.c",
          "lines": "52-62",
          "snippet": "void\nerrx(int r, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(r);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\nvoid\nerrx(int r, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gai_strerror",
          "args": [
            "error"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "140-146",
          "snippet": "const char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "sflag",
            "pflag",
            "&ahints",
            "&ares"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "getaddrinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/fake-rfc2553.c",
          "lines": "154-234",
          "snippet": "int\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}",
          "includes": [
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\nint\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t/* Don't try DNS if AI_NUMERICHOST is set */\n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ahints",
            "0",
            "sizeof(struct addrinfo)"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "s",
            "SOL_SOCKET",
            "SO_BINDANY",
            "&on",
            "sizeof(on)"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "s",
            "SOL_SOCKET",
            "SO_RTABLE",
            "&rtableid",
            "sizeof(rtableid)"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "res0->ai_family",
            "res0->ai_socktype",
            "res0->ai_protocol"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "67-111",
          "snippet": "static char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar   *pflag;\nchar   *sflag;\nint\tuflag;\nint\tvflag;\nint\trtableid = -1;\nint\tlocal_listen(char *, char *, struct addrinfo);\nint\tremote_connect(const char *, const char *, struct addrinfo);\nint\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int, const char *);\nvoid\tset_common_sockopts(int);\nint\tremote_connect(const char *, const char *, struct addrinfo);\nint\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int,\n\t    const char *);\n\nint\nremote_connect(const char *host, const char *port, struct addrinfo hints)\n{\n\tstruct addrinfo *res, *res0;\n\tint s, error;\n#if defined(SO_RTABLE) || defined(SO_BINDANY)\n\tint on = 1;\n#endif\n\n\tif ((error = getaddrinfo(host, port, &hints, &res)))\n\t\terrx(1, \"getaddrinfo: %s\", gai_strerror(error));\n\n\tres0 = res;\n\tdo {\n\t\tif ((s = socket(res0->ai_family, res0->ai_socktype,\n\t\t    res0->ai_protocol)) < 0)\n\t\t\tcontinue;\n\n#ifdef SO_RTABLE\n\t\tif (rtableid >= 0 && (setsockopt(s, SOL_SOCKET, SO_RTABLE,\n\t\t    &rtableid, sizeof(rtableid)) == -1))\n\t\t\terr(1, \"setsockopt SO_RTABLE\");\n#endif\n\t\t/* Bind to a local port or source address if specified. */\n\t\tif (sflag || pflag) {\n\t\t\tstruct addrinfo ahints, *ares;\n\n#ifdef SO_BINDANY\n\t\t\t/* try SO_BINDANY, but don't insist */\n\t\t\tsetsockopt(s, SOL_SOCKET, SO_BINDANY, &on, sizeof(on));\n#endif\n\t\t\tmemset(&ahints, 0, sizeof(struct addrinfo));\n\t\t\tahints.ai_family = res0->ai_family;\n\t\t\tahints.ai_socktype = uflag ? SOCK_DGRAM : SOCK_STREAM;\n\t\t\tahints.ai_protocol = uflag ? IPPROTO_UDP : IPPROTO_TCP;\n\t\t\tahints.ai_flags = AI_PASSIVE;\n\t\t\tif ((error = getaddrinfo(sflag, pflag, &ahints, &ares)))\n\t\t\t\terrx(1, \"getaddrinfo: %s\", gai_strerror(error));\n\n\t\t\tif (bind(s, (struct sockaddr *)ares->ai_addr,\n\t\t\t    ares->ai_addrlen) < 0)\n\t\t\t\terr(1, \"bind failed\");\n\t\t\tfreeaddrinfo(ares);\n\t\t}\n\n\t\tset_common_sockopts(s);\n\n\t\tif (timeout_connect(s, res0->ai_addr, res0->ai_addrlen) == 0)\n\t\t\tbreak;\n\t\telse if (vflag)\n\t\t\twarn(\"connect to %s port %s (%s) failed\", host, port,\n\t\t\t    uflag ? \"udp\" : \"tcp\");\n\n\t\tclose(s);\n\t\ts = -1;\n\t} while ((res0 = res0->ai_next) != NULL);\n\n\tfreeaddrinfo(res);\n\n\treturn (s);\n}"
  },
  {
    "function_name": "unix_listen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
    "lines": "584-596",
    "snippet": "int\nunix_listen(char *path)\n{\n\tint s;\n\tif ((s = unix_bind(path)) < 0)\n\t\treturn (-1);\n\n\tif (listen(s, 5) < 0) {\n\t\tclose(s);\n\t\treturn (-1);\n\t}\n\treturn (s);\n}",
    "includes": [
      "#include <resolv.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "# include <err.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/uio.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tunix_bind(char *);",
      "int\tunix_listen(char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "s"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "listen",
          "args": [
            "s",
            "5"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "open_listen_match_streamlocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/channels.c",
          "lines": "3931-3943",
          "snippet": "static int\nopen_listen_match_streamlocal(struct permission *allowed_open,\n    const char *requestedpath)\n{\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->listen_port != PORT_STREAMLOCAL)\n\t\treturn 0;\n\tif (allowed_open->listen_path == NULL ||\n\t    strcmp(allowed_open->listen_path, requestedpath) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"match.h\"",
            "#include \"pathnames.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"compat.h\"",
            "#include \"channels.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssherr.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <unistd.h>",
            "#include <termios.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include \"pathnames.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <unistd.h>\n#include <termios.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nopen_listen_match_streamlocal(struct permission *allowed_open,\n    const char *requestedpath)\n{\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->listen_port != PORT_STREAMLOCAL)\n\t\treturn 0;\n\tif (allowed_open->listen_path == NULL ||\n\t    strcmp(allowed_open->listen_path, requestedpath) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unix_bind",
          "args": [
            "path"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "unix_bind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "516-542",
          "snippet": "int\nunix_bind(char *path)\n{\n\tstruct sockaddr_un sun_sa;\n\tint s;\n\n\t/* Create unix domain socket. */\n\tif ((s = socket(AF_UNIX, uflag ? SOCK_DGRAM : SOCK_STREAM,\n\t     0)) < 0)\n\t\treturn (-1);\n\n\tmemset(&sun_sa, 0, sizeof(struct sockaddr_un));\n\tsun_sa.sun_family = AF_UNIX;\n\n\tif (strlcpy(sun_sa.sun_path, path, sizeof(sun_sa.sun_path)) >=\n\t    sizeof(sun_sa.sun_path)) {\n\t\tclose(s);\n\t\terrno = ENAMETOOLONG;\n\t\treturn (-1);\n\t}\n\n\tif (bind(s, (struct sockaddr *)&sun_sa, SUN_LEN(&sun_sa)) < 0) {\n\t\tclose(s);\n\t\treturn (-1);\n\t}\n\treturn (s);\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tuflag;",
            "int\tunix_bind(char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tuflag;\nint\tunix_bind(char *);\n\nint\nunix_bind(char *path)\n{\n\tstruct sockaddr_un sun_sa;\n\tint s;\n\n\t/* Create unix domain socket. */\n\tif ((s = socket(AF_UNIX, uflag ? SOCK_DGRAM : SOCK_STREAM,\n\t     0)) < 0)\n\t\treturn (-1);\n\n\tmemset(&sun_sa, 0, sizeof(struct sockaddr_un));\n\tsun_sa.sun_family = AF_UNIX;\n\n\tif (strlcpy(sun_sa.sun_path, path, sizeof(sun_sa.sun_path)) >=\n\t    sizeof(sun_sa.sun_path)) {\n\t\tclose(s);\n\t\terrno = ENAMETOOLONG;\n\t\treturn (-1);\n\t}\n\n\tif (bind(s, (struct sockaddr *)&sun_sa, SUN_LEN(&sun_sa)) < 0) {\n\t\tclose(s);\n\t\treturn (-1);\n\t}\n\treturn (s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tunix_bind(char *);\nint\tunix_listen(char *);\n\nint\nunix_listen(char *path)\n{\n\tint s;\n\tif ((s = unix_bind(path)) < 0)\n\t\treturn (-1);\n\n\tif (listen(s, 5) < 0) {\n\t\tclose(s);\n\t\treturn (-1);\n\t}\n\treturn (s);\n}"
  },
  {
    "function_name": "unix_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
    "lines": "548-578",
    "snippet": "int\nunix_connect(char *path)\n{\n\tstruct sockaddr_un sun_sa;\n\tint s;\n\n\tif (uflag) {\n\t\tif ((s = unix_bind(unix_dg_tmp_socket)) < 0)\n\t\t\treturn (-1);\n\t} else {\n\t\tif ((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\t\treturn (-1);\n\t}\n\t(void)fcntl(s, F_SETFD, FD_CLOEXEC);\n\n\tmemset(&sun_sa, 0, sizeof(struct sockaddr_un));\n\tsun_sa.sun_family = AF_UNIX;\n\n\tif (strlcpy(sun_sa.sun_path, path, sizeof(sun_sa.sun_path)) >=\n\t    sizeof(sun_sa.sun_path)) {\n\t\tclose(s);\n\t\terrno = ENAMETOOLONG;\n\t\treturn (-1);\n\t}\n\tif (connect(s, (struct sockaddr *)&sun_sa, SUN_LEN(&sun_sa)) < 0) {\n\t\tclose(s);\n\t\treturn (-1);\n\t}\n\treturn (s);\n\n}",
    "includes": [
      "#include <resolv.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "# include <err.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/uio.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tuflag;",
      "char *unix_dg_tmp_socket;",
      "int\tunix_bind(char *);",
      "int\tunix_connect(char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "s"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "s",
            "(struct sockaddr *)&sun_sa",
            "SUN_LEN(&sun_sa)"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "timeout_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "665-700",
          "snippet": "int\ntimeout_connect(int s, const struct sockaddr *name, socklen_t namelen)\n{\n\tstruct pollfd pfd;\n\tsocklen_t optlen;\n\tint flags = 0, optval;\n\tint ret;\n\n\tif (timeout != -1) {\n\t\tflags = fcntl(s, F_GETFL, 0);\n\t\tif (fcntl(s, F_SETFL, flags | O_NONBLOCK) == -1)\n\t\t\terr(1, \"set non-blocking mode\");\n\t}\n\n\tif ((ret = connect(s, name, namelen)) != 0 && errno == EINPROGRESS) {\n\t\tpfd.fd = s;\n\t\tpfd.events = POLLOUT;\n\t\tif ((ret = poll(&pfd, 1, timeout)) == 1) {\n\t\t\toptlen = sizeof(optval);\n\t\t\tif ((ret = getsockopt(s, SOL_SOCKET, SO_ERROR,\n\t\t\t    &optval, &optlen)) == 0) {\n\t\t\t\terrno = optval;\n\t\t\t\tret = optval == 0 ? 0 : -1;\n\t\t\t}\n\t\t} else if (ret == 0) {\n\t\t\terrno = ETIMEDOUT;\n\t\t\tret = -1;\n\t\t} else\n\t\t\terr(1, \"poll failed\");\n\t}\n\n\tif (timeout != -1 && fcntl(s, F_SETFL, flags) == -1)\n\t\terr(1, \"restoring flags\");\n\n\treturn (ret);\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int timeout = -1;",
            "int\ttimeout_connect(int, const struct sockaddr *, socklen_t);",
            "void\treport_connect(const struct sockaddr *, socklen_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint timeout = -1;\nint\ttimeout_connect(int, const struct sockaddr *, socklen_t);\nvoid\treport_connect(const struct sockaddr *, socklen_t);\n\nint\ntimeout_connect(int s, const struct sockaddr *name, socklen_t namelen)\n{\n\tstruct pollfd pfd;\n\tsocklen_t optlen;\n\tint flags = 0, optval;\n\tint ret;\n\n\tif (timeout != -1) {\n\t\tflags = fcntl(s, F_GETFL, 0);\n\t\tif (fcntl(s, F_SETFL, flags | O_NONBLOCK) == -1)\n\t\t\terr(1, \"set non-blocking mode\");\n\t}\n\n\tif ((ret = connect(s, name, namelen)) != 0 && errno == EINPROGRESS) {\n\t\tpfd.fd = s;\n\t\tpfd.events = POLLOUT;\n\t\tif ((ret = poll(&pfd, 1, timeout)) == 1) {\n\t\t\toptlen = sizeof(optval);\n\t\t\tif ((ret = getsockopt(s, SOL_SOCKET, SO_ERROR,\n\t\t\t    &optval, &optlen)) == 0) {\n\t\t\t\terrno = optval;\n\t\t\t\tret = optval == 0 ? 0 : -1;\n\t\t\t}\n\t\t} else if (ret == 0) {\n\t\t\terrno = ETIMEDOUT;\n\t\t\tret = -1;\n\t\t} else\n\t\t\terr(1, \"poll failed\");\n\t}\n\n\tif (timeout != -1 && fcntl(s, F_SETFL, flags) == -1)\n\t\terr(1, \"restoring flags\");\n\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SUN_LEN",
          "args": [
            "&sun_sa"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "sun_sa.sun_path",
            "path",
            "sizeof(sun_sa.sun_path)"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sun_sa",
            "0",
            "sizeof(struct sockaddr_un)"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "s",
            "F_SETFD",
            "FD_CLOEXEC"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_UNIX",
            "SOCK_STREAM",
            "0"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "67-111",
          "snippet": "static char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unix_bind",
          "args": [
            "unix_dg_tmp_socket"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "unix_bind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "516-542",
          "snippet": "int\nunix_bind(char *path)\n{\n\tstruct sockaddr_un sun_sa;\n\tint s;\n\n\t/* Create unix domain socket. */\n\tif ((s = socket(AF_UNIX, uflag ? SOCK_DGRAM : SOCK_STREAM,\n\t     0)) < 0)\n\t\treturn (-1);\n\n\tmemset(&sun_sa, 0, sizeof(struct sockaddr_un));\n\tsun_sa.sun_family = AF_UNIX;\n\n\tif (strlcpy(sun_sa.sun_path, path, sizeof(sun_sa.sun_path)) >=\n\t    sizeof(sun_sa.sun_path)) {\n\t\tclose(s);\n\t\terrno = ENAMETOOLONG;\n\t\treturn (-1);\n\t}\n\n\tif (bind(s, (struct sockaddr *)&sun_sa, SUN_LEN(&sun_sa)) < 0) {\n\t\tclose(s);\n\t\treturn (-1);\n\t}\n\treturn (s);\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tuflag;",
            "int\tunix_bind(char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tuflag;\nint\tunix_bind(char *);\n\nint\nunix_bind(char *path)\n{\n\tstruct sockaddr_un sun_sa;\n\tint s;\n\n\t/* Create unix domain socket. */\n\tif ((s = socket(AF_UNIX, uflag ? SOCK_DGRAM : SOCK_STREAM,\n\t     0)) < 0)\n\t\treturn (-1);\n\n\tmemset(&sun_sa, 0, sizeof(struct sockaddr_un));\n\tsun_sa.sun_family = AF_UNIX;\n\n\tif (strlcpy(sun_sa.sun_path, path, sizeof(sun_sa.sun_path)) >=\n\t    sizeof(sun_sa.sun_path)) {\n\t\tclose(s);\n\t\terrno = ENAMETOOLONG;\n\t\treturn (-1);\n\t}\n\n\tif (bind(s, (struct sockaddr *)&sun_sa, SUN_LEN(&sun_sa)) < 0) {\n\t\tclose(s);\n\t\treturn (-1);\n\t}\n\treturn (s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tuflag;\nchar *unix_dg_tmp_socket;\nint\tunix_bind(char *);\nint\tunix_connect(char *);\n\nint\nunix_connect(char *path)\n{\n\tstruct sockaddr_un sun_sa;\n\tint s;\n\n\tif (uflag) {\n\t\tif ((s = unix_bind(unix_dg_tmp_socket)) < 0)\n\t\t\treturn (-1);\n\t} else {\n\t\tif ((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\t\treturn (-1);\n\t}\n\t(void)fcntl(s, F_SETFD, FD_CLOEXEC);\n\n\tmemset(&sun_sa, 0, sizeof(struct sockaddr_un));\n\tsun_sa.sun_family = AF_UNIX;\n\n\tif (strlcpy(sun_sa.sun_path, path, sizeof(sun_sa.sun_path)) >=\n\t    sizeof(sun_sa.sun_path)) {\n\t\tclose(s);\n\t\terrno = ENAMETOOLONG;\n\t\treturn (-1);\n\t}\n\tif (connect(s, (struct sockaddr *)&sun_sa, SUN_LEN(&sun_sa)) < 0) {\n\t\tclose(s);\n\t\treturn (-1);\n\t}\n\treturn (s);\n\n}"
  },
  {
    "function_name": "unix_bind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
    "lines": "516-542",
    "snippet": "int\nunix_bind(char *path)\n{\n\tstruct sockaddr_un sun_sa;\n\tint s;\n\n\t/* Create unix domain socket. */\n\tif ((s = socket(AF_UNIX, uflag ? SOCK_DGRAM : SOCK_STREAM,\n\t     0)) < 0)\n\t\treturn (-1);\n\n\tmemset(&sun_sa, 0, sizeof(struct sockaddr_un));\n\tsun_sa.sun_family = AF_UNIX;\n\n\tif (strlcpy(sun_sa.sun_path, path, sizeof(sun_sa.sun_path)) >=\n\t    sizeof(sun_sa.sun_path)) {\n\t\tclose(s);\n\t\terrno = ENAMETOOLONG;\n\t\treturn (-1);\n\t}\n\n\tif (bind(s, (struct sockaddr *)&sun_sa, SUN_LEN(&sun_sa)) < 0) {\n\t\tclose(s);\n\t\treturn (-1);\n\t}\n\treturn (s);\n}",
    "includes": [
      "#include <resolv.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "# include <err.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/uio.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tuflag;",
      "int\tunix_bind(char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "s"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "s",
            "(struct sockaddr *)&sun_sa",
            "SUN_LEN(&sun_sa)"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SUN_LEN",
          "args": [
            "&sun_sa"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "sun_sa.sun_path",
            "path",
            "sizeof(sun_sa.sun_path)"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sun_sa",
            "0",
            "sizeof(struct sockaddr_un)"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_UNIX",
            "uflag ? SOCK_DGRAM : SOCK_STREAM",
            "0"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "get_socket_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/canohost.c",
          "lines": "67-111",
          "snippet": "static char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"canohost.h\"",
            "#include \"log.h\"",
            "#include \"packet.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nget_socket_address(int sock, int remote, int flags)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tchar ntop[NI_MAXHOST];\n\tint r;\n\n\t/* Get IP address of client. */\n\taddrlen = sizeof(addr);\n\tmemset(&addr, 0, sizeof(addr));\n\n\tif (remote) {\n\t\tif (getpeername(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t} else {\n\t\tif (getsockname(sock, (struct sockaddr *)&addr, &addrlen) != 0)\n\t\t\treturn NULL;\n\t}\n\n\t/* Work around Linux IPv6 weirdness */\n\tif (addr.ss_family == AF_INET6) {\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tipv64_normalise_mapped(&addr, &addrlen);\n\t}\n\n\tswitch (addr.ss_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\t/* Get the address in ascii. */\n\t\tif ((r = getnameinfo((struct sockaddr *)&addr, addrlen, ntop,\n\t\t    sizeof(ntop), NULL, 0, flags)) != 0) {\n\t\t\terror(\"%s: getnameinfo %d failed: %s\", __func__,\n\t\t\t    flags, ssh_gai_strerror(r));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn xstrdup(ntop);\n\tcase AF_UNIX:\n\t\t/* Get the Unix domain socket path. */\n\t\treturn xstrdup(((struct sockaddr_un *)&addr)->sun_path);\n\tdefault:\n\t\t/* We can't look up remote Unix domain sockets. */\n\t\treturn NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tuflag;\nint\tunix_bind(char *);\n\nint\nunix_bind(char *path)\n{\n\tstruct sockaddr_un sun_sa;\n\tint s;\n\n\t/* Create unix domain socket. */\n\tif ((s = socket(AF_UNIX, uflag ? SOCK_DGRAM : SOCK_STREAM,\n\t     0)) < 0)\n\t\treturn (-1);\n\n\tmemset(&sun_sa, 0, sizeof(struct sockaddr_un));\n\tsun_sa.sun_family = AF_UNIX;\n\n\tif (strlcpy(sun_sa.sun_path, path, sizeof(sun_sa.sun_path)) >=\n\t    sizeof(sun_sa.sun_path)) {\n\t\tclose(s);\n\t\terrno = ENAMETOOLONG;\n\t\treturn (-1);\n\t}\n\n\tif (bind(s, (struct sockaddr *)&sun_sa, SUN_LEN(&sun_sa)) < 0) {\n\t\tclose(s);\n\t\treturn (-1);\n\t}\n\treturn (s);\n}"
  },
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
    "lines": "141-510",
    "snippet": "int\nmain(int argc, char *argv[])\n{\n\tint ch, s, ret, socksv;\n\tchar *host, *uport;\n\tstruct addrinfo hints;\n\tstruct servent *sv;\n\tsocklen_t len;\n\tstruct sockaddr_storage cliaddr;\n\tchar *proxy = NULL;\n\tconst char *errstr, *proxyhost = \"\", *proxyport = NULL;\n\tstruct addrinfo proxyhints;\n\tchar unix_dg_tmp_socket_buf[UNIX_DG_TMP_SOCKET_SIZE];\n\n\tret = 1;\n\ts = 0;\n\tsocksv = 5;\n\thost = NULL;\n\tuport = NULL;\n\tsv = NULL;\n\n\twhile ((ch = getopt(argc, argv,\n\t    \"46DdFhI:i:klNnO:P:p:rSs:tT:UuV:vw:X:x:z\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase '4':\n\t\t\tfamily = AF_INET;\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tfamily = AF_INET6;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tfamily = AF_UNIX;\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\tif (strcasecmp(optarg, \"connect\") == 0)\n\t\t\t\tsocksv = -1; /* HTTP proxy CONNECT */\n\t\t\telse if (strcmp(optarg, \"4\") == 0)\n\t\t\t\tsocksv = 4; /* SOCKS v.4 */\n\t\t\telse if (strcmp(optarg, \"5\") == 0)\n\t\t\t\tsocksv = 5; /* SOCKS v.5 */\n\t\t\telse\n\t\t\t\terrx(1, \"unsupported proxy protocol\");\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdflag = 1;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tFflag = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\thelp();\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tiflag = strtonum(optarg, 0, UINT_MAX, &errstr);\n\t\t\tif (errstr)\n\t\t\t\terrx(1, \"interval %s: %s\", errstr, optarg);\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tkflag = 1;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlflag = 1;\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tNflag = 1;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnflag = 1;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tPflag = optarg;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpflag = optarg;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trflag = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsflag = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttflag = 1;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tuflag = 1;\n\t\t\tbreak;\n#ifdef SO_RTABLE\n\t\tcase 'V':\n\t\t\trtableid = (int)strtonum(optarg, 0,\n\t\t\t    RT_TABLEID_MAX, &errstr);\n\t\t\tif (errstr)\n\t\t\t\terrx(1, \"rtable %s: %s\", errstr, optarg);\n\t\t\tbreak;\n#endif\n\t\tcase 'v':\n\t\t\tvflag = 1;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\ttimeout = strtonum(optarg, 0, INT_MAX / 1000, &errstr);\n\t\t\tif (errstr)\n\t\t\t\terrx(1, \"timeout %s: %s\", errstr, optarg);\n\t\t\ttimeout *= 1000;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\txflag = 1;\n\t\t\tif ((proxy = strdup(optarg)) == NULL)\n\t\t\t\terrx(1, \"strdup\");\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\tzflag = 1;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tDflag = 1;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tIflag = strtonum(optarg, 1, 65536 << 14, &errstr);\n\t\t\tif (errstr != NULL)\n\t\t\t\terrx(1, \"TCP receive window %s: %s\",\n\t\t\t\t    errstr, optarg);\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tOflag = strtonum(optarg, 1, 65536 << 14, &errstr);\n\t\t\tif (errstr != NULL)\n\t\t\t\terrx(1, \"TCP send window %s: %s\",\n\t\t\t\t    errstr, optarg);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tSflag = 1;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\terrstr = NULL;\n\t\t\terrno = 0;\n\t\t\tif (map_tos(optarg, &Tflag))\n\t\t\t\tbreak;\n\t\t\tif (strlen(optarg) > 1 && optarg[0] == '0' &&\n\t\t\t    optarg[1] == 'x')\n\t\t\t\tTflag = (int)strtol(optarg, NULL, 16);\n\t\t\telse\n\t\t\t\tTflag = (int)strtonum(optarg, 0, 255,\n\t\t\t\t    &errstr);\n\t\t\tif (Tflag < 0 || Tflag > 255 || errstr || errno)\n\t\t\t\terrx(1, \"illegal tos value %s\", optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(1);\n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\n\t/* Cruft to make sure options are clean, and used properly. */\n\tif (argv[0] && !argv[1] && family == AF_UNIX) {\n\t\thost = argv[0];\n\t\tuport = NULL;\n\t} else if (argv[0] && !argv[1]) {\n\t\tif  (!lflag)\n\t\t\tusage(1);\n\t\tuport = argv[0];\n\t\thost = NULL;\n\t} else if (argv[0] && argv[1]) {\n\t\thost = argv[0];\n\t\tuport = argv[1];\n\t} else\n\t\tusage(1);\n\n\tif (lflag && sflag)\n\t\terrx(1, \"cannot use -s and -l\");\n\tif (lflag && pflag)\n\t\terrx(1, \"cannot use -p and -l\");\n\tif (lflag && zflag)\n\t\terrx(1, \"cannot use -z and -l\");\n\tif (!lflag && kflag)\n\t\terrx(1, \"must use -l with -k\");\n\n\t/* Get name of temporary socket for unix datagram client */\n\tif ((family == AF_UNIX) && uflag && !lflag) {\n\t\tif (sflag) {\n\t\t\tunix_dg_tmp_socket = sflag;\n\t\t} else {\n\t\t\tstrlcpy(unix_dg_tmp_socket_buf, \"/tmp/nc.XXXXXXXXXX\",\n\t\t\t\tUNIX_DG_TMP_SOCKET_SIZE);\n\t\t\tif (mktemp(unix_dg_tmp_socket_buf) == NULL)\n\t\t\t\terr(1, \"mktemp\");\n\t\t\tunix_dg_tmp_socket = unix_dg_tmp_socket_buf;\n\t\t}\n\t}\n\n\t/* Initialize addrinfo structure. */\n\tif (family != AF_UNIX) {\n\t\tmemset(&hints, 0, sizeof(struct addrinfo));\n\t\thints.ai_family = family;\n\t\thints.ai_socktype = uflag ? SOCK_DGRAM : SOCK_STREAM;\n\t\thints.ai_protocol = uflag ? IPPROTO_UDP : IPPROTO_TCP;\n\t\tif (nflag)\n\t\t\thints.ai_flags |= AI_NUMERICHOST;\n\t}\n\n\tif (xflag) {\n\t\tif (uflag)\n\t\t\terrx(1, \"no proxy support for UDP mode\");\n\n\t\tif (lflag)\n\t\t\terrx(1, \"no proxy support for listen\");\n\n\t\tif (family == AF_UNIX)\n\t\t\terrx(1, \"no proxy support for unix sockets\");\n\n\t\t/* XXX IPv6 transport to proxy would probably work */\n\t\tif (family == AF_INET6)\n\t\t\terrx(1, \"no proxy support for IPv6\");\n\n\t\tif (sflag)\n\t\t\terrx(1, \"no proxy support for local source address\");\n\n\t\tproxyhost = strsep(&proxy, \":\");\n\t\tproxyport = proxy;\n\n\t\tmemset(&proxyhints, 0, sizeof(struct addrinfo));\n\t\tproxyhints.ai_family = family;\n\t\tproxyhints.ai_socktype = SOCK_STREAM;\n\t\tproxyhints.ai_protocol = IPPROTO_TCP;\n\t\tif (nflag)\n\t\t\tproxyhints.ai_flags |= AI_NUMERICHOST;\n\t}\n\n\tif (lflag) {\n\t\tint connfd;\n\t\tret = 0;\n\n\t\tif (family == AF_UNIX) {\n\t\t\tif (uflag)\n\t\t\t\ts = unix_bind(host);\n\t\t\telse\n\t\t\t\ts = unix_listen(host);\n\t\t}\n\n\t\t/* Allow only one connection at a time, but stay alive. */\n\t\tfor (;;) {\n\t\t\tif (family != AF_UNIX)\n\t\t\t\ts = local_listen(host, uport, hints);\n\t\t\tif (s < 0)\n\t\t\t\terr(1, \"local_listen\");\n\t\t\t/*\n\t\t\t * For UDP and -k, don't connect the socket, let it\n\t\t\t * receive datagrams from multiple socket pairs.\n\t\t\t */\n\t\t\tif (uflag && kflag)\n\t\t\t\treadwrite(s);\n\t\t\t/*\n\t\t\t * For UDP and not -k, we will use recvfrom() initially\n\t\t\t * to wait for a caller, then use the regular functions\n\t\t\t * to talk to the caller.\n\t\t\t */\n\t\t\telse if (uflag && !kflag) {\n\t\t\t\tint rv, plen;\n\t\t\t\tchar buf[16384];\n\t\t\t\tstruct sockaddr_storage z;\n\n\t\t\t\tlen = sizeof(z);\n\t\t\t\tplen = 2048;\n\t\t\t\trv = recvfrom(s, buf, plen, MSG_PEEK,\n\t\t\t\t    (struct sockaddr *)&z, &len);\n\t\t\t\tif (rv < 0)\n\t\t\t\t\terr(1, \"recvfrom\");\n\n\t\t\t\trv = connect(s, (struct sockaddr *)&z, len);\n\t\t\t\tif (rv < 0)\n\t\t\t\t\terr(1, \"connect\");\n\n\t\t\t\tif (vflag)\n\t\t\t\t\treport_connect((struct sockaddr *)&z, len);\n\n\t\t\t\treadwrite(s);\n\t\t\t} else {\n\t\t\t\tlen = sizeof(cliaddr);\n\t\t\t\tconnfd = accept(s, (struct sockaddr *)&cliaddr,\n\t\t\t\t    &len);\n\t\t\t\tif (connfd == -1) {\n\t\t\t\t\t/* For now, all errnos are fatal */\n\t\t\t\t\terr(1, \"accept\");\n\t\t\t\t}\n\t\t\t\tif (vflag)\n\t\t\t\t\treport_connect((struct sockaddr *)&cliaddr, len);\n\n\t\t\t\treadwrite(connfd);\n\t\t\t\tclose(connfd);\n\t\t\t}\n\n\t\t\tif (family != AF_UNIX)\n\t\t\t\tclose(s);\n\t\t\telse if (uflag) {\n\t\t\t\tif (connect(s, NULL, 0) < 0)\n\t\t\t\t\terr(1, \"connect\");\n\t\t\t}\n\n\t\t\tif (!kflag)\n\t\t\t\tbreak;\n\t\t}\n\t} else if (family == AF_UNIX) {\n\t\tret = 0;\n\n\t\tif ((s = unix_connect(host)) > 0 && !zflag) {\n\t\t\treadwrite(s);\n\t\t\tclose(s);\n\t\t} else\n\t\t\tret = 1;\n\n\t\tif (uflag)\n\t\t\tunlink(unix_dg_tmp_socket);\n\t\texit(ret);\n\n\t} else {\n\t\tint i = 0;\n\n\t\t/* Construct the portlist[] array. */\n\t\tbuild_ports(uport);\n\n\t\t/* Cycle through portlist, connecting to each port. */\n\t\tfor (i = 0; portlist[i] != NULL; i++) {\n\t\t\tif (s)\n\t\t\t\tclose(s);\n\n\t\t\tif (xflag)\n\t\t\t\ts = socks_connect(host, portlist[i], hints,\n\t\t\t\t    proxyhost, proxyport, proxyhints, socksv,\n\t\t\t\t    Pflag);\n\t\t\telse\n\t\t\t\ts = remote_connect(host, portlist[i], hints);\n\n\t\t\tif (s < 0)\n\t\t\t\tcontinue;\n\n\t\t\tret = 0;\n\t\t\tif (vflag || zflag) {\n\t\t\t\t/* For UDP, make sure we are connected. */\n\t\t\t\tif (uflag) {\n\t\t\t\t\tif (udptest(s) == -1) {\n\t\t\t\t\t\tret = 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* Don't look up port if -n. */\n\t\t\t\tif (nflag)\n\t\t\t\t\tsv = NULL;\n\t\t\t\telse {\n\t\t\t\t\tsv = getservbyport(\n\t\t\t\t\t    ntohs(atoi(portlist[i])),\n\t\t\t\t\t    uflag ? \"udp\" : \"tcp\");\n\t\t\t\t}\n\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Connection to %s %s port [%s/%s] \"\n\t\t\t\t    \"succeeded!\\n\", host, portlist[i],\n\t\t\t\t    uflag ? \"udp\" : \"tcp\",\n\t\t\t\t    sv ? sv->s_name : \"*\");\n\t\t\t}\n\t\t\tif (Fflag)\n\t\t\t\tfdpass(s);\n\t\t\telse if (!zflag)\n\t\t\t\treadwrite(s);\n\t\t}\n\t}\n\n\tif (s)\n\t\tclose(s);\n\n\texit(ret);\n}",
    "includes": [
      "#include <resolv.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "# include <err.h>",
      "#  include <sys/poll.h>",
      "#include <poll.h>",
      "#include \"atomicio.h\"",
      "#include <limits.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/uio.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define UNIX_DG_TMP_SOCKET_SIZE\t19"
    ],
    "globals_used": [
      "int\tdflag;",
      "int\tFflag;",
      "unsigned int iflag;",
      "int\tkflag;",
      "int\tlflag;",
      "int\tNflag;",
      "int\tnflag;",
      "char   *Pflag;",
      "char   *pflag;",
      "int\trflag;",
      "char   *sflag;",
      "int\ttflag;",
      "int\tuflag;",
      "int\tvflag;",
      "int\txflag;",
      "int\tzflag;",
      "int\tDflag;",
      "int\tIflag;",
      "int\tOflag;",
      "int\tSflag;",
      "int\tTflag = -1;",
      "int\trtableid = -1;",
      "int timeout = -1;",
      "int family = AF_UNSPEC;",
      "char *portlist[PORT_MAX+1];",
      "char *unix_dg_tmp_socket;",
      "void\tbuild_ports(char *);",
      "void\thelp(void);",
      "int\tlocal_listen(char *, char *, struct addrinfo);",
      "void\treadwrite(int);",
      "int\tremote_connect(const char *, const char *, struct addrinfo);",
      "int\ttimeout_connect(int, const struct sockaddr *, socklen_t);",
      "int\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int, const char *);",
      "int\tudptest(int);",
      "int\tunix_bind(char *);",
      "int\tunix_connect(char *);",
      "int\tunix_listen(char *);",
      "int\tmap_tos(char *, int *);",
      "void\treport_connect(const struct sockaddr *, socklen_t);",
      "void\tusage(int);",
      "int\tremote_connect(const char *, const char *, struct addrinfo);",
      "int\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int,\n\t    const char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "ret"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "sftp_server_cleanup_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sftp-server.c",
          "lines": "1474-1483",
          "snippet": "void\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}",
          "includes": [
            "#include \"sftp-common.h\"",
            "#include \"sftp.h\"",
            "#include \"uidswap.h\"",
            "#include \"match.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"xmalloc.h\"",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/mount.h>",
            "# include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct passwd *pw = NULL;",
            "static char *client_addr = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sftp-common.h\"\n#include \"sftp.h\"\n#include \"uidswap.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"xmalloc.h\"\n#include <stdarg.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/statvfs.h>\n#include <sys/mount.h>\n# include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "s"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "readwrite",
          "args": [
            "s"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "readwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "772-952",
          "snippet": "void\nreadwrite(int net_fd)\n{\n\tstruct pollfd pfd[4];\n\tint stdin_fd = STDIN_FILENO;\n\tint stdout_fd = STDOUT_FILENO;\n\tunsigned char netinbuf[BUFSIZE];\n\tsize_t netinbufpos = 0;\n\tunsigned char stdinbuf[BUFSIZE];\n\tsize_t stdinbufpos = 0;\n\tint n, num_fds;\n\tssize_t ret;\n\n\t/* don't read from stdin if requested */\n\tif (dflag)\n\t\tstdin_fd = -1;\n\n\t/* stdin */\n\tpfd[POLL_STDIN].fd = stdin_fd;\n\tpfd[POLL_STDIN].events = POLLIN;\n\n\t/* network out */\n\tpfd[POLL_NETOUT].fd = net_fd;\n\tpfd[POLL_NETOUT].events = 0;\n\n\t/* network in */\n\tpfd[POLL_NETIN].fd = net_fd;\n\tpfd[POLL_NETIN].events = POLLIN;\n\n\t/* stdout */\n\tpfd[POLL_STDOUT].fd = stdout_fd;\n\tpfd[POLL_STDOUT].events = 0;\n\n\twhile (1) {\n\t\t/* both inputs are gone, buffers are empty, we are done */\n\t\tif (pfd[POLL_STDIN].fd == -1 && pfd[POLL_NETIN].fd == -1\n\t\t    && stdinbufpos == 0 && netinbufpos == 0) {\n\t\t\tclose(net_fd);\n\t\t\treturn;\n\t\t}\n\t\t/* both outputs are gone, we can't continue */\n\t\tif (pfd[POLL_NETOUT].fd == -1 && pfd[POLL_STDOUT].fd == -1) {\n\t\t\tclose(net_fd);\n\t\t\treturn;\n\t\t}\n\t\t/* listen and net in gone, queues empty, done */\n\t\tif (lflag && pfd[POLL_NETIN].fd == -1\n\t\t    && stdinbufpos == 0 && netinbufpos == 0) {\n\t\t\tclose(net_fd);\n\t\t\treturn;\n\t\t}\n\n\t\t/* help says -i is for \"wait between lines sent\". We read and\n\t\t * write arbitrary amounts of data, and we don't want to start\n\t\t * scanning for newlines, so this is as good as it gets */\n\t\tif (iflag)\n\t\t\tsleep(iflag);\n\n\t\t/* poll */\n\t\tnum_fds = poll(pfd, 4, timeout);\n\n\t\t/* treat poll errors */\n\t\tif (num_fds == -1) {\n\t\t\tclose(net_fd);\n\t\t\terr(1, \"polling error\");\n\t\t}\n\n\t\t/* timeout happened */\n\t\tif (num_fds == 0)\n\t\t\treturn;\n\n\t\t/* treat socket error conditions */\n\t\tfor (n = 0; n < 4; n++) {\n\t\t\tif (pfd[n].revents & (POLLERR|POLLNVAL)) {\n\t\t\t\tpfd[n].fd = -1;\n\t\t\t}\n\t\t}\n\t\t/* reading is possible after HUP */\n\t\tif (pfd[POLL_STDIN].events & POLLIN &&\n\t\t    pfd[POLL_STDIN].revents & POLLHUP &&\n\t\t    ! (pfd[POLL_STDIN].revents & POLLIN))\n\t\t\t\tpfd[POLL_STDIN].fd = -1;\n\n\t\tif (pfd[POLL_NETIN].events & POLLIN &&\n\t\t    pfd[POLL_NETIN].revents & POLLHUP &&\n\t\t    ! (pfd[POLL_NETIN].revents & POLLIN))\n\t\t\t\tpfd[POLL_NETIN].fd = -1;\n\n\t\tif (pfd[POLL_NETOUT].revents & POLLHUP) {\n\t\t\tif (Nflag)\n\t\t\t\tshutdown(pfd[POLL_NETOUT].fd, SHUT_WR);\n\t\t\tpfd[POLL_NETOUT].fd = -1;\n\t\t}\n\t\t/* if HUP, stop watching stdout */\n\t\tif (pfd[POLL_STDOUT].revents & POLLHUP)\n\t\t\tpfd[POLL_STDOUT].fd = -1;\n\t\t/* if no net out, stop watching stdin */\n\t\tif (pfd[POLL_NETOUT].fd == -1)\n\t\t\tpfd[POLL_STDIN].fd = -1;\n\t\t/* if no stdout, stop watching net in */\n\t\tif (pfd[POLL_STDOUT].fd == -1) {\n\t\t\tif (pfd[POLL_NETIN].fd != -1)\n\t\t\t\tshutdown(pfd[POLL_NETIN].fd, SHUT_RD);\n\t\t\tpfd[POLL_NETIN].fd = -1;\n\t\t}\n\n\t\t/* try to read from stdin */\n\t\tif (pfd[POLL_STDIN].revents & POLLIN && stdinbufpos < BUFSIZE) {\n\t\t\tret = fillbuf(pfd[POLL_STDIN].fd, stdinbuf,\n\t\t\t    &stdinbufpos);\n\t\t\t/* error or eof on stdin - remove from pfd */\n\t\t\tif (ret == 0 || ret == -1)\n\t\t\t\tpfd[POLL_STDIN].fd = -1;\n\t\t\t/* read something - poll net out */\n\t\t\tif (stdinbufpos > 0)\n\t\t\t\tpfd[POLL_NETOUT].events = POLLOUT;\n\t\t\t/* filled buffer - remove self from polling */\n\t\t\tif (stdinbufpos == BUFSIZE)\n\t\t\t\tpfd[POLL_STDIN].events = 0;\n\t\t}\n\t\t/* try to write to network */\n\t\tif (pfd[POLL_NETOUT].revents & POLLOUT && stdinbufpos > 0) {\n\t\t\tret = drainbuf(pfd[POLL_NETOUT].fd, stdinbuf,\n\t\t\t    &stdinbufpos);\n\t\t\tif (ret == -1)\n\t\t\t\tpfd[POLL_NETOUT].fd = -1;\n\t\t\t/* buffer empty - remove self from polling */\n\t\t\tif (stdinbufpos == 0)\n\t\t\t\tpfd[POLL_NETOUT].events = 0;\n\t\t\t/* buffer no longer full - poll stdin again */\n\t\t\tif (stdinbufpos < BUFSIZE)\n\t\t\t\tpfd[POLL_STDIN].events = POLLIN;\n\t\t}\n\t\t/* try to read from network */\n\t\tif (pfd[POLL_NETIN].revents & POLLIN && netinbufpos < BUFSIZE) {\n\t\t\tret = fillbuf(pfd[POLL_NETIN].fd, netinbuf,\n\t\t\t    &netinbufpos);\n\t\t\tif (ret == -1)\n\t\t\t\tpfd[POLL_NETIN].fd = -1;\n\t\t\t/* eof on net in - remove from pfd */\n\t\t\tif (ret == 0) {\n\t\t\t\tshutdown(pfd[POLL_NETIN].fd, SHUT_RD);\n\t\t\t\tpfd[POLL_NETIN].fd = -1;\n\t\t\t}\n\t\t\t/* read something - poll stdout */\n\t\t\tif (netinbufpos > 0)\n\t\t\t\tpfd[POLL_STDOUT].events = POLLOUT;\n\t\t\t/* filled buffer - remove self from polling */\n\t\t\tif (netinbufpos == BUFSIZE)\n\t\t\t\tpfd[POLL_NETIN].events = 0;\n\t\t\t/* handle telnet */\n\t\t\tif (tflag)\n\t\t\t\tatelnet(pfd[POLL_NETIN].fd, netinbuf,\n\t\t\t\t    netinbufpos);\n\t\t}\n\t\t/* try to write to stdout */\n\t\tif (pfd[POLL_STDOUT].revents & POLLOUT && netinbufpos > 0) {\n\t\t\tret = drainbuf(pfd[POLL_STDOUT].fd, netinbuf,\n\t\t\t    &netinbufpos);\n\t\t\tif (ret == -1)\n\t\t\t\tpfd[POLL_STDOUT].fd = -1;\n\t\t\t/* buffer empty - remove self from polling */\n\t\t\tif (netinbufpos == 0)\n\t\t\t\tpfd[POLL_STDOUT].events = 0;\n\t\t\t/* buffer no longer full - poll net in again */\n\t\t\tif (netinbufpos < BUFSIZE)\n\t\t\t\tpfd[POLL_NETIN].events = POLLIN;\n\t\t}\n\n\t\t/* stdin gone and queue empty? */\n\t\tif (pfd[POLL_STDIN].fd == -1 && stdinbufpos == 0) {\n\t\t\tif (pfd[POLL_NETOUT].fd != -1 && Nflag)\n\t\t\t\tshutdown(pfd[POLL_NETOUT].fd, SHUT_WR);\n\t\t\tpfd[POLL_NETOUT].fd = -1;\n\t\t}\n\t\t/* net in gone and queue empty? */\n\t\tif (pfd[POLL_NETIN].fd == -1 && netinbufpos == 0) {\n\t\t\tpfd[POLL_STDOUT].fd = -1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define BUFSIZE 16384",
            "#define POLL_STDOUT 3",
            "#define POLL_NETIN 2",
            "#define POLL_NETOUT 1",
            "#define POLL_STDIN 0"
          ],
          "globals_used": [
            "int\tdflag;",
            "unsigned int iflag;",
            "int\tlflag;",
            "int\tNflag;",
            "int\ttflag;",
            "int timeout = -1;",
            "void\tatelnet(int, unsigned char *, unsigned int);",
            "void\thelp(void);",
            "void\treadwrite(int);",
            "ssize_t drainbuf(int, unsigned char *, size_t *);",
            "ssize_t fillbuf(int, unsigned char *, size_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define BUFSIZE 16384\n#define POLL_STDOUT 3\n#define POLL_NETIN 2\n#define POLL_NETOUT 1\n#define POLL_STDIN 0\n\nint\tdflag;\nunsigned int iflag;\nint\tlflag;\nint\tNflag;\nint\ttflag;\nint timeout = -1;\nvoid\tatelnet(int, unsigned char *, unsigned int);\nvoid\thelp(void);\nvoid\treadwrite(int);\nssize_t drainbuf(int, unsigned char *, size_t *);\nssize_t fillbuf(int, unsigned char *, size_t *);\n\nvoid\nreadwrite(int net_fd)\n{\n\tstruct pollfd pfd[4];\n\tint stdin_fd = STDIN_FILENO;\n\tint stdout_fd = STDOUT_FILENO;\n\tunsigned char netinbuf[BUFSIZE];\n\tsize_t netinbufpos = 0;\n\tunsigned char stdinbuf[BUFSIZE];\n\tsize_t stdinbufpos = 0;\n\tint n, num_fds;\n\tssize_t ret;\n\n\t/* don't read from stdin if requested */\n\tif (dflag)\n\t\tstdin_fd = -1;\n\n\t/* stdin */\n\tpfd[POLL_STDIN].fd = stdin_fd;\n\tpfd[POLL_STDIN].events = POLLIN;\n\n\t/* network out */\n\tpfd[POLL_NETOUT].fd = net_fd;\n\tpfd[POLL_NETOUT].events = 0;\n\n\t/* network in */\n\tpfd[POLL_NETIN].fd = net_fd;\n\tpfd[POLL_NETIN].events = POLLIN;\n\n\t/* stdout */\n\tpfd[POLL_STDOUT].fd = stdout_fd;\n\tpfd[POLL_STDOUT].events = 0;\n\n\twhile (1) {\n\t\t/* both inputs are gone, buffers are empty, we are done */\n\t\tif (pfd[POLL_STDIN].fd == -1 && pfd[POLL_NETIN].fd == -1\n\t\t    && stdinbufpos == 0 && netinbufpos == 0) {\n\t\t\tclose(net_fd);\n\t\t\treturn;\n\t\t}\n\t\t/* both outputs are gone, we can't continue */\n\t\tif (pfd[POLL_NETOUT].fd == -1 && pfd[POLL_STDOUT].fd == -1) {\n\t\t\tclose(net_fd);\n\t\t\treturn;\n\t\t}\n\t\t/* listen and net in gone, queues empty, done */\n\t\tif (lflag && pfd[POLL_NETIN].fd == -1\n\t\t    && stdinbufpos == 0 && netinbufpos == 0) {\n\t\t\tclose(net_fd);\n\t\t\treturn;\n\t\t}\n\n\t\t/* help says -i is for \"wait between lines sent\". We read and\n\t\t * write arbitrary amounts of data, and we don't want to start\n\t\t * scanning for newlines, so this is as good as it gets */\n\t\tif (iflag)\n\t\t\tsleep(iflag);\n\n\t\t/* poll */\n\t\tnum_fds = poll(pfd, 4, timeout);\n\n\t\t/* treat poll errors */\n\t\tif (num_fds == -1) {\n\t\t\tclose(net_fd);\n\t\t\terr(1, \"polling error\");\n\t\t}\n\n\t\t/* timeout happened */\n\t\tif (num_fds == 0)\n\t\t\treturn;\n\n\t\t/* treat socket error conditions */\n\t\tfor (n = 0; n < 4; n++) {\n\t\t\tif (pfd[n].revents & (POLLERR|POLLNVAL)) {\n\t\t\t\tpfd[n].fd = -1;\n\t\t\t}\n\t\t}\n\t\t/* reading is possible after HUP */\n\t\tif (pfd[POLL_STDIN].events & POLLIN &&\n\t\t    pfd[POLL_STDIN].revents & POLLHUP &&\n\t\t    ! (pfd[POLL_STDIN].revents & POLLIN))\n\t\t\t\tpfd[POLL_STDIN].fd = -1;\n\n\t\tif (pfd[POLL_NETIN].events & POLLIN &&\n\t\t    pfd[POLL_NETIN].revents & POLLHUP &&\n\t\t    ! (pfd[POLL_NETIN].revents & POLLIN))\n\t\t\t\tpfd[POLL_NETIN].fd = -1;\n\n\t\tif (pfd[POLL_NETOUT].revents & POLLHUP) {\n\t\t\tif (Nflag)\n\t\t\t\tshutdown(pfd[POLL_NETOUT].fd, SHUT_WR);\n\t\t\tpfd[POLL_NETOUT].fd = -1;\n\t\t}\n\t\t/* if HUP, stop watching stdout */\n\t\tif (pfd[POLL_STDOUT].revents & POLLHUP)\n\t\t\tpfd[POLL_STDOUT].fd = -1;\n\t\t/* if no net out, stop watching stdin */\n\t\tif (pfd[POLL_NETOUT].fd == -1)\n\t\t\tpfd[POLL_STDIN].fd = -1;\n\t\t/* if no stdout, stop watching net in */\n\t\tif (pfd[POLL_STDOUT].fd == -1) {\n\t\t\tif (pfd[POLL_NETIN].fd != -1)\n\t\t\t\tshutdown(pfd[POLL_NETIN].fd, SHUT_RD);\n\t\t\tpfd[POLL_NETIN].fd = -1;\n\t\t}\n\n\t\t/* try to read from stdin */\n\t\tif (pfd[POLL_STDIN].revents & POLLIN && stdinbufpos < BUFSIZE) {\n\t\t\tret = fillbuf(pfd[POLL_STDIN].fd, stdinbuf,\n\t\t\t    &stdinbufpos);\n\t\t\t/* error or eof on stdin - remove from pfd */\n\t\t\tif (ret == 0 || ret == -1)\n\t\t\t\tpfd[POLL_STDIN].fd = -1;\n\t\t\t/* read something - poll net out */\n\t\t\tif (stdinbufpos > 0)\n\t\t\t\tpfd[POLL_NETOUT].events = POLLOUT;\n\t\t\t/* filled buffer - remove self from polling */\n\t\t\tif (stdinbufpos == BUFSIZE)\n\t\t\t\tpfd[POLL_STDIN].events = 0;\n\t\t}\n\t\t/* try to write to network */\n\t\tif (pfd[POLL_NETOUT].revents & POLLOUT && stdinbufpos > 0) {\n\t\t\tret = drainbuf(pfd[POLL_NETOUT].fd, stdinbuf,\n\t\t\t    &stdinbufpos);\n\t\t\tif (ret == -1)\n\t\t\t\tpfd[POLL_NETOUT].fd = -1;\n\t\t\t/* buffer empty - remove self from polling */\n\t\t\tif (stdinbufpos == 0)\n\t\t\t\tpfd[POLL_NETOUT].events = 0;\n\t\t\t/* buffer no longer full - poll stdin again */\n\t\t\tif (stdinbufpos < BUFSIZE)\n\t\t\t\tpfd[POLL_STDIN].events = POLLIN;\n\t\t}\n\t\t/* try to read from network */\n\t\tif (pfd[POLL_NETIN].revents & POLLIN && netinbufpos < BUFSIZE) {\n\t\t\tret = fillbuf(pfd[POLL_NETIN].fd, netinbuf,\n\t\t\t    &netinbufpos);\n\t\t\tif (ret == -1)\n\t\t\t\tpfd[POLL_NETIN].fd = -1;\n\t\t\t/* eof on net in - remove from pfd */\n\t\t\tif (ret == 0) {\n\t\t\t\tshutdown(pfd[POLL_NETIN].fd, SHUT_RD);\n\t\t\t\tpfd[POLL_NETIN].fd = -1;\n\t\t\t}\n\t\t\t/* read something - poll stdout */\n\t\t\tif (netinbufpos > 0)\n\t\t\t\tpfd[POLL_STDOUT].events = POLLOUT;\n\t\t\t/* filled buffer - remove self from polling */\n\t\t\tif (netinbufpos == BUFSIZE)\n\t\t\t\tpfd[POLL_NETIN].events = 0;\n\t\t\t/* handle telnet */\n\t\t\tif (tflag)\n\t\t\t\tatelnet(pfd[POLL_NETIN].fd, netinbuf,\n\t\t\t\t    netinbufpos);\n\t\t}\n\t\t/* try to write to stdout */\n\t\tif (pfd[POLL_STDOUT].revents & POLLOUT && netinbufpos > 0) {\n\t\t\tret = drainbuf(pfd[POLL_STDOUT].fd, netinbuf,\n\t\t\t    &netinbufpos);\n\t\t\tif (ret == -1)\n\t\t\t\tpfd[POLL_STDOUT].fd = -1;\n\t\t\t/* buffer empty - remove self from polling */\n\t\t\tif (netinbufpos == 0)\n\t\t\t\tpfd[POLL_STDOUT].events = 0;\n\t\t\t/* buffer no longer full - poll net in again */\n\t\t\tif (netinbufpos < BUFSIZE)\n\t\t\t\tpfd[POLL_NETIN].events = POLLIN;\n\t\t}\n\n\t\t/* stdin gone and queue empty? */\n\t\tif (pfd[POLL_STDIN].fd == -1 && stdinbufpos == 0) {\n\t\t\tif (pfd[POLL_NETOUT].fd != -1 && Nflag)\n\t\t\t\tshutdown(pfd[POLL_NETOUT].fd, SHUT_WR);\n\t\t\tpfd[POLL_NETOUT].fd = -1;\n\t\t}\n\t\t/* net in gone and queue empty? */\n\t\tif (pfd[POLL_NETIN].fd == -1 && netinbufpos == 0) {\n\t\t\tpfd[POLL_STDOUT].fd = -1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdpass",
          "args": [
            "s"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "fdpass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "995-1053",
          "snippet": "void\nfdpass(int nfd)\n{\n#if defined(HAVE_SENDMSG) && (defined(HAVE_ACCRIGHTS_IN_MSGHDR) || defined(HAVE_CONTROL_IN_MSGHDR))\n\tstruct msghdr msg;\n#ifndef HAVE_ACCRIGHTS_IN_MSGHDR\n\tunion {\n\t\tstruct cmsghdr hdr;\n\t\tchar buf[CMSG_SPACE(sizeof(int))];\n\t} cmsgbuf;\n\tstruct cmsghdr *cmsg;\n#endif\n\tstruct iovec vec;\n\tchar ch = '\\0';\n\tstruct pollfd pfd;\n\tssize_t r;\n\n\tmemset(&msg, 0, sizeof(msg));\n#ifdef HAVE_ACCRIGHTS_IN_MSGHDR\n\tmsg.msg_accrights = (caddr_t)&nfd;\n\tmsg.msg_accrightslen = sizeof(nfd);\n#else\n\tmemset(&cmsgbuf, 0, sizeof(cmsgbuf));\n\tmsg.msg_control = (caddr_t)&cmsgbuf.buf;\n\tmsg.msg_controllen = sizeof(cmsgbuf.buf);\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\t*(int *)CMSG_DATA(cmsg) = nfd;\n#endif\n\n\tvec.iov_base = &ch;\n\tvec.iov_len = 1;\n\tmsg.msg_iov = &vec;\n\tmsg.msg_iovlen = 1;\n\n\tbzero(&pfd, sizeof(pfd));\n\tpfd.fd = STDOUT_FILENO;\n\tfor (;;) {\n\t\tr = sendmsg(STDOUT_FILENO, &msg, 0);\n\t\tif (r == -1) {\n\t\t\tif (errno == EAGAIN || errno == EINTR) {\n\t\t\t\tpfd.events = POLLOUT;\n\t\t\t\tif (poll(&pfd, 1, -1) == -1)\n\t\t\t\t\terr(1, \"poll\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr(1, \"sendmsg\");\n\t\t} else if (r == -1)\n\t\t\terrx(1, \"sendmsg: unexpected return value %zd\", r);\n\t\telse\n\t\t\tbreak;\n\t}\n\texit(0);\n#else\n\terrx(1, \"%s: file descriptor passing not supported\", __func__);\n#endif\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nfdpass(int nfd)\n{\n#if defined(HAVE_SENDMSG) && (defined(HAVE_ACCRIGHTS_IN_MSGHDR) || defined(HAVE_CONTROL_IN_MSGHDR))\n\tstruct msghdr msg;\n#ifndef HAVE_ACCRIGHTS_IN_MSGHDR\n\tunion {\n\t\tstruct cmsghdr hdr;\n\t\tchar buf[CMSG_SPACE(sizeof(int))];\n\t} cmsgbuf;\n\tstruct cmsghdr *cmsg;\n#endif\n\tstruct iovec vec;\n\tchar ch = '\\0';\n\tstruct pollfd pfd;\n\tssize_t r;\n\n\tmemset(&msg, 0, sizeof(msg));\n#ifdef HAVE_ACCRIGHTS_IN_MSGHDR\n\tmsg.msg_accrights = (caddr_t)&nfd;\n\tmsg.msg_accrightslen = sizeof(nfd);\n#else\n\tmemset(&cmsgbuf, 0, sizeof(cmsgbuf));\n\tmsg.msg_control = (caddr_t)&cmsgbuf.buf;\n\tmsg.msg_controllen = sizeof(cmsgbuf.buf);\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\t*(int *)CMSG_DATA(cmsg) = nfd;\n#endif\n\n\tvec.iov_base = &ch;\n\tvec.iov_len = 1;\n\tmsg.msg_iov = &vec;\n\tmsg.msg_iovlen = 1;\n\n\tbzero(&pfd, sizeof(pfd));\n\tpfd.fd = STDOUT_FILENO;\n\tfor (;;) {\n\t\tr = sendmsg(STDOUT_FILENO, &msg, 0);\n\t\tif (r == -1) {\n\t\t\tif (errno == EAGAIN || errno == EINTR) {\n\t\t\t\tpfd.events = POLLOUT;\n\t\t\t\tif (poll(&pfd, 1, -1) == -1)\n\t\t\t\t\terr(1, \"poll\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr(1, \"sendmsg\");\n\t\t} else if (r == -1)\n\t\t\terrx(1, \"sendmsg: unexpected return value %zd\", r);\n\t\telse\n\t\t\tbreak;\n\t}\n\texit(0);\n#else\n\terrx(1, \"%s: file descriptor passing not supported\", __func__);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Connection to %s %s port [%s/%s] \"\n\t\t\t\t    \"succeeded!\\n\"",
            "host",
            "portlist[i]",
            "uflag ? \"udp\" : \"tcp\"",
            "sv ? sv->s_name : \"*\""
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getservbyport",
          "args": [
            "ntohs(atoi(portlist[i]))",
            "uflag ? \"udp\" : \"tcp\""
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "atoi(portlist[i])"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "portlist[i]"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udptest",
          "args": [
            "s"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "udptest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "1153-1165",
          "snippet": "int\nudptest(int s)\n{\n\tint i, ret;\n\n\tfor (i = 0; i <= 3; i++) {\n\t\tif (write(s, \"X\", 1) == 1)\n\t\t\tret = 1;\n\t\telse\n\t\t\tret = -1;\n\t}\n\treturn (ret);\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tudptest(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tudptest(int);\n\nint\nudptest(int s)\n{\n\tint i, ret;\n\n\tfor (i = 0; i <= 3; i++) {\n\t\tif (write(s, \"X\", 1) == 1)\n\t\t\tret = 1;\n\t\telse\n\t\t\tret = -1;\n\t}\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remote_connect",
          "args": [
            "host",
            "portlist[i]",
            "hints"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "remote_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "603-663",
          "snippet": "int\nremote_connect(const char *host, const char *port, struct addrinfo hints)\n{\n\tstruct addrinfo *res, *res0;\n\tint s, error;\n#if defined(SO_RTABLE) || defined(SO_BINDANY)\n\tint on = 1;\n#endif\n\n\tif ((error = getaddrinfo(host, port, &hints, &res)))\n\t\terrx(1, \"getaddrinfo: %s\", gai_strerror(error));\n\n\tres0 = res;\n\tdo {\n\t\tif ((s = socket(res0->ai_family, res0->ai_socktype,\n\t\t    res0->ai_protocol)) < 0)\n\t\t\tcontinue;\n\n#ifdef SO_RTABLE\n\t\tif (rtableid >= 0 && (setsockopt(s, SOL_SOCKET, SO_RTABLE,\n\t\t    &rtableid, sizeof(rtableid)) == -1))\n\t\t\terr(1, \"setsockopt SO_RTABLE\");\n#endif\n\t\t/* Bind to a local port or source address if specified. */\n\t\tif (sflag || pflag) {\n\t\t\tstruct addrinfo ahints, *ares;\n\n#ifdef SO_BINDANY\n\t\t\t/* try SO_BINDANY, but don't insist */\n\t\t\tsetsockopt(s, SOL_SOCKET, SO_BINDANY, &on, sizeof(on));\n#endif\n\t\t\tmemset(&ahints, 0, sizeof(struct addrinfo));\n\t\t\tahints.ai_family = res0->ai_family;\n\t\t\tahints.ai_socktype = uflag ? SOCK_DGRAM : SOCK_STREAM;\n\t\t\tahints.ai_protocol = uflag ? IPPROTO_UDP : IPPROTO_TCP;\n\t\t\tahints.ai_flags = AI_PASSIVE;\n\t\t\tif ((error = getaddrinfo(sflag, pflag, &ahints, &ares)))\n\t\t\t\terrx(1, \"getaddrinfo: %s\", gai_strerror(error));\n\n\t\t\tif (bind(s, (struct sockaddr *)ares->ai_addr,\n\t\t\t    ares->ai_addrlen) < 0)\n\t\t\t\terr(1, \"bind failed\");\n\t\t\tfreeaddrinfo(ares);\n\t\t}\n\n\t\tset_common_sockopts(s);\n\n\t\tif (timeout_connect(s, res0->ai_addr, res0->ai_addrlen) == 0)\n\t\t\tbreak;\n\t\telse if (vflag)\n\t\t\twarn(\"connect to %s port %s (%s) failed\", host, port,\n\t\t\t    uflag ? \"udp\" : \"tcp\");\n\n\t\tclose(s);\n\t\ts = -1;\n\t} while ((res0 = res0->ai_next) != NULL);\n\n\tfreeaddrinfo(res);\n\n\treturn (s);\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char   *pflag;",
            "char   *sflag;",
            "int\tuflag;",
            "int\tvflag;",
            "int\trtableid = -1;",
            "int\tlocal_listen(char *, char *, struct addrinfo);",
            "int\tremote_connect(const char *, const char *, struct addrinfo);",
            "int\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int, const char *);",
            "void\tset_common_sockopts(int);",
            "int\tremote_connect(const char *, const char *, struct addrinfo);",
            "int\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int,\n\t    const char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar   *pflag;\nchar   *sflag;\nint\tuflag;\nint\tvflag;\nint\trtableid = -1;\nint\tlocal_listen(char *, char *, struct addrinfo);\nint\tremote_connect(const char *, const char *, struct addrinfo);\nint\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int, const char *);\nvoid\tset_common_sockopts(int);\nint\tremote_connect(const char *, const char *, struct addrinfo);\nint\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int,\n\t    const char *);\n\nint\nremote_connect(const char *host, const char *port, struct addrinfo hints)\n{\n\tstruct addrinfo *res, *res0;\n\tint s, error;\n#if defined(SO_RTABLE) || defined(SO_BINDANY)\n\tint on = 1;\n#endif\n\n\tif ((error = getaddrinfo(host, port, &hints, &res)))\n\t\terrx(1, \"getaddrinfo: %s\", gai_strerror(error));\n\n\tres0 = res;\n\tdo {\n\t\tif ((s = socket(res0->ai_family, res0->ai_socktype,\n\t\t    res0->ai_protocol)) < 0)\n\t\t\tcontinue;\n\n#ifdef SO_RTABLE\n\t\tif (rtableid >= 0 && (setsockopt(s, SOL_SOCKET, SO_RTABLE,\n\t\t    &rtableid, sizeof(rtableid)) == -1))\n\t\t\terr(1, \"setsockopt SO_RTABLE\");\n#endif\n\t\t/* Bind to a local port or source address if specified. */\n\t\tif (sflag || pflag) {\n\t\t\tstruct addrinfo ahints, *ares;\n\n#ifdef SO_BINDANY\n\t\t\t/* try SO_BINDANY, but don't insist */\n\t\t\tsetsockopt(s, SOL_SOCKET, SO_BINDANY, &on, sizeof(on));\n#endif\n\t\t\tmemset(&ahints, 0, sizeof(struct addrinfo));\n\t\t\tahints.ai_family = res0->ai_family;\n\t\t\tahints.ai_socktype = uflag ? SOCK_DGRAM : SOCK_STREAM;\n\t\t\tahints.ai_protocol = uflag ? IPPROTO_UDP : IPPROTO_TCP;\n\t\t\tahints.ai_flags = AI_PASSIVE;\n\t\t\tif ((error = getaddrinfo(sflag, pflag, &ahints, &ares)))\n\t\t\t\terrx(1, \"getaddrinfo: %s\", gai_strerror(error));\n\n\t\t\tif (bind(s, (struct sockaddr *)ares->ai_addr,\n\t\t\t    ares->ai_addrlen) < 0)\n\t\t\t\terr(1, \"bind failed\");\n\t\t\tfreeaddrinfo(ares);\n\t\t}\n\n\t\tset_common_sockopts(s);\n\n\t\tif (timeout_connect(s, res0->ai_addr, res0->ai_addrlen) == 0)\n\t\t\tbreak;\n\t\telse if (vflag)\n\t\t\twarn(\"connect to %s port %s (%s) failed\", host, port,\n\t\t\t    uflag ? \"udp\" : \"tcp\");\n\n\t\tclose(s);\n\t\ts = -1;\n\t} while ((res0 = res0->ai_next) != NULL);\n\n\tfreeaddrinfo(res);\n\n\treturn (s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "socks_connect",
          "args": [
            "host",
            "portlist[i]",
            "hints",
            "proxyhost",
            "proxyport",
            "proxyhints",
            "socksv",
            "Pflag"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "socks_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "1448-1663",
          "snippet": "int\nsocks_connect(const char *host, const char *port,\n    struct addrinfo hints __attribute__ ((__unused__)),\n    const char *proxyhost, const char *proxyport, struct addrinfo proxyhints,\n    int socksv, const char *proxyuser)\n{\n\tint proxyfd, r, authretry = 0;\n\tsize_t hlen, wlen = 0;\n\tunsigned char buf[1024];\n\tsize_t cnt;\n\tstruct sockaddr_storage addr;\n\tstruct sockaddr_in *in4 = (struct sockaddr_in *)&addr;\n\tstruct sockaddr_in6 *in6 = (struct sockaddr_in6 *)&addr;\n\tin_port_t serverport;\n\tconst char *proxypass = NULL;\n\n\tif (proxyport == NULL)\n\t\tproxyport = (socksv == -1) ? HTTP_PROXY_PORT : SOCKS_PORT;\n\n\t/* Abuse API to lookup port */\n\tif (decode_addrport(\"0.0.0.0\", port, (struct sockaddr *)&addr,\n\t    sizeof(addr), 1, 1) == -1)\n\t\terrx(1, \"unknown port \\\"%.64s\\\"\", port);\n\tserverport = in4->sin_port;\n\n again:\n\tif (authretry++ > 3)\n\t\terrx(1, \"Too many authentication failures\");\n\n\tproxyfd = remote_connect(proxyhost, proxyport, proxyhints);\n\n\tif (proxyfd < 0)\n\t\treturn (-1);\n\n\tif (socksv == 5) {\n\t\tif (decode_addrport(host, port, (struct sockaddr *)&addr,\n\t\t    sizeof(addr), 0, 1) == -1)\n\t\t\taddr.ss_family = 0; /* used in switch below */\n\n\t\t/* Version 5, one method: no authentication */\n\t\tbuf[0] = SOCKS_V5;\n\t\tbuf[1] = 1;\n\t\tbuf[2] = SOCKS_NOAUTH;\n\t\tcnt = atomicio(vwrite, proxyfd, buf, 3);\n\t\tif (cnt != 3)\n\t\t\terr(1, \"write failed (%zu/3)\", cnt);\n\n\t\tcnt = atomicio(read, proxyfd, buf, 2);\n\t\tif (cnt != 2)\n\t\t\terr(1, \"read failed (%zu/3)\", cnt);\n\n\t\tif (buf[1] == SOCKS_NOMETHOD)\n\t\t\terrx(1, \"authentication method negotiation failed\");\n\n\t\tswitch (addr.ss_family) {\n\t\tcase 0:\n\t\t\t/* Version 5, connect: domain name */\n\n\t\t\t/* Max domain name length is 255 bytes */\n\t\t\thlen = strlen(host);\n\t\t\tif (hlen > 255)\n\t\t\t\terrx(1, \"host name too long for SOCKS5\");\n\t\t\tbuf[0] = SOCKS_V5;\n\t\t\tbuf[1] = SOCKS_CONNECT;\n\t\t\tbuf[2] = 0;\n\t\t\tbuf[3] = SOCKS_DOMAIN;\n\t\t\tbuf[4] = hlen;\n\t\t\tmemcpy(buf + 5, host, hlen);\t\t\t\n\t\t\tmemcpy(buf + 5 + hlen, &serverport, sizeof serverport);\n\t\t\twlen = 7 + hlen;\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\t\t/* Version 5, connect: IPv4 address */\n\t\t\tbuf[0] = SOCKS_V5;\n\t\t\tbuf[1] = SOCKS_CONNECT;\n\t\t\tbuf[2] = 0;\n\t\t\tbuf[3] = SOCKS_IPV4;\n\t\t\tmemcpy(buf + 4, &in4->sin_addr, sizeof in4->sin_addr);\n\t\t\tmemcpy(buf + 8, &in4->sin_port, sizeof in4->sin_port);\n\t\t\twlen = 10;\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\t/* Version 5, connect: IPv6 address */\n\t\t\tbuf[0] = SOCKS_V5;\n\t\t\tbuf[1] = SOCKS_CONNECT;\n\t\t\tbuf[2] = 0;\n\t\t\tbuf[3] = SOCKS_IPV6;\n\t\t\tmemcpy(buf + 4, &in6->sin6_addr, sizeof in6->sin6_addr);\n\t\t\tmemcpy(buf + 20, &in6->sin6_port,\n\t\t\t    sizeof in6->sin6_port);\n\t\t\twlen = 22;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terrx(1, \"internal error: silly AF\");\n\t\t}\n\n\t\tcnt = atomicio(vwrite, proxyfd, buf, wlen);\n\t\tif (cnt != wlen)\n\t\t\terr(1, \"write failed (%zu/%zu)\", cnt, wlen);\n\n\t\tcnt = atomicio(read, proxyfd, buf, 4);\n\t\tif (cnt != 4)\n\t\t\terr(1, \"read failed (%zu/4)\", cnt);\n\t\tif (buf[1] != 0)\n\t\t\terrx(1, \"connection failed, SOCKS error %d\", buf[1]);\n\t\tswitch (buf[3]) {\n\t\tcase SOCKS_IPV4:\n\t\t\tcnt = atomicio(read, proxyfd, buf + 4, 6);\n\t\t\tif (cnt != 6)\n\t\t\t\terr(1, \"read failed (%zu/6)\", cnt);\n\t\t\tbreak;\n\t\tcase SOCKS_IPV6:\n\t\t\tcnt = atomicio(read, proxyfd, buf + 4, 18);\n\t\t\tif (cnt != 18)\n\t\t\t\terr(1, \"read failed (%zu/18)\", cnt);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terrx(1, \"connection failed, unsupported address type\");\n\t\t}\n\t} else if (socksv == 4) {\n\t\t/* This will exit on lookup failure */\n\t\tdecode_addrport(host, port, (struct sockaddr *)&addr,\n\t\t    sizeof(addr), 1, 0);\n\n\t\t/* Version 4 */\n\t\tbuf[0] = SOCKS_V4;\n\t\tbuf[1] = SOCKS_CONNECT;\t/* connect */\n\t\tmemcpy(buf + 2, &in4->sin_port, sizeof in4->sin_port);\n\t\tmemcpy(buf + 4, &in4->sin_addr, sizeof in4->sin_addr);\n\t\tbuf[8] = 0;\t/* empty username */\n\t\twlen = 9;\n\n\t\tcnt = atomicio(vwrite, proxyfd, buf, wlen);\n\t\tif (cnt != wlen)\n\t\t\terr(1, \"write failed (%zu/%zu)\", cnt, wlen);\n\n\t\tcnt = atomicio(read, proxyfd, buf, 8);\n\t\tif (cnt != 8)\n\t\t\terr(1, \"read failed (%zu/8)\", cnt);\n\t\tif (buf[1] != 90)\n\t\t\terrx(1, \"connection failed, SOCKS error %d\", buf[1]);\n\t} else if (socksv == -1) {\n\t\t/* HTTP proxy CONNECT */\n\n\t\t/* Disallow bad chars in hostname */\n\t\tif (strcspn(host, \"\\r\\n\\t []:\") != strlen(host))\n\t\t\terrx(1, \"Invalid hostname\");\n\n\t\t/* Try to be sane about numeric IPv6 addresses */\n\t\tif (strchr(host, ':') != NULL) {\n\t\t\tr = snprintf(buf, sizeof(buf),\n\t\t\t    \"CONNECT [%s]:%d HTTP/1.0\\r\\n\",\n\t\t\t    host, ntohs(serverport));\n\t\t} else {\n\t\t\tr = snprintf(buf, sizeof(buf),\n\t\t\t    \"CONNECT %s:%d HTTP/1.0\\r\\n\",\n\t\t\t    host, ntohs(serverport));\n\t\t}\n\t\tif (r == -1 || (size_t)r >= sizeof(buf))\n\t\t\terrx(1, \"hostname too long\");\n\t\tr = strlen(buf);\n\n\t\tcnt = atomicio(vwrite, proxyfd, buf, r);\n\t\tif (cnt != (size_t)r)\n\t\t\terr(1, \"write failed (%zu/%d)\", cnt, r);\n\n\t\tif (authretry > 1) {\n\t\t\tchar resp[1024];\n\n\t\t\tproxypass = getproxypass(proxyuser, proxyhost);\n\t\t\tr = snprintf(buf, sizeof(buf), \"%s:%s\",\n\t\t\t    proxyuser, proxypass);\n\t\t\tif (r == -1 || (size_t)r >= sizeof(buf) ||\n\t\t\t    b64_ntop(buf, strlen(buf), resp,\n\t\t\t    sizeof(resp)) == -1)\n\t\t\t\terrx(1, \"Proxy username/password too long\");\n\t\t\tr = snprintf(buf, sizeof(buf), \"Proxy-Authorization: \"\n\t\t\t    \"Basic %s\\r\\n\", resp);\n\t\t\tif (r == -1 || (size_t)r >= sizeof(buf))\n\t\t\t\terrx(1, \"Proxy auth response too long\");\n\t\t\tr = strlen(buf);\n\t\t\tif ((cnt = atomicio(vwrite, proxyfd, buf, r)) != (size_t)r)\n\t\t\t\terr(1, \"write failed (%zu/%d)\", cnt, r);\n\t\t}\n\n\t\t/* Terminate headers */\n\t\tif ((r = atomicio(vwrite, proxyfd, \"\\r\\n\", 2)) != 2)\n\t\t\terr(1, \"write failed (2/%d)\", r);\n\n\t\t/* Read status reply */\n\t\tproxy_read_line(proxyfd, buf, sizeof(buf));\n\t\tif (proxyuser != NULL &&\n\t\t    strncmp(buf, \"HTTP/1.0 407 \", 12) == 0) {\n\t\t\tif (authretry > 1) {\n\t\t\t\tfprintf(stderr, \"Proxy authentication \"\n\t\t\t\t    \"failed\\n\");\n\t\t\t}\n\t\t\tclose(proxyfd);\n\t\t\tgoto again;\n\t\t} else if (strncmp(buf, \"HTTP/1.0 200 \", 12) != 0 &&\n\t\t    strncmp(buf, \"HTTP/1.1 200 \", 12) != 0)\n\t\t\terrx(1, \"Proxy error: \\\"%s\\\"\", buf);\n\n\t\t/* Headers continue until we hit an empty line */\n\t\tfor (r = 0; r < HTTP_MAXHDRS; r++) {\n\t\t\tproxy_read_line(proxyfd, buf, sizeof(buf));\n\t\t\tif (*buf == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*buf != '\\0')\n\t\t\terrx(1, \"Too many proxy headers received\");\n\t} else\n\t\terrx(1, \"Unknown proxy protocol %d\", socksv);\n\n\treturn (proxyfd);\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SOCKS_IPV6\t4",
            "#define SOCKS_DOMAIN\t3",
            "#define SOCKS_IPV4\t1",
            "#define SOCKS_CONNECT\t1",
            "#define SOCKS_NOMETHOD\t0xff",
            "#define SOCKS_NOAUTH\t0",
            "#define SOCKS_V4\t4",
            "#define SOCKS_V5\t5",
            "#define HTTP_MAXHDRS\t64",
            "#define HTTP_PROXY_PORT\t\"3128\"",
            "#define SOCKS_PORT\t\"1080\""
          ],
          "globals_used": [
            "int\tlocal_listen(char *, char *, struct addrinfo);",
            "int\tremote_connect(const char *, const char *, struct addrinfo);",
            "int\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int, const char *);",
            "ssize_t drainbuf(int, unsigned char *, size_t *);",
            "ssize_t fillbuf(int, unsigned char *, size_t *);",
            "int\tremote_connect(const char *, const char *, struct addrinfo);",
            "int\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int,\n\t    const char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define SOCKS_IPV6\t4\n#define SOCKS_DOMAIN\t3\n#define SOCKS_IPV4\t1\n#define SOCKS_CONNECT\t1\n#define SOCKS_NOMETHOD\t0xff\n#define SOCKS_NOAUTH\t0\n#define SOCKS_V4\t4\n#define SOCKS_V5\t5\n#define HTTP_MAXHDRS\t64\n#define HTTP_PROXY_PORT\t\"3128\"\n#define SOCKS_PORT\t\"1080\"\n\nint\tlocal_listen(char *, char *, struct addrinfo);\nint\tremote_connect(const char *, const char *, struct addrinfo);\nint\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int, const char *);\nssize_t drainbuf(int, unsigned char *, size_t *);\nssize_t fillbuf(int, unsigned char *, size_t *);\nint\tremote_connect(const char *, const char *, struct addrinfo);\nint\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int,\n\t    const char *);\n\nint\nsocks_connect(const char *host, const char *port,\n    struct addrinfo hints __attribute__ ((__unused__)),\n    const char *proxyhost, const char *proxyport, struct addrinfo proxyhints,\n    int socksv, const char *proxyuser)\n{\n\tint proxyfd, r, authretry = 0;\n\tsize_t hlen, wlen = 0;\n\tunsigned char buf[1024];\n\tsize_t cnt;\n\tstruct sockaddr_storage addr;\n\tstruct sockaddr_in *in4 = (struct sockaddr_in *)&addr;\n\tstruct sockaddr_in6 *in6 = (struct sockaddr_in6 *)&addr;\n\tin_port_t serverport;\n\tconst char *proxypass = NULL;\n\n\tif (proxyport == NULL)\n\t\tproxyport = (socksv == -1) ? HTTP_PROXY_PORT : SOCKS_PORT;\n\n\t/* Abuse API to lookup port */\n\tif (decode_addrport(\"0.0.0.0\", port, (struct sockaddr *)&addr,\n\t    sizeof(addr), 1, 1) == -1)\n\t\terrx(1, \"unknown port \\\"%.64s\\\"\", port);\n\tserverport = in4->sin_port;\n\n again:\n\tif (authretry++ > 3)\n\t\terrx(1, \"Too many authentication failures\");\n\n\tproxyfd = remote_connect(proxyhost, proxyport, proxyhints);\n\n\tif (proxyfd < 0)\n\t\treturn (-1);\n\n\tif (socksv == 5) {\n\t\tif (decode_addrport(host, port, (struct sockaddr *)&addr,\n\t\t    sizeof(addr), 0, 1) == -1)\n\t\t\taddr.ss_family = 0; /* used in switch below */\n\n\t\t/* Version 5, one method: no authentication */\n\t\tbuf[0] = SOCKS_V5;\n\t\tbuf[1] = 1;\n\t\tbuf[2] = SOCKS_NOAUTH;\n\t\tcnt = atomicio(vwrite, proxyfd, buf, 3);\n\t\tif (cnt != 3)\n\t\t\terr(1, \"write failed (%zu/3)\", cnt);\n\n\t\tcnt = atomicio(read, proxyfd, buf, 2);\n\t\tif (cnt != 2)\n\t\t\terr(1, \"read failed (%zu/3)\", cnt);\n\n\t\tif (buf[1] == SOCKS_NOMETHOD)\n\t\t\terrx(1, \"authentication method negotiation failed\");\n\n\t\tswitch (addr.ss_family) {\n\t\tcase 0:\n\t\t\t/* Version 5, connect: domain name */\n\n\t\t\t/* Max domain name length is 255 bytes */\n\t\t\thlen = strlen(host);\n\t\t\tif (hlen > 255)\n\t\t\t\terrx(1, \"host name too long for SOCKS5\");\n\t\t\tbuf[0] = SOCKS_V5;\n\t\t\tbuf[1] = SOCKS_CONNECT;\n\t\t\tbuf[2] = 0;\n\t\t\tbuf[3] = SOCKS_DOMAIN;\n\t\t\tbuf[4] = hlen;\n\t\t\tmemcpy(buf + 5, host, hlen);\t\t\t\n\t\t\tmemcpy(buf + 5 + hlen, &serverport, sizeof serverport);\n\t\t\twlen = 7 + hlen;\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\t\t/* Version 5, connect: IPv4 address */\n\t\t\tbuf[0] = SOCKS_V5;\n\t\t\tbuf[1] = SOCKS_CONNECT;\n\t\t\tbuf[2] = 0;\n\t\t\tbuf[3] = SOCKS_IPV4;\n\t\t\tmemcpy(buf + 4, &in4->sin_addr, sizeof in4->sin_addr);\n\t\t\tmemcpy(buf + 8, &in4->sin_port, sizeof in4->sin_port);\n\t\t\twlen = 10;\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\t/* Version 5, connect: IPv6 address */\n\t\t\tbuf[0] = SOCKS_V5;\n\t\t\tbuf[1] = SOCKS_CONNECT;\n\t\t\tbuf[2] = 0;\n\t\t\tbuf[3] = SOCKS_IPV6;\n\t\t\tmemcpy(buf + 4, &in6->sin6_addr, sizeof in6->sin6_addr);\n\t\t\tmemcpy(buf + 20, &in6->sin6_port,\n\t\t\t    sizeof in6->sin6_port);\n\t\t\twlen = 22;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terrx(1, \"internal error: silly AF\");\n\t\t}\n\n\t\tcnt = atomicio(vwrite, proxyfd, buf, wlen);\n\t\tif (cnt != wlen)\n\t\t\terr(1, \"write failed (%zu/%zu)\", cnt, wlen);\n\n\t\tcnt = atomicio(read, proxyfd, buf, 4);\n\t\tif (cnt != 4)\n\t\t\terr(1, \"read failed (%zu/4)\", cnt);\n\t\tif (buf[1] != 0)\n\t\t\terrx(1, \"connection failed, SOCKS error %d\", buf[1]);\n\t\tswitch (buf[3]) {\n\t\tcase SOCKS_IPV4:\n\t\t\tcnt = atomicio(read, proxyfd, buf + 4, 6);\n\t\t\tif (cnt != 6)\n\t\t\t\terr(1, \"read failed (%zu/6)\", cnt);\n\t\t\tbreak;\n\t\tcase SOCKS_IPV6:\n\t\t\tcnt = atomicio(read, proxyfd, buf + 4, 18);\n\t\t\tif (cnt != 18)\n\t\t\t\terr(1, \"read failed (%zu/18)\", cnt);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terrx(1, \"connection failed, unsupported address type\");\n\t\t}\n\t} else if (socksv == 4) {\n\t\t/* This will exit on lookup failure */\n\t\tdecode_addrport(host, port, (struct sockaddr *)&addr,\n\t\t    sizeof(addr), 1, 0);\n\n\t\t/* Version 4 */\n\t\tbuf[0] = SOCKS_V4;\n\t\tbuf[1] = SOCKS_CONNECT;\t/* connect */\n\t\tmemcpy(buf + 2, &in4->sin_port, sizeof in4->sin_port);\n\t\tmemcpy(buf + 4, &in4->sin_addr, sizeof in4->sin_addr);\n\t\tbuf[8] = 0;\t/* empty username */\n\t\twlen = 9;\n\n\t\tcnt = atomicio(vwrite, proxyfd, buf, wlen);\n\t\tif (cnt != wlen)\n\t\t\terr(1, \"write failed (%zu/%zu)\", cnt, wlen);\n\n\t\tcnt = atomicio(read, proxyfd, buf, 8);\n\t\tif (cnt != 8)\n\t\t\terr(1, \"read failed (%zu/8)\", cnt);\n\t\tif (buf[1] != 90)\n\t\t\terrx(1, \"connection failed, SOCKS error %d\", buf[1]);\n\t} else if (socksv == -1) {\n\t\t/* HTTP proxy CONNECT */\n\n\t\t/* Disallow bad chars in hostname */\n\t\tif (strcspn(host, \"\\r\\n\\t []:\") != strlen(host))\n\t\t\terrx(1, \"Invalid hostname\");\n\n\t\t/* Try to be sane about numeric IPv6 addresses */\n\t\tif (strchr(host, ':') != NULL) {\n\t\t\tr = snprintf(buf, sizeof(buf),\n\t\t\t    \"CONNECT [%s]:%d HTTP/1.0\\r\\n\",\n\t\t\t    host, ntohs(serverport));\n\t\t} else {\n\t\t\tr = snprintf(buf, sizeof(buf),\n\t\t\t    \"CONNECT %s:%d HTTP/1.0\\r\\n\",\n\t\t\t    host, ntohs(serverport));\n\t\t}\n\t\tif (r == -1 || (size_t)r >= sizeof(buf))\n\t\t\terrx(1, \"hostname too long\");\n\t\tr = strlen(buf);\n\n\t\tcnt = atomicio(vwrite, proxyfd, buf, r);\n\t\tif (cnt != (size_t)r)\n\t\t\terr(1, \"write failed (%zu/%d)\", cnt, r);\n\n\t\tif (authretry > 1) {\n\t\t\tchar resp[1024];\n\n\t\t\tproxypass = getproxypass(proxyuser, proxyhost);\n\t\t\tr = snprintf(buf, sizeof(buf), \"%s:%s\",\n\t\t\t    proxyuser, proxypass);\n\t\t\tif (r == -1 || (size_t)r >= sizeof(buf) ||\n\t\t\t    b64_ntop(buf, strlen(buf), resp,\n\t\t\t    sizeof(resp)) == -1)\n\t\t\t\terrx(1, \"Proxy username/password too long\");\n\t\t\tr = snprintf(buf, sizeof(buf), \"Proxy-Authorization: \"\n\t\t\t    \"Basic %s\\r\\n\", resp);\n\t\t\tif (r == -1 || (size_t)r >= sizeof(buf))\n\t\t\t\terrx(1, \"Proxy auth response too long\");\n\t\t\tr = strlen(buf);\n\t\t\tif ((cnt = atomicio(vwrite, proxyfd, buf, r)) != (size_t)r)\n\t\t\t\terr(1, \"write failed (%zu/%d)\", cnt, r);\n\t\t}\n\n\t\t/* Terminate headers */\n\t\tif ((r = atomicio(vwrite, proxyfd, \"\\r\\n\", 2)) != 2)\n\t\t\terr(1, \"write failed (2/%d)\", r);\n\n\t\t/* Read status reply */\n\t\tproxy_read_line(proxyfd, buf, sizeof(buf));\n\t\tif (proxyuser != NULL &&\n\t\t    strncmp(buf, \"HTTP/1.0 407 \", 12) == 0) {\n\t\t\tif (authretry > 1) {\n\t\t\t\tfprintf(stderr, \"Proxy authentication \"\n\t\t\t\t    \"failed\\n\");\n\t\t\t}\n\t\t\tclose(proxyfd);\n\t\t\tgoto again;\n\t\t} else if (strncmp(buf, \"HTTP/1.0 200 \", 12) != 0 &&\n\t\t    strncmp(buf, \"HTTP/1.1 200 \", 12) != 0)\n\t\t\terrx(1, \"Proxy error: \\\"%s\\\"\", buf);\n\n\t\t/* Headers continue until we hit an empty line */\n\t\tfor (r = 0; r < HTTP_MAXHDRS; r++) {\n\t\t\tproxy_read_line(proxyfd, buf, sizeof(buf));\n\t\t\tif (*buf == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*buf != '\\0')\n\t\t\terrx(1, \"Too many proxy headers received\");\n\t} else\n\t\terrx(1, \"Unknown proxy protocol %d\", socksv);\n\n\treturn (proxyfd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_ports",
          "args": [
            "uport"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "build_ports",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "1091-1146",
          "snippet": "void\nbuild_ports(char *p)\n{\n\tconst char *errstr;\n\tchar *n;\n\tint hi, lo, cp;\n\tint x = 0;\n\n\tif ((n = strchr(p, '-')) != NULL) {\n\t\t*n = '\\0';\n\t\tn++;\n\n\t\t/* Make sure the ports are in order: lowest->highest. */\n\t\thi = strtonum(n, 1, PORT_MAX, &errstr);\n\t\tif (errstr)\n\t\t\terrx(1, \"port number %s: %s\", errstr, n);\n\t\tlo = strtonum(p, 1, PORT_MAX, &errstr);\n\t\tif (errstr)\n\t\t\terrx(1, \"port number %s: %s\", errstr, p);\n\n\t\tif (lo > hi) {\n\t\t\tcp = hi;\n\t\t\thi = lo;\n\t\t\tlo = cp;\n\t\t}\n\n\t\t/* Load ports sequentially. */\n\t\tfor (cp = lo; cp <= hi; cp++) {\n\t\t\tportlist[x] = calloc(1, PORT_MAX_LEN);\n\t\t\tif (portlist[x] == NULL)\n\t\t\t\terrx(1, \"calloc\");\n\t\t\tsnprintf(portlist[x], PORT_MAX_LEN, \"%d\", cp);\n\t\t\tx++;\n\t\t}\n\n\t\t/* Randomly swap ports. */\n\t\tif (rflag) {\n\t\t\tint y;\n\t\t\tchar *c;\n\n\t\t\tfor (x = 0; x <= (hi - lo); x++) {\n\t\t\t\ty = (arc4random() & 0xFFFF) % (hi - lo);\n\t\t\t\tc = portlist[x];\n\t\t\t\tportlist[x] = portlist[y];\n\t\t\t\tportlist[y] = c;\n\t\t\t}\n\t\t}\n\t} else {\n\t\thi = strtonum(p, 1, PORT_MAX, &errstr);\n\t\tif (errstr)\n\t\t\terrx(1, \"port number %s: %s\", errstr, p);\n\t\tportlist[0] = strdup(p);\n\t\tif (portlist[0] == NULL)\n\t\t\terrx(1, \"strdup\");\n\t}\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define PORT_MAX_LEN\t6",
            "#define PORT_MAX\t65535"
          ],
          "globals_used": [
            "int\trflag;",
            "char *portlist[PORT_MAX+1];",
            "void\tbuild_ports(char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define PORT_MAX_LEN\t6\n#define PORT_MAX\t65535\n\nint\trflag;\nchar *portlist[PORT_MAX+1];\nvoid\tbuild_ports(char *);\n\nvoid\nbuild_ports(char *p)\n{\n\tconst char *errstr;\n\tchar *n;\n\tint hi, lo, cp;\n\tint x = 0;\n\n\tif ((n = strchr(p, '-')) != NULL) {\n\t\t*n = '\\0';\n\t\tn++;\n\n\t\t/* Make sure the ports are in order: lowest->highest. */\n\t\thi = strtonum(n, 1, PORT_MAX, &errstr);\n\t\tif (errstr)\n\t\t\terrx(1, \"port number %s: %s\", errstr, n);\n\t\tlo = strtonum(p, 1, PORT_MAX, &errstr);\n\t\tif (errstr)\n\t\t\terrx(1, \"port number %s: %s\", errstr, p);\n\n\t\tif (lo > hi) {\n\t\t\tcp = hi;\n\t\t\thi = lo;\n\t\t\tlo = cp;\n\t\t}\n\n\t\t/* Load ports sequentially. */\n\t\tfor (cp = lo; cp <= hi; cp++) {\n\t\t\tportlist[x] = calloc(1, PORT_MAX_LEN);\n\t\t\tif (portlist[x] == NULL)\n\t\t\t\terrx(1, \"calloc\");\n\t\t\tsnprintf(portlist[x], PORT_MAX_LEN, \"%d\", cp);\n\t\t\tx++;\n\t\t}\n\n\t\t/* Randomly swap ports. */\n\t\tif (rflag) {\n\t\t\tint y;\n\t\t\tchar *c;\n\n\t\t\tfor (x = 0; x <= (hi - lo); x++) {\n\t\t\t\ty = (arc4random() & 0xFFFF) % (hi - lo);\n\t\t\t\tc = portlist[x];\n\t\t\t\tportlist[x] = portlist[y];\n\t\t\t\tportlist[y] = c;\n\t\t\t}\n\t\t}\n\t} else {\n\t\thi = strtonum(p, 1, PORT_MAX, &errstr);\n\t\tif (errstr)\n\t\t\terrx(1, \"port number %s: %s\", errstr, p);\n\t\tportlist[0] = strdup(p);\n\t\tif (portlist[0] == NULL)\n\t\t\terrx(1, \"strdup\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "unix_dg_tmp_socket"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unix_connect",
          "args": [
            "host"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "unix_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "548-578",
          "snippet": "int\nunix_connect(char *path)\n{\n\tstruct sockaddr_un sun_sa;\n\tint s;\n\n\tif (uflag) {\n\t\tif ((s = unix_bind(unix_dg_tmp_socket)) < 0)\n\t\t\treturn (-1);\n\t} else {\n\t\tif ((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\t\treturn (-1);\n\t}\n\t(void)fcntl(s, F_SETFD, FD_CLOEXEC);\n\n\tmemset(&sun_sa, 0, sizeof(struct sockaddr_un));\n\tsun_sa.sun_family = AF_UNIX;\n\n\tif (strlcpy(sun_sa.sun_path, path, sizeof(sun_sa.sun_path)) >=\n\t    sizeof(sun_sa.sun_path)) {\n\t\tclose(s);\n\t\terrno = ENAMETOOLONG;\n\t\treturn (-1);\n\t}\n\tif (connect(s, (struct sockaddr *)&sun_sa, SUN_LEN(&sun_sa)) < 0) {\n\t\tclose(s);\n\t\treturn (-1);\n\t}\n\treturn (s);\n\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tuflag;",
            "char *unix_dg_tmp_socket;",
            "int\tunix_bind(char *);",
            "int\tunix_connect(char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tuflag;\nchar *unix_dg_tmp_socket;\nint\tunix_bind(char *);\nint\tunix_connect(char *);\n\nint\nunix_connect(char *path)\n{\n\tstruct sockaddr_un sun_sa;\n\tint s;\n\n\tif (uflag) {\n\t\tif ((s = unix_bind(unix_dg_tmp_socket)) < 0)\n\t\t\treturn (-1);\n\t} else {\n\t\tif ((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\t\treturn (-1);\n\t}\n\t(void)fcntl(s, F_SETFD, FD_CLOEXEC);\n\n\tmemset(&sun_sa, 0, sizeof(struct sockaddr_un));\n\tsun_sa.sun_family = AF_UNIX;\n\n\tif (strlcpy(sun_sa.sun_path, path, sizeof(sun_sa.sun_path)) >=\n\t    sizeof(sun_sa.sun_path)) {\n\t\tclose(s);\n\t\terrno = ENAMETOOLONG;\n\t\treturn (-1);\n\t}\n\tif (connect(s, (struct sockaddr *)&sun_sa, SUN_LEN(&sun_sa)) < 0) {\n\t\tclose(s);\n\t\treturn (-1);\n\t}\n\treturn (s);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "1",
            "\"connect\""
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "run_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/scp.c",
          "lines": "1323-1346",
          "snippet": "void\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}",
          "includes": [
            "#include \"utf8.h\"",
            "#include \"progressmeter.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"atomicio.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <locale.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <ctype.h>",
            "#include <sys/uio.h>",
            "#include <sys/wait.h>",
            "# include <sys/time.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "# include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void run_err(const char *,...);",
            "int errs, remin, remout;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utf8.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <locale.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n# include <sys/time.h>\n#  include <sys/poll.h>\n#include <poll.h>\n# include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid run_err(const char *,...);\nint errs, remin, remout;\n\nvoid\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "s",
            "NULL",
            "0"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "timeout_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "665-700",
          "snippet": "int\ntimeout_connect(int s, const struct sockaddr *name, socklen_t namelen)\n{\n\tstruct pollfd pfd;\n\tsocklen_t optlen;\n\tint flags = 0, optval;\n\tint ret;\n\n\tif (timeout != -1) {\n\t\tflags = fcntl(s, F_GETFL, 0);\n\t\tif (fcntl(s, F_SETFL, flags | O_NONBLOCK) == -1)\n\t\t\terr(1, \"set non-blocking mode\");\n\t}\n\n\tif ((ret = connect(s, name, namelen)) != 0 && errno == EINPROGRESS) {\n\t\tpfd.fd = s;\n\t\tpfd.events = POLLOUT;\n\t\tif ((ret = poll(&pfd, 1, timeout)) == 1) {\n\t\t\toptlen = sizeof(optval);\n\t\t\tif ((ret = getsockopt(s, SOL_SOCKET, SO_ERROR,\n\t\t\t    &optval, &optlen)) == 0) {\n\t\t\t\terrno = optval;\n\t\t\t\tret = optval == 0 ? 0 : -1;\n\t\t\t}\n\t\t} else if (ret == 0) {\n\t\t\terrno = ETIMEDOUT;\n\t\t\tret = -1;\n\t\t} else\n\t\t\terr(1, \"poll failed\");\n\t}\n\n\tif (timeout != -1 && fcntl(s, F_SETFL, flags) == -1)\n\t\terr(1, \"restoring flags\");\n\n\treturn (ret);\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int timeout = -1;",
            "int\ttimeout_connect(int, const struct sockaddr *, socklen_t);",
            "void\treport_connect(const struct sockaddr *, socklen_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint timeout = -1;\nint\ttimeout_connect(int, const struct sockaddr *, socklen_t);\nvoid\treport_connect(const struct sockaddr *, socklen_t);\n\nint\ntimeout_connect(int s, const struct sockaddr *name, socklen_t namelen)\n{\n\tstruct pollfd pfd;\n\tsocklen_t optlen;\n\tint flags = 0, optval;\n\tint ret;\n\n\tif (timeout != -1) {\n\t\tflags = fcntl(s, F_GETFL, 0);\n\t\tif (fcntl(s, F_SETFL, flags | O_NONBLOCK) == -1)\n\t\t\terr(1, \"set non-blocking mode\");\n\t}\n\n\tif ((ret = connect(s, name, namelen)) != 0 && errno == EINPROGRESS) {\n\t\tpfd.fd = s;\n\t\tpfd.events = POLLOUT;\n\t\tif ((ret = poll(&pfd, 1, timeout)) == 1) {\n\t\t\toptlen = sizeof(optval);\n\t\t\tif ((ret = getsockopt(s, SOL_SOCKET, SO_ERROR,\n\t\t\t    &optval, &optlen)) == 0) {\n\t\t\t\terrno = optval;\n\t\t\t\tret = optval == 0 ? 0 : -1;\n\t\t\t}\n\t\t} else if (ret == 0) {\n\t\t\terrno = ETIMEDOUT;\n\t\t\tret = -1;\n\t\t} else\n\t\t\terr(1, \"poll failed\");\n\t}\n\n\tif (timeout != -1 && fcntl(s, F_SETFL, flags) == -1)\n\t\terr(1, \"restoring flags\");\n\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_connect",
          "args": [
            "(struct sockaddr *)&cliaddr",
            "len"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "report_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "1249-1273",
          "snippet": "void\nreport_connect(const struct sockaddr *sa, socklen_t salen)\n{\n\tchar remote_host[NI_MAXHOST];\n\tchar remote_port[NI_MAXSERV];\n\tint herr;\n\tint flags = NI_NUMERICSERV;\n\t\n\tif (nflag)\n\t\tflags |= NI_NUMERICHOST;\n\t\n\tif ((herr = getnameinfo(sa, salen,\n\t    remote_host, sizeof(remote_host),\n\t    remote_port, sizeof(remote_port),\n\t    flags)) != 0) {\n\t\tif (herr == EAI_SYSTEM)\n\t\t\terr(1, \"getnameinfo\");\n\t\telse\n\t\t\terrx(1, \"getnameinfo: %s\", gai_strerror(herr));\n\t}\n\t\n\tfprintf(stderr,\n\t    \"Connection from %s %s \"\n\t    \"received!\\n\", remote_host, remote_port);\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tnflag;",
            "int\ttimeout_connect(int, const struct sockaddr *, socklen_t);",
            "void\treport_connect(const struct sockaddr *, socklen_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tnflag;\nint\ttimeout_connect(int, const struct sockaddr *, socklen_t);\nvoid\treport_connect(const struct sockaddr *, socklen_t);\n\nvoid\nreport_connect(const struct sockaddr *sa, socklen_t salen)\n{\n\tchar remote_host[NI_MAXHOST];\n\tchar remote_port[NI_MAXSERV];\n\tint herr;\n\tint flags = NI_NUMERICSERV;\n\t\n\tif (nflag)\n\t\tflags |= NI_NUMERICHOST;\n\t\n\tif ((herr = getnameinfo(sa, salen,\n\t    remote_host, sizeof(remote_host),\n\t    remote_port, sizeof(remote_port),\n\t    flags)) != 0) {\n\t\tif (herr == EAI_SYSTEM)\n\t\t\terr(1, \"getnameinfo\");\n\t\telse\n\t\t\terrx(1, \"getnameinfo: %s\", gai_strerror(herr));\n\t}\n\t\n\tfprintf(stderr,\n\t    \"Connection from %s %s \"\n\t    \"received!\\n\", remote_host, remote_port);\n}"
        }
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "s",
            "(struct sockaddr *)&cliaddr",
            "&len"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "input_userauth_service_accept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/sshconnect2.c",
          "lines": "419-449",
          "snippet": "int\ninput_userauth_service_accept(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tint r;\n\n\tif (ssh_packet_remaining(ssh) > 0) {\n\t\tchar *reply;\n\n\t\tif ((r = sshpkt_get_cstring(ssh, &reply, NULL)) != 0)\n\t\t\tgoto out;\n\t\tdebug2(\"service_accept: %s\", reply);\n\t\tfree(reply);\n\t} else {\n\t\tdebug2(\"buggy server: service_accept w/o service\");\n\t}\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto out;\n\tdebug(\"SSH2_MSG_SERVICE_ACCEPT received\");\n\n\t/* initial userauth request */\n\tuserauth_none(authctxt);\n\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &input_userauth_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_SUCCESS, &input_userauth_success);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_FAILURE, &input_userauth_failure);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_BANNER, &input_userauth_banner);\n\tr = 0;\n out:\n\treturn r;\n}",
          "includes": [
            "#include \"ssh-gss.h\"",
            "#include \"utf8.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"uidswap.h\"",
            "#include \"pathnames.h\"",
            "#include \"msg.h\"",
            "#include \"canohost.h\"",
            "#include \"dispatch.h\"",
            "#include \"match.h\"",
            "#include \"readconf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"authfd.h\"",
            "#include \"dh.h\"",
            "#include \"authfile.h\"",
            "#include \"sshconnect.h\"",
            "#include \"myproposal.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"compat.h\"",
            "#include \"packet.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh2.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <vis.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_failure(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_banner(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_error(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_info_req(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);",
            "int\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);",
            "int\tuserauth_none(Authctxt *);",
            "int\tuserauth_pubkey(Authctxt *);",
            "int\tuserauth_passwd(Authctxt *);",
            "int\tuserauth_kbdint(Authctxt *);",
            "int\tuserauth_hostbased(Authctxt *);",
            "void\tuserauth(Authctxt *, char *);",
            "static void pubkey_prepare(Authctxt *);",
            "static void pubkey_cleanup(Authctxt *);",
            "static void pubkey_reset(Authctxt *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh-gss.h\"\n#include \"utf8.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"uidswap.h\"\n#include \"pathnames.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"dispatch.h\"\n#include \"match.h\"\n#include \"readconf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"authfd.h\"\n#include \"dh.h\"\n#include \"authfile.h\"\n#include \"sshconnect.h\"\n#include \"myproposal.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssh2.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <vis.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tinput_userauth_service_accept(int, u_int32_t, struct ssh *);\nint\tinput_userauth_ext_info(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success(int, u_int32_t, struct ssh *);\nint\tinput_userauth_success_unexpected(int, u_int32_t, struct ssh *);\nint\tinput_userauth_failure(int, u_int32_t, struct ssh *);\nint\tinput_userauth_banner(int, u_int32_t, struct ssh *);\nint\tinput_userauth_error(int, u_int32_t, struct ssh *);\nint\tinput_userauth_info_req(int, u_int32_t, struct ssh *);\nint\tinput_userauth_pk_ok(int, u_int32_t, struct ssh *);\nint\tinput_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\nint\tuserauth_none(Authctxt *);\nint\tuserauth_pubkey(Authctxt *);\nint\tuserauth_passwd(Authctxt *);\nint\tuserauth_kbdint(Authctxt *);\nint\tuserauth_hostbased(Authctxt *);\nvoid\tuserauth(Authctxt *, char *);\nstatic void pubkey_prepare(Authctxt *);\nstatic void pubkey_cleanup(Authctxt *);\nstatic void pubkey_reset(Authctxt *);\n\nint\ninput_userauth_service_accept(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tint r;\n\n\tif (ssh_packet_remaining(ssh) > 0) {\n\t\tchar *reply;\n\n\t\tif ((r = sshpkt_get_cstring(ssh, &reply, NULL)) != 0)\n\t\t\tgoto out;\n\t\tdebug2(\"service_accept: %s\", reply);\n\t\tfree(reply);\n\t} else {\n\t\tdebug2(\"buggy server: service_accept w/o service\");\n\t}\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto out;\n\tdebug(\"SSH2_MSG_SERVICE_ACCEPT received\");\n\n\t/* initial userauth request */\n\tuserauth_none(authctxt);\n\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &input_userauth_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_SUCCESS, &input_userauth_success);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_FAILURE, &input_userauth_failure);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_BANNER, &input_userauth_banner);\n\tr = 0;\n out:\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recvfrom",
          "args": [
            "s",
            "buf",
            "plen",
            "MSG_PEEK",
            "(struct sockaddr *)&z",
            "&len"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_listen",
          "args": [
            "host",
            "uport",
            "hints"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "local_listen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "707-766",
          "snippet": "int\nlocal_listen(char *host, char *port, struct addrinfo hints)\n{\n\tstruct addrinfo *res, *res0;\n\tint s, ret, x = 1;\n\tint error;\n\n\t/* Allow nodename to be null. */\n\thints.ai_flags |= AI_PASSIVE;\n\n\t/*\n\t * In the case of binding to a wildcard address\n\t * default to binding to an ipv4 address.\n\t */\n\tif (host == NULL && hints.ai_family == AF_UNSPEC)\n\t\thints.ai_family = AF_INET;\n\n\tif ((error = getaddrinfo(host, port, &hints, &res)))\n\t\terrx(1, \"getaddrinfo: %s\", gai_strerror(error));\n\n\tres0 = res;\n\tdo {\n\t\tif ((s = socket(res0->ai_family, res0->ai_socktype,\n\t\t    res0->ai_protocol)) < 0)\n\t\t\tcontinue;\n\n#ifdef SO_RTABLE\n\t\tif (rtableid >= 0 && (setsockopt(s, SOL_SOCKET, SO_RTABLE,\n\t\t    &rtableid, sizeof(rtableid)) == -1))\n\t\t\terr(1, \"setsockopt SO_RTABLE\");\n#endif\n#ifdef SO_REUSEPORT\n\t\tret = setsockopt(s, SOL_SOCKET, SO_REUSEPORT, &x, sizeof(x));\n\t\tif (ret == -1)\n\t\t\terr(1, \"setsockopt SO_REUSEPORT\");\n#endif\n#ifdef SO_REUSEADDR\n\t\tret = setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &x, sizeof(x));\n\t\tif (ret == -1)\n\t\t\terr(1, \"setsockopt SO_REUSEADDR\");\n#endif\n\t\tset_common_sockopts(s);\n\n\t\tif (bind(s, (struct sockaddr *)res0->ai_addr,\n\t\t    res0->ai_addrlen) == 0)\n\t\t\tbreak;\n\n\t\tclose(s);\n\t\ts = -1;\n\t} while ((res0 = res0->ai_next) != NULL);\n\n\tif (!uflag && s != -1) {\n\t\tif (listen(s, 1) < 0)\n\t\t\terr(1, \"listen\");\n\t}\n\n\tfreeaddrinfo(res);\n\n\treturn (s);\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tuflag;",
            "int\trtableid = -1;",
            "int\tlocal_listen(char *, char *, struct addrinfo);",
            "int\tremote_connect(const char *, const char *, struct addrinfo);",
            "int\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int, const char *);",
            "void\tset_common_sockopts(int);",
            "int\tremote_connect(const char *, const char *, struct addrinfo);",
            "int\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int,\n\t    const char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tuflag;\nint\trtableid = -1;\nint\tlocal_listen(char *, char *, struct addrinfo);\nint\tremote_connect(const char *, const char *, struct addrinfo);\nint\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int, const char *);\nvoid\tset_common_sockopts(int);\nint\tremote_connect(const char *, const char *, struct addrinfo);\nint\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int,\n\t    const char *);\n\nint\nlocal_listen(char *host, char *port, struct addrinfo hints)\n{\n\tstruct addrinfo *res, *res0;\n\tint s, ret, x = 1;\n\tint error;\n\n\t/* Allow nodename to be null. */\n\thints.ai_flags |= AI_PASSIVE;\n\n\t/*\n\t * In the case of binding to a wildcard address\n\t * default to binding to an ipv4 address.\n\t */\n\tif (host == NULL && hints.ai_family == AF_UNSPEC)\n\t\thints.ai_family = AF_INET;\n\n\tif ((error = getaddrinfo(host, port, &hints, &res)))\n\t\terrx(1, \"getaddrinfo: %s\", gai_strerror(error));\n\n\tres0 = res;\n\tdo {\n\t\tif ((s = socket(res0->ai_family, res0->ai_socktype,\n\t\t    res0->ai_protocol)) < 0)\n\t\t\tcontinue;\n\n#ifdef SO_RTABLE\n\t\tif (rtableid >= 0 && (setsockopt(s, SOL_SOCKET, SO_RTABLE,\n\t\t    &rtableid, sizeof(rtableid)) == -1))\n\t\t\terr(1, \"setsockopt SO_RTABLE\");\n#endif\n#ifdef SO_REUSEPORT\n\t\tret = setsockopt(s, SOL_SOCKET, SO_REUSEPORT, &x, sizeof(x));\n\t\tif (ret == -1)\n\t\t\terr(1, \"setsockopt SO_REUSEPORT\");\n#endif\n#ifdef SO_REUSEADDR\n\t\tret = setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &x, sizeof(x));\n\t\tif (ret == -1)\n\t\t\terr(1, \"setsockopt SO_REUSEADDR\");\n#endif\n\t\tset_common_sockopts(s);\n\n\t\tif (bind(s, (struct sockaddr *)res0->ai_addr,\n\t\t    res0->ai_addrlen) == 0)\n\t\t\tbreak;\n\n\t\tclose(s);\n\t\ts = -1;\n\t} while ((res0 = res0->ai_next) != NULL);\n\n\tif (!uflag && s != -1) {\n\t\tif (listen(s, 1) < 0)\n\t\t\terr(1, \"listen\");\n\t}\n\n\tfreeaddrinfo(res);\n\n\treturn (s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unix_listen",
          "args": [
            "host"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "unix_listen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "584-596",
          "snippet": "int\nunix_listen(char *path)\n{\n\tint s;\n\tif ((s = unix_bind(path)) < 0)\n\t\treturn (-1);\n\n\tif (listen(s, 5) < 0) {\n\t\tclose(s);\n\t\treturn (-1);\n\t}\n\treturn (s);\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tunix_bind(char *);",
            "int\tunix_listen(char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tunix_bind(char *);\nint\tunix_listen(char *);\n\nint\nunix_listen(char *path)\n{\n\tint s;\n\tif ((s = unix_bind(path)) < 0)\n\t\treturn (-1);\n\n\tif (listen(s, 5) < 0) {\n\t\tclose(s);\n\t\treturn (-1);\n\t}\n\treturn (s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unix_bind",
          "args": [
            "host"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "unix_bind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "516-542",
          "snippet": "int\nunix_bind(char *path)\n{\n\tstruct sockaddr_un sun_sa;\n\tint s;\n\n\t/* Create unix domain socket. */\n\tif ((s = socket(AF_UNIX, uflag ? SOCK_DGRAM : SOCK_STREAM,\n\t     0)) < 0)\n\t\treturn (-1);\n\n\tmemset(&sun_sa, 0, sizeof(struct sockaddr_un));\n\tsun_sa.sun_family = AF_UNIX;\n\n\tif (strlcpy(sun_sa.sun_path, path, sizeof(sun_sa.sun_path)) >=\n\t    sizeof(sun_sa.sun_path)) {\n\t\tclose(s);\n\t\terrno = ENAMETOOLONG;\n\t\treturn (-1);\n\t}\n\n\tif (bind(s, (struct sockaddr *)&sun_sa, SUN_LEN(&sun_sa)) < 0) {\n\t\tclose(s);\n\t\treturn (-1);\n\t}\n\treturn (s);\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tuflag;",
            "int\tunix_bind(char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tuflag;\nint\tunix_bind(char *);\n\nint\nunix_bind(char *path)\n{\n\tstruct sockaddr_un sun_sa;\n\tint s;\n\n\t/* Create unix domain socket. */\n\tif ((s = socket(AF_UNIX, uflag ? SOCK_DGRAM : SOCK_STREAM,\n\t     0)) < 0)\n\t\treturn (-1);\n\n\tmemset(&sun_sa, 0, sizeof(struct sockaddr_un));\n\tsun_sa.sun_family = AF_UNIX;\n\n\tif (strlcpy(sun_sa.sun_path, path, sizeof(sun_sa.sun_path)) >=\n\t    sizeof(sun_sa.sun_path)) {\n\t\tclose(s);\n\t\terrno = ENAMETOOLONG;\n\t\treturn (-1);\n\t}\n\n\tif (bind(s, (struct sockaddr *)&sun_sa, SUN_LEN(&sun_sa)) < 0) {\n\t\tclose(s);\n\t\treturn (-1);\n\t}\n\treturn (s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&proxyhints",
            "0",
            "sizeof(struct addrinfo)"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&proxy",
            "\":\""
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "xstrsep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/ssh-keyscan.c",
          "lines": "162-178",
          "snippet": "static char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}",
          "includes": [
            "#include \"dns.h\"",
            "#include \"ssh_api.h\"",
            "#include \"ssherr.h\"",
            "#include \"hostfile.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"dispatch.h\"",
            "#include \"packet.h\"",
            "#include \"myproposal.h\"",
            "#include \"compat.h\"",
            "#include \"kex.h\"",
            "#include \"cipher.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include <netdb.h>",
            "#include <openssl/bn.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "# include <sys/time.h>",
            "#include <sys/resource.h>",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns.h\"\n#include \"ssh_api.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"dispatch.h\"\n#include \"packet.h\"\n#include \"myproposal.h\"\n#include \"compat.h\"\n#include \"kex.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <unistd.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <netdb.h>\n#include <openssl/bn.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n# include <sys/time.h>\n#include <sys/resource.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errx",
          "args": [
            "1",
            "\"no proxy support for local source address\""
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "errx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-err.c",
          "lines": "52-62",
          "snippet": "void\nerrx(int r, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(r);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"includes.h\"\n\nvoid\nerrx(int r, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hints",
            "0",
            "sizeof(struct addrinfo)"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mktemp",
          "args": [
            "unix_dg_tmp_socket_buf"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "mktemp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/mktemp.c",
          "lines": "113-117",
          "snippet": "char *\nmktemp(char *path)\n{\n\treturn(_mktemp(path));\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nchar *\nmktemp(char *path)\n{\n\treturn(_mktemp(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "unix_dg_tmp_socket_buf",
            "\"/tmp/nc.XXXXXXXXXX\"",
            "UNIX_DG_TMP_SOCKET_SIZE"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [
            "1"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "1312-1322",
          "snippet": "void\nusage(int ret)\n{\n\tfprintf(stderr,\n\t    \"usage: nc [-46DdFhklNnrStUuvz] [-I length] [-i interval] [-O length]\\n\"\n\t    \"\\t  [-P proxy_username] [-p source_port] [-s source] [-T ToS]\\n\"\n\t    \"\\t  [-V rtable] [-w timeout] [-X proxy_protocol]\\n\"\n\t    \"\\t  [-x proxy_address[:port]] [destination] [port]\\n\");\n\tif (ret)\n\t\texit(1);\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int timeout = -1;",
            "void\tusage(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint timeout = -1;\nvoid\tusage(int);\n\nvoid\nusage(int ret)\n{\n\tfprintf(stderr,\n\t    \"usage: nc [-46DdFhklNnrStUuvz] [-I length] [-i interval] [-O length]\\n\"\n\t    \"\\t  [-P proxy_username] [-p source_port] [-s source] [-T ToS]\\n\"\n\t    \"\\t  [-V rtable] [-w timeout] [-X proxy_protocol]\\n\"\n\t    \"\\t  [-x proxy_address[:port]] [destination] [port]\\n\");\n\tif (ret)\n\t\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtonum",
          "args": [
            "optarg",
            "0",
            "255",
            "&errstr"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "strtonum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strtonum.c",
          "lines": "33-70",
          "snippet": "long long\nstrtonum(const char *numstr, long long minval, long long maxval,\n    const char **errstrp)\n{\n\tlong long ll = 0;\n\tchar *ep;\n\tint error = 0;\n\tstruct errval {\n\t\tconst char *errstr;\n\t\tint err;\n\t} ev[4] = {\n\t\t{ NULL,\t\t0 },\n\t\t{ \"invalid\",\tEINVAL },\n\t\t{ \"too small\",\tERANGE },\n\t\t{ \"too large\",\tERANGE },\n\t};\n\n\tev[0].err = errno;\n\terrno = 0;\n\tif (minval > maxval)\n\t\terror = INVALID;\n\telse {\n\t\tll = strtoll(numstr, &ep, 10);\n\t\tif (numstr == ep || *ep != '\\0')\n\t\t\terror = INVALID;\n\t\telse if ((ll == LLONG_MIN && errno == ERANGE) || ll < minval)\n\t\t\terror = TOOSMALL;\n\t\telse if ((ll == LLONG_MAX && errno == ERANGE) || ll > maxval)\n\t\t\terror = TOOLARGE;\n\t}\n\tif (errstrp != NULL)\n\t\t*errstrp = ev[error].errstr;\n\terrno = ev[error].err;\n\tif (error)\n\t\tll = 0;\n\n\treturn (ll);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <stdlib.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define TOOLARGE \t3",
            "#define TOOSMALL \t2",
            "#define INVALID \t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n#include \"includes.h\"\n\n#define TOOLARGE \t3\n#define TOOSMALL \t2\n#define INVALID \t1\n\nlong long\nstrtonum(const char *numstr, long long minval, long long maxval,\n    const char **errstrp)\n{\n\tlong long ll = 0;\n\tchar *ep;\n\tint error = 0;\n\tstruct errval {\n\t\tconst char *errstr;\n\t\tint err;\n\t} ev[4] = {\n\t\t{ NULL,\t\t0 },\n\t\t{ \"invalid\",\tEINVAL },\n\t\t{ \"too small\",\tERANGE },\n\t\t{ \"too large\",\tERANGE },\n\t};\n\n\tev[0].err = errno;\n\terrno = 0;\n\tif (minval > maxval)\n\t\terror = INVALID;\n\telse {\n\t\tll = strtoll(numstr, &ep, 10);\n\t\tif (numstr == ep || *ep != '\\0')\n\t\t\terror = INVALID;\n\t\telse if ((ll == LLONG_MIN && errno == ERANGE) || ll < minval)\n\t\t\terror = TOOSMALL;\n\t\telse if ((ll == LLONG_MAX && errno == ERANGE) || ll > maxval)\n\t\t\terror = TOOLARGE;\n\t}\n\tif (errstrp != NULL)\n\t\t*errstrp = ev[error].errstr;\n\terrno = ev[error].err;\n\tif (error)\n\t\tll = 0;\n\n\treturn (ll);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "optarg",
            "NULL",
            "16"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "strtoll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strtoll.c",
          "lines": "49-147",
          "snippet": "long long\nstrtoll(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\tlong long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * Skip white space and pick up leading +/- sign if any.\n\t * If base is 0, allow 0x for hex and 0 for octal, else\n\t * assume decimal; if base is already 16, allow 0x.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else {\n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\t/*\n\t * Compute the cutoff value between legal numbers and illegal\n\t * numbers.  That is the largest legal value, divided by the\n\t * base.  An input number that is greater than this value, if\n\t * followed by a legal input character, is too big.  One that\n\t * is equal to this value may be valid or not; the limit\n\t * between valid and invalid numbers is then based on the last\n\t * digit.  For instance, if the range for long longs is\n\t * [-9223372036854775808..9223372036854775807] and the input base\n\t * is 10, cutoff will be set to 922337203685477580 and cutlim to\n\t * either 7 (neg==0) or 8 (neg==1), meaning that if we have\n\t * accumulated a value > 922337203685477580, or equal but the\n\t * next digit is > 7 (or 8), the number is too big, and we will\n\t * return a range error.\n\t *\n\t * Set any if any `digits' consumed; make it negative to indicate\n\t * overflow.\n\t */\n\tcutoff = neg ? LLONG_MIN : LLONG_MAX;\n\tcutlim = cutoff % base;\n\tcutoff /= base;\n\tif (neg) {\n\t\tif (cutlim > 0) {\n\t\t\tcutlim -= base;\n\t\t\tcutoff += 1;\n\t\t}\n\t\tcutlim = -cutlim;\n\t}\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (neg) {\n\t\t\tif (acc < cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MIN;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc -= c;\n\t\t\t}\n\t\t} else {\n\t\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MAX;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc += c;\n\t\t\t}\n\t\t}\n\t}\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nlong long\nstrtoll(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\tlong long acc, cutoff;\n\tint c;\n\tint neg, any, cutlim;\n\n\t/*\n\t * Skip white space and pick up leading +/- sign if any.\n\t * If base is 0, allow 0x for hex and 0 for octal, else\n\t * assume decimal; if base is already 16, allow 0x.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = (unsigned char) *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else {\n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X')) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t}\n\tif (base == 0)\n\t\tbase = c == '0' ? 8 : 10;\n\n\t/*\n\t * Compute the cutoff value between legal numbers and illegal\n\t * numbers.  That is the largest legal value, divided by the\n\t * base.  An input number that is greater than this value, if\n\t * followed by a legal input character, is too big.  One that\n\t * is equal to this value may be valid or not; the limit\n\t * between valid and invalid numbers is then based on the last\n\t * digit.  For instance, if the range for long longs is\n\t * [-9223372036854775808..9223372036854775807] and the input base\n\t * is 10, cutoff will be set to 922337203685477580 and cutlim to\n\t * either 7 (neg==0) or 8 (neg==1), meaning that if we have\n\t * accumulated a value > 922337203685477580, or equal but the\n\t * next digit is > 7 (or 8), the number is too big, and we will\n\t * return a range error.\n\t *\n\t * Set any if any `digits' consumed; make it negative to indicate\n\t * overflow.\n\t */\n\tcutoff = neg ? LLONG_MIN : LLONG_MAX;\n\tcutlim = cutoff % base;\n\tcutoff /= base;\n\tif (neg) {\n\t\tif (cutlim > 0) {\n\t\t\tcutlim -= base;\n\t\t\tcutoff += 1;\n\t\t}\n\t\tcutlim = -cutlim;\n\t}\n\tfor (acc = 0, any = 0;; c = (unsigned char) *s++) {\n\t\tif (isdigit(c))\n\t\t\tc -= '0';\n\t\telse if (isalpha(c))\n\t\t\tc -= isupper(c) ? 'A' - 10 : 'a' - 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (c >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (neg) {\n\t\t\tif (acc < cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MIN;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc -= c;\n\t\t\t}\n\t\t} else {\n\t\t\tif (acc > cutoff || (acc == cutoff && c > cutlim)) {\n\t\t\t\tany = -1;\n\t\t\t\tacc = LLONG_MAX;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc += c;\n\t\t\t}\n\t\t}\n\t}\n\tif (endptr != 0)\n\t\t*endptr = (char *) (any ? s - 1 : nptr);\n\treturn (acc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "optarg"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_tos",
          "args": [
            "optarg",
            "&Tflag"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "map_tos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "1201-1247",
          "snippet": "int\nmap_tos(char *s, int *val)\n{\n\t/* DiffServ Codepoints and other TOS mappings */\n\tconst struct toskeywords {\n\t\tconst char\t*keyword;\n\t\tint\t\t val;\n\t} *t, toskeywords[] = {\n\t\t{ \"af11\",\t\tIPTOS_DSCP_AF11 },\n\t\t{ \"af12\",\t\tIPTOS_DSCP_AF12 },\n\t\t{ \"af13\",\t\tIPTOS_DSCP_AF13 },\n\t\t{ \"af21\",\t\tIPTOS_DSCP_AF21 },\n\t\t{ \"af22\",\t\tIPTOS_DSCP_AF22 },\n\t\t{ \"af23\",\t\tIPTOS_DSCP_AF23 },\n\t\t{ \"af31\",\t\tIPTOS_DSCP_AF31 },\n\t\t{ \"af32\",\t\tIPTOS_DSCP_AF32 },\n\t\t{ \"af33\",\t\tIPTOS_DSCP_AF33 },\n\t\t{ \"af41\",\t\tIPTOS_DSCP_AF41 },\n\t\t{ \"af42\",\t\tIPTOS_DSCP_AF42 },\n\t\t{ \"af43\",\t\tIPTOS_DSCP_AF43 },\n\t\t{ \"critical\",\t\tIPTOS_PREC_CRITIC_ECP },\n\t\t{ \"cs0\",\t\tIPTOS_DSCP_CS0 },\n\t\t{ \"cs1\",\t\tIPTOS_DSCP_CS1 },\n\t\t{ \"cs2\",\t\tIPTOS_DSCP_CS2 },\n\t\t{ \"cs3\",\t\tIPTOS_DSCP_CS3 },\n\t\t{ \"cs4\",\t\tIPTOS_DSCP_CS4 },\n\t\t{ \"cs5\",\t\tIPTOS_DSCP_CS5 },\n\t\t{ \"cs6\",\t\tIPTOS_DSCP_CS6 },\n\t\t{ \"cs7\",\t\tIPTOS_DSCP_CS7 },\n\t\t{ \"ef\",\t\t\tIPTOS_DSCP_EF },\n\t\t{ \"inetcontrol\",\tIPTOS_PREC_INTERNETCONTROL },\n\t\t{ \"lowdelay\",\t\tIPTOS_LOWDELAY },\n\t\t{ \"netcontrol\",\t\tIPTOS_PREC_NETCONTROL },\n\t\t{ \"reliability\",\tIPTOS_RELIABILITY },\n\t\t{ \"throughput\",\t\tIPTOS_THROUGHPUT },\n\t\t{ NULL, \t\t-1 },\n\t};\n\n\tfor (t = toskeywords; t->keyword != NULL; t++) {\n\t\tif (strcmp(s, t->keyword) == 0) {\n\t\t\t*val = t->val;\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tmap_tos(char *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\tmap_tos(char *, int *);\n\nint\nmap_tos(char *s, int *val)\n{\n\t/* DiffServ Codepoints and other TOS mappings */\n\tconst struct toskeywords {\n\t\tconst char\t*keyword;\n\t\tint\t\t val;\n\t} *t, toskeywords[] = {\n\t\t{ \"af11\",\t\tIPTOS_DSCP_AF11 },\n\t\t{ \"af12\",\t\tIPTOS_DSCP_AF12 },\n\t\t{ \"af13\",\t\tIPTOS_DSCP_AF13 },\n\t\t{ \"af21\",\t\tIPTOS_DSCP_AF21 },\n\t\t{ \"af22\",\t\tIPTOS_DSCP_AF22 },\n\t\t{ \"af23\",\t\tIPTOS_DSCP_AF23 },\n\t\t{ \"af31\",\t\tIPTOS_DSCP_AF31 },\n\t\t{ \"af32\",\t\tIPTOS_DSCP_AF32 },\n\t\t{ \"af33\",\t\tIPTOS_DSCP_AF33 },\n\t\t{ \"af41\",\t\tIPTOS_DSCP_AF41 },\n\t\t{ \"af42\",\t\tIPTOS_DSCP_AF42 },\n\t\t{ \"af43\",\t\tIPTOS_DSCP_AF43 },\n\t\t{ \"critical\",\t\tIPTOS_PREC_CRITIC_ECP },\n\t\t{ \"cs0\",\t\tIPTOS_DSCP_CS0 },\n\t\t{ \"cs1\",\t\tIPTOS_DSCP_CS1 },\n\t\t{ \"cs2\",\t\tIPTOS_DSCP_CS2 },\n\t\t{ \"cs3\",\t\tIPTOS_DSCP_CS3 },\n\t\t{ \"cs4\",\t\tIPTOS_DSCP_CS4 },\n\t\t{ \"cs5\",\t\tIPTOS_DSCP_CS5 },\n\t\t{ \"cs6\",\t\tIPTOS_DSCP_CS6 },\n\t\t{ \"cs7\",\t\tIPTOS_DSCP_CS7 },\n\t\t{ \"ef\",\t\t\tIPTOS_DSCP_EF },\n\t\t{ \"inetcontrol\",\tIPTOS_PREC_INTERNETCONTROL },\n\t\t{ \"lowdelay\",\t\tIPTOS_LOWDELAY },\n\t\t{ \"netcontrol\",\t\tIPTOS_PREC_NETCONTROL },\n\t\t{ \"reliability\",\tIPTOS_RELIABILITY },\n\t\t{ \"throughput\",\t\tIPTOS_THROUGHPUT },\n\t\t{ NULL, \t\t-1 },\n\t};\n\n\tfor (t = toskeywords; t->keyword != NULL; t++) {\n\t\tif (strcmp(s, t->keyword) == 0) {\n\t\t\t*val = t->val;\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "optarg"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "xstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/xmalloc.c",
          "lines": "92-102",
          "snippet": "char *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}",
          "includes": [
            "#include \"log.h\"",
            "#include \"xmalloc.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include \"xmalloc.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include \"includes.h\"\n\nchar *\nxstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = xmalloc(len);\n\tstrlcpy(cp, str, len);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "help",
          "args": [],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "help",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/regress/netcat.c",
          "lines": "1275-1310",
          "snippet": "void\nhelp(void)\n{\n\tusage(0);\n\tfprintf(stderr, \"\\tCommand Summary:\\n\\\n\t\\t-4\t\tUse IPv4\\n\\\n\t\\t-6\t\tUse IPv6\\n\\\n\t\\t-D\t\tEnable the debug socket option\\n\\\n\t\\t-d\t\tDetach from stdin\\n\\\n\t\\t-F\t\tPass socket fd\\n\\\n\t\\t-h\t\tThis help text\\n\\\n\t\\t-I length\tTCP receive buffer length\\n\\\n\t\\t-i secs\\t\tDelay interval for lines sent, ports scanned\\n\\\n\t\\t-k\t\tKeep inbound sockets open for multiple connects\\n\\\n\t\\t-l\t\tListen mode, for inbound connects\\n\\\n\t\\t-N\t\tShutdown the network socket after EOF on stdin\\n\\\n\t\\t-n\t\tSuppress name/port resolutions\\n\\\n\t\\t-O length\tTCP send buffer length\\n\\\n\t\\t-P proxyuser\\tUsername for proxy authentication\\n\\\n\t\\t-p port\\t\tSpecify local port for remote connects\\n\\\n\t\\t-r\t\tRandomize remote ports\\n\\\n\t\\t-S\t\tEnable the TCP MD5 signature option\\n\\\n\t\\t-s addr\\t\tLocal source address\\n\\\n\t\\t-T toskeyword\\tSet IP Type of Service\\n\\\n\t\\t-t\t\tAnswer TELNET negotiation\\n\\\n\t\\t-U\t\tUse UNIX domain socket\\n\\\n\t\\t-u\t\tUDP mode\\n\\\n\t\\t-V rtable\tSpecify alternate routing table\\n\\\n\t\\t-v\t\tVerbose\\n\\\n\t\\t-w secs\\t\tTimeout for connects and final net reads\\n\\\n\t\\t-X proto\tProxy protocol: \\\"4\\\", \\\"5\\\" (SOCKS) or \\\"connect\\\"\\n\\\n\t\\t-x addr[:port]\\tSpecify proxy address and port\\n\\\n\t\\t-z\t\tZero-I/O mode [used for scanning]\\n\\\n\tPort numbers can be individual or ranges: lo-hi [inclusive]\\n\");\n\texit(1);\n}",
          "includes": [
            "#include <resolv.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "# include <err.h>",
            "#  include <sys/poll.h>",
            "#include <poll.h>",
            "#include \"atomicio.h\"",
            "#include <limits.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/uio.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\thelp(void);",
            "void\tusage(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\thelp(void);\nvoid\tusage(int);\n\nvoid\nhelp(void)\n{\n\tusage(0);\n\tfprintf(stderr, \"\\tCommand Summary:\\n\\\n\t\\t-4\t\tUse IPv4\\n\\\n\t\\t-6\t\tUse IPv6\\n\\\n\t\\t-D\t\tEnable the debug socket option\\n\\\n\t\\t-d\t\tDetach from stdin\\n\\\n\t\\t-F\t\tPass socket fd\\n\\\n\t\\t-h\t\tThis help text\\n\\\n\t\\t-I length\tTCP receive buffer length\\n\\\n\t\\t-i secs\\t\tDelay interval for lines sent, ports scanned\\n\\\n\t\\t-k\t\tKeep inbound sockets open for multiple connects\\n\\\n\t\\t-l\t\tListen mode, for inbound connects\\n\\\n\t\\t-N\t\tShutdown the network socket after EOF on stdin\\n\\\n\t\\t-n\t\tSuppress name/port resolutions\\n\\\n\t\\t-O length\tTCP send buffer length\\n\\\n\t\\t-P proxyuser\\tUsername for proxy authentication\\n\\\n\t\\t-p port\\t\tSpecify local port for remote connects\\n\\\n\t\\t-r\t\tRandomize remote ports\\n\\\n\t\\t-S\t\tEnable the TCP MD5 signature option\\n\\\n\t\\t-s addr\\t\tLocal source address\\n\\\n\t\\t-T toskeyword\\tSet IP Type of Service\\n\\\n\t\\t-t\t\tAnswer TELNET negotiation\\n\\\n\t\\t-U\t\tUse UNIX domain socket\\n\\\n\t\\t-u\t\tUDP mode\\n\\\n\t\\t-V rtable\tSpecify alternate routing table\\n\\\n\t\\t-v\t\tVerbose\\n\\\n\t\\t-w secs\\t\tTimeout for connects and final net reads\\n\\\n\t\\t-X proto\tProxy protocol: \\\"4\\\", \\\"5\\\" (SOCKS) or \\\"connect\\\"\\n\\\n\t\\t-x addr[:port]\\tSpecify proxy address and port\\n\\\n\t\\t-z\t\tZero-I/O mode [used for scanning]\\n\\\n\tPort numbers can be individual or ranges: lo-hi [inclusive]\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "optarg",
            "\"5\""
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "optarg",
            "\"connect\""
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getopt",
          "args": [
            "argc",
            "argv",
            "\"46DdFhI:i:klNnO:P:p:rSs:tT:UuV:vw:X:x:z\""
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "getopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/getopt_long.c",
          "lines": "489-502",
          "snippet": "int\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}",
          "includes": [
            "#include \"log.h\"",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <getopt.h>",
            "#include <err.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n#include <stdarg.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <getopt.h>\n#include <err.h>\n#include \"includes.h\"\n\n#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */\n\nint\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <resolv.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n# include <err.h>\n#  include <sys/poll.h>\n#include <poll.h>\n#include \"atomicio.h\"\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/uio.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define UNIX_DG_TMP_SOCKET_SIZE\t19\n\nint\tdflag;\nint\tFflag;\nunsigned int iflag;\nint\tkflag;\nint\tlflag;\nint\tNflag;\nint\tnflag;\nchar   *Pflag;\nchar   *pflag;\nint\trflag;\nchar   *sflag;\nint\ttflag;\nint\tuflag;\nint\tvflag;\nint\txflag;\nint\tzflag;\nint\tDflag;\nint\tIflag;\nint\tOflag;\nint\tSflag;\nint\tTflag = -1;\nint\trtableid = -1;\nint timeout = -1;\nint family = AF_UNSPEC;\nchar *portlist[PORT_MAX+1];\nchar *unix_dg_tmp_socket;\nvoid\tbuild_ports(char *);\nvoid\thelp(void);\nint\tlocal_listen(char *, char *, struct addrinfo);\nvoid\treadwrite(int);\nint\tremote_connect(const char *, const char *, struct addrinfo);\nint\ttimeout_connect(int, const struct sockaddr *, socklen_t);\nint\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int, const char *);\nint\tudptest(int);\nint\tunix_bind(char *);\nint\tunix_connect(char *);\nint\tunix_listen(char *);\nint\tmap_tos(char *, int *);\nvoid\treport_connect(const struct sockaddr *, socklen_t);\nvoid\tusage(int);\nint\tremote_connect(const char *, const char *, struct addrinfo);\nint\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int,\n\t    const char *);\n\nint\nmain(int argc, char *argv[])\n{\n\tint ch, s, ret, socksv;\n\tchar *host, *uport;\n\tstruct addrinfo hints;\n\tstruct servent *sv;\n\tsocklen_t len;\n\tstruct sockaddr_storage cliaddr;\n\tchar *proxy = NULL;\n\tconst char *errstr, *proxyhost = \"\", *proxyport = NULL;\n\tstruct addrinfo proxyhints;\n\tchar unix_dg_tmp_socket_buf[UNIX_DG_TMP_SOCKET_SIZE];\n\n\tret = 1;\n\ts = 0;\n\tsocksv = 5;\n\thost = NULL;\n\tuport = NULL;\n\tsv = NULL;\n\n\twhile ((ch = getopt(argc, argv,\n\t    \"46DdFhI:i:klNnO:P:p:rSs:tT:UuV:vw:X:x:z\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase '4':\n\t\t\tfamily = AF_INET;\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tfamily = AF_INET6;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tfamily = AF_UNIX;\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\tif (strcasecmp(optarg, \"connect\") == 0)\n\t\t\t\tsocksv = -1; /* HTTP proxy CONNECT */\n\t\t\telse if (strcmp(optarg, \"4\") == 0)\n\t\t\t\tsocksv = 4; /* SOCKS v.4 */\n\t\t\telse if (strcmp(optarg, \"5\") == 0)\n\t\t\t\tsocksv = 5; /* SOCKS v.5 */\n\t\t\telse\n\t\t\t\terrx(1, \"unsupported proxy protocol\");\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdflag = 1;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tFflag = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\thelp();\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tiflag = strtonum(optarg, 0, UINT_MAX, &errstr);\n\t\t\tif (errstr)\n\t\t\t\terrx(1, \"interval %s: %s\", errstr, optarg);\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tkflag = 1;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlflag = 1;\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tNflag = 1;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnflag = 1;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tPflag = optarg;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpflag = optarg;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trflag = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsflag = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttflag = 1;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tuflag = 1;\n\t\t\tbreak;\n#ifdef SO_RTABLE\n\t\tcase 'V':\n\t\t\trtableid = (int)strtonum(optarg, 0,\n\t\t\t    RT_TABLEID_MAX, &errstr);\n\t\t\tif (errstr)\n\t\t\t\terrx(1, \"rtable %s: %s\", errstr, optarg);\n\t\t\tbreak;\n#endif\n\t\tcase 'v':\n\t\t\tvflag = 1;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\ttimeout = strtonum(optarg, 0, INT_MAX / 1000, &errstr);\n\t\t\tif (errstr)\n\t\t\t\terrx(1, \"timeout %s: %s\", errstr, optarg);\n\t\t\ttimeout *= 1000;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\txflag = 1;\n\t\t\tif ((proxy = strdup(optarg)) == NULL)\n\t\t\t\terrx(1, \"strdup\");\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\tzflag = 1;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tDflag = 1;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tIflag = strtonum(optarg, 1, 65536 << 14, &errstr);\n\t\t\tif (errstr != NULL)\n\t\t\t\terrx(1, \"TCP receive window %s: %s\",\n\t\t\t\t    errstr, optarg);\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tOflag = strtonum(optarg, 1, 65536 << 14, &errstr);\n\t\t\tif (errstr != NULL)\n\t\t\t\terrx(1, \"TCP send window %s: %s\",\n\t\t\t\t    errstr, optarg);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tSflag = 1;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\terrstr = NULL;\n\t\t\terrno = 0;\n\t\t\tif (map_tos(optarg, &Tflag))\n\t\t\t\tbreak;\n\t\t\tif (strlen(optarg) > 1 && optarg[0] == '0' &&\n\t\t\t    optarg[1] == 'x')\n\t\t\t\tTflag = (int)strtol(optarg, NULL, 16);\n\t\t\telse\n\t\t\t\tTflag = (int)strtonum(optarg, 0, 255,\n\t\t\t\t    &errstr);\n\t\t\tif (Tflag < 0 || Tflag > 255 || errstr || errno)\n\t\t\t\terrx(1, \"illegal tos value %s\", optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(1);\n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\n\t/* Cruft to make sure options are clean, and used properly. */\n\tif (argv[0] && !argv[1] && family == AF_UNIX) {\n\t\thost = argv[0];\n\t\tuport = NULL;\n\t} else if (argv[0] && !argv[1]) {\n\t\tif  (!lflag)\n\t\t\tusage(1);\n\t\tuport = argv[0];\n\t\thost = NULL;\n\t} else if (argv[0] && argv[1]) {\n\t\thost = argv[0];\n\t\tuport = argv[1];\n\t} else\n\t\tusage(1);\n\n\tif (lflag && sflag)\n\t\terrx(1, \"cannot use -s and -l\");\n\tif (lflag && pflag)\n\t\terrx(1, \"cannot use -p and -l\");\n\tif (lflag && zflag)\n\t\terrx(1, \"cannot use -z and -l\");\n\tif (!lflag && kflag)\n\t\terrx(1, \"must use -l with -k\");\n\n\t/* Get name of temporary socket for unix datagram client */\n\tif ((family == AF_UNIX) && uflag && !lflag) {\n\t\tif (sflag) {\n\t\t\tunix_dg_tmp_socket = sflag;\n\t\t} else {\n\t\t\tstrlcpy(unix_dg_tmp_socket_buf, \"/tmp/nc.XXXXXXXXXX\",\n\t\t\t\tUNIX_DG_TMP_SOCKET_SIZE);\n\t\t\tif (mktemp(unix_dg_tmp_socket_buf) == NULL)\n\t\t\t\terr(1, \"mktemp\");\n\t\t\tunix_dg_tmp_socket = unix_dg_tmp_socket_buf;\n\t\t}\n\t}\n\n\t/* Initialize addrinfo structure. */\n\tif (family != AF_UNIX) {\n\t\tmemset(&hints, 0, sizeof(struct addrinfo));\n\t\thints.ai_family = family;\n\t\thints.ai_socktype = uflag ? SOCK_DGRAM : SOCK_STREAM;\n\t\thints.ai_protocol = uflag ? IPPROTO_UDP : IPPROTO_TCP;\n\t\tif (nflag)\n\t\t\thints.ai_flags |= AI_NUMERICHOST;\n\t}\n\n\tif (xflag) {\n\t\tif (uflag)\n\t\t\terrx(1, \"no proxy support for UDP mode\");\n\n\t\tif (lflag)\n\t\t\terrx(1, \"no proxy support for listen\");\n\n\t\tif (family == AF_UNIX)\n\t\t\terrx(1, \"no proxy support for unix sockets\");\n\n\t\t/* XXX IPv6 transport to proxy would probably work */\n\t\tif (family == AF_INET6)\n\t\t\terrx(1, \"no proxy support for IPv6\");\n\n\t\tif (sflag)\n\t\t\terrx(1, \"no proxy support for local source address\");\n\n\t\tproxyhost = strsep(&proxy, \":\");\n\t\tproxyport = proxy;\n\n\t\tmemset(&proxyhints, 0, sizeof(struct addrinfo));\n\t\tproxyhints.ai_family = family;\n\t\tproxyhints.ai_socktype = SOCK_STREAM;\n\t\tproxyhints.ai_protocol = IPPROTO_TCP;\n\t\tif (nflag)\n\t\t\tproxyhints.ai_flags |= AI_NUMERICHOST;\n\t}\n\n\tif (lflag) {\n\t\tint connfd;\n\t\tret = 0;\n\n\t\tif (family == AF_UNIX) {\n\t\t\tif (uflag)\n\t\t\t\ts = unix_bind(host);\n\t\t\telse\n\t\t\t\ts = unix_listen(host);\n\t\t}\n\n\t\t/* Allow only one connection at a time, but stay alive. */\n\t\tfor (;;) {\n\t\t\tif (family != AF_UNIX)\n\t\t\t\ts = local_listen(host, uport, hints);\n\t\t\tif (s < 0)\n\t\t\t\terr(1, \"local_listen\");\n\t\t\t/*\n\t\t\t * For UDP and -k, don't connect the socket, let it\n\t\t\t * receive datagrams from multiple socket pairs.\n\t\t\t */\n\t\t\tif (uflag && kflag)\n\t\t\t\treadwrite(s);\n\t\t\t/*\n\t\t\t * For UDP and not -k, we will use recvfrom() initially\n\t\t\t * to wait for a caller, then use the regular functions\n\t\t\t * to talk to the caller.\n\t\t\t */\n\t\t\telse if (uflag && !kflag) {\n\t\t\t\tint rv, plen;\n\t\t\t\tchar buf[16384];\n\t\t\t\tstruct sockaddr_storage z;\n\n\t\t\t\tlen = sizeof(z);\n\t\t\t\tplen = 2048;\n\t\t\t\trv = recvfrom(s, buf, plen, MSG_PEEK,\n\t\t\t\t    (struct sockaddr *)&z, &len);\n\t\t\t\tif (rv < 0)\n\t\t\t\t\terr(1, \"recvfrom\");\n\n\t\t\t\trv = connect(s, (struct sockaddr *)&z, len);\n\t\t\t\tif (rv < 0)\n\t\t\t\t\terr(1, \"connect\");\n\n\t\t\t\tif (vflag)\n\t\t\t\t\treport_connect((struct sockaddr *)&z, len);\n\n\t\t\t\treadwrite(s);\n\t\t\t} else {\n\t\t\t\tlen = sizeof(cliaddr);\n\t\t\t\tconnfd = accept(s, (struct sockaddr *)&cliaddr,\n\t\t\t\t    &len);\n\t\t\t\tif (connfd == -1) {\n\t\t\t\t\t/* For now, all errnos are fatal */\n\t\t\t\t\terr(1, \"accept\");\n\t\t\t\t}\n\t\t\t\tif (vflag)\n\t\t\t\t\treport_connect((struct sockaddr *)&cliaddr, len);\n\n\t\t\t\treadwrite(connfd);\n\t\t\t\tclose(connfd);\n\t\t\t}\n\n\t\t\tif (family != AF_UNIX)\n\t\t\t\tclose(s);\n\t\t\telse if (uflag) {\n\t\t\t\tif (connect(s, NULL, 0) < 0)\n\t\t\t\t\terr(1, \"connect\");\n\t\t\t}\n\n\t\t\tif (!kflag)\n\t\t\t\tbreak;\n\t\t}\n\t} else if (family == AF_UNIX) {\n\t\tret = 0;\n\n\t\tif ((s = unix_connect(host)) > 0 && !zflag) {\n\t\t\treadwrite(s);\n\t\t\tclose(s);\n\t\t} else\n\t\t\tret = 1;\n\n\t\tif (uflag)\n\t\t\tunlink(unix_dg_tmp_socket);\n\t\texit(ret);\n\n\t} else {\n\t\tint i = 0;\n\n\t\t/* Construct the portlist[] array. */\n\t\tbuild_ports(uport);\n\n\t\t/* Cycle through portlist, connecting to each port. */\n\t\tfor (i = 0; portlist[i] != NULL; i++) {\n\t\t\tif (s)\n\t\t\t\tclose(s);\n\n\t\t\tif (xflag)\n\t\t\t\ts = socks_connect(host, portlist[i], hints,\n\t\t\t\t    proxyhost, proxyport, proxyhints, socksv,\n\t\t\t\t    Pflag);\n\t\t\telse\n\t\t\t\ts = remote_connect(host, portlist[i], hints);\n\n\t\t\tif (s < 0)\n\t\t\t\tcontinue;\n\n\t\t\tret = 0;\n\t\t\tif (vflag || zflag) {\n\t\t\t\t/* For UDP, make sure we are connected. */\n\t\t\t\tif (uflag) {\n\t\t\t\t\tif (udptest(s) == -1) {\n\t\t\t\t\t\tret = 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* Don't look up port if -n. */\n\t\t\t\tif (nflag)\n\t\t\t\t\tsv = NULL;\n\t\t\t\telse {\n\t\t\t\t\tsv = getservbyport(\n\t\t\t\t\t    ntohs(atoi(portlist[i])),\n\t\t\t\t\t    uflag ? \"udp\" : \"tcp\");\n\t\t\t\t}\n\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Connection to %s %s port [%s/%s] \"\n\t\t\t\t    \"succeeded!\\n\", host, portlist[i],\n\t\t\t\t    uflag ? \"udp\" : \"tcp\",\n\t\t\t\t    sv ? sv->s_name : \"*\");\n\t\t\t}\n\t\t\tif (Fflag)\n\t\t\t\tfdpass(s);\n\t\t\telse if (!zflag)\n\t\t\t\treadwrite(s);\n\t\t}\n\t}\n\n\tif (s)\n\t\tclose(s);\n\n\texit(ret);\n}"
  }
]