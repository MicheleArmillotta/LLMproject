[
  {
    "function_name": "auth_rhosts2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-rhosts.c",
    "lines": "189-324",
    "snippet": "int\nauth_rhosts2(struct passwd *pw, const char *client_user, const char *hostname,\n    const char *ipaddr)\n{\n\tchar buf[1024];\n\tstruct stat st;\n\tstatic const char *rhosts_files[] = {\".shosts\", \".rhosts\", NULL};\n\tu_int rhosts_file_index;\n\n\tdebug2(\"auth_rhosts2: clientuser %s hostname %s ipaddr %s\",\n\t    client_user, hostname, ipaddr);\n\n\t/* Switch to the user's uid. */\n\ttemporarily_use_uid(pw);\n\t/*\n\t * Quick check: if the user has no .shosts or .rhosts files and\n\t * no system hosts.equiv/shosts.equiv files exist then return\n\t * failure immediately without doing costly lookups from name\n\t * servers.\n\t */\n\tfor (rhosts_file_index = 0; rhosts_files[rhosts_file_index];\n\t    rhosts_file_index++) {\n\t\t/* Check users .rhosts or .shosts. */\n\t\tsnprintf(buf, sizeof buf, \"%.500s/%.100s\",\n\t\t\t pw->pw_dir, rhosts_files[rhosts_file_index]);\n\t\tif (stat(buf, &st) >= 0)\n\t\t\tbreak;\n\t}\n\t/* Switch back to privileged uid. */\n\trestore_uid();\n\n\t/*\n\t * Deny if The user has no .shosts or .rhosts file and there\n\t * are no system-wide files.\n\t */\n\tif (!rhosts_files[rhosts_file_index] &&\n\t    stat(_PATH_RHOSTS_EQUIV, &st) < 0 &&\n\t    stat(_PATH_SSH_HOSTS_EQUIV, &st) < 0) {\n\t\tdebug3(\"%s: no hosts access files exist\", __func__);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If not logging in as superuser, try /etc/hosts.equiv and\n\t * shosts.equiv.\n\t */\n\tif (pw->pw_uid == 0)\n\t\tdebug3(\"%s: root user, ignoring system hosts files\", __func__);\n\telse {\n\t\tif (check_rhosts_file(_PATH_RHOSTS_EQUIV, hostname, ipaddr,\n\t\t    client_user, pw->pw_name)) {\n\t\t\tauth_debug_add(\"Accepted for %.100s [%.100s] by \"\n\t\t\t    \"/etc/hosts.equiv.\", hostname, ipaddr);\n\t\t\treturn 1;\n\t\t}\n\t\tif (check_rhosts_file(_PATH_SSH_HOSTS_EQUIV, hostname, ipaddr,\n\t\t    client_user, pw->pw_name)) {\n\t\t\tauth_debug_add(\"Accepted for %.100s [%.100s] by \"\n\t\t\t    \"%.100s.\", hostname, ipaddr, _PATH_SSH_HOSTS_EQUIV);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * Check that the home directory is owned by root or the user, and is\n\t * not group or world writable.\n\t */\n\tif (stat(pw->pw_dir, &st) < 0) {\n\t\tlogit(\"Rhosts authentication refused for %.100s: \"\n\t\t    \"no home directory %.200s\", pw->pw_name, pw->pw_dir);\n\t\tauth_debug_add(\"Rhosts authentication refused for %.100s: \"\n\t\t    \"no home directory %.200s\", pw->pw_name, pw->pw_dir);\n\t\treturn 0;\n\t}\n\tif (options.strict_modes &&\n\t    ((st.st_uid != 0 && st.st_uid != pw->pw_uid) ||\n\t    (st.st_mode & 022) != 0)) {\n\t\tlogit(\"Rhosts authentication refused for %.100s: \"\n\t\t    \"bad ownership or modes for home directory.\", pw->pw_name);\n\t\tauth_debug_add(\"Rhosts authentication refused for %.100s: \"\n\t\t    \"bad ownership or modes for home directory.\", pw->pw_name);\n\t\treturn 0;\n\t}\n\t/* Temporarily use the user's uid. */\n\ttemporarily_use_uid(pw);\n\n\t/* Check all .rhosts files (currently .shosts and .rhosts). */\n\tfor (rhosts_file_index = 0; rhosts_files[rhosts_file_index];\n\t    rhosts_file_index++) {\n\t\t/* Check users .rhosts or .shosts. */\n\t\tsnprintf(buf, sizeof buf, \"%.500s/%.100s\",\n\t\t\t pw->pw_dir, rhosts_files[rhosts_file_index]);\n\t\tif (stat(buf, &st) < 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Make sure that the file is either owned by the user or by\n\t\t * root, and make sure it is not writable by anyone but the\n\t\t * owner.  This is to help avoid novices accidentally\n\t\t * allowing access to their account by anyone.\n\t\t */\n\t\tif (options.strict_modes &&\n\t\t    ((st.st_uid != 0 && st.st_uid != pw->pw_uid) ||\n\t\t    (st.st_mode & 022) != 0)) {\n\t\t\tlogit(\"Rhosts authentication refused for %.100s: bad modes for %.200s\",\n\t\t\t    pw->pw_name, buf);\n\t\t\tauth_debug_add(\"Bad file modes for %.200s\", buf);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Check if we have been configured to ignore .rhosts\n\t\t * and .shosts files.\n\t\t */\n\t\tif (options.ignore_rhosts) {\n\t\t\tauth_debug_add(\"Server has been configured to \"\n\t\t\t    \"ignore %.100s.\", rhosts_files[rhosts_file_index]);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Check if authentication is permitted by the file. */\n\t\tif (check_rhosts_file(buf, hostname, ipaddr,\n\t\t    client_user, pw->pw_name)) {\n\t\t\tauth_debug_add(\"Accepted by %.100s.\",\n\t\t\t    rhosts_files[rhosts_file_index]);\n\t\t\t/* Restore the privileged uid. */\n\t\t\trestore_uid();\n\t\t\tauth_debug_add(\"Accepted host %s ip %s client_user \"\n\t\t\t    \"%s server_user %s\", hostname, ipaddr,\n\t\t\t    client_user, pw->pw_name);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* Restore the privileged uid. */\n\trestore_uid();\n\treturn 0;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"uidswap.h\"",
      "#include \"packet.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "# include <netgroup.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ServerOptions options;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "restore_uid",
          "args": [],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "restore_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "141-172",
          "snippet": "void\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\nrestore_uid(void)\n{\n\t/* it's a no-op unless privileged */\n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t/* Set the effective uid back to the saved privileged uid. */\n\tif (seteuid(saved_euid) < 0)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else /* SAVED_IDS_WORK_WITH_SETEUID */\n\t/*\n\t * We are unable to restore the real uid to its unprivileged value.\n\t * Propagate the real uid (usually more privileged) to effective uid\n\t * as well.\n\t */\n\tsetuid(getuid());\n\tsetgid(getgid());\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tif (setgroups(saved_egroupslen, saved_egroups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_debug_add",
          "args": [
            "\"Accepted host %s ip %s client_user \"\n\t\t\t    \"%s server_user %s\"",
            "hostname",
            "ipaddr",
            "client_user",
            "pw->pw_name"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "auth_debug_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "673-688",
          "snippet": "void\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sshbuf *auth_debug;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshbuf *auth_debug;\n\nvoid\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_rhosts_file",
          "args": [
            "buf",
            "hostname",
            "ipaddr",
            "client_user",
            "pw->pw_name"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "check_rhosts_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-rhosts.c",
          "lines": "55-182",
          "snippet": "static int\ncheck_rhosts_file(const char *filename, const char *hostname,\n\t\t  const char *ipaddr, const char *client_user,\n\t\t  const char *server_user)\n{\n\tFILE *f;\n#define RBUFLN 1024\n\tchar buf[RBUFLN];/* Must not be larger than host, user, dummy below. */\n\tint fd;\n\tstruct stat st;\n\n\t/* Open the .rhosts file, deny if unreadable */\n\tif ((fd = open(filename, O_RDONLY|O_NONBLOCK)) == -1)\n\t\treturn 0;\n\tif (fstat(fd, &st) == -1) {\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\tif (!S_ISREG(st.st_mode)) {\n\t\tlogit(\"User %s hosts file %s is not a regular file\",\n\t\t    server_user, filename);\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\tunset_nonblock(fd);\n\tif ((f = fdopen(fd, \"r\")) == NULL) {\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\twhile (fgets(buf, sizeof(buf), f)) {\n\t\t/* All three must have length >= buf to avoid overflows. */\n\t\tchar hostbuf[RBUFLN], userbuf[RBUFLN], dummy[RBUFLN];\n\t\tchar *host, *user, *cp;\n\t\tint negated;\n\n\t\tfor (cp = buf; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\tif (*cp == '#' || *cp == '\\n' || !*cp)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * NO_PLUS is supported at least on OSF/1.  We skip it (we\n\t\t * don't ever support the plus syntax).\n\t\t */\n\t\tif (strncmp(cp, \"NO_PLUS\", 7) == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * This should be safe because each buffer is as big as the\n\t\t * whole string, and thus cannot be overwritten.\n\t\t */\n\t\tswitch (sscanf(buf, \"%1023s %1023s %1023s\", hostbuf, userbuf,\n\t\t    dummy)) {\n\t\tcase 0:\n\t\t\tauth_debug_add(\"Found empty line in %.100s.\", filename);\n\t\t\tcontinue;\n\t\tcase 1:\n\t\t\t/* Host name only. */\n\t\t\tstrlcpy(userbuf, server_user, sizeof(userbuf));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t/* Got both host and user name. */\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tauth_debug_add(\"Found garbage in %.100s.\", filename);\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\t/* Weird... */\n\t\t\tcontinue;\n\t\t}\n\n\t\thost = hostbuf;\n\t\tuser = userbuf;\n\t\tnegated = 0;\n\n\t\t/* Process negated host names, or positive netgroups. */\n\t\tif (host[0] == '-') {\n\t\t\tnegated = 1;\n\t\t\thost++;\n\t\t} else if (host[0] == '+')\n\t\t\thost++;\n\n\t\tif (user[0] == '-') {\n\t\t\tnegated = 1;\n\t\t\tuser++;\n\t\t} else if (user[0] == '+')\n\t\t\tuser++;\n\n\t\t/* Check for empty host/user names (particularly '+'). */\n\t\tif (!host[0] || !user[0]) {\n\t\t\t/* We come here if either was '+' or '-'. */\n\t\t\tauth_debug_add(\"Ignoring wild host/user names \"\n\t\t\t    \"in %.100s.\", filename);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Verify that host name matches. */\n\t\tif (host[0] == '@') {\n\t\t\tif (!innetgr(host + 1, hostname, NULL, NULL) &&\n\t\t\t    !innetgr(host + 1, ipaddr, NULL, NULL))\n\t\t\t\tcontinue;\n\t\t} else if (strcasecmp(host, hostname) &&\n\t\t    strcmp(host, ipaddr) != 0)\n\t\t\tcontinue;\t/* Different hostname. */\n\n\t\t/* Verify that user name matches. */\n\t\tif (user[0] == '@') {\n\t\t\tif (!innetgr(user + 1, NULL, client_user, NULL))\n\t\t\t\tcontinue;\n\t\t} else if (strcmp(user, client_user) != 0)\n\t\t\tcontinue;\t/* Different username. */\n\n\t\t/* Found the user and host. */\n\t\tfclose(f);\n\n\t\t/* If the entry was negated, deny access. */\n\t\tif (negated) {\n\t\t\tauth_debug_add(\"Matched negative entry in %.100s.\",\n\t\t\t    filename);\n\t\t\treturn 0;\n\t\t}\n\t\t/* Accept authentication. */\n\t\treturn 1;\n\t}\n\n\t/* Authentication using this file denied. */\n\tfclose(f);\n\treturn 0;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"canohost.h\"",
            "#include \"servconf.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"misc.h\"",
            "#include \"log.h\"",
            "#include \"pathnames.h\"",
            "#include \"uidswap.h\"",
            "#include \"packet.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <stdarg.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "# include <netgroup.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define RBUFLN 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"uidswap.h\"\n#include \"packet.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n# include <netgroup.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define RBUFLN 1024\n\nstatic int\ncheck_rhosts_file(const char *filename, const char *hostname,\n\t\t  const char *ipaddr, const char *client_user,\n\t\t  const char *server_user)\n{\n\tFILE *f;\n#define RBUFLN 1024\n\tchar buf[RBUFLN];/* Must not be larger than host, user, dummy below. */\n\tint fd;\n\tstruct stat st;\n\n\t/* Open the .rhosts file, deny if unreadable */\n\tif ((fd = open(filename, O_RDONLY|O_NONBLOCK)) == -1)\n\t\treturn 0;\n\tif (fstat(fd, &st) == -1) {\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\tif (!S_ISREG(st.st_mode)) {\n\t\tlogit(\"User %s hosts file %s is not a regular file\",\n\t\t    server_user, filename);\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\tunset_nonblock(fd);\n\tif ((f = fdopen(fd, \"r\")) == NULL) {\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\twhile (fgets(buf, sizeof(buf), f)) {\n\t\t/* All three must have length >= buf to avoid overflows. */\n\t\tchar hostbuf[RBUFLN], userbuf[RBUFLN], dummy[RBUFLN];\n\t\tchar *host, *user, *cp;\n\t\tint negated;\n\n\t\tfor (cp = buf; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\tif (*cp == '#' || *cp == '\\n' || !*cp)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * NO_PLUS is supported at least on OSF/1.  We skip it (we\n\t\t * don't ever support the plus syntax).\n\t\t */\n\t\tif (strncmp(cp, \"NO_PLUS\", 7) == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * This should be safe because each buffer is as big as the\n\t\t * whole string, and thus cannot be overwritten.\n\t\t */\n\t\tswitch (sscanf(buf, \"%1023s %1023s %1023s\", hostbuf, userbuf,\n\t\t    dummy)) {\n\t\tcase 0:\n\t\t\tauth_debug_add(\"Found empty line in %.100s.\", filename);\n\t\t\tcontinue;\n\t\tcase 1:\n\t\t\t/* Host name only. */\n\t\t\tstrlcpy(userbuf, server_user, sizeof(userbuf));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t/* Got both host and user name. */\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tauth_debug_add(\"Found garbage in %.100s.\", filename);\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\t/* Weird... */\n\t\t\tcontinue;\n\t\t}\n\n\t\thost = hostbuf;\n\t\tuser = userbuf;\n\t\tnegated = 0;\n\n\t\t/* Process negated host names, or positive netgroups. */\n\t\tif (host[0] == '-') {\n\t\t\tnegated = 1;\n\t\t\thost++;\n\t\t} else if (host[0] == '+')\n\t\t\thost++;\n\n\t\tif (user[0] == '-') {\n\t\t\tnegated = 1;\n\t\t\tuser++;\n\t\t} else if (user[0] == '+')\n\t\t\tuser++;\n\n\t\t/* Check for empty host/user names (particularly '+'). */\n\t\tif (!host[0] || !user[0]) {\n\t\t\t/* We come here if either was '+' or '-'. */\n\t\t\tauth_debug_add(\"Ignoring wild host/user names \"\n\t\t\t    \"in %.100s.\", filename);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Verify that host name matches. */\n\t\tif (host[0] == '@') {\n\t\t\tif (!innetgr(host + 1, hostname, NULL, NULL) &&\n\t\t\t    !innetgr(host + 1, ipaddr, NULL, NULL))\n\t\t\t\tcontinue;\n\t\t} else if (strcasecmp(host, hostname) &&\n\t\t    strcmp(host, ipaddr) != 0)\n\t\t\tcontinue;\t/* Different hostname. */\n\n\t\t/* Verify that user name matches. */\n\t\tif (user[0] == '@') {\n\t\t\tif (!innetgr(user + 1, NULL, client_user, NULL))\n\t\t\t\tcontinue;\n\t\t} else if (strcmp(user, client_user) != 0)\n\t\t\tcontinue;\t/* Different username. */\n\n\t\t/* Found the user and host. */\n\t\tfclose(f);\n\n\t\t/* If the entry was negated, deny access. */\n\t\tif (negated) {\n\t\t\tauth_debug_add(\"Matched negative entry in %.100s.\",\n\t\t\t    filename);\n\t\t\treturn 0;\n\t\t}\n\t\t/* Accept authentication. */\n\t\treturn 1;\n\t}\n\n\t/* Authentication using this file denied. */\n\tfclose(f);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"Rhosts authentication refused for %.100s: bad modes for %.200s\"",
            "pw->pw_name",
            "buf"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "buf",
            "&st"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "fmt_multistate_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "2384-2394",
          "snippet": "static const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof buf",
            "\"%.500s/%.100s\"",
            "pw->pw_dir",
            "rhosts_files[rhosts_file_index]"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "snprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-snprintf.c",
          "lines": "869-879",
          "snippet": "int\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <limits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <ctype.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include \"includes.h\"\n\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "temporarily_use_uid",
          "args": [
            "pw"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "temporarily_use_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/uidswap.c",
          "lines": "60-136",
          "snippet": "void\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}",
          "includes": [
            "#include \"xmalloc.h\"",
            "#include \"uidswap.h\"",
            "#include \"log.h\"",
            "#include <grp.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <errno.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [
            "#define SAVED_IDS_WORK_WITH_SETEUID"
          ],
          "globals_used": [
            "static int\tprivileged = 0;",
            "static int\ttemporarily_use_uid_effective = 0;",
            "static uid_t\tuser_groups_uid;",
            "static gid_t\t*saved_egroups = NULL, *user_groups = NULL;",
            "static int\tsaved_egroupslen = -1, user_groupslen = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xmalloc.h\"\n#include \"uidswap.h\"\n#include \"log.h\"\n#include <grp.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <errno.h>\n#include \"includes.h\"\n\n#define SAVED_IDS_WORK_WITH_SETEUID\n\nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic uid_t\tuser_groups_uid;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\nvoid\ntemporarily_use_uid(struct passwd *pw)\n{\n\t/* Save the current euid, and egroups. */\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen < 0)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else { /* saved_egroupslen == 0 */\n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t/* set and save the user's groups */\n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen < 0)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) < 0)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else { /* user_groupslen == 0 */\n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t/* Set the effective uid to the given (unprivileged) uid. */\n\tif (setgroups(user_groupslen, user_groups) < 0)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t/* Propagate the privileged gid to all of our gids. */\n\tif (setgid(getegid()) < 0)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t/* Propagate the privileged uid to all of our uids. */\n\tif (setuid(geteuid()) < 0)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif /* SAVED_IDS_WORK_WITH_SETEUID */\n\tif (setegid(pw->pw_gid) < 0)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%s: root user, ignoring system hosts files\"",
            "__func__"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "debug3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "242-250",
          "snippet": "void\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug3(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG3, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"auth_rhosts2: clientuser %s hostname %s ipaddr %s\"",
            "client_user",
            "hostname",
            "ipaddr"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "debug2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "232-240",
          "snippet": "void\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\ndebug2(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_DEBUG2, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"uidswap.h\"\n#include \"packet.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n# include <netgroup.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nextern ServerOptions options;\n\nint\nauth_rhosts2(struct passwd *pw, const char *client_user, const char *hostname,\n    const char *ipaddr)\n{\n\tchar buf[1024];\n\tstruct stat st;\n\tstatic const char *rhosts_files[] = {\".shosts\", \".rhosts\", NULL};\n\tu_int rhosts_file_index;\n\n\tdebug2(\"auth_rhosts2: clientuser %s hostname %s ipaddr %s\",\n\t    client_user, hostname, ipaddr);\n\n\t/* Switch to the user's uid. */\n\ttemporarily_use_uid(pw);\n\t/*\n\t * Quick check: if the user has no .shosts or .rhosts files and\n\t * no system hosts.equiv/shosts.equiv files exist then return\n\t * failure immediately without doing costly lookups from name\n\t * servers.\n\t */\n\tfor (rhosts_file_index = 0; rhosts_files[rhosts_file_index];\n\t    rhosts_file_index++) {\n\t\t/* Check users .rhosts or .shosts. */\n\t\tsnprintf(buf, sizeof buf, \"%.500s/%.100s\",\n\t\t\t pw->pw_dir, rhosts_files[rhosts_file_index]);\n\t\tif (stat(buf, &st) >= 0)\n\t\t\tbreak;\n\t}\n\t/* Switch back to privileged uid. */\n\trestore_uid();\n\n\t/*\n\t * Deny if The user has no .shosts or .rhosts file and there\n\t * are no system-wide files.\n\t */\n\tif (!rhosts_files[rhosts_file_index] &&\n\t    stat(_PATH_RHOSTS_EQUIV, &st) < 0 &&\n\t    stat(_PATH_SSH_HOSTS_EQUIV, &st) < 0) {\n\t\tdebug3(\"%s: no hosts access files exist\", __func__);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If not logging in as superuser, try /etc/hosts.equiv and\n\t * shosts.equiv.\n\t */\n\tif (pw->pw_uid == 0)\n\t\tdebug3(\"%s: root user, ignoring system hosts files\", __func__);\n\telse {\n\t\tif (check_rhosts_file(_PATH_RHOSTS_EQUIV, hostname, ipaddr,\n\t\t    client_user, pw->pw_name)) {\n\t\t\tauth_debug_add(\"Accepted for %.100s [%.100s] by \"\n\t\t\t    \"/etc/hosts.equiv.\", hostname, ipaddr);\n\t\t\treturn 1;\n\t\t}\n\t\tif (check_rhosts_file(_PATH_SSH_HOSTS_EQUIV, hostname, ipaddr,\n\t\t    client_user, pw->pw_name)) {\n\t\t\tauth_debug_add(\"Accepted for %.100s [%.100s] by \"\n\t\t\t    \"%.100s.\", hostname, ipaddr, _PATH_SSH_HOSTS_EQUIV);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * Check that the home directory is owned by root or the user, and is\n\t * not group or world writable.\n\t */\n\tif (stat(pw->pw_dir, &st) < 0) {\n\t\tlogit(\"Rhosts authentication refused for %.100s: \"\n\t\t    \"no home directory %.200s\", pw->pw_name, pw->pw_dir);\n\t\tauth_debug_add(\"Rhosts authentication refused for %.100s: \"\n\t\t    \"no home directory %.200s\", pw->pw_name, pw->pw_dir);\n\t\treturn 0;\n\t}\n\tif (options.strict_modes &&\n\t    ((st.st_uid != 0 && st.st_uid != pw->pw_uid) ||\n\t    (st.st_mode & 022) != 0)) {\n\t\tlogit(\"Rhosts authentication refused for %.100s: \"\n\t\t    \"bad ownership or modes for home directory.\", pw->pw_name);\n\t\tauth_debug_add(\"Rhosts authentication refused for %.100s: \"\n\t\t    \"bad ownership or modes for home directory.\", pw->pw_name);\n\t\treturn 0;\n\t}\n\t/* Temporarily use the user's uid. */\n\ttemporarily_use_uid(pw);\n\n\t/* Check all .rhosts files (currently .shosts and .rhosts). */\n\tfor (rhosts_file_index = 0; rhosts_files[rhosts_file_index];\n\t    rhosts_file_index++) {\n\t\t/* Check users .rhosts or .shosts. */\n\t\tsnprintf(buf, sizeof buf, \"%.500s/%.100s\",\n\t\t\t pw->pw_dir, rhosts_files[rhosts_file_index]);\n\t\tif (stat(buf, &st) < 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Make sure that the file is either owned by the user or by\n\t\t * root, and make sure it is not writable by anyone but the\n\t\t * owner.  This is to help avoid novices accidentally\n\t\t * allowing access to their account by anyone.\n\t\t */\n\t\tif (options.strict_modes &&\n\t\t    ((st.st_uid != 0 && st.st_uid != pw->pw_uid) ||\n\t\t    (st.st_mode & 022) != 0)) {\n\t\t\tlogit(\"Rhosts authentication refused for %.100s: bad modes for %.200s\",\n\t\t\t    pw->pw_name, buf);\n\t\t\tauth_debug_add(\"Bad file modes for %.200s\", buf);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Check if we have been configured to ignore .rhosts\n\t\t * and .shosts files.\n\t\t */\n\t\tif (options.ignore_rhosts) {\n\t\t\tauth_debug_add(\"Server has been configured to \"\n\t\t\t    \"ignore %.100s.\", rhosts_files[rhosts_file_index]);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Check if authentication is permitted by the file. */\n\t\tif (check_rhosts_file(buf, hostname, ipaddr,\n\t\t    client_user, pw->pw_name)) {\n\t\t\tauth_debug_add(\"Accepted by %.100s.\",\n\t\t\t    rhosts_files[rhosts_file_index]);\n\t\t\t/* Restore the privileged uid. */\n\t\t\trestore_uid();\n\t\t\tauth_debug_add(\"Accepted host %s ip %s client_user \"\n\t\t\t    \"%s server_user %s\", hostname, ipaddr,\n\t\t\t    client_user, pw->pw_name);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* Restore the privileged uid. */\n\trestore_uid();\n\treturn 0;\n}"
  },
  {
    "function_name": "check_rhosts_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth-rhosts.c",
    "lines": "55-182",
    "snippet": "static int\ncheck_rhosts_file(const char *filename, const char *hostname,\n\t\t  const char *ipaddr, const char *client_user,\n\t\t  const char *server_user)\n{\n\tFILE *f;\n#define RBUFLN 1024\n\tchar buf[RBUFLN];/* Must not be larger than host, user, dummy below. */\n\tint fd;\n\tstruct stat st;\n\n\t/* Open the .rhosts file, deny if unreadable */\n\tif ((fd = open(filename, O_RDONLY|O_NONBLOCK)) == -1)\n\t\treturn 0;\n\tif (fstat(fd, &st) == -1) {\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\tif (!S_ISREG(st.st_mode)) {\n\t\tlogit(\"User %s hosts file %s is not a regular file\",\n\t\t    server_user, filename);\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\tunset_nonblock(fd);\n\tif ((f = fdopen(fd, \"r\")) == NULL) {\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\twhile (fgets(buf, sizeof(buf), f)) {\n\t\t/* All three must have length >= buf to avoid overflows. */\n\t\tchar hostbuf[RBUFLN], userbuf[RBUFLN], dummy[RBUFLN];\n\t\tchar *host, *user, *cp;\n\t\tint negated;\n\n\t\tfor (cp = buf; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\tif (*cp == '#' || *cp == '\\n' || !*cp)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * NO_PLUS is supported at least on OSF/1.  We skip it (we\n\t\t * don't ever support the plus syntax).\n\t\t */\n\t\tif (strncmp(cp, \"NO_PLUS\", 7) == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * This should be safe because each buffer is as big as the\n\t\t * whole string, and thus cannot be overwritten.\n\t\t */\n\t\tswitch (sscanf(buf, \"%1023s %1023s %1023s\", hostbuf, userbuf,\n\t\t    dummy)) {\n\t\tcase 0:\n\t\t\tauth_debug_add(\"Found empty line in %.100s.\", filename);\n\t\t\tcontinue;\n\t\tcase 1:\n\t\t\t/* Host name only. */\n\t\t\tstrlcpy(userbuf, server_user, sizeof(userbuf));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t/* Got both host and user name. */\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tauth_debug_add(\"Found garbage in %.100s.\", filename);\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\t/* Weird... */\n\t\t\tcontinue;\n\t\t}\n\n\t\thost = hostbuf;\n\t\tuser = userbuf;\n\t\tnegated = 0;\n\n\t\t/* Process negated host names, or positive netgroups. */\n\t\tif (host[0] == '-') {\n\t\t\tnegated = 1;\n\t\t\thost++;\n\t\t} else if (host[0] == '+')\n\t\t\thost++;\n\n\t\tif (user[0] == '-') {\n\t\t\tnegated = 1;\n\t\t\tuser++;\n\t\t} else if (user[0] == '+')\n\t\t\tuser++;\n\n\t\t/* Check for empty host/user names (particularly '+'). */\n\t\tif (!host[0] || !user[0]) {\n\t\t\t/* We come here if either was '+' or '-'. */\n\t\t\tauth_debug_add(\"Ignoring wild host/user names \"\n\t\t\t    \"in %.100s.\", filename);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Verify that host name matches. */\n\t\tif (host[0] == '@') {\n\t\t\tif (!innetgr(host + 1, hostname, NULL, NULL) &&\n\t\t\t    !innetgr(host + 1, ipaddr, NULL, NULL))\n\t\t\t\tcontinue;\n\t\t} else if (strcasecmp(host, hostname) &&\n\t\t    strcmp(host, ipaddr) != 0)\n\t\t\tcontinue;\t/* Different hostname. */\n\n\t\t/* Verify that user name matches. */\n\t\tif (user[0] == '@') {\n\t\t\tif (!innetgr(user + 1, NULL, client_user, NULL))\n\t\t\t\tcontinue;\n\t\t} else if (strcmp(user, client_user) != 0)\n\t\t\tcontinue;\t/* Different username. */\n\n\t\t/* Found the user and host. */\n\t\tfclose(f);\n\n\t\t/* If the entry was negated, deny access. */\n\t\tif (negated) {\n\t\t\tauth_debug_add(\"Matched negative entry in %.100s.\",\n\t\t\t    filename);\n\t\t\treturn 0;\n\t\t}\n\t\t/* Accept authentication. */\n\t\treturn 1;\n\t}\n\n\t/* Authentication using this file denied. */\n\tfclose(f);\n\treturn 0;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"hostfile.h\"",
      "#include \"sshkey.h\"",
      "#include \"canohost.h\"",
      "#include \"servconf.h\"",
      "#include \"sshkey.h\"",
      "#include \"sshbuf.h\"",
      "#include \"misc.h\"",
      "#include \"log.h\"",
      "#include \"pathnames.h\"",
      "#include \"uidswap.h\"",
      "#include \"packet.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <stdarg.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <pwd.h>",
      "# include <netgroup.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"includes.h\""
    ],
    "macros_used": [
      "#define RBUFLN 1024"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth_debug_add",
          "args": [
            "\"Matched negative entry in %.100s.\"",
            "filename"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "auth_debug_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/auth.c",
          "lines": "673-688",
          "snippet": "void\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}",
          "includes": [
            "#include \"channels.h\"",
            "#include \"compat.h\"",
            "#include \"ssherr.h\"",
            "#include \"authfile.h\"",
            "#include \"monitor_wrap.h\"",
            "#include \"authfile.h\"",
            "#include \"ssh-gss.h\"",
            "#include \"loginrec.h\"",
            "#include \"packet.h\"",
            "#include \"uidswap.h\"",
            "#include \"canohost.h\"",
            "#include \"auth-options.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"sshkey.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"groupaccess.h\"",
            "#include \"match.h\"",
            "#include \"xmalloc.h\"",
            "#include <netdb.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <shadow.h>",
            "#include <login.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <netinet/in.h>",
            "#include <sys/wait.h>",
            "#include <sys/socket.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sshbuf *auth_debug;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"ssh-gss.h\"\n#include \"loginrec.h\"\n#include \"packet.h\"\n#include \"uidswap.h\"\n#include \"canohost.h\"\n#include \"auth-options.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"groupaccess.h\"\n#include \"match.h\"\n#include \"xmalloc.h\"\n#include <netdb.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <shadow.h>\n#include <login.h>\n#include <pwd.h>\n# include <paths.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic struct sshbuf *auth_debug;\n\nvoid\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\tfatal(\"%s: sshbuf_put_cstring: %s\", __func__, ssh_err(r));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "user",
            "client_user"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_maybe_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "1550-1558",
          "snippet": "static int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "innetgr",
          "args": [
            "user + 1",
            "NULL",
            "client_user",
            "NULL"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "innetgr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-misc.c",
          "lines": "74-78",
          "snippet": "int innetgr(const char *netgroup, const char *host,\n\t    const char *user, const char *domain)\n{\n\treturn (0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "# include <sys/time.h>",
            "# include <sys/select.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n# include <sys/time.h>\n# include <sys/select.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint innetgr(const char *netgroup, const char *host,\n\t    const char *user, const char *domain)\n{\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "host",
            "hostname"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "userbuf",
            "server_user",
            "sizeof(userbuf)"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/strlcpy.c",
          "lines": "32-56",
          "snippet": "size_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nsize_t\nstrlcpy(char *dst, const char *src, size_t siz)\n{\n\tchar *d = dst;\n\tconst char *s = src;\n\tsize_t n = siz;\n\n\t/* Copy as many bytes as will fit */\n\tif (n != 0) {\n\t\twhile (--n != 0) {\n\t\t\tif ((*d++ = *s++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src */\n\tif (n == 0) {\n\t\tif (siz != 0)\n\t\t\t*d = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*s++)\n\t\t\t;\n\t}\n\n\treturn(s - src - 1);\t/* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%1023s %1023s %1023s\"",
            "hostbuf",
            "userbuf",
            "dummy"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "cp",
            "\"NO_PLUS\"",
            "7"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "g_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/glob.c",
          "lines": "422-435",
          "snippet": "static int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"charclass.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pwd.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <dirent.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"glob.h\"",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"charclass.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pwd.h>\n#include <limits.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"glob.h\"\n#include \"includes.h\"\n\nstatic int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "sizeof(buf)",
            "f"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_close_authentication_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/authfd.c",
          "lines": "171-176",
          "snippet": "void\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}",
          "includes": [
            "#include \"ssherr.h\"",
            "#include \"misc.h\"",
            "#include \"atomicio.h\"",
            "#include \"log.h\"",
            "#include \"compat.h\"",
            "#include \"cipher.h\"",
            "#include \"authfd.h\"",
            "#include \"sshkey.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"authfd.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nssh_close_authentication_socket(int sock)\n{\n\tif (getenv(SSH_AUTHSOCKET_ENV_NAME))\n\t\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "fd",
            "\"r\""
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unset_nonblock",
          "args": [
            "fd"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "unset_nonblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/misc.c",
          "lines": "116-138",
          "snippet": "int\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"platform.h\"",
            "#include \"ssherr.h\"",
            "#include \"sshbuf.h\"",
            "#include \"ssh.h\"",
            "#include \"log.h\"",
            "#include \"misc.h\"",
            "#include \"xmalloc.h\"",
            "#include <net/if.h>",
            "#include <pwd.h>",
            "# include <paths.h>",
            "#include <netdb.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <ctype.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <libgen.h>",
            "#include <limits.h>",
            "#include <sys/un.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"platform.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"xmalloc.h\"\n#include <net/if.h>\n#include <pwd.h>\n# include <paths.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <libgen.h>\n#include <limits.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nint\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val < 0) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logit",
          "args": [
            "\"User %s hosts file %s is not a regular file\"",
            "server_user",
            "filename"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "logit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/log.c",
          "lines": "198-206",
          "snippet": "void\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"log.h\"",
            "# include <vis.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"log.h\"\n# include <vis.h>\n#include <errno.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nvoid\nlogit(const char *fmt,...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(SYSLOG_LEVEL_INFO, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "st.st_mode"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&st"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "fstatvfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/openbsd-compat/bsd-statvfs.c",
          "lines": "71-85",
          "snippet": "int fstatvfs(int fd, struct statvfs *buf)\n{\n#  ifdef HAVE_FSTATFS\n\tstruct statfs fs;\n\n\tmemset(&fs, 0, sizeof(fs));\n\tif (fstatfs(fd, &fs) == -1)\n\t\treturn -1;\n\tcopy_statfs_to_statvfs(buf, &fs);\n\treturn 0;\n#  else\n\terrno = ENOSYS;\n\treturn -1;\n#  endif\n}",
          "includes": [
            "#include <errno.h>",
            "# include <sys/mount.h>",
            "#include <sys/param.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n# include <sys/mount.h>\n#include <sys/param.h>\n#include \"includes.h\"\n\nint fstatvfs(int fd, struct statvfs *buf)\n{\n#  ifdef HAVE_FSTATFS\n\tstruct statfs fs;\n\n\tmemset(&fs, 0, sizeof(fs));\n\tif (fstatfs(fd, &fs) == -1)\n\t\treturn -1;\n\tcopy_statfs_to_statvfs(buf, &fs);\n\treturn 0;\n#  else\n\terrno = ENOSYS;\n\treturn -1;\n#  endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "filename",
            "O_RDONLY|O_NONBLOCK"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "process_permitopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-20685/repo/servconf.c",
          "lines": "901-909",
          "snippet": "void\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}",
          "includes": [
            "#include \"digest.h\"",
            "#include \"myproposal.h\"",
            "#include \"auth.h\"",
            "#include \"hostfile.h\"",
            "#include \"ssherr.h\"",
            "#include \"packet.h\"",
            "#include \"canohost.h\"",
            "#include \"groupaccess.h\"",
            "#include \"channels.h\"",
            "#include \"match.h\"",
            "#include \"mac.h\"",
            "#include \"kex.h\"",
            "#include \"sshkey.h\"",
            "#include \"cipher.h\"",
            "#include \"pathnames.h\"",
            "#include \"compat.h\"",
            "#include \"servconf.h\"",
            "#include \"misc.h\"",
            "#include \"sshbuf.h\"",
            "#include \"log.h\"",
            "#include \"ssh.h\"",
            "#include \"xmalloc.h\"",
            "#include \"openbsd-compat/sys-queue.h\"",
            "#include <util.h>",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <netdb.h>",
            "#include <ctype.h>",
            "#include <net/route.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"includes.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);",
            "static void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"digest.h\"\n#include \"myproposal.h\"\n#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"groupaccess.h\"\n#include \"channels.h\"\n#include \"match.h\"\n#include \"mac.h\"\n#include \"kex.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"compat.h\"\n#include \"servconf.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"xmalloc.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <util.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <net/route.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\n\nvoid\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"hostfile.h\"\n#include \"sshkey.h\"\n#include \"canohost.h\"\n#include \"servconf.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"uidswap.h\"\n#include \"packet.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n# include <netgroup.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"includes.h\"\n\n#define RBUFLN 1024\n\nstatic int\ncheck_rhosts_file(const char *filename, const char *hostname,\n\t\t  const char *ipaddr, const char *client_user,\n\t\t  const char *server_user)\n{\n\tFILE *f;\n#define RBUFLN 1024\n\tchar buf[RBUFLN];/* Must not be larger than host, user, dummy below. */\n\tint fd;\n\tstruct stat st;\n\n\t/* Open the .rhosts file, deny if unreadable */\n\tif ((fd = open(filename, O_RDONLY|O_NONBLOCK)) == -1)\n\t\treturn 0;\n\tif (fstat(fd, &st) == -1) {\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\tif (!S_ISREG(st.st_mode)) {\n\t\tlogit(\"User %s hosts file %s is not a regular file\",\n\t\t    server_user, filename);\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\tunset_nonblock(fd);\n\tif ((f = fdopen(fd, \"r\")) == NULL) {\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\twhile (fgets(buf, sizeof(buf), f)) {\n\t\t/* All three must have length >= buf to avoid overflows. */\n\t\tchar hostbuf[RBUFLN], userbuf[RBUFLN], dummy[RBUFLN];\n\t\tchar *host, *user, *cp;\n\t\tint negated;\n\n\t\tfor (cp = buf; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\tif (*cp == '#' || *cp == '\\n' || !*cp)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * NO_PLUS is supported at least on OSF/1.  We skip it (we\n\t\t * don't ever support the plus syntax).\n\t\t */\n\t\tif (strncmp(cp, \"NO_PLUS\", 7) == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * This should be safe because each buffer is as big as the\n\t\t * whole string, and thus cannot be overwritten.\n\t\t */\n\t\tswitch (sscanf(buf, \"%1023s %1023s %1023s\", hostbuf, userbuf,\n\t\t    dummy)) {\n\t\tcase 0:\n\t\t\tauth_debug_add(\"Found empty line in %.100s.\", filename);\n\t\t\tcontinue;\n\t\tcase 1:\n\t\t\t/* Host name only. */\n\t\t\tstrlcpy(userbuf, server_user, sizeof(userbuf));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t/* Got both host and user name. */\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tauth_debug_add(\"Found garbage in %.100s.\", filename);\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\t/* Weird... */\n\t\t\tcontinue;\n\t\t}\n\n\t\thost = hostbuf;\n\t\tuser = userbuf;\n\t\tnegated = 0;\n\n\t\t/* Process negated host names, or positive netgroups. */\n\t\tif (host[0] == '-') {\n\t\t\tnegated = 1;\n\t\t\thost++;\n\t\t} else if (host[0] == '+')\n\t\t\thost++;\n\n\t\tif (user[0] == '-') {\n\t\t\tnegated = 1;\n\t\t\tuser++;\n\t\t} else if (user[0] == '+')\n\t\t\tuser++;\n\n\t\t/* Check for empty host/user names (particularly '+'). */\n\t\tif (!host[0] || !user[0]) {\n\t\t\t/* We come here if either was '+' or '-'. */\n\t\t\tauth_debug_add(\"Ignoring wild host/user names \"\n\t\t\t    \"in %.100s.\", filename);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Verify that host name matches. */\n\t\tif (host[0] == '@') {\n\t\t\tif (!innetgr(host + 1, hostname, NULL, NULL) &&\n\t\t\t    !innetgr(host + 1, ipaddr, NULL, NULL))\n\t\t\t\tcontinue;\n\t\t} else if (strcasecmp(host, hostname) &&\n\t\t    strcmp(host, ipaddr) != 0)\n\t\t\tcontinue;\t/* Different hostname. */\n\n\t\t/* Verify that user name matches. */\n\t\tif (user[0] == '@') {\n\t\t\tif (!innetgr(user + 1, NULL, client_user, NULL))\n\t\t\t\tcontinue;\n\t\t} else if (strcmp(user, client_user) != 0)\n\t\t\tcontinue;\t/* Different username. */\n\n\t\t/* Found the user and host. */\n\t\tfclose(f);\n\n\t\t/* If the entry was negated, deny access. */\n\t\tif (negated) {\n\t\t\tauth_debug_add(\"Matched negative entry in %.100s.\",\n\t\t\t    filename);\n\t\t\treturn 0;\n\t\t}\n\t\t/* Accept authentication. */\n\t\treturn 1;\n\t}\n\n\t/* Authentication using this file denied. */\n\tfclose(f);\n\treturn 0;\n}"
  }
]